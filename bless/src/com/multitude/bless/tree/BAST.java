//BAST.java
//Brian's Abstract Syntax Tree node
//everything is built from BAST

package com.multitude.bless.tree;

import java.util.ArrayList;
import java.util.HashMap;

//BAST.java

//BLESS Abstract Syntax Tree
//by extending ASTImpl, BAST looks like an EMF object
//by implementing Tree, BAST is produced by ANTLR v3 parser

import java.util.List;
import java.util.Vector;

import org.antlr.runtime.CommonToken;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.antlr.runtime.tree.Tree;
import org.antlr.stringtemplate.StringTemplate;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.TreeItem;
import org.osate.aadl2.Element;
import org.osate.aadl2.modelsupport.util.AadlUtil;

import com.multitude.bless.Activator;
import com.multitude.bless.Parse;
//import com.multitude.bless.Activator;
import com.multitude.bless.antlr3generated.BLESS3Lexer;
import com.multitude.bless.antlr3generated.BLESS3Parser;
import com.multitude.bless.antlr3generated.UnparseBLESS3;
import com.multitude.bless.app.Global;
//import com.multitude.bless.app.Parse;
import com.multitude.bless.exceptions.Dump;
import com.multitude.bless.exceptions.YouIdiot;
//import com.multitude.bless.proof.exception.ProofException;
import com.multitude.bless.record.EntityRecord;
import com.multitude.bless.record.ParseRecord;
import com.multitude.bless.symbol.Scope;

/**
 *
 * <!-- begin-user-doc --> BLESS Abstract Syntax Tree:
 * By implementing Tree, BAST is produced by
 * ANTLR v3 parser. <!-- end-user-doc -->
 *
 * @author brl
 *
 */

public class BAST //extends CommonTree
// extends ASTImpl
  implements Tree
  {
  // // FLAGS ////

  // public static boolean includeCommentsInText = false;

  // // STATIC -- SHARED BY ALL BAST ////

  /** A Tree holding a token that is invalid. */
  public static final Tree INVALID_NODE = new BAST(Token.INVALID_TOKEN);

  /** Pointer to the token stream */
  public static CommonTokenStream tokens;

  /** index of the last token used to make a BAST */
  public static int lastTokenIndex = 0;

  /** Pointer to the last BAST node created that has a Token from the input text */
  public static BAST lastASTwithToken = null;

  // // PUBLIC VALUES ////
  // probably should make as many of these private as possible

  /** A single token is the payload */
  public Token token;

  /** Who is the parent node of this node; if null, implies node is root */
  public BAST parent;

  /** What index is this node in the child list? Range: 0..n-1 */
  public int childIndex = -1;

  /** comments after the token in this AST */
  // public String comments = null;

  // public
  // BAST myParent; //points to parent in the AST, set by overriding addChild
  public String nodeID = "no nodeID yet"; // identifier string if appropriate
  // public
  // Tuple nodeTuple; //pointer to referenced object in symbol table if
  // appropriate
  public int construct = 0; // is this the root of a DANCE construct?
  // I don't think these are used anymore
  // public
  // Vector precondition = null;
  // public
  // Vector postcondition = null;
  public String myAlphaValue = "";
  public String myText = "";
  private int lineNumber = 0;
  public boolean hasTick = false;

  // // PRIVATE VALUES ///
  // private static final long serialVersionUID = -6284695760597422029L;

  /**
   * Scope if there is one attatched to this node or the nearest enclosing
   * scope's symbol table instead
   */
  // public
  Scope scope = null; //
  // or the nearest enclosing scope's symbol table instead

  /** Entity Record for this node if an ID not in Assertion */
  public EntityRecord entityRecord = null;

  /**
   * if this thing has a type, what is it? filled-in using CheckType
   */
  public BAST checkedType = null;

  /**
   * has this node been substituted?
   * */
  public boolean substituted = false;

  // // PROTECTED VALUES ////

  /** A list of ASTs */
  protected EList<BAST> children;

  /**
   * What token indexes bracket all tokens associated with this node and below?
   */
  protected int startIndex = -1, stopIndex = -1;

  /** Parse record that holds the root of this tree */
  ParseRecord parseRecord = null;
  /** Currently parsing ParseRecord */

  /**
   * Link to EMF element generated by Xtext parser
   */
  protected Element element = null;



  /** default, parameterless, constructor */
  public BAST()
    {
    super();
    // this.parseRecord = currentParseRecord;
    }


//  /** link to Ecore model element corresponding to the tree rooted at this node
//   * added by brl 19FEB2015*/
//  public BAST(AObject e)
//  {
//  super();  //run superclass constructor
//  this.reference =e;  //set link to AADL/EMF object
////  this.token = e.getLocationReference().  how to set 'Token' ?
////  this.startIndex = ?;
////  this.stopIndex = ?;
//  this.lineNumber = e.getLocationReference().getLine();
//  this.myText = e.getLocationReference().toString();
//  }  //end of new Ecore-linked node


  /*
   * Constructor from AADL "Element"
   * The xtext grammar has a production like:
Element returns aadl2::Element:
	SubcomponentElement
	| ActualAssertionParameter
	| Assertion
	| AssertionType
  . . .
  * which causes all EMF objects created by the BLESS Xtext parser to also be "Element"
  * a BAST created in translation from heterogeneous, EMF trees
   */
  public BAST(Element e)
      {
    super();
    element=e;
  //set its line number,
//brl 2/17/2022  adding starting line of annex no longer needed
    setLine(AadlUtil.getLineNumberFor(e));
//    setLine(AadlUtil.getLineNumberFor(e)+AadlUtil.getLineNumberFor(AadlUtil.getContainingDefaultAnnex(e)));
    }


  /**
   * Constructor from another tree node does not copy EList<AST> child or parent
   */
  public BAST(BAST node)
    {
    super();
    this.token = node.token;
    this.startIndex = node.startIndex;
    this.stopIndex = node.stopIndex;
    this.lineNumber = node.lineNumber;
    this.myText = node.myText;
    this.parseRecord = node.getParseRecord();
    this.scope = node.scope;
    this.element = node.element;  //copy link to EMF
    // this.comments = node.comments;
    // look for comments
    // if ((this.token!=null)&&(this.token!=Token.INVALID_TOKEN))
    // findAntecedentComments(this.startIndex);
    }

  /** Constructor from a token */
  public BAST(Token t)
    {
    super();
    this.token = t;
    if (t != null)
      {
      this.lineNumber = t.getLine() + BLESS3Parser.getStaticStartingLine();
      // this.lineNumber = BLESS3Lexer.lineNumberOffset+t.getLine();
      this.myText = t.getText();
      }
    // this.parseRecord = currentParseRecord;
    // look for comments
    // if ((this.token != null) && (this.token != Token.INVALID_TOKEN))
    // findAntecedentComments(this.token.getTokenIndex());
    }

  /** Constructor from a string */
  public BAST(String s)
    {
    super();
    this.myText = s;
    // this.parseRecord = currentParseRecord;
    // look for comments
    // if ((this.token != null) && (this.token != Token.INVALID_TOKEN))
    // findAntecedentComments(this.token.getTokenIndex());
    }

  /** Constructor from String, token type, and line number */
  public BAST(String s, int tokenType, int line)
    {
    super();
    this.token = new CommonToken(tokenType, s);
    this.lineNumber = line;
    this.myText = s;
    // this.parseRecord = currentParseRecord;
    }

  /** Constructor from String, token type, and BAST on intended line */
  public BAST(String s, int tokenType, BAST b)
    {
    super();
    this.token = new CommonToken(tokenType, s);
    this.lineNumber = b.getLine();
    this.myText = s;
    this.parseRecord = b.getParseRecord();
    this.element = b.element;  //copy link to EMF
    }

  /**
   * Get AADL/EMF Element for messages, and error marker setting
   * */
  public Element getElement() { return element; }



  /** look for comments between this token and the last one, put into comments */
  /*
   * void findAntecedentComments(int tokenIndex) { if (lastASTwithToken == null)
   * lastASTwithToken = this; else { for (int i = lastTokenIndex + 1; i <
   * tokenIndex; i++) if (tokens.get(i).getChannel() ==
   * BLESS3Lexer.COMMENT_CHANNEL) if (lastASTwithToken.comments == null)
   * lastASTwithToken.comments = "\t" + tokens.get(i).getText() + "\n"; else
   * lastASTwithToken.comments = lastASTwithToken.comments + "\t" +
   * tokens.get(i).getText() + "\n"; if (lastTokenIndex < tokenIndex) {
   * lastTokenIndex = tokenIndex; lastASTwithToken = this; } } }
   */

  public void addChildrenFromVector(Vector<BAST> v)
    {
    for (int i = 0; i < v.size(); i++) {
		addChild(v.elementAt(i));
	}
    }

  /**
   * Add t as child of this node.
   *
   * Warning: if t has no children, but child does and child isNil then this
   * routine moves children to t via t.children = child.children; i.e., without
   * copying the array.
   */
  @Override
  public void addChild(Tree arg0)
    {
    // Dump.it("add child "+t.toStringTree()+"
    // "+this.toStringTree());
    // Dump.it("existing children: "+children);
    if (arg0 == null)
      {
      return; // do nothing upon addChild(null)
      }
    BAST childTree = (BAST) arg0;
    // EList<AST> children = getChild();
    if (childTree.isNil())
      { // t is an empty node possibly with children
      if (children != null && children == childTree.getChildren())
        {
        throw new RuntimeException("attempt to add child list to itself");
        }
      // just add all of childTree's children to this
      if (childTree.getChildren() != null)
        {
        if (children != null)
          { // must copy, this has children already
          int n = childTree.getChildren().size();
          for (int i = 0; i < n; i++)
            {
            try
              {
              BAST c = childTree.getChildren().get(i);
              children.add(c);
              // handle double-link stuff for each child of nil root
              c.setParent(this);
              c.setChildIndex(children.size() - 1);
              }
            catch (Exception ex)
              {
              Dump.it("BAST.addChild(arg0):\nthis="
                  + this.toStringTree() + "arg0=" + childTree.toStringTree());
              ex.printStackTrace();
              }
            }
          }
        else
          {
          // no children for this but t has children; just set pointer
          // call general freshener routine
          this.children = childTree.getChildren();
          this.freshenParentAndChildIndexes();
          }
        }
      }
    else
      { // child is not nil (don't care about children)
      if (children == null)
        {
        children = new BasicEList<BAST>();
        // throw new RuntimeException("EList<AST> child is null.");
        }
      children.add(childTree);
      childTree.setParent(this);
      childTree.setChildIndex(children.size() - 1);
      }
    // Dump.it("now children are: "+children);
    } // end of addChild

  public EList<BAST> getChildren()
    {
    return children;
    }

  @Override
  public Object deleteChild(int i)
    {
    // EList<AST> children = getChildren();
    if (children == null)
      {
      return null;
      }
    BAST disowned = children.remove(i);
    // walk rest and decrement their child indexes
    this.freshenParentAndChildIndexes(i);
    return disowned;
    } // end of deleteChild

  @Override
  public BAST dupNode()
    {
    return new BAST(this);
    }

  public BAST dupTree()
    {
    BAST newTree = new BAST(this);
    // duplicate everything in EList<AST> child
    if (getChildCount() > 0) {
		for (int i = 0; i < getChildCount(); i++) {
			try
		      {
		      newTree.addChild(((BAST) getChild(i)).dupTree());
		      }
		    catch (OutOfMemoryError e)
		      {
		      Dump.it("\nWhatever you just did is really, really bad.\n"
		          + "You f***ed it up, big time.\n"
		          + "Please don\'t try this again, out of memory errors are really, really bad.\n"
		          + "You tried to dupTree() on child " + Integer.toString(i)
		          + " of " + Integer.toString(getChildCount())
		          + " children, with root, " + this.getText() + ".");
		      e.printStackTrace();
		      return null;
		      // throw e;
		      }
		}
	}
    return newTree;
    }

  @Override
  public int getCharPositionInLine()
    {
    if (token == null || token.getCharPositionInLine() == -1)
      {
      if (getChildCount() > 0)
        {
        return getChild(0).getCharPositionInLine();
        }
      return 0;
      }
    return token.getCharPositionInLine();
    }

  @Override
  public Tree getChild(int i)
    {
    if (children == null || i >= children.size())
      {
      return null;
      }
    return children.get(i);
    }

  @Override
  public int getChildCount()
    {
    if (children != null) {
		return children.size();
	} else {
		return 0;
	}
    }

  @Override
  public int getChildIndex()
    {
    return childIndex;
    }

  @Override
  public int getLine()
    {  //replace with location reference?
    return this.lineNumber;
    }

  public void setLine(int line)
  { this.lineNumber=line; }

  @Override
  public Tree getParent()
    {
    return parent;
    }

  /**
   * compare a string with this node's text
   */
  public boolean isText(String s)
    {
    return (s.compareTo(getText()) == 0);
    }

  /**
   * Return contained token's text, if any; o.w. use myText, unless
   * Global.useOnlyASTtext is set
   */
  @Override
  public String getText()
    {
    if (Global.useOnlyASTtext || (token == null))
      {
      return myText;
      }
    // if (includeCommentsInText && (this.comments != null))
    // {
    // return token.getText() + this.comments;
    // }
    return token.getText();
    }

  /**
   * Returns token's staring index
   */
  @Override
  public int getTokenStartIndex()
    {
    if (startIndex == -1 && token != null)
      {
      return token.getTokenIndex();
      }
    return startIndex;
    }

  /**
   * Returns token's ending index
   */
  @Override
  public int getTokenStopIndex()
    {
    if (stopIndex == -1 && token != null)
      {
      return token.getTokenIndex();
      }
    return stopIndex;
    }

  /**
   * Return token's type
   */
  @Override
  public int getType()
    {
    if (token == null)
      {
      return Token.INVALID_TOKEN_TYPE;
      }
    return token.getType();
    }

  /**
   * Return token
   */
  public Token getToken()
    {
    return token;
    }

  /**
   * test token's type
   */
  public boolean hasType(int t)
    {
    return (getType() == t);
    }

  /** is there an AST with geven token type anywhere in my tree? */
  public boolean hasThisTokenTypeAnywhere(int t) throws YouIdiot
    {
    boolean found = false;
    if (this.hasType(t)) {
		found = true; // yes, the type was found
	} else if (this.getChildCount() > 0) {
		for (int ch = 0; !found && (ch < this.getChildCount()); ch++) {
			found = ((BAST) this.getChild(ch)).hasThisTokenTypeAnywhere(t);
		}
	}
    return found;
    } // end of hasThisTokenTypeAnywhere

  /**
   * Is the token held in this tree node null?
   */
  @Override
  public boolean isNil()
    {
    return token == null;
    }

  // /**
  // * Delete children from start to stop and replace with t even if t is a list
  // * (nil-root tree). num of children can increase or decrease. For huge child
  // * lists, inserting children can force walking rest of children to set their
  // * childindex; could be slow.
  // */
  // public void replaceChildren(int startChildIndex, int stopChildIndex, Object
  // t)
  // {
  // /*
  // * Dump.it("replaceChildren "+startChildIndex+", "+stopChildIndex
  // * + " with "+((BaseTree)t).toStringTree());
  // * Dump.it("in="+toStringTree());
  // */
  // // EList<AST> children = getChild();
  // if (children == null)
  // {
  // throw new IllegalArgumentException(
  // "indexes invalid; no children in list");
  // }
  // int replacingHowMany = stopChildIndex - startChildIndex + 1;
  // int replacingWithHowMany;
  // BAST newTree = (BAST) t;
  // EList<BAST> newChildren = null;
  // // normalize to a list of children to add: newChildren
  // if (newTree.isNil())
  // {
  // newChildren = newTree.getChildren();
  // } else
  // {
  // newChildren = newTree.getChildren();
  // newChildren.add((BAST) newTree);
  // }
  // replacingWithHowMany = newChildren.size();
  // int numNewChildren = newChildren.size();
  // int delta = replacingHowMany - replacingWithHowMany;
  // // if same number of nodes, do direct replace
  // if (delta == 0)
  // {
  // int j = 0; // index into new children
  // for (int i = startChildIndex; i <= stopChildIndex; i++)
  // {
  // BAST child = (BAST) newChildren.get(j);
  // children.set(i, child);
  // child.setParent(this);
  // child.setChildIndex(i);
  // j++;
  // }
  // } else if (delta > 0)
  // { // fewer new nodes than there were
  // // set children and then delete extra
  // for (int j = 0; j < numNewChildren; j++)
  // {
  // children.set(startChildIndex + j, newChildren.get(j));
  // }
  // int indexToDelete = startChildIndex + numNewChildren;
  // for (int c = indexToDelete; c <= stopChildIndex; c++)
  // {
  // // delete same index, shifting everybody down each time
  // // BAST killed = (BAST)
  // children.remove(indexToDelete);
  // }
  // freshenParentAndChildIndexes(startChildIndex);
  // } else
  // { // more new nodes than were there before
  // // fill in as many children as we can (replacingHowMany) w/o moving
  // // data
  // for (int j = 0; j < replacingHowMany; j++)
  // {
  // children.set(startChildIndex + j, newChildren.get(j));
  // }
  // // int numToInsert = replacingWithHowMany - replacingHowMany;
  // for (int j = replacingHowMany; j < replacingWithHowMany; j++)
  // {
  // children.add(startChildIndex + j, newChildren.get(j));
  // }
  // freshenParentAndChildIndexes(startChildIndex);
  // }
  // // Dump.it("out="+toStringTree());
  // } // end of replaceChildren

  // public void setAObjectReference(AObject ao)
  // {
  // reference = ao;
  // }

  /**
   * Set ith child (0..n-1) to t; t must be non-null and non-nil node
   *
   * @param i
   * @param t
   */
  @Override
  public void setChild(int i, Tree t)
    {
    if (t == null)
      {
      return;
      }
    if (t.isNil())
      {
      throw new IllegalArgumentException("Can't set single child to a list");
      }
    // EList<AST> children = getChild();
    if (children == null)
      {
      throw new IllegalArgumentException("null EList<AST> from getChild()");
      }
    children.set(i, (BAST) t);
    ((BAST) t).setParent(this);
    ((BAST) t).setChildIndex(i);
    }

  @Override
  public void setTokenStartIndex(int index)
    {
    startIndex = index;
    }

  @Override
  public void setTokenStopIndex(int index)
    {
    stopIndex = index;
    }

  @Override
  public String toString()
    {
    if (isNil())
      {
      return "nil";
      }
    if (getType() == Token.INVALID_TOKEN_TYPE)
      {
      return "<errornode>";
      }
    if (token == null)
      {
      return null;
      }
    return token.getText();
    }

private static int tab=0;  //tabbing for toStringTree

  /** Print out a whole tree not just a node. */
  @Override
  public String toStringTree()
    {
    // EList<AST> children = getChild();
    if (children == null || children.size() == 0)
      {
      return this.toString();
      }
    StringBuffer buf = new StringBuffer();
    if (!isNil())
      {
      buf.append('\n');
      for (int j=0;j<tab;j++) {
		buf.append(" ");
	}
      buf.append("^{");
      buf.append(this.toString());
//      buf.append(' ');
      }
    tab++;
    for (int i = 0; children != null && i < children.size(); i++)
      {
      buf.append(' ');
      BAST t = children.get(i);
      buf.append(t.toStringTree());
//      buf.append(' ');
      }
    tab--;
    if (!isNil())
      {
      buf.append("}");
      }
    return buf.toString();
    } // end of toStringTree

  @Override
  public void setParent(Tree t)
    {
    this.parent = (BAST) t;
    }

  @Override
  public void setChildIndex(int index)
    {
    this.childIndex = index;
    }

  /** Set the parent and child index values for all children of t */
  @Override
  public void freshenParentAndChildIndexes()
    {
    freshenParentAndChildIndexes(0);
    }

  /**
   * Re-compute parent and child indices starting at offset.
   *
   * @param offset
   */
  public void freshenParentAndChildIndexes(int offset)
    {
    int n = getChildCount();
    for (int c = offset; c < n; c++)
      {
      BAST thisChild = (BAST) getChild(c);
      thisChild.setChildIndex(c);
      thisChild.setParent(this);
      }
    }

  //why override to no function from parent?
//  public Tree getAncestor(int arg0)
//    {
//    return null;
//    }
//
//  public List<BAST> getAncestors()
//    {
//    return null;
//    }
//
//  public boolean hasAncestor(int arg0)
//    {
//    return false;
//    }

  public void addTreeItemChildren(TreeItem rootItem)
    {
    for (int ch = 0; ch < getChildCount(); ch++)
      {
      BAST child = (BAST) getChild(ch);
      TreeItem childItem = new TreeItem(rootItem, 0);
      childItem.setText(child.getText());
      // childItem.setForeground(new Color(AWT.));
      child.addTreeItemChildren(childItem);
      }
    } // end of addTreeItemChildren

  public void showParseTree(String s)
    {
    if (!Global.parsingPredeclaredProperties)
      {
      Dump.it("showing tree: " + s);
      if (Activator.plugin != null) // is this an Eclipse plugin?
        {
        try {
        Display display = Display.getDefault();  
        Shell shell = new Shell(display);
        shell.setLayout(new FillLayout());
        shell.setText(s);
        final org.eclipse.swt.widgets.Tree tree = new org.eclipse.swt.widgets.Tree(
            shell, SWT.BORDER);
        TreeItem fakeRootItem = new TreeItem(tree, 0);
        fakeRootItem.setText(s);
        TreeItem rootItem = new TreeItem(fakeRootItem, 0);
        rootItem.setText(getText());
        addTreeItemChildren(rootItem);
        shell.setSize(500, 500);
        shell.open();
          } catch (Exception ex) 
          {Dump.it("Unable to show parse tree.");}
        } 
      else 
		  Dump.it("Please choose Window->Show View->Other->Absract Syntax Tree to see the tree for \""
            + s + "\"");
      }
    } // end of showParseTree

  public int findSmallestLineInTree()
    { // smallest, non-zero line number
    int s = lineNumber; // start with our line number
    for (int i = 0; i < getChildCount(); i++)
      {
      int d = ((BAST) getChild(i)).findSmallestLineInTree();
      if ((d > 0) && (d < s) || s == 0) {
		s = d;
	}
      }
    return s;
    } // end of findSmallestLineInTree

  public int findLargestLineInTree()
    { // smallest, non-zero line number
    int s = lineNumber; // start with our line number
    for (int i = 0; i < getChildCount(); i++)
      {
      int d = ((BAST) getChild(i)).findLargestLineInTree();
      if (d > s) {
		s = d;
	}
      }
    return s;
    } // end of findLargestLineInTree

  public void findAllNodesOfType(int t, Vector<BAST> v) throws YouIdiot
    { // t is a DANCETokenTypes, put nodes with that type in v
    try
      {
      if (getType() == t) {
		v.addElement(this);
	}
      for (int i = 0; i < getChildCount(); i++)
        {
        BAST theChild = (BAST) this.getChild(i);
        theChild.findAllNodesOfType(t, v);
        }
      } // end of try
    catch (Throwable e2)
      {
      Global.dumpToSystemOutToo = true;
      if (e2 instanceof OutOfMemoryError)
        {
        Dump.it("Ha ha.  You\'re out of memory in"
            + " BA.findAllNodesOfType.  " + "\rFix your infinite loop.\r ");
        throw new YouIdiot("infinite loop", this);
        }
      else if (e2 instanceof YouIdiot)
        {
        Dump.it(this.getText() + " ");
        throw (YouIdiot) e2;
        }
      else
        {
        Dump.it("This is so bad that even innocuous"
            + " people must try hard to " + "cause this error.\r "
            + e2.toString());
        throw new YouIdiot("Problem with BA" + ".findAllNodesOfType()",
            this);
        }
      } // end of catch
    } // end of findAllNodesOfType

  /**
   * compares trees on String equality only
   *
   * @param theOtherTree
   * @return boolean
   */
  public boolean equalsTree(BAST theOtherTree)
    {
    // quantified variable map holds mappings between #xxx# q.v. IDs
    HashMap<String, String> qvMap = new HashMap<String, String>();
    return equalsTree(theOtherTree, qvMap);
    } // end of equalsTree

  
  /**
   * compares trees on String equality only modified to match quantified
   * variables
   *
   * @param theOtherTree
   *          qvMap
   * @return boolean
   */
  boolean equalsTree(BAST theOtherTree, HashMap<String, String> qvMap)
    {
    //  check for numeric literals
    if (this.isNumericLiteral()
            && theOtherTree.isNumericLiteral())
      return (this.truncateWholeLiterals().contentEquals(theOtherTree.truncateWholeLiterals()));
    // make INVOKE match FUNCTION_CALL
    if (!((this.hasType(BLESS3Lexer.INVOKE)||this.hasType(BLESS3Lexer.SUBPROGRAM_INVOCATION))
// 		      this.hasType(BLESS3Lexer.INVOKE_FUNCTION))
        && (theOtherTree.hasType(BLESS3Lexer.INVOKE)||theOtherTree.hasType(BLESS3Lexer.SUBPROGRAM_INVOCATION)))
//    		  theOtherTree.hasType(BLESS3Lexer.INVOKE_FUNCTION)))
        && !this.hasType(theOtherTree.getType()))
		return false; // different token types
    // then check alphabetic IDs
    if (this.hasType(BLESS3Lexer.ID)
        && theOtherTree.hasType(BLESS3Lexer.ID))
      {
      if (Global.allQuantifiedVariablesAreEqual
          && this.getText().startsWith("#")
          && theOtherTree.getText().startsWith("#"))
        { // check quantified variables
        if (qvMap.containsKey(this.getText())) {
			// does the other string match to one in the map?
			  return qvMap.get(this.getText())
			      .equalsIgnoreCase(theOtherTree.getText());
		} else
          { // put this pair in map
          qvMap.put(this.getText(), theOtherTree.getText());
          return true;
          }
        } // done with quantified variables
      else if (!this.isText(theOtherTree.getText()))
		    return false; // not equal
      }
    // still equal token types and equal IDs (if any)
    if (this.getChildCount() != theOtherTree.getChildCount())
	 {
		// children?
		  return false; // not same number of children
	}

    // okay, parents match, let's try children
    boolean childrenStillEqual = true;
    if (this.getChildCount() > 0) {
		for (int j = 0; childrenStillEqual && (j < this.getChildCount()); j++) {
			childrenStillEqual = ((BAST) this.getChild(j))
		        .equalsTree((BAST) theOtherTree.getChild(j));
		}
	}
    return childrenStillEqual;
    } // end of equalsTree

  public String truncateWholeLiterals()
  {
  String s = this.getText();
  if (hasType(BLESS3Lexer.NUMBER))
    return s;
  if (s.contains(".") && !s.contains("e"))
    {
    boolean foundNonZero = false;
    for (int i=s.indexOf('.')+1; i<s.length(); i++)
      if (s.charAt(i) != '0')
        foundNonZero = true;
    if (foundNonZero)
      return s;
    else
      return s.substring(0, s.indexOf('.'));
    }
  else
    return s;
  }
  
  /**
   * sort the children lexicographically
   */
  public boolean sortChildren()
    { // returns true when something changed
    boolean madeChange = false; //
    for (int i = 0; i < (getChildCount() - 1); i++) {
		for (int j = i + 1; j < getChildCount(); j++)
		    {
		    BAST iChild = (BAST) getChild(i);
		    BAST jChild = (BAST) getChild(j);
		    // just for debugging
		    // String textOfi = iChild.getText();
		    // String textOfj = jChild.getText();
		    if (jChild.lessThanTree(iChild))
		      {
		      setChild(j, iChild);
		      setChild(i, jChild);
		      madeChange = true;
		      }
		    }
	}
    return madeChange;
    } // end of sortChildren

  public boolean lessThanNode(BAST theOtherNode)
    { // compare .getText
    if (hasType(BLESS3Lexer.ID) && theOtherNode.hasType(BLESS3Lexer.ID)) 
		// ID?
		  return (getText().compareTo(theOtherNode.getText()) < 0); // conpare text
    else if (isNumericLiteral() && !theOtherNode.isNumericLiteral())
      return true;
    else if (!isNumericLiteral() && theOtherNode.isNumericLiteral())
      return false;
	  else 
		  return (getType() < theOtherNode.getType());
    } // end of lessThanNode

  public boolean lessThanTree(BAST theOtherTree)
    {
    if (lessThanNode(theOtherTree)) {
		return true;
	} else if (theOtherTree.lessThanNode(this)) {
		return false;
	} else {
		for (int i = 0; (i < getChildCount())
		      && (i < theOtherTree.getChildCount()); i++)
		    { // check children
		    BAST myChild = (BAST) getChild(i);
		    BAST otherChild = (BAST) theOtherTree.getChild(i);
		    if (myChild.lessThanTree(otherChild)) {
				return true;
			} else if (otherChild.lessThanTree(myChild)) {
				return false;
			}
		    }
	}
    // children all the same?
    return getChildCount() < theOtherTree.getChildCount();
    } // end of lessThanTree

  public boolean atMostTree(BAST theOtherTree)
    { // is the tree rooted in this node <= the other tree?
    return equalsTree(theOtherTree) || lessThanTree(theOtherTree);
    } // end of atMostTree

  public BAST replaceOccurrences(BAST ofThis, BAST withThis)
    { // replace all occurrences of ofThis, with a duplicate of withThat
    // look through children for match
    if (getChildCount() > 0)
      {
    //don't replace formal labels formal:actual, start with second child to replace
      for (int i = (hasType(BLESS3Lexer.PARAMETER)?1:0); i < getChildCount(); i++) {
		// does child match?
        if (((BAST) getChild(i)).equalsTree(ofThis)) {
			setChild(i, withThis.dupTree());
			// otherwise replaceOccurences on children
		} else {
			((BAST) getChild(i)).replaceOccurrences(ofThis, withThis);
		}
	}
      }
    return this;
    } // end of replaceOccurances

  public BAST replaceOccurrencesNotAlreadySubstituted(BAST ofThis, BAST withThis)
    { // replace all occurrences of ofThis, with a duplicate of withThat
    // look through children for match
    if (getChildCount() > 0)
      {
      for (int i = 0; i < getChildCount(); i++) {
		// does child match?
        if (!((BAST) getChild(i)).substituted
            && ((BAST) getChild(i)).equalsTree(ofThis)) {
			setChild(i, withThis.dupTree());
			// otherwise replaceOccurences on children
		} else {
			((BAST) getChild(i)).replaceOccurrences(ofThis, withThis);
		}
	}
      }
    return this;
    } // end of replaceOccurrencesNotAlreadySubstituted

  public String unparse() throws YouIdiot
    {
    String result = getText();
    try
      {
      CommonTreeNodeStream nodes    = new CommonTreeNodeStream(this.dupTree());
      UnparseBLESS3         unparser = new UnparseBLESS3(nodes);
      unparser.setTemplateLib(Global.templates);
      unparser.setStartingLine(getLine());
      // UnparseBLESS3.blessSubclause_return tbu = null;
      // UnparseBLESS3.actionSubclause_return sbu = null;
      // UnparseBLESS3.assertionLibrary_return aau = null;
//Parse.templates.getInstanceOf("blessSubclause",new STAttrMap().put("sv", (sv!=null?((StringTemplate)sv.getTemplate()):null)).put("bs", list_bs)
//      retval.st = new StringTemplate(templateLib, "assert \n  <ass; separator=\"\\n\"> \n",new STAttrMap().put("ass", list_ass));

      switch (this.getType())
        {
        case BLESS3Lexer.DUMMY:
          result = " ";
          break;
        case BLESS3Lexer.DOUBLE_COLON:
          result = getChild(0).getText() + "::" + getChild(1).getText();
          break;
        case BLESS3Lexer.AT_SIGN:
          result = ((BAST) this.getChild(0)).unparse() + "@" + ((BAST) this.getChild(1)).unparse();
          break;
        case BLESS3Lexer.CARET:
          result = ((BAST) this.getChild(0)).unparse() + "^" + ((BAST) this.getChild(1)).unparse();
          break;
        case BLESS3Lexer.BLESS_SUBCLAUSE:
          UnparseBLESS3.blessSubclause_return tbu = null;
          tbu = unparser.blessSubclause();
          StringTemplate threadOutput = (StringTemplate) tbu.getTemplate();
          if (threadOutput != null)
            {
            result = threadOutput.toString(Global.wrapLength); // wrap
            }
          // at 72
          break;
        case BLESS3Lexer.ACTION_SUBCLAUSE:
          UnparseBLESS3.actionSubclause_return sbu = null;
          sbu = unparser.actionSubclause();
          StringTemplate subprogramOutput = (StringTemplate) sbu.getTemplate();
          if (subprogramOutput != null)
            {
            result = subprogramOutput.toString(Global.wrapLength); // wrap
            }
          // at
          // 72
          break;
        case BLESS3Lexer.ASSERTION_ANNEX: // library
          UnparseBLESS3.assertionLibrary_return al = null;
          al = unparser.assertionLibrary();
          StringTemplate annexLibraryeOutput = (StringTemplate) al.getTemplate();
          if (annexLibraryeOutput != null)
            {
            result = annexLibraryeOutput.toString(Global.wrapLength); // wrap
            }
          // at
          // 72
          break;
        case BLESS3Lexer.ASSERTION:
        case BLESS3Lexer.ASSERTION_ENUMERATION:
        case BLESS3Lexer.ASSERTION_FUNCTION:
          // Dump.it("unparse Assertion: "+toStringTree());
          // THIS IS A STUPID KLUDGE TO GET RID OF SPURIOUS ROOT THAT
          // APPEARS WHEN MAKING CONNECTION OBLIGATIONS
          // USING ENUMERATION TYPES
          if ((getChild(0) != null) && ((BAST) getChild(0)).hasType(BLESS3Lexer.ASSERTION_ENUMERATION))
            {
            result = ((BAST) getChild(0)).unparse();
            } else
            {
            UnparseBLESS3.assertion_return a = null;
            a = unparser.assertion();
            if (a == null)
              {
              throw new YouIdiot("null return from UnparseBLESS3.assertion", this);
              }
            StringTemplate assertionOutput = (StringTemplate) a.getTemplate();
            if (assertionOutput == null)
              {
              throw new YouIdiot("null return from UnparseBLESS3.getTemplate", this);
              }
            result = assertionOutput.toString(Global.wrapLength); // wrap
            // at
            // 72
            }
          break;
        case BLESS3Lexer.LPAREN:
          try
            {
            UnparseBLESS3.parenthesizedSubexpression_return pp = null;
            pp = unparser.parenthesizedSubexpression();
            if (pp == null)
              {
              throw new YouIdiot("null return from UnparseBLESS3.parenthesized_xxx", this);
              }
            StringTemplate lparenOutput = (StringTemplate) pp.getTemplate();
            if (lparenOutput == null)
              {
              throw new RecognitionException(); // YI("null return from UnparseBLESS3.getTemplate",this);
              }
            result = lparenOutput.toString(Global.wrapLength); // wrap
            // at 72
            } catch (RecognitionException re)
            {
            Dump.it("Tree rooted in LPAREN wouldn\'t unparse.  Using toStringTree instead.");
            result = this.toStringTree();
            }
          break;
        case BLESS3Lexer.INVOKE:
        case BLESS3Lexer.WP:
          UnparseBLESS3.invocation_return pi = null;
          pi = unparser.invocation();
          if (pi == null)
            {
            throw new YouIdiot("null return from UnparseBLESS3.invocation", this);
            }
          StringTemplate piOutput = (StringTemplate) pi.getTemplate();
          if (piOutput == null)
            {
            throw new YouIdiot("null return from UnparseBLESS3.getTemplate", this);
            }
          result = piOutput.toString(Global.wrapLength); // wrap at 72
          break;
//        case BLESS3Lexer.INVOKE_FUNCTION:
//          UnparseBLESS3.assertion_function_invocation_return afi = null;
//          afi = unparser.assertion_function_invocation();
//          if (afi == null)
//            {
//            throw new YouIdiot("null return from UnparseBLESS3.invocation", this);
//            }
//          StringTemplate afiOutput = (StringTemplate) afi.getTemplate();
//          if (afiOutput == null)
//            {
//            throw new YouIdiot("null return from UnparseBLESS3.getTemplate", this);
//            }
//          result = afiOutput.toString(Global.wrapLength); // wrap at 72
//          break;
        case BLESS3Lexer.LITERAL_all:
        case BLESS3Lexer.LITERAL_exists:
        case BLESS3Lexer.LITERAL_and:
        case BLESS3Lexer.LITERAL_or:
        case BLESS3Lexer.LITERAL_xor:
        case BLESS3Lexer.LITERAL_implies:
        case BLESS3Lexer.LITERAL_iff:
          // case BLESS3Lexer.IMP:
        case BLESS3Lexer.LITERAL_not:
        case BLESS3Lexer.LITERAL_true:
        case BLESS3Lexer.LITERAL_false:
        case BLESS3Lexer.EQ:
        case BLESS3Lexer.NEQ:
        case BLESS3Lexer.LT:
        case BLESS3Lexer.AM:
        case BLESS3Lexer.AL:
        case BLESS3Lexer.GT:
          UnparseBLESS3.predicate_return pred = null;
//        UnparseBLESS3.expression_or_relation_return expr = null;
//          try {expr = unparser.expression_or_relation();}
//          catch (RecognitionException re)
          {
          pred = unparser.predicate();
          }
          if (pred != null)
            { // it was a predicate
            StringTemplate predOutput = (StringTemplate) pred.getTemplate();
            if (predOutput == null)
              {
              throw new YouIdiot("null return from UnparseBLESS3.getTemplate for predicate", this);
              }
            result = predOutput.toString(Global.wrapLength); // wrap at 72
            }
//          else if (expr!=null)
//          	{  //it was an expression or range
//          	StringTemplate exprOutput = (StringTemplate) expr.getTemplate();
//          	if (exprOutput == null)
//          		throw new YouIdiot("null return from UnparseBLESS3.getTemplate for expressio_or_relation",
//          				this);
//          	result = exprOutput.toString(Global.wrapLength); // wrap at 72
//          	}
          else
            {
            throw new YouIdiot("null return from UnparseBLESS3.predicate", this);
            }
          break;
        // constructs unparsed by behaviorActions
        case BLESS3Lexer.ACTION:
        case BLESS3Lexer.AMPERSAND:
        case BLESS3Lexer.SEMICOLON:
          UnparseBLESS3.behaviorActions_return bau = null;
          bau = unparser.behaviorActions();
          StringTemplate actionOutput = (StringTemplate) bau.getTemplate();
          result = actionOutput.toString(Global.wrapLength); // wrap at 72
          break;
        // constructs unparsed by action
        case BLESS3Lexer.ASSIGN:
        case BLESS3Lexer.LITERAL_skip:
        case BLESS3Lexer.LITERAL_setmode:
   //     case BLESS3Lexer.SUBPROGRAM_INVOCATION:
        case BLESS3Lexer.PORT_OUTPUT:
        case BLESS3Lexer.PORT_INPUT:
        case BLESS3Lexer.LITERAL_computation:
        case BLESS3Lexer.LITERAL_delay:
        case BLESS3Lexer.LITERAL_fetchadd: // combinable operations
        case BLESS3Lexer.LITERAL_fetchand:
        case BLESS3Lexer.LITERAL_fetchor:
        case BLESS3Lexer.LITERAL_fetchxor:
        case BLESS3Lexer.LITERAL_swap:
        case BLESS3Lexer.LCURLY: // existential_lattice_quantification
        case BLESS3Lexer.LITERAL_declare: // existential_lattice_quantification
        case BLESS3Lexer.LITERAL_forall: // universal_lattice_quantification
        case BLESS3Lexer.LITERAL_while: // while loop
        case BLESS3Lexer.LITERAL_for: // for loop
        case BLESS3Lexer.LITERAL_do: // do until loop
        case BLESS3Lexer.LITERAL_if: // alternative
          UnparseBLESS3.action_return act = null;
          act = unparser.action();
          actionOutput = (StringTemplate) act.getTemplate();
          result = actionOutput.toString(Global.wrapLength); // wrap at 72
          break;
        // case BLESS3Lexer.PORT_NAME: //alternative
        // UnparseBLESS3.port_name_return pnr=null;
        // pnr = unparser.port_name();
        // actionOutput = (StringTemplate)pnr.getTemplate();
        // result = actionOutput.toString(Global.wrapLength); //wrap at 72
        // break;
        case BLESS3Lexer.ARROW:
          result = "=>";
          break;
        case BLESS3Lexer.IMP:
          if (getChildCount() == 2)
            {
            UnparseBLESS3.conditionValuePair_return cvp = null;
            cvp          = unparser.conditionValuePair();
            actionOutput = (StringTemplate) cvp.getTemplate();
            result       = actionOutput.toString(Global.wrapLength); // wrap at 72
            } else
            {
            result = "->";
            }
          break;
        case BLESS3Lexer.LITERAL_now:
          result = "now";
          break;
        case BLESS3Lexer.UNARY_MINUS:
          result = "- " + ((BAST) this.getChild(0)).unparse();
          break;
        // name
        case BLESS3Lexer.DOT:
          // case BLESS3Lexer.ID:
          UnparseBLESS3.valueName_return nam = null;
          nam = unparser.valueName();
          StringTemplate nameOutput = (StringTemplate) nam.getTemplate();
          result = nameOutput.toString(Global.wrapLength); // wrap at 72
          break;
        // literals
        case BLESS3Lexer.LITERAL_boolean:
//        case BLESS3Lexer.LITERAL_time:
//          if (getChildCount() == 0)
//            {
//            result = UnparseBLESS3.template(getText()).toString();
//            } else
//            {
//            UnparseBLESS3.number_type_return nt = null;
//            nt = unparser.number_type();
//            StringTemplate number_typeOutput = (StringTemplate) nt.getTemplate();
//            result = number_typeOutput.toString(Global.wrapLength); // wrap at 72
//            }
//          break;
        // string
        case BLESS3Lexer.LITERAL_string:
          result = getText();
          break;
        // otherwise unparse it as a type
        // type
        case BLESS3Lexer.LITERAL_enumeration: // enumeration_type
        case BLESS3Lexer.LITERAL_array: // array_type
        case BLESS3Lexer.LITERAL_record: // record_type
        case BLESS3Lexer.LITERAL_variant: // variant_type
        case BLESS3Lexer.TYPE_OPERATOR_INVOCATION: // variant_type
          UnparseBLESS3.type_return typ = null;
          typ = unparser.type();
          StringTemplate typeOutput = (StringTemplate) typ.getTemplate();
          result = typeOutput.toString(Global.wrapLength); // wrap at 72
          break;
        case BLESS3Lexer.SUBPROGRAM_INVOCATION: // subprogramCall
          UnparseBLESS3.subprogramCall_return fc = null;
          fc = unparser.subprogramCall();
          StringTemplate fcOutput = (StringTemplate) fc.getTemplate();
          result = fcOutput.toString(Global.wrapLength); // wrap at 72
          break;
        case BLESS3Lexer.PLUS:
        case BLESS3Lexer.MINUS:
        case BLESS3Lexer.TIMES:
        case BLESS3Lexer.DIVIDE:
        case BLESS3Lexer.EXP:
        case BLESS3Lexer.LITERAL_numberof:
        case BLESS3Lexer.LITERAL_product:
        case BLESS3Lexer.LITERAL_sum:
          try
            {
            UnparseBLESS3.expression_return ae = null;
            ae = unparser.expression();
            StringTemplate aeOutput = (StringTemplate) ae.getTemplate();
            result = aeOutput.toString(Global.wrapLength); // wrap at 72
            } catch (Exception e)
            {
            result = this.toStringTree();
            }
          break;
//        case BLESS3Lexer.CONDITIONAL:
//          try
//            {
//            UnparseBLESS3.conditional_assertion_expression_return cae = null;
//            cae = unparser.conditional_assertion_expression();
//            StringTemplate caeOutput = (StringTemplate) cae.getTemplate();
//            result = caeOutput.toString(Global.wrapLength); // wrap at 72
//            } catch (Exception e)
//            {
//            result = this.toStringTree();
//            }
//          break;
//        case BLESS3Lexer.CONDITIONAL_FUNCTION:
//          try
//            {
//            UnparseBLESS3.conditional_assertion_function_return caf = null;
//            caf = unparser.conditional_assertion_function();
//            StringTemplate caeOutput = (StringTemplate) caf.getTemplate();
//            result = caeOutput.toString(Global.wrapLength); // wrap at 72
//            } catch (Exception e)
//            {
//            result = this.toStringTree();
//            }
//          break;
        case BLESS3Lexer.QUESTION:
        case BLESS3Lexer.INMODE:
          try
            {
            UnparseBLESS3.value_return v = null;
            v = unparser.value();
            StringTemplate valueOutput = (StringTemplate) v.getTemplate();
            result = valueOutput.toString(Global.wrapLength); // wrap at 72
            } catch (Exception e)
            {
            result = this.toStringTree();
            }
          break;
        case BLESS3Lexer.TICK:
          try
            {  //is it a port'fresh, etc. or a timed_predicate or a timedExpression
            if ((getChildCount()==2) && 
                (((BAST)getChild(1)).hasType(BLESS3Lexer.LITERAL_fresh)
                  || ((BAST)getChild(1)).hasType(BLESS3Lexer.LITERAL_count)
                  || ((BAST)getChild(1)).hasType(BLESS3Lexer.LITERAL_updated)        
               ))            
              {  //it's a port
              UnparseBLESS3.value_return v = null;
              v = unparser.value();
              StringTemplate valueOutput = (StringTemplate) v.getTemplate();
              result = valueOutput.toString(Global.wrapLength); // wrap at 72
              }
            else //try  //timedExpression
              {
              UnparseBLESS3.timedExpression_return te = null;
              te = unparser.timedExpression();
              StringTemplate valueOutput = (StringTemplate) te.getTemplate();
              result = valueOutput.toString(Global.wrapLength); // wrap at 72              
              }
//            catch (RecognitionException re)
//              {  //if that doesn't work, try timed_predicate
//              UnparseBLESS3.timed_predicate_return tp = null;
//              tp = unparser.timed_predicate();
//              StringTemplate valueOutput = (StringTemplate) tp.getTemplate();
//              result = valueOutput.toString(Global.wrapLength); // wrap at 72                            
//              }
            } catch (Exception e)
            {
            result = this.toStringTree();
            }
          break; 
        case BLESS3Lexer.LITERAL_timeout:
          try
            {
            UnparseBLESS3.dispatchTrigger_return dt = null;
            dt = unparser.dispatchTrigger();
            StringTemplate caeOutput = (StringTemplate) dt.getTemplate();
            result = caeOutput.toString(Global.wrapLength); // wrap at 72
            } catch (Exception e)
            {
            result = this.toStringTree();
            }
          break;
        case BLESS3Lexer.TRANSITION:
          try
            {
            UnparseBLESS3.behaviorTransition_return bt = null;
            bt = unparser.behaviorTransition();
            StringTemplate btOutput = (StringTemplate) bt.getTemplate();
            result = btOutput.toString(Global.wrapLength); // wrap at 72
            } catch (Exception e)
            {
            result = this.toStringTree();
            }
          break;
        case BLESS3Lexer.LITERAL_dispatch:
        try
          {
          UnparseBLESS3.dispatchCondition_return dc = null;
          dc = unparser.dispatchCondition();
          StringTemplate btOutput = (StringTemplate) dc.getTemplate();
          result = btOutput.toString(Global.wrapLength); // wrap at 72
          } catch (Exception e)
          {
          result = this.toStringTree();
          }
          break;
        case BLESS3Lexer.OCTOTHORPE:
        try
          {
          UnparseBLESS3.propertyReference_return pr = null;
          pr = unparser.propertyReference();
          StringTemplate btOutput = (StringTemplate) pr.getTemplate();
          result = btOutput.toString(Global.wrapLength); // wrap at 72
          } catch (Exception e)
          {
          result = this.toStringTree();
          }
          break;
        // case BLESS3Lexer.PORT_OUTPUT:
        // if (this.getChildCount()==1) //any parameter?
        // result=this.getChild(0).getText()+"!"; //no, just ID!
        // else
        // result=this.getChild(0).getText()+"!("+((BAST)this.getChild(1)).unparse()+")";
        // break;
        default:
          result = this.toStringTree();
          // throw new YI("This token type, "+
          // (this.getType()<QuantificationLaw.tokenNames.length?
          // QuantificationLaw.tokenNames[this.getType()]:
          // Integer.toString(this.getType())
          // )+
          // " does not match its switch choices in BAST.unparse().",this);
        } // end of switch
      } catch (RecognitionException e)
      {
      result = this.toStringTree();
//      if (!Global.dumpFileClosed)
//        {
//        Global.dumpToSystemOutToo = true;
//        if (!Global.stackTracePrinted)
//          {
//          Dump.it(e.getMessage());
//          e.printStackTrace(System.out);
//          e.printStackTrace(Global.pw);
//          Global.stackTracePrinted = true;
//          }
//        Dump.it("RecognitionException during unparsing" + e.toString());
//        }
//      else
//        {
//        Dump.it("RecognitionException during unparsing"
//            + e.toString());
//        e.printStackTrace();
//        }
      }
    return result;
    } // end of unparse

  /** Delete children from start to stop and replace with t even if t is
	 *  a list (nil-root tree).  num of children can increase or decrease.
	 *  For huge child lists, inserting children can force walking rest of
	 *  children to set their childindex; could be slow.
   * cut&pasted from org.antlr.runtime.tree.BaseTree override to figure out why
   * it was throwing IllegalArgumentException during ANTLR3-contolled tree
   * pattern matching in SubstituteAssertions.g
   */
  @Override
  public void replaceChildren(int startChildIndex, int stopChildIndex, Object t)
    {
    /*
     * Dump.it("replaceChildren "+startChildIndex+", "+stopChildIndex+
     * " with "+((BAST)t).toStringTree());
     * Dump.it("in="+toStringTree());
     */
    if (children == null)
      {
      Dump.it("\nOoooh.  You\'ve somehow tried to replace the children of a tree node without children.");
      Dump.it("Actually, this is quite the achievement.  Now fix your flaw.\n\n");
      Dump.it("text=" + getText() + " token type="
          + Integer.toString(getType()) + " line="
          + Integer.toString(getLine()));
      if (getParent() != null) {
		Dump.it("Parent\'s text=" + getParent().getText() + " token type="
            + Integer.toString(getParent().getType()) + " line="
            + Integer.toString(getParent().getLine()));
	}
      throw new IllegalArgumentException("indexes invalid; no children in list");
      }
    int replacingHowMany = stopChildIndex - startChildIndex + 1;
    int replacingWithHowMany;
    BAST newTree = (BAST) t;
    EList<BAST> newChildren = null;
    // normalize to a list of children to add: newChildren
    if (newTree.isNil())
      {
      newChildren = newTree.getChildren();
      }
    else
      {
      newChildren = new BasicEList<BAST>(1);
      newChildren.add(newTree);
      }
    replacingWithHowMany = newChildren.size();
    int numNewChildren = newChildren.size();
    int delta = replacingHowMany - replacingWithHowMany;
    // if same number of nodes, do direct replace
    if (delta == 0)
      {
      int j = 0; // index into new children
      for (int i = startChildIndex; i <= stopChildIndex; i++)
        {
        BAST child = newChildren.get(j);
        children.set(i, child);
        child.setParent(this);
        child.setChildIndex(i);
        j++;
        }
      }
    else if (delta > 0)
      { // fewer new nodes than there were
      // set children and then delete extra
      for (int j = 0; j < numNewChildren; j++)
        {
        children.set(startChildIndex + j, newChildren.get(j));
        }
      int indexToDelete = startChildIndex + numNewChildren;
      for (int c = indexToDelete; c <= stopChildIndex; c++)
        {
        // delete same index, shifting everybody down each time
        // BAST killed = (BAST)
        children.remove(indexToDelete);
        }
      freshenParentAndChildIndexes(startChildIndex);
      }
    else
      { // more new nodes than were there before
      // fill in as many children as we can (replacingHowMany) w/o moving data
      for (int j = 0; j < replacingHowMany; j++)
        {
        children.set(startChildIndex + j, newChildren.get(j));
        }
      // int numToInsert = replacingWithHowMany-replacingHowMany;
      for (int j = replacingHowMany; j < replacingWithHowMany; j++)
        {
        children.add(startChildIndex + j, newChildren.get(j));
        }
      freshenParentAndChildIndexes(startChildIndex);
      }
    // Dump.it("out="+toStringTree());
    } // end of replaceChildren

  /** is there an "ID" AST matching a given ID anywhere in my tree? */
  public boolean hasThisIDanywhere(BAST s) throws YouIdiot
    {
    boolean found = false;
    if (s == null) {
		throw new YouIdiot("null parameter to BAST.hasThisIDanywhere");
	}
    if (!s.hasType(BLESS3Lexer.ID)) {
		throw new YouIdiot("you must call BAST.hasThisIDanywhere with an ID ", s);
	}
    if (this.hasType(BLESS3Lexer.ID) && s.isText(this.getText())) {
		found = true; // this is an ID with same text
	} else if (this.getChildCount() > 0) {
		for (int ch = 0; !found && (ch < this.getChildCount()); ch++) {
			found = ((BAST) this.getChild(ch)).hasThisIDanywhere(s);
		}
	}
    return found;
    } // end of hasThisIDanywhere

  /** look through IDs in ^(COLON type=. ID+) using hasThisIDanywhere */
  public boolean hasAnyOfTheChildIDsAnywhere(BAST s) throws YouIdiot
    {
    boolean found = false;
    if (s == null) {
		throw new YouIdiot("null parameter to BAST.hasAnyOfTheChildIDsAnywhere");
	}
    if (!s.hasType(BLESS3Lexer.COLON)) {
		throw new YouIdiot(
		      "you must call BAST.hasAnyOfTheChildIDsAnywhere with \":\" as root! ^(COLON type=. ID+) ",
		      s);
	}
    if (s.getChildCount() < 2) {
		throw new YouIdiot(
		      "you must call BAST.hasAnyOfTheChildIDsAnywhere with \",\" as root with at least two children ",
		      s);
	}
    for (int ch = 0; !found && ch < s.getChildCount(); ch++)
      { // check each child id with hasThisIDanywhere
      if (((BAST) s.getChild(ch)).hasType(BLESS3Lexer.ID)) {
		// children that
                                                               // are IDs
        found = hasThisIDanywhere((BAST) s.getChild(ch));
	}
      } // end of for ch
    return found;
    } // end of hasAnyOfTheChildIDsAnywhere

  public BAST getPredicateFromAssertion() throws YouIdiot
    {
    if (!this.hasType(BLESS3Lexer.ASSERTION)) {
		throw new YouIdiot("Tried to BAST.getPredicateFromAssertion "
		      + "on something that isn\'t BLESS3Lexer.ASSERTION", this);
	}
    // ^( ASSERTION ^( LABEL a=ID ) ^(PARAMETERS lv+=ID+ ) p=predicate )
    if (((BAST) this.getChild(0)).hasType(BLESS3Lexer.LABEL)
        && ((BAST) this.getChild(1)).hasType(BLESS3Lexer.PARAMETERS)) {
		return (BAST) this.getChild(2);
	} else if (((BAST) this.getChild(0)).hasType(BLESS3Lexer.LABEL)) {
		return (BAST) this.getChild(1);
		// ^( ASSERTION p2=predicate )
	} else {
		return (BAST) this.getChild(0);
	}
    } // end of getPredicateFromAssertion

  /** how many node in tree rooted at this node? */
  public int subtreeNodeCount()
    {
    if (getChildCount() == 0) {
		return 1;
	}
    int total = 1;
    for (int ch = 0; ch < getChildCount(); ch++) {
		total += ((BAST) getChild(ch)).subtreeNodeCount();
	}
    return total;
    } // end of subtreeNodeCount

  /**
   * does this node have a sub-tree node count to get a newline prepended when
   * unparsed?
   */
  public boolean n()
    {
    return subtreeNodeCount() >= Global.newlineNodeCountThreshold;
    }

  /** get nearest enclosing Scope */
  public Scope getScope()
    {
    if ((scope != null) && (parent != null)) {
		scope = parent.getScope();
	}
    return scope;
    } // end of getScope

  public void setScope(Scope s)
    { // only set scope it it is null
    if (scope == null) {
		scope = s;
	}
    for (int i = 0; i < getChildCount(); i++) {
		((BAST) getChild(i)).setScope(scope);
	}
    }

  /** is this node part of an Assertion? */
  public boolean isPartOfAssertion()
    {
    if (hasType(BLESS3Lexer.ASSERTION)||hasType(BLESS3Lexer.ASSERTION_FUNCTION)||
    		hasType(BLESS3Lexer.ASSERTION_ENUMERATION)) {
		return true;
	} else if (parent != null) {
		return parent.isPartOfAssertion();
	}
	else {
		return false; // null parent and not itself part of action
	}
    } // end of isPartOfAssertion


  /** is this node part of an action? */
  public boolean isPartOfAction()
    {
    if (hasType(BLESS3Lexer.ACTION)) {
		return true;
	} else if (parent != null) {
		return parent.isPartOfAction();
	}
	else {
		return false; // null parent and not itself part of action
	}
    } // end of isPartOfAction

  /** is this node part of a dispatch condition? */
  public boolean isPartOfDispatchCondition()
    { // check parent for CONDITION
    if ((parent != null) && parent.hasType(BLESS3Lexer.LITERAL_dispatch)) {
		return true;
	} else if (parent != null) {
		return parent.isPartOfDispatchCondition();
	}
	else {
		return false; // null parent and not itself a condition
	}
    } // end of isPartOfDispatchCondition

  /** is this node part of an execute condition? */
  public boolean isPartOfExecuteCondition()
    { // check parent for CONDITION
    if ((parent != null) && parent.hasType(BLESS3Lexer.CONDITION)) {
		return true;
	} else if ((parent != null) && parent.hasType(BLESS3Lexer.LITERAL_dispatch)) {
		return false;
	} else if (parent != null) {
		return parent.isPartOfExecuteCondition();
	}
	else {
		return false; // null parent and not itself a condition
	}
    } // end of isPartOfExecuteCondition

  // * set checkedType reference, henceforth this node will have BLESS type t */
  public void setCheckedType(BAST t)
    {
    this.checkedType = t;
    }

  // * set checkedType reference, henceforth this node will have BLESS type t */
  public BAST getCheckedType()
    {
    return this.checkedType;
    }

  /**
   * returns checked-type of this node as String
   *
   */
  public String checkedTypeToString()
    {
    if (this.checkedType == null) {
		return "";
	} else {
		return this.checkedType.toStringTree();
	}
    }

  public boolean myParentIsNeitherPeriodNorDoubleColon()
    {
    if (this.getParent() == null) {
		return true; // no parent
	} else if (((BAST) this.getParent()).hasType(BLESS3Lexer.DOT)
        || ((BAST) this.getParent()).hasType(BLESS3Lexer.DOUBLE_COLON)
//        || ((BAST) this.getParent()).hasType(BLESS3Lexer.BEHAVIOR_TIME)
        ) {
		return false;
	} else {
		return true;
	}
    }

  public boolean hasChildren()
    {
    return (getChildCount() > 0);
    }

  public static BAST makeIntoBAST(Object o) throws YouIdiot
    {
    if (o instanceof BAST) {
		return (BAST) o;
	}
    if (o instanceof Token)
      {
      Dump.it("making Token \"" + ((Token) o).getText() + "\" on line"
          + Integer.toString(((Token) o).getLine()) + " into BAST");
      return new BAST((Token) o);
      }
    if (o instanceof String)
      {
      Dump.it("making String \"" + ((String) o) + "\" on line 0 into BAST");
      return new BAST((String) o);
      }
    if (o instanceof CommonTree) {
		return (BAST) o;
	}
    Dump.it(" BAST.makeIntoBAST(o) accepts BAST, Token, or String argments.\n"
        + "This is not:  " + o.toString());
    return null;
    } // end of makeIntoBAST

  /**
   * how many occurrences of a given tree are there in my tree? used to choose
   * given n=k, do you substitute n for k, or the reverse? whichever's largest
   * gets substituted
   * */
  public int countOccurrenceOfTree(BAST z)
    {
    int numberOfOccurrences = 0;
    if (z.equalsTree(this)) {
		return 1;
	} else if (this.getChildCount() > 0)
	 {
		for (int ch = 0; ch < this.getChildCount(); ch++)
		    { // add up their counts
		    numberOfOccurrences += ((BAST) this.getChild(ch))
		        .countOccurrenceOfTree(z);
		    } // end of summing children
	}
    return numberOfOccurrences;
    } // end of countOccurrenceOfTree

  public boolean myParentIsNotTimed()
    {
    if (getParent() == null)
      {
      return true;
      }
    else if (((BAST) getParent()).hasType(BLESS3Lexer.CARET)
        || ((BAST) getParent()).hasType(BLESS3Lexer.AT_SIGN)
        || ((BAST) getParent()).hasType(BLESS3Lexer.IMP)  //prevent removal of parentheses from conditional function
        || ((BAST) getParent()).hasType(BLESS3Lexer.TICK))
      {
      return false;
      }
    return true;
    } // end of myParentIsNotTimed

//  public boolean myParentIsNotLogicalOperator()
//    {
//    if (getParent() == null)
//      {
//      return true;
//      }
//    else if (((BAST) getParent()).hasType(BLESS3Lexer.LITERAL_and)
//        || ((BAST) getParent()).hasType(BLESS3Lexer.LITERAL_or)
//        || ((BAST) getParent()).hasType(BLESS3Lexer.LITERAL_xor)
//        || ((BAST) getParent()).hasType(BLESS3Lexer.ARROW)
//        || ((BAST) getParent()).hasType(BLESS3Lexer.LITERAL_implies) 
//        || ((BAST) getParent()).hasType(BLESS3Lexer.LITERAL_not))
//      {
//      return false;
//      }
//    return true;
//    } // end of myParentIsNotTimed

  public void setParseRecord(ParseRecord pr)
    {
      // if (parseRecord==null)
      {
      parseRecord = pr;
      for (int ch = 0; ch < getChildCount(); ch++) {
		((BAST) getChild(ch)).setParseRecord(pr);
	}
      }
    } // end of setParseRecord

  public ParseRecord getParseRecord()
    {
    ParseRecord result = null;
    if (parseRecord != null) {
		result = parseRecord;
	} else if (parent != null) {
		result = parent.getParseRecord();
	}
    return result;
    } // end of getParseRecord

  /**
   * compares BAST nodes for type and value
   *
   * @param theOtherNode
   * @return boolean
   */
  boolean equalsNode(BAST theOtherNode)
    {
    //  check for numeric literals
    if (this.isNumericLiteral()
            && theOtherNode.isNumericLiteral())
      {
      if (this.truncateWholeLiterals().contentEquals(theOtherNode.truncateWholeLiterals()))
        return true;
      }
    // make INVOKE and FUNCTION_CALL match
    if ((this.hasType(BLESS3Lexer.INVOKE)||this.hasType(BLESS3Lexer.SUBPROGRAM_INVOCATION)
 //       || this.hasType(BLESS3Lexer.INVOKE_FUNCTION)
        )
        && (theOtherNode.hasType(BLESS3Lexer.INVOKE)||theOtherNode.hasType(BLESS3Lexer.SUBPROGRAM_INVOCATION)
//            || theOtherNode.hasType(BLESS3Lexer.INVOKE_FUNCTION)
        		)) {
		return true;
	}
    // first check token types
    if (!this.hasType(theOtherNode.getType()))
	 {
		return false; // different token types
	}
    if (!this.isText(theOtherNode.getText())) {
		return false; // not equal
	} else {
		return true;
	}
    } // end of equalsNode

  /**
   * replaces all occurrences of nodes, not trees
   */
  public BAST replaceNodes(BAST ofThis, BAST withThis) throws YouIdiot
    { // replace all occurances of ofThis, with a duplicate of withThat
    // look through children for match
    if (getChildCount() > 0)
      {
      for (int i = 0; i < getChildCount(); i++) {
		// does child match?
        if (((BAST) getChild(i)).equalsNode(ofThis))
          {
          ((BAST) getChild(i)).myText = withThis.getText();
          ((BAST) getChild(i)).token = withThis.token;
          }
        // otherwise replaceOccurences on children
 else {
			((BAST) getChild(i)).replaceNodes(ofThis, withThis);
		}
	}
      }
    return this;
    } // end of replaceNodes

  /**
   * Count decendents of this node
   */
  public int countDecendents()
    {
    int count = 1;
    for (int i = 0; i < this.getChildCount(); i++) {
		count += ((BAST) this.getChild(i)).countDecendents();
	}
    return count;
    } // end of countDecendents

  public BAST getNodeWithTokenAtOffset(int offset)
    {
    if (getToken() != null)
      {
      CommonToken myToken = (CommonToken) getToken();
      if ((myToken.getStartIndex() <= offset)
          && (myToken.getStopIndex() >= offset))
	 {
		return this; // this token has the offset between its start and stop
	}
      }
    for (int ch = 0; ch < getChildCount(); ch++)
      {
      BAST childWithTokenAtOffset = ((BAST) getChild(ch))
          .getNodeWithTokenAtOffset(offset);
      if (childWithTokenAtOffset != null) {
		return childWithTokenAtOffset;
	}
      }
    return null; // otherwise no find
    }

  public boolean hasPositiveNumericValue()
    { // is it a number starting with - ?
	  boolean result = false;
    if (hasType(BLESS3Lexer.NUMBER)) 
		  result = (0<Integer.parseInt(getText()));
	  else if (hasType(BLESS3Lexer.NUMBER)) 
		  result = (0.0<Double.valueOf(getText()));
    return result;
    }


  public boolean isNumericLiteral()
  {
  return hasType(BLESS3Lexer.NUMBER) || hasType(BLESS3Lexer.NUMBER);
  }
    
  
  // is this the name of a constant?
  public boolean isConstant()
    {
    boolean result = false;
    // is this just an identifier?
    if (hasType(BLESS3Lexer.ID) && (getChildCount() == 0))
      { // find its declaration, see if it's declared 'constant'
      // try
      // {
      Scope sc = getScope();
      if ((sc == null) && (parseRecord != null) && (parseRecord.ast != null)) {
		sc = parseRecord.ast.getScope();
	}
      if (sc != null)
        {
        EntityRecord er = sc.get(getText());
        if (er != null) {
			result = er.constant;
		}
        }
      // }
      // catch (YI yi) {yi.handleException();}
      } // done just an identifier
    // is this a property name?
    else if (hasType(BLESS3Lexer.DOUBLE_COLON) && (getChildCount() == 2))
      { // then it's constant
      result = true;
      }

    // is this the name of a one-dimensional constant array?
    // else if (hasType(BLESS3Lexer.ID))
    // { //find its declaration, see if it's declared 'constant'
    // try
    // {
    // result = getScope().get(getText()).constant;
    // }
    // catch (Exception e) {Dump.it("a");}
    // } //done just an identifier

    return result;
    } // end of isConstant

  public void clearSubstitutedFlags()
    {
    substituted = false;
    for (int i = 0; i < getChildCount(); i++) {
		((BAST) getChild(i)).clearSubstitutedFlags();
	}
    }

  public void setSubstitutedFlags()
    {
    substituted = true;
    for (int i = 0; i < getChildCount(); i++) {
		((BAST) getChild(i)).setSubstitutedFlags();
	}
    }


  public Element makeIntoElement()
  {
//	Element e=null;

	return element;
  }  //end of Element


  /** Walk upwards looking for ancestor with this token type. */
	@Override
	public boolean hasAncestor(int ttype)
		{
		return getAncestor(ttype)!=null;
		}


  /** Walk upwards and get first ancestor with this token type. */
	@Override
	public Tree getAncestor(int ttype)
		{
    BAST t = this;
    t = (BAST)t.getParent();
    while ( t!=null ) {
        if ( t.getType()==ttype ) {
			return t;
		}
        t = (BAST)t.getParent();
    }
		return null;
		}


  /** Return a list of all ancestors of this node.  The first node of
   *  list is the root and the last is the parent of this node.
   */
	@Override
	public List getAncestors()
		{
    if ( getParent()==null ) {
		return null;
	}
    List ancestors = new ArrayList<BAST>();
    BAST t = this;
    t = (BAST)t.getParent();
    while ( t!=null ) {
        ancestors.add(0, t); // insert at start
        t = (BAST)t.getParent();
    }
    return ancestors;
		}


  } // end of BAST

