// $ANTLR 3.5.2 /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g 2023-05-08 05:02:19

//copyright 2020 Multitude Corporation
package com.multitude.bless.antlr3generated;
import java.util.HashMap;
import java.util.Vector;
//import com.multitude.bless.BAST;
import org.antlr.runtime.Parser;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.UnwantedTokenException;
import com.multitude.bless.exceptions.*;
import com.multitude.bless.tree.BAST;
import com.multitude.bless.ui.preferences.ConfigurationPreferencePage;
import com.multitude.bless.app.Global;
import com.multitude.bless.record.ParseRecord;
import com.multitude.bless.record.PackageRecord;
import com.multitude.bless.record.ThreadRecord;
import com.multitude.bless.record.DataRecord;
import com.multitude.bless.record.SubprogramRecord;
import com.multitude.bless.record.PropertySetRecord;
//import com.multitude.bless.symbol.Model;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings("all")
public class BLESStoASTParser extends Parser {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AADL_STRING_LITERAL", "AADL_STRING_PART", 
		"ACTION", "AL", "AM", "AMPERSAND", "ANNEX_END", "ANNEX_START", "ARROW", 
		"ASSERTION", "ASSERTION_ANNEX", "ASSERTION_ENUMERATION", "ASSERTION_FUNCTION", 
		"ASSIGN", "AT_SIGN", "BASE", "BASED_INTEGER", "BEHAVIOR_GUARD", "BEHAVIOR_TIME", 
		"BI", "BOUND", "BOX", "CARET", "CASE_EXPRESSION", "COLON", "COMMA", "COMMACOMMA", 
		"COMMADOT", "COMPLEX", "COMPONENT", "CONDITION", "CONDITIONAL", "CONDITIONAL_FUNCTION", 
		"CONNECTION", "COUNTING_TRIGGER", "DESTINATION", "DIGIT", "DIVIDE", "DOLLAR", 
		"DOTCOMMA", "DOTDOT", "DOUBLE_COLON", "DOUBLE_QUOTE", "DO_NOT_PROVE", 
		"DUMMY", "EMPTY_CURLY", "END_ASSERTION_PROPERTY", "EQ", "EXCLAMATION", 
		"EXP", "EXPONENT", "EXTENDED_DIGIT", "FLOATING", "FUNCTION", "FUNCTION_CALL", 
		"GT", "GUARD", "HEX_DIGIT", "ID", "IMP", "INMODE", "INOUT", "INTEGER_LIT", 
		"INT_EXPONENT", "INVARIANT", "INVOKE", "INVOKE_FUNCTION", "IP_NAME", "IP_PE", 
		"IP_PRED", "LABEL", "LASS", "LBRACKET", "LCON", "LCURLY", "LITERAL_Assertion", 
		"LITERAL_Invariant", "LITERAL_Postcondition", "LITERAL_Precondition", 
		"LITERAL_Typed", "LITERAL_aadlboolean", "LITERAL_aadlinteger", "LITERAL_aadlreal", 
		"LITERAL_aadlstring", "LITERAL_abs", "LITERAL_abstract", "LITERAL_access", 
		"LITERAL_all", "LITERAL_and", "LITERAL_annex", "LITERAL_any", "LITERAL_applies", 
		"LITERAL_are", "LITERAL_array", "LITERAL_assert", "LITERAL_availability", 
		"LITERAL_boolean", "LITERAL_bound", "LITERAL_bus", "LITERAL_call", "LITERAL_calls", 
		"LITERAL_cand", "LITERAL_catch", "LITERAL_classifier", "LITERAL_complete", 
		"LITERAL_complex", "LITERAL_component", "LITERAL_computation", "LITERAL_connection", 
		"LITERAL_connections", "LITERAL_constant", "LITERAL_cor", "LITERAL_count", 
		"LITERAL_data", "LITERAL_declare", "LITERAL_def", "LITERAL_delay", "LITERAL_device", 
		"LITERAL_dispatch", "LITERAL_do", "LITERAL_else", "LITERAL_end", "LITERAL_enumeration", 
		"LITERAL_event", "LITERAL_exception", "LITERAL_exists", "LITERAL_extends", 
		"LITERAL_false", "LITERAL_feature", "LITERAL_features", "LITERAL_fetchadd", 
		"LITERAL_fetchand", "LITERAL_fetchor", "LITERAL_fetchxor", "LITERAL_fi", 
		"LITERAL_final", "LITERAL_flow", "LITERAL_flows", "LITERAL_for", "LITERAL_forall", 
		"LITERAL_fresh", "LITERAL_function", "LITERAL_group", "LITERAL_hr", "LITERAL_if", 
		"LITERAL_iff", "LITERAL_implementation", "LITERAL_implies", "LITERAL_in", 
		"LITERAL_inherit", "LITERAL_initial", "LITERAL_integer", "LITERAL_invariant", 
		"LITERAL_inverse", "LITERAL_is", "LITERAL_list", "LITERAL_lower_bound", 
		"LITERAL_memory", "LITERAL_min", "LITERAL_mod", "LITERAL_mode", "LITERAL_modes", 
		"LITERAL_ms", "LITERAL_natural", "LITERAL_none", "LITERAL_nonvolatile", 
		"LITERAL_not", "LITERAL_now", "LITERAL_ns", "LITERAL_null", "LITERAL_numberof", 
		"LITERAL_of", "LITERAL_on", "LITERAL_or", "LITERAL_out", "LITERAL_package", 
		"LITERAL_parameter", "LITERAL_pause", "LITERAL_port", "LITERAL_post", 
		"LITERAL_pre", "LITERAL_private", "LITERAL_procedure", "LITERAL_process", 
		"LITERAL_processor", "LITERAL_product", "LITERAL_properties", "LITERAL_property", 
		"LITERAL_prototypes", "LITERAL_provides", "LITERAL_ps", "LITERAL_public", 
		"LITERAL_range", "LITERAL_rational", "LITERAL_real", "LITERAL_record", 
		"LITERAL_reference", "LITERAL_rem", "LITERAL_renames", "LITERAL_requires", 
		"LITERAL_sec", "LITERAL_self", "LITERAL_sequence", "LITERAL_set", "LITERAL_setmode", 
		"LITERAL_shared", "LITERAL_skip", "LITERAL_spread", "LITERAL_state", "LITERAL_states", 
		"LITERAL_stop", "LITERAL_string", "LITERAL_subcomponents", "LITERAL_subprogram", 
		"LITERAL_sum", "LITERAL_swap", "LITERAL_system", "LITERAL_that", "LITERAL_then", 
		"LITERAL_thread", "LITERAL_throw", "LITERAL_time", "LITERAL_timeout", 
		"LITERAL_to", "LITERAL_tops", "LITERAL_transition", "LITERAL_transitions", 
		"LITERAL_true", "LITERAL_type", "LITERAL_units", "LITERAL_until", "LITERAL_updated", 
		"LITERAL_upper_bound", "LITERAL_us", "LITERAL_variables", "LITERAL_variant", 
		"LITERAL_virtual", "LITERAL_when", "LITERAL_while", "LITERAL_with", "LITERAL_xor", 
		"LPAREN", "LT", "LTE_STRING", "LT_STRING", "MINUS", "MT_STRING", "NEQ", 
		"OBLIGATION", "OCTOTHORPE", "ON", "P", "PARAMETER", "PARAMETERS", "PERIOD", 
		"PLUS", "PLUS_ARROW", "PLUS_EQUALS", "PORT", "PORT_INPUT", "PORT_OUTPUT", 
		"PREDICATE_RELATION", "PROCEDURE", "PROCEDURE_CALL", "PROPERTY_LIST", 
		"Q", "QQ", "QUESTION", "RASS", "RATIONAL", "RBRACKET", "RCON", "RCURLY", 
		"REAL_LIT", "RECORD_VALUE", "RPAREN", "S", "SEMICOLON", "SLCOMMENT", "SOURCE", 
		"START", "START_ASSERTION_PROPERTY", "STOP", "SUBCOMPONENT", "SUBPROGRAM_ANNEX", 
		"THREAD_ANNEX", "THREAD_GROUP", "TICK", "TILDE", "TIMES", "TOP", "TRANSITION", 
		"TYPE", "TYPE_OPERATOR", "TYPE_OPERATOR_INVOCATION", "UNARY_MINUS", "VALUE", 
		"WP", "WS", "'|'"
	};
	public static final int EOF=-1;
	public static final int T__303=303;
	public static final int AADL_STRING_LITERAL=4;
	public static final int AADL_STRING_PART=5;
	public static final int ACTION=6;
	public static final int AL=7;
	public static final int AM=8;
	public static final int AMPERSAND=9;
	public static final int ANNEX_END=10;
	public static final int ANNEX_START=11;
	public static final int ARROW=12;
	public static final int ASSERTION=13;
	public static final int ASSERTION_ANNEX=14;
	public static final int ASSERTION_ENUMERATION=15;
	public static final int ASSERTION_FUNCTION=16;
	public static final int ASSIGN=17;
	public static final int AT_SIGN=18;
	public static final int BASE=19;
	public static final int BASED_INTEGER=20;
	public static final int BEHAVIOR_GUARD=21;
	public static final int BEHAVIOR_TIME=22;
	public static final int BI=23;
	public static final int BOUND=24;
	public static final int BOX=25;
	public static final int CARET=26;
	public static final int CASE_EXPRESSION=27;
	public static final int COLON=28;
	public static final int COMMA=29;
	public static final int COMMACOMMA=30;
	public static final int COMMADOT=31;
	public static final int COMPLEX=32;
	public static final int COMPONENT=33;
	public static final int CONDITION=34;
	public static final int CONDITIONAL=35;
	public static final int CONDITIONAL_FUNCTION=36;
	public static final int CONNECTION=37;
	public static final int COUNTING_TRIGGER=38;
	public static final int DESTINATION=39;
	public static final int DIGIT=40;
	public static final int DIVIDE=41;
	public static final int DOLLAR=42;
	public static final int DOTCOMMA=43;
	public static final int DOTDOT=44;
	public static final int DOUBLE_COLON=45;
	public static final int DOUBLE_QUOTE=46;
	public static final int DO_NOT_PROVE=47;
	public static final int DUMMY=48;
	public static final int EMPTY_CURLY=49;
	public static final int END_ASSERTION_PROPERTY=50;
	public static final int EQ=51;
	public static final int EXCLAMATION=52;
	public static final int EXP=53;
	public static final int EXPONENT=54;
	public static final int EXTENDED_DIGIT=55;
	public static final int FLOATING=56;
	public static final int FUNCTION=57;
	public static final int FUNCTION_CALL=58;
	public static final int GT=59;
	public static final int GUARD=60;
	public static final int HEX_DIGIT=61;
	public static final int ID=62;
	public static final int IMP=63;
	public static final int INMODE=64;
	public static final int INOUT=65;
	public static final int INTEGER_LIT=66;
	public static final int INT_EXPONENT=67;
	public static final int INVARIANT=68;
	public static final int INVOKE=69;
	public static final int INVOKE_FUNCTION=70;
	public static final int IP_NAME=71;
	public static final int IP_PE=72;
	public static final int IP_PRED=73;
	public static final int LABEL=74;
	public static final int LASS=75;
	public static final int LBRACKET=76;
	public static final int LCON=77;
	public static final int LCURLY=78;
	public static final int LITERAL_Assertion=79;
	public static final int LITERAL_Invariant=80;
	public static final int LITERAL_Postcondition=81;
	public static final int LITERAL_Precondition=82;
	public static final int LITERAL_Typed=83;
	public static final int LITERAL_aadlboolean=84;
	public static final int LITERAL_aadlinteger=85;
	public static final int LITERAL_aadlreal=86;
	public static final int LITERAL_aadlstring=87;
	public static final int LITERAL_abs=88;
	public static final int LITERAL_abstract=89;
	public static final int LITERAL_access=90;
	public static final int LITERAL_all=91;
	public static final int LITERAL_and=92;
	public static final int LITERAL_annex=93;
	public static final int LITERAL_any=94;
	public static final int LITERAL_applies=95;
	public static final int LITERAL_are=96;
	public static final int LITERAL_array=97;
	public static final int LITERAL_assert=98;
	public static final int LITERAL_availability=99;
	public static final int LITERAL_boolean=100;
	public static final int LITERAL_bound=101;
	public static final int LITERAL_bus=102;
	public static final int LITERAL_call=103;
	public static final int LITERAL_calls=104;
	public static final int LITERAL_cand=105;
	public static final int LITERAL_catch=106;
	public static final int LITERAL_classifier=107;
	public static final int LITERAL_complete=108;
	public static final int LITERAL_complex=109;
	public static final int LITERAL_component=110;
	public static final int LITERAL_computation=111;
	public static final int LITERAL_connection=112;
	public static final int LITERAL_connections=113;
	public static final int LITERAL_constant=114;
	public static final int LITERAL_cor=115;
	public static final int LITERAL_count=116;
	public static final int LITERAL_data=117;
	public static final int LITERAL_declare=118;
	public static final int LITERAL_def=119;
	public static final int LITERAL_delay=120;
	public static final int LITERAL_device=121;
	public static final int LITERAL_dispatch=122;
	public static final int LITERAL_do=123;
	public static final int LITERAL_else=124;
	public static final int LITERAL_end=125;
	public static final int LITERAL_enumeration=126;
	public static final int LITERAL_event=127;
	public static final int LITERAL_exception=128;
	public static final int LITERAL_exists=129;
	public static final int LITERAL_extends=130;
	public static final int LITERAL_false=131;
	public static final int LITERAL_feature=132;
	public static final int LITERAL_features=133;
	public static final int LITERAL_fetchadd=134;
	public static final int LITERAL_fetchand=135;
	public static final int LITERAL_fetchor=136;
	public static final int LITERAL_fetchxor=137;
	public static final int LITERAL_fi=138;
	public static final int LITERAL_final=139;
	public static final int LITERAL_flow=140;
	public static final int LITERAL_flows=141;
	public static final int LITERAL_for=142;
	public static final int LITERAL_forall=143;
	public static final int LITERAL_fresh=144;
	public static final int LITERAL_function=145;
	public static final int LITERAL_group=146;
	public static final int LITERAL_hr=147;
	public static final int LITERAL_if=148;
	public static final int LITERAL_iff=149;
	public static final int LITERAL_implementation=150;
	public static final int LITERAL_implies=151;
	public static final int LITERAL_in=152;
	public static final int LITERAL_inherit=153;
	public static final int LITERAL_initial=154;
	public static final int LITERAL_integer=155;
	public static final int LITERAL_invariant=156;
	public static final int LITERAL_inverse=157;
	public static final int LITERAL_is=158;
	public static final int LITERAL_list=159;
	public static final int LITERAL_lower_bound=160;
	public static final int LITERAL_memory=161;
	public static final int LITERAL_min=162;
	public static final int LITERAL_mod=163;
	public static final int LITERAL_mode=164;
	public static final int LITERAL_modes=165;
	public static final int LITERAL_ms=166;
	public static final int LITERAL_natural=167;
	public static final int LITERAL_none=168;
	public static final int LITERAL_nonvolatile=169;
	public static final int LITERAL_not=170;
	public static final int LITERAL_now=171;
	public static final int LITERAL_ns=172;
	public static final int LITERAL_null=173;
	public static final int LITERAL_numberof=174;
	public static final int LITERAL_of=175;
	public static final int LITERAL_on=176;
	public static final int LITERAL_or=177;
	public static final int LITERAL_out=178;
	public static final int LITERAL_package=179;
	public static final int LITERAL_parameter=180;
	public static final int LITERAL_pause=181;
	public static final int LITERAL_port=182;
	public static final int LITERAL_post=183;
	public static final int LITERAL_pre=184;
	public static final int LITERAL_private=185;
	public static final int LITERAL_procedure=186;
	public static final int LITERAL_process=187;
	public static final int LITERAL_processor=188;
	public static final int LITERAL_product=189;
	public static final int LITERAL_properties=190;
	public static final int LITERAL_property=191;
	public static final int LITERAL_prototypes=192;
	public static final int LITERAL_provides=193;
	public static final int LITERAL_ps=194;
	public static final int LITERAL_public=195;
	public static final int LITERAL_range=196;
	public static final int LITERAL_rational=197;
	public static final int LITERAL_real=198;
	public static final int LITERAL_record=199;
	public static final int LITERAL_reference=200;
	public static final int LITERAL_rem=201;
	public static final int LITERAL_renames=202;
	public static final int LITERAL_requires=203;
	public static final int LITERAL_sec=204;
	public static final int LITERAL_self=205;
	public static final int LITERAL_sequence=206;
	public static final int LITERAL_set=207;
	public static final int LITERAL_setmode=208;
	public static final int LITERAL_shared=209;
	public static final int LITERAL_skip=210;
	public static final int LITERAL_spread=211;
	public static final int LITERAL_state=212;
	public static final int LITERAL_states=213;
	public static final int LITERAL_stop=214;
	public static final int LITERAL_string=215;
	public static final int LITERAL_subcomponents=216;
	public static final int LITERAL_subprogram=217;
	public static final int LITERAL_sum=218;
	public static final int LITERAL_swap=219;
	public static final int LITERAL_system=220;
	public static final int LITERAL_that=221;
	public static final int LITERAL_then=222;
	public static final int LITERAL_thread=223;
	public static final int LITERAL_throw=224;
	public static final int LITERAL_time=225;
	public static final int LITERAL_timeout=226;
	public static final int LITERAL_to=227;
	public static final int LITERAL_tops=228;
	public static final int LITERAL_transition=229;
	public static final int LITERAL_transitions=230;
	public static final int LITERAL_true=231;
	public static final int LITERAL_type=232;
	public static final int LITERAL_units=233;
	public static final int LITERAL_until=234;
	public static final int LITERAL_updated=235;
	public static final int LITERAL_upper_bound=236;
	public static final int LITERAL_us=237;
	public static final int LITERAL_variables=238;
	public static final int LITERAL_variant=239;
	public static final int LITERAL_virtual=240;
	public static final int LITERAL_when=241;
	public static final int LITERAL_while=242;
	public static final int LITERAL_with=243;
	public static final int LITERAL_xor=244;
	public static final int LPAREN=245;
	public static final int LT=246;
	public static final int LTE_STRING=247;
	public static final int LT_STRING=248;
	public static final int MINUS=249;
	public static final int MT_STRING=250;
	public static final int NEQ=251;
	public static final int OBLIGATION=252;
	public static final int OCTOTHORPE=253;
	public static final int ON=254;
	public static final int P=255;
	public static final int PARAMETER=256;
	public static final int PARAMETERS=257;
	public static final int PERIOD=258;
	public static final int PLUS=259;
	public static final int PLUS_ARROW=260;
	public static final int PLUS_EQUALS=261;
	public static final int PORT=262;
	public static final int PORT_INPUT=263;
	public static final int PORT_OUTPUT=264;
	public static final int PREDICATE_RELATION=265;
	public static final int PROCEDURE=266;
	public static final int PROCEDURE_CALL=267;
	public static final int PROPERTY_LIST=268;
	public static final int Q=269;
	public static final int QQ=270;
	public static final int QUESTION=271;
	public static final int RASS=272;
	public static final int RATIONAL=273;
	public static final int RBRACKET=274;
	public static final int RCON=275;
	public static final int RCURLY=276;
	public static final int REAL_LIT=277;
	public static final int RECORD_VALUE=278;
	public static final int RPAREN=279;
	public static final int S=280;
	public static final int SEMICOLON=281;
	public static final int SLCOMMENT=282;
	public static final int SOURCE=283;
	public static final int START=284;
	public static final int START_ASSERTION_PROPERTY=285;
	public static final int STOP=286;
	public static final int SUBCOMPONENT=287;
	public static final int SUBPROGRAM_ANNEX=288;
	public static final int THREAD_ANNEX=289;
	public static final int THREAD_GROUP=290;
	public static final int TICK=291;
	public static final int TILDE=292;
	public static final int TIMES=293;
	public static final int TOP=294;
	public static final int TRANSITION=295;
	public static final int TYPE=296;
	public static final int TYPE_OPERATOR=297;
	public static final int TYPE_OPERATOR_INVOCATION=298;
	public static final int UNARY_MINUS=299;
	public static final int VALUE=300;
	public static final int WP=301;
	public static final int WS=302;

	// delegates
	public Parser[] getDelegates() {
		return new Parser[] {};
	}

	// delegators


	public BLESStoASTParser(TokenStream input) {
		this(input, new RecognizerSharedState());
	}
	public BLESStoASTParser(TokenStream input, RecognizerSharedState state) {
		super(input, state);
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return BLESStoASTParser.tokenNames; }
	@Override public String getGrammarFileName() { return "/Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g"; }


	/** Map variable name to Integer object holding value */
	HashMap memory = new HashMap();
	Token tok = null;
	public boolean recognitionErrorOccurred = false;    //did a parse error occur?
	public static int countRecognitionErrors = 1; //accumulates count of recognition errors
	public static Vector<String> error_messages = new Vector<String>();

	//MUST SET currentPackageRecord BEFORE USE
	public PackageRecord currentPackageRecord = null;  //created by package_spec
	public PropertySetRecord currentPropertySetRecord = null;  //created by property_set
	public ParseRecord currentParseRecord = null;  //either currentPackageRecord or currentPropertySetRecord
	//public boolean putAssertionsIntoMap = true;  //put Assertions with labels into Proof.label_assertion_map?
	boolean saidTypeError = false;  //has a type exception already happened
	public String fileName = null;

	int startingLine = 0; //starting line of sublanguage in AADL file
	static int staticLine=0;  //used by BAST constructor

	  public void 
	setStartingLine(int line) //sets starting line
	  {
	  startingLine = line;
	  staticLine = line;
	  }

	  public int
	getStartingLine()
	  {
	  return startingLine;
	  }

	  public static int
	getStaticStartingLine()
	  {
	  return staticLine;
	  }
	  
	 
	public void reportError(RecognitionException ex, BAST start)
	  {
	  if (start!=null)
	    if (start.getParent()!=null)
	      ((BAST)start.getParent()).showParseTree("parent of "+start.getText());
	    else
	      start.showParseTree(start.getText());
	  reportError(ex);     
	  }  //end of reportError(RecognitionException ex, BAST start)

	public void reportError(RecognitionException ex)
	  {
	  if ((currentPackageRecord != null) && (currentPackageRecord.packageID != null))
	    Dump.it("In Package "+currentPackageRecord.packageID);
	  if ((currentPackageRecord != null) && (currentPackageRecord.file != null))
	    Dump.it("In File "+currentPackageRecord.file.getName());
	  else if (fileName != null)
	    Dump.it("In File "+fileName);
	  Dump.it("\nBLESS Syntax Error #"+
	    Integer.toString(countRecognitionErrors)+"\n");
	  error_messages.add(getErrorHeader(ex));  
	  Dump.it("\nSome "+Global.dope+", made another "+
	     (Global.kindMessages?"unfortunate":"stupid")+" grammatical mistake. \n"+
	      "We know this because the token we\'re trying to parse has token-type \""+
	      ((ex.getUnexpectedType()>0)&&(ex.getUnexpectedType()<tokenNames.length)?tokenNames[ex.getUnexpectedType()]:Integer.toString(ex.getUnexpectedType()))+
	      "\" "+
	      (ex.token!=null?"having text \""+ex.token.getText()+"\"":"")+"\n"+
	      "  which is not among the permitted token types here on line "+
	      (ex.token!=null?ex.token.getLine():"null ex.token"));
	//  Dump.it("This "+Global.dope+" may not be you, but you must fix it.");
	  if ((ex.node!=null)&&(ex.node instanceof BAST))
	    ((BAST)ex.node).showParseTree(((BAST)ex.node).getText());
	  int x=5;
	  if (ex instanceof UnwantedTokenException)
	    {
	    UnwantedTokenException ute = (UnwantedTokenException)ex;
	    Dump.it("Expecting:  "+tokenNames[ute.expecting]);
	    Dump.it("\nHint: Don\'t include units for numeric literals in BLESS::Assertion property strings.\n");
	    }
	  if (countRecognitionErrors<Global.YouIdiotReportLimit)
	    {
	    recognitionErrorOccurred = true;
	    ex.line = ex.line+startingLine;
	    Dump.it("offending text = \""+input.toString()+"\"");
	    Dump.it(getErrorHeader(ex));
	//    super.reportError(ex);
	  ex.printStackTrace();
	//    StackTraceElement[] ste = ex.getStackTrace(); 
	//    for (int k=0;k<ste.length;k++)
	//      Dump.it("   "+ste[k].toString());     
	//    HelpfulHints.giveHint();
	    }
	  else
	    {
	    Dump.it(countRecognitionErrors+" recognition errors occurred; divide by zero to stop runaway parser");
	    x=(x+x)/(x-5);
	    }
	  countRecognitionErrors++;
	//  // Global.stopProof = true; 
	  } //end of reportError

	public int errorCount = 0;
	public final int errorLimit=3;

	//REPLACE THIS WITH LOOK-UP OF OSATE RENAMES CLAUSE
	public String timeAlias = "T";

	//public void emitErrorMessage(String msg) 
	//  {
	//  System.err.println(msg);
	//  Dump.it(msg);
	//  }

	public void recover(IntStream input, RecognitionException re) {}
	 

	//tell user of BNF when they make a mistake 
	public boolean toldBNF=false;         
	public void tellBNF(String s, RecognitionException re)
	  {
	  if (!toldBNF)
	    {
	    Dump.it("BNF reminder:\n"+s);
	    toldBNF=true;
	    }
	  } //end of tellBNF(String s, RecognitionException re)
	  
	public void tellBNF(String s, RecognitionException re, BAST errorTree)
	  {
	  if (errorTree!=null)
	    {
	    errorTree.showParseTree(errorTree.getText()!=null?errorTree.getText():"error");
	    Dump.it("error on line "+Integer.toString(errorTree.getLine()+startingLine)+": "+
	      (errorTree.getText()!=null?errorTree.getText():""));
	    }
	  else Dump.it("error tree is null");
	  tellBNF(s,re);
	  }  //end of tellBNF(String s, RecognitionException re, BAST errorTree)
	  
	  


	public static class rational_literal_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "rational_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:720:1: rational_literal : LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) ) -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor) -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) ) -> ^( RATIONAL $dividend $divisor) ;
	public final BLESStoASTParser.rational_literal_return rational_literal() throws RecognitionException {
		BLESStoASTParser.rational_literal_return retval = new BLESStoASTParser.rational_literal_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token up=null;
		Token dividend=null;
		Token down=null;
		Token divisor=null;
		Token LBRACKET1=null;
		Token char_literal2=null;
		Token RBRACKET3=null;

		BAST up_tree=null;
		BAST dividend_tree=null;
		BAST down_tree=null;
		BAST divisor_tree=null;
		BAST LBRACKET1_tree=null;
		BAST char_literal2_tree=null;
		BAST RBRACKET3_tree=null;
		RewriteRuleTokenStream stream_INTEGER_LIT=new RewriteRuleTokenStream(adaptor,"token INTEGER_LIT");
		RewriteRuleTokenStream stream_303=new RewriteRuleTokenStream(adaptor,"token 303");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:721:3: ( LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) ) -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor) -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) ) -> ^( RATIONAL $dividend $divisor) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:3: LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET
			{
			LBRACKET1=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_rational_literal2624); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET1);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:14: (up= MINUS )?
			int alt1=2;
			int LA1_0 = input.LA(1);
			if ( (LA1_0==MINUS) ) {
				alt1=1;
			}
			switch (alt1) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:14: up= MINUS
					{
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2628); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(up);

					}
					break;

			}

			dividend=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2633); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(dividend);

			char_literal2=(Token)match(input,303,FOLLOW_303_in_rational_literal2635); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_303.add(char_literal2);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:51: (down= MINUS )?
			int alt2=2;
			int LA2_0 = input.LA(1);
			if ( (LA2_0==MINUS) ) {
				alt2=1;
			}
			switch (alt2) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:51: down= MINUS
					{
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2639); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(down);

					}
					break;

			}

			divisor=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2644); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(divisor);

			RBRACKET3=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_rational_literal2646); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET3);

			// AST REWRITE
			// elements: up, dividend, dividend, dividend, divisor, up, dividend, down, divisor, divisor, down, divisor
			// token labels: divisor, dividend, up, down
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_divisor=new RewriteRuleTokenStream(adaptor,"token divisor",divisor);
			RewriteRuleTokenStream stream_dividend=new RewriteRuleTokenStream(adaptor,"token dividend",dividend);
			RewriteRuleTokenStream stream_up=new RewriteRuleTokenStream(adaptor,"token up",up);
			RewriteRuleTokenStream stream_down=new RewriteRuleTokenStream(adaptor,"token down",down);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 723:3: -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) )
			if ((up!=null)&&(down!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:723:34: ^( RATIONAL ^( $up $dividend) ^( $down $divisor) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:723:45: ^( $up $dividend)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_dividend.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:723:62: ^( $down $divisor)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_divisor.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 724:3: -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor)
			if (up!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:18: ^( RATIONAL ^( $up $dividend) $divisor)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:29: ^( $up $dividend)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_dividend.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_divisor.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 725:3: -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) )
			if (down!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:20: ^( RATIONAL $dividend ^( $down $divisor) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				adaptor.addChild(root_1, stream_dividend.nextNode());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:41: ^( $down $divisor)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_divisor.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 726:3: -> ^( RATIONAL $dividend $divisor)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:726:6: ^( RATIONAL $dividend $divisor)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				adaptor.addChild(root_1, stream_dividend.nextNode());
				adaptor.addChild(root_1, stream_divisor.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rational_literal"


	public static class complex_literal_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "complex_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:729:1: complex_literal : LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) ) -> {up!=null}? ^( COMPLEX ^( $up $real) $im) -> {down!=null}? ^( COMPLEX $real ^( $down $im) ) -> ^( COMPLEX $real $im) ;
	public final BLESStoASTParser.complex_literal_return complex_literal() throws RecognitionException {
		BLESStoASTParser.complex_literal_return retval = new BLESStoASTParser.complex_literal_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token up=null;
		Token real=null;
		Token down=null;
		Token im=null;
		Token LBRACKET4=null;
		Token COLON5=null;
		Token RBRACKET6=null;

		BAST up_tree=null;
		BAST real_tree=null;
		BAST down_tree=null;
		BAST im_tree=null;
		BAST LBRACKET4_tree=null;
		BAST COLON5_tree=null;
		BAST RBRACKET6_tree=null;
		RewriteRuleTokenStream stream_REAL_LIT=new RewriteRuleTokenStream(adaptor,"token REAL_LIT");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:730:3: ( LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) ) -> {up!=null}? ^( COMPLEX ^( $up $real) $im) -> {down!=null}? ^( COMPLEX $real ^( $down $im) ) -> ^( COMPLEX $real $im) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:3: LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET
			{
			LBRACKET4=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_complex_literal2743); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET4);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:14: (up= MINUS )?
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==MINUS) ) {
				alt3=1;
			}
			switch (alt3) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:14: up= MINUS
					{
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2747); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(up);

					}
					break;

			}

			real=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2752); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(real);

			COLON5=(Token)match(input,COLON,FOLLOW_COLON_in_complex_literal2754); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON5);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:46: (down= MINUS )?
			int alt4=2;
			int LA4_0 = input.LA(1);
			if ( (LA4_0==MINUS) ) {
				alt4=1;
			}
			switch (alt4) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:46: down= MINUS
					{
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2758); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(down);

					}
					break;

			}

			im=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2763); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(im);

			RBRACKET6=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_complex_literal2765); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET6);

			// AST REWRITE
			// elements: im, up, im, im, up, down, real, real, im, real, real, down
			// token labels: im, up, real, down
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_im=new RewriteRuleTokenStream(adaptor,"token im",im);
			RewriteRuleTokenStream stream_up=new RewriteRuleTokenStream(adaptor,"token up",up);
			RewriteRuleTokenStream stream_real=new RewriteRuleTokenStream(adaptor,"token real",real);
			RewriteRuleTokenStream stream_down=new RewriteRuleTokenStream(adaptor,"token down",down);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 732:3: -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) )
			if ((up!=null)&&(down!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:732:34: ^( COMPLEX ^( $up $real) ^( $down $im) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:732:44: ^( $up $real)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_real.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:732:57: ^( $down $im)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_im.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 733:3: -> {up!=null}? ^( COMPLEX ^( $up $real) $im)
			if (up!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:18: ^( COMPLEX ^( $up $real) $im)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:28: ^( $up $real)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_real.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_im.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 734:3: -> {down!=null}? ^( COMPLEX $real ^( $down $im) )
			if (down!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:20: ^( COMPLEX $real ^( $down $im) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				adaptor.addChild(root_1, stream_real.nextNode());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:36: ^( $down $im)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_im.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 735:3: -> ^( COMPLEX $real $im)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:735:6: ^( COMPLEX $real $im)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				adaptor.addChild(root_1, stream_real.nextNode());
				adaptor.addChild(root_1, stream_im.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "complex_literal"


	public static class relation_symbol_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "relation_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:738:1: relation_symbol : ( EQ | NEQ | LT | AM | AL | GT );
	public final BLESStoASTParser.relation_symbol_return relation_symbol() throws RecognitionException {
		BLESStoASTParser.relation_symbol_return retval = new BLESStoASTParser.relation_symbol_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set7=null;

		BAST set7_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:739:3: ( EQ | NEQ | LT | AM | AL | GT )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set7=input.LT(1);
			if ( (input.LA(1) >= AL && input.LA(1) <= AM)||input.LA(1)==EQ||input.LA(1)==GT||input.LA(1)==LT||input.LA(1)==NEQ ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set7));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relation_symbol"


	public static class range_symbol_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "range_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:744:1: range_symbol : ( DOTDOT | COMMADOT | DOTCOMMA | COMMACOMMA );
	public final BLESStoASTParser.range_symbol_return range_symbol() throws RecognitionException {
		BLESStoASTParser.range_symbol_return retval = new BLESStoASTParser.range_symbol_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set8=null;

		BAST set8_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:744:14: ( DOTDOT | COMMADOT | DOTCOMMA | COMMACOMMA )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set8=input.LT(1);
			if ( (input.LA(1) >= COMMACOMMA && input.LA(1) <= COMMADOT)||(input.LA(1) >= DOTCOMMA && input.LA(1) <= DOTDOT) ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set8));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range_symbol"


	public static class identifier_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "identifier"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:746:1: identifier : ID ;
	public final BLESStoASTParser.identifier_return identifier() throws RecognitionException {
		BLESStoASTParser.identifier_return retval = new BLESStoASTParser.identifier_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID9=null;

		BAST ID9_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:747:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:747:5: ID
			{
			root_0 = (BAST)adaptor.nil();


			ID9=(Token)match(input,ID,FOLLOW_ID_in_identifier2919); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID9_tree = (BAST)adaptor.create(ID9);
			adaptor.addChild(root_0, ID9_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re,(BAST)retval.getTree()); Dump.it("\nYou may be using a reserved word inappropriately.\n");throw(re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "identifier"


	public static class annex_library_assertions_return extends ParserRuleReturnScope {
		public BAST newRoot;
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "annex_library_assertions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1081:1: annex_library_assertions[HashMap<String,BAST> assertions_in_library] returns [BAST newRoot] : ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )? ;
	public final BLESStoASTParser.annex_library_assertions_return annex_library_assertions(HashMap<String,BAST> assertions_in_library) throws RecognitionException {
		BLESStoASTParser.annex_library_assertions_return retval = new BLESStoASTParser.annex_library_assertions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START10=null;
		Token ANNEX_END11=null;
		ParserRuleReturnScope ala =null;

		BAST ANNEX_START10_tree=null;
		BAST ANNEX_END11_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1083:3: ( ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1084:3: ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )?
			{
			root_0 = (BAST)adaptor.nil();


			if ( state.backtracking==0 ) {retval.newRoot = new BAST("ASSERTION_ANNEX",BLESStoASTLexer.ASSERTION_ANNEX,getStartingLine());}
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1085:3: ( ANNEX_START )?
			int alt5=2;
			int LA5_0 = input.LA(1);
			if ( (LA5_0==ANNEX_START) ) {
				alt5=1;
			}
			switch (alt5) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1085:3: ANNEX_START
					{
					ANNEX_START10=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_annex_library_assertions3294); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ANNEX_START10_tree = (BAST)adaptor.create(ANNEX_START10);
					adaptor.addChild(root_0, ANNEX_START10_tree);
					}

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1086:5: (ala= assertion )+
			int cnt6=0;
			loop6:
			while (true) {
				int alt6=2;
				int LA6_0 = input.LA(1);
				if ( (LA6_0==LASS) ) {
					alt6=1;
				}

				switch (alt6) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1086:6: ala= assertion
					{
					pushFollow(FOLLOW_assertion_in_annex_library_assertions3304);
					ala=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, ala.getTree());

					if ( state.backtracking==0 ) {if ((assertions_in_library!=null)&&
					      ((ala!=null?((BAST)ala.getTree()):null)!=null)&&((ala!=null?((BAST)ala.getTree()):null).getChild(0)!=null)&&
					      ((ala!=null?((BAST)ala.getTree()):null).getChild(0).getChild(0)!=null)&&
					      ((BAST)(ala!=null?((BAST)ala.getTree()):null).getChild(0)).hasType(BLESStoASTLexer.LABEL)) 
					      assertions_in_library.put(((BAST)(ala!=null?((BAST)ala.getTree()):null).getChild(0).getChild(0)).getText(),(ala!=null?((BAST)ala.getTree()):null));
					      retval.newRoot.addChild((BAST)(ala!=null?((BAST)ala.getTree()):null));}
					}
					break;

				default :
					if ( cnt6 >= 1 ) break loop6;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(6, input);
					throw eee;
				}
				cnt6++;
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1094:3: ( ANNEX_END )?
			int alt7=2;
			int LA7_0 = input.LA(1);
			if ( (LA7_0==ANNEX_END) ) {
				alt7=1;
			}
			switch (alt7) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1094:3: ANNEX_END
					{
					ANNEX_END11=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_annex_library_assertions3324); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ANNEX_END11_tree = (BAST)adaptor.create(ANNEX_END11);
					adaptor.addChild(root_0, ANNEX_END11_tree);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "annex_library_assertions"


	public static class thread_behavior_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "thread_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1674:1: thread_behavior : ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )? -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP ) ;
	public final BLESStoASTParser.thread_behavior_return thread_behavior() throws RecognitionException {
		BLESStoASTParser.thread_behavior_return retval = new BLESStoASTParser.thread_behavior_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token no_proof=null;
		Token s=null;
		Token ANNEX_START12=null;
		Token ANNEX_END13=null;
		List<Object> list_bs=null;
		ParserRuleReturnScope av =null;
		ParserRuleReturnScope ac =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope sv =null;
		ParserRuleReturnScope tran =null;
		RuleReturnScope bs = null;
		BAST no_proof_tree=null;
		BAST s_tree=null;
		BAST ANNEX_START12_tree=null;
		BAST ANNEX_END13_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_LITERAL_states=new RewriteRuleTokenStream(adaptor,"token LITERAL_states");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleTokenStream stream_DO_NOT_PROVE=new RewriteRuleTokenStream(adaptor,"token DO_NOT_PROVE");
		RewriteRuleSubtreeStream stream_assert_clause=new RewriteRuleSubtreeStream(adaptor,"rule assert_clause");
		RewriteRuleSubtreeStream stream_variables=new RewriteRuleSubtreeStream(adaptor,"rule variables");
		RewriteRuleSubtreeStream stream_behavior_state=new RewriteRuleSubtreeStream(adaptor,"rule behavior_state");
		RewriteRuleSubtreeStream stream_invariant_clause=new RewriteRuleSubtreeStream(adaptor,"rule invariant_clause");
		RewriteRuleSubtreeStream stream_availability=new RewriteRuleSubtreeStream(adaptor,"rule availability");
		RewriteRuleSubtreeStream stream_transitions=new RewriteRuleSubtreeStream(adaptor,"rule transitions");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1675:3: ( ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )? -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1676:3: ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1676:3: ( ANNEX_START )?
			int alt8=2;
			int LA8_0 = input.LA(1);
			if ( (LA8_0==ANNEX_START) ) {
				alt8=1;
			}
			switch (alt8) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1676:3: ANNEX_START
					{
					ANNEX_START12=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_thread_behavior3999); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START12);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1677:11: (no_proof= DO_NOT_PROVE )?
			int alt9=2;
			int LA9_0 = input.LA(1);
			if ( (LA9_0==DO_NOT_PROVE) ) {
				alt9=1;
			}
			switch (alt9) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1677:11: no_proof= DO_NOT_PROVE
					{
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_thread_behavior4006); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DO_NOT_PROVE.add(no_proof);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:5: (av= availability )?
			int alt10=2;
			int LA10_0 = input.LA(1);
			if ( (LA10_0==LITERAL_availability) ) {
				alt10=1;
			}
			switch (alt10) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:5: av= availability
					{
					pushFollow(FOLLOW_availability_in_thread_behavior4013);
					av=availability();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_availability.add(av.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1679:5: (ac= assert_clause )?
			int alt11=2;
			int LA11_0 = input.LA(1);
			if ( (LA11_0==LITERAL_assert) ) {
				alt11=1;
			}
			switch (alt11) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1679:5: ac= assert_clause
					{
					pushFollow(FOLLOW_assert_clause_in_thread_behavior4020);
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assert_clause.add(ac.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1680:6: (inv= invariant_clause )?
			int alt12=2;
			int LA12_0 = input.LA(1);
			if ( (LA12_0==LITERAL_invariant) ) {
				alt12=1;
			}
			switch (alt12) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1680:6: inv= invariant_clause
					{
					pushFollow(FOLLOW_invariant_clause_in_thread_behavior4027);
					inv=invariant_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_invariant_clause.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1681:5: (sv= variables )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==LITERAL_variables) ) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1681:5: sv= variables
					{
					pushFollow(FOLLOW_variables_in_thread_behavior4034);
					sv=variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_variables.add(sv.getTree());
					}
					break;

			}

			s=(Token)match(input,LITERAL_states,FOLLOW_LITERAL_states_in_thread_behavior4041); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_states.add(s);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1682:20: (bs+= behavior_state )+
			int cnt14=0;
			loop14:
			while (true) {
				int alt14=2;
				int LA14_0 = input.LA(1);
				if ( (LA14_0==ID) ) {
					alt14=1;
				}

				switch (alt14) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1682:22: bs+= behavior_state
					{
					pushFollow(FOLLOW_behavior_state_in_thread_behavior4047);
					bs=behavior_state();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_state.add(bs.getTree());
					if (list_bs==null) list_bs=new ArrayList<Object>();
					list_bs.add(bs.getTree());
					}
					break;

				default :
					if ( cnt14 >= 1 ) break loop14;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(14, input);
					throw eee;
				}
				cnt14++;
			}

			pushFollow(FOLLOW_transitions_in_thread_behavior4056);
			tran=transitions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_transitions.add(tran.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1684:3: ( ANNEX_END )?
			int alt15=2;
			int LA15_0 = input.LA(1);
			if ( (LA15_0==ANNEX_END) ) {
				alt15=1;
			}
			switch (alt15) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1684:3: ANNEX_END
					{
					ANNEX_END13=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_thread_behavior4060); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END13);

					}
					break;

			}

			// AST REWRITE
			// elements: LITERAL_states, inv, bs, ac, no_proof, tran, sv
			// token labels: no_proof
			// rule labels: inv, ac, sv, tran, retval
			// token list labels: 
			// rule list labels: bs
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_no_proof=new RewriteRuleTokenStream(adaptor,"token no_proof",no_proof);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"rule ac",ac!=null?ac.getTree():null);
			RewriteRuleSubtreeStream stream_sv=new RewriteRuleSubtreeStream(adaptor,"rule sv",sv!=null?sv.getTree():null);
			RewriteRuleSubtreeStream stream_tran=new RewriteRuleSubtreeStream(adaptor,"rule tran",tran!=null?tran.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bs=new RewriteRuleSubtreeStream(adaptor,"token bs",list_bs);
			root_0 = (BAST)adaptor.nil();
			// 1685:5: -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1685:8: ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(THREAD_ANNEX, s, "THREAD_ANNEX"+(startingLine>0?"["+startingLine+"]":"")), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1686:9: ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_states, s, "states["+Integer.toString(s.getLine()+startingLine)+"]"), root_2);
				if ( !(stream_bs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bs.hasNext() ) {
					adaptor.addChild(root_2, stream_bs.nextTree());
				}
				stream_bs.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1687:10: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1687:15: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_1, stream_inv.nextTree());
				}
				stream_inv.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1687:21: ( $sv)?
				if ( stream_sv.hasNext() ) {
					adaptor.addChild(root_1, stream_sv.nextTree());
				}
				stream_sv.reset();

				adaptor.addChild(root_1, stream_tran.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1687:32: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_1, (BAST)adaptor.create(STOP, "STOP"));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
			    Dump.it("RecognitionException in BLESStoAST.thread_behavior");
			     if (re instanceof MismatchedTokenException)
			       Dump.it("\nHey "+HelpfulHints.getIdiot()+"!\n\nDid you put the semicolon *after* "+
			        "the Assertion?\n"+
			        "You must have \"states\" and at least one behvior state:  PowerOn: initial state;\n");
			     tellBNF(GrammarStrings.threadBehavior,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "thread_behavior"


	public static class assert_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assert_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1698:1: assert_clause : la= LITERAL_assert (ass+= assertion )+ -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ ) ;
	public final BLESStoASTParser.assert_clause_return assert_clause() throws RecognitionException {
		BLESStoASTParser.assert_clause_return retval = new BLESStoASTParser.assert_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token la=null;
		List<Object> list_ass=null;
		RuleReturnScope ass = null;
		BAST la_tree=null;
		RewriteRuleTokenStream stream_LITERAL_assert=new RewriteRuleTokenStream(adaptor,"token LITERAL_assert");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1699:3: (la= LITERAL_assert (ass+= assertion )+ -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1700:3: la= LITERAL_assert (ass+= assertion )+
			{
			la=(Token)match(input,LITERAL_assert,FOLLOW_LITERAL_assert_in_assert_clause4149); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_assert.add(la);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1700:24: (ass+= assertion )+
			int cnt16=0;
			loop16:
			while (true) {
				int alt16=2;
				int LA16_0 = input.LA(1);
				if ( (LA16_0==LASS) ) {
					alt16=1;
				}

				switch (alt16) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1700:24: ass+= assertion
					{
					pushFollow(FOLLOW_assertion_in_assert_clause4153);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(ass.getTree());
					if (list_ass==null) list_ass=new ArrayList<Object>();
					list_ass.add(ass.getTree());
					}
					break;

				default :
					if ( cnt16 >= 1 ) break loop16;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(16, input);
					throw eee;
				}
				cnt16++;
			}

			// AST REWRITE
			// elements: LITERAL_assert, ass
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: ass
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ass=new RewriteRuleSubtreeStream(adaptor,"token ass",list_ass);
			root_0 = (BAST)adaptor.nil();
			// 1701:5: -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1701:8: ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_assert, la, "assert["+Integer.toString(la.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_ass.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.assertClause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assert_clause"


	public static class invariant_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "invariant_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1706:1: invariant_clause : li= LITERAL_invariant inv= assertion -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv) ;
	public final BLESStoASTParser.invariant_clause_return invariant_clause() throws RecognitionException {
		BLESStoASTParser.invariant_clause_return retval = new BLESStoASTParser.invariant_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token li=null;
		ParserRuleReturnScope inv =null;

		BAST li_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1707:3: (li= LITERAL_invariant inv= assertion -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1708:3: li= LITERAL_invariant inv= assertion
			{
			li=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_invariant_clause4197); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_invariant.add(li);

			pushFollow(FOLLOW_assertion_in_invariant_clause4201);
			inv=assertion();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
			// AST REWRITE
			// elements: LITERAL_invariant, inv
			// token labels: 
			// rule labels: inv, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1709:5: -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1709:8: ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_invariant, li, "invariant["+Integer.toString(li.getLine()+startingLine)+"]"), root_1);
				adaptor.addChild(root_1, stream_inv.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.invariantClause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "invariant_clause"


	public static class variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1714:1: variables : v= LITERAL_variables (bv+= behavior_variable )+ -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* ) ;
	public final BLESStoASTParser.variables_return variables() throws RecognitionException {
		BLESStoASTParser.variables_return retval = new BLESStoASTParser.variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		BAST v_tree=null;
		RewriteRuleTokenStream stream_LITERAL_variables=new RewriteRuleTokenStream(adaptor,"token LITERAL_variables");
		RewriteRuleSubtreeStream stream_behavior_variable=new RewriteRuleSubtreeStream(adaptor,"rule behavior_variable");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1715:3: (v= LITERAL_variables (bv+= behavior_variable )+ -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1716:3: v= LITERAL_variables (bv+= behavior_variable )+
			{
			v=(Token)match(input,LITERAL_variables,FOLLOW_LITERAL_variables_in_variables4244); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_variables.add(v);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1716:23: (bv+= behavior_variable )+
			int cnt17=0;
			loop17:
			while (true) {
				int alt17=2;
				int LA17_0 = input.LA(1);
				if ( (LA17_0==ID) ) {
					alt17=1;
				}

				switch (alt17) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1716:25: bv+= behavior_variable
					{
					pushFollow(FOLLOW_behavior_variable_in_variables4250);
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_variable.add(bv.getTree());
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTree());
					}
					break;

				default :
					if ( cnt17 >= 1 ) break loop17;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(17, input);
					throw eee;
				}
				cnt17++;
			}

			// AST REWRITE
			// elements: LITERAL_variables, bv
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bv=new RewriteRuleSubtreeStream(adaptor,"token bv",list_bv);
			root_0 = (BAST)adaptor.nil();
			// 1717:5: -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1717:8: ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_variables, v, "variables["+Integer.toString(v.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1717:95: ( $bv)*
				while ( stream_bv.hasNext() ) {
					adaptor.addChild(root_1, stream_bv.nextTree());
				}
				stream_bv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.variables,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variables"


	public static class quantified_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "quantified_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1724:1: quantified_variables : v= LITERAL_declare (bv+= behavior_variable )+ -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ ) ;
	public final BLESStoASTParser.quantified_variables_return quantified_variables() throws RecognitionException {
		BLESStoASTParser.quantified_variables_return retval = new BLESStoASTParser.quantified_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		BAST v_tree=null;
		RewriteRuleTokenStream stream_LITERAL_declare=new RewriteRuleTokenStream(adaptor,"token LITERAL_declare");
		RewriteRuleSubtreeStream stream_behavior_variable=new RewriteRuleSubtreeStream(adaptor,"rule behavior_variable");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1725:3: (v= LITERAL_declare (bv+= behavior_variable )+ -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1726:3: v= LITERAL_declare (bv+= behavior_variable )+
			{
			v=(Token)match(input,LITERAL_declare,FOLLOW_LITERAL_declare_in_quantified_variables4302); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_declare.add(v);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1726:21: (bv+= behavior_variable )+
			int cnt18=0;
			loop18:
			while (true) {
				int alt18=2;
				int LA18_0 = input.LA(1);
				if ( (LA18_0==ID) ) {
					alt18=1;
				}

				switch (alt18) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1726:23: bv+= behavior_variable
					{
					pushFollow(FOLLOW_behavior_variable_in_quantified_variables4308);
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_variable.add(bv.getTree());
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTree());
					}
					break;

				default :
					if ( cnt18 >= 1 ) break loop18;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(18, input);
					throw eee;
				}
				cnt18++;
			}

			// AST REWRITE
			// elements: LITERAL_declare, bv
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bv=new RewriteRuleSubtreeStream(adaptor,"token bv",list_bv);
			root_0 = (BAST)adaptor.nil();
			// 1727:5: -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1727:8: ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_declare, v, "declare["+Integer.toString(v.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_bv.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bv.hasNext() ) {
					adaptor.addChild(root_1, stream_bv.nextTree());
				}
				stream_bv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.quantifiedVariables,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "quantified_variables"


	public static class behavior_variable_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_variable"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1742:1: behavior_variable : dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) ;
	public final BLESStoASTParser.behavior_variable_return behavior_variable() throws RecognitionException {
		BLESStoASTParser.behavior_variable_return retval = new BLESStoASTParser.behavior_variable_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token p=null;
		Token s=null;
		Token con=null;
		Token sp=null;
		Token finl=null;
		Token agn=null;
		Token semi=null;
		ParserRuleReturnScope dec =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope ass =null;

		BAST c_tree=null;
		BAST p_tree=null;
		BAST s_tree=null;
		BAST con_tree=null;
		BAST sp_tree=null;
		BAST finl_tree=null;
		BAST agn_tree=null;
		BAST semi_tree=null;
		RewriteRuleTokenStream stream_LITERAL_shared=new RewriteRuleTokenStream(adaptor,"token LITERAL_shared");
		RewriteRuleTokenStream stream_LITERAL_final=new RewriteRuleTokenStream(adaptor,"token LITERAL_final");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_LITERAL_nonvolatile=new RewriteRuleTokenStream(adaptor,"token LITERAL_nonvolatile");
		RewriteRuleTokenStream stream_LITERAL_spread=new RewriteRuleTokenStream(adaptor,"token LITERAL_spread");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleTokenStream stream_LITERAL_constant=new RewriteRuleTokenStream(adaptor,"token LITERAL_constant");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_declarators=new RewriteRuleSubtreeStream(adaptor,"rule declarators");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1743:3: (dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1744:3: dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON
			{
			pushFollow(FOLLOW_declarators_in_behavior_variable4368);
			dec=declarators();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_declarators.add(dec.getTree());
			c=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_variable4372); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:3: (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )?
			int alt19=6;
			switch ( input.LA(1) ) {
				case LITERAL_nonvolatile:
					{
					alt19=1;
					}
					break;
				case LITERAL_shared:
					{
					alt19=2;
					}
					break;
				case LITERAL_constant:
					{
					alt19=3;
					}
					break;
				case LITERAL_spread:
					{
					alt19=4;
					}
					break;
				case LITERAL_final:
					{
					alt19=5;
					}
					break;
			}
			switch (alt19) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:5: p= LITERAL_nonvolatile
					{
					p=(Token)match(input,LITERAL_nonvolatile,FOLLOW_LITERAL_nonvolatile_in_behavior_variable4381); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_nonvolatile.add(p);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:29: s= LITERAL_shared
					{
					s=(Token)match(input,LITERAL_shared,FOLLOW_LITERAL_shared_in_behavior_variable4387); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_shared.add(s);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:48: con= LITERAL_constant
					{
					con=(Token)match(input,LITERAL_constant,FOLLOW_LITERAL_constant_in_behavior_variable4393); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_constant.add(con);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:71: sp= LITERAL_spread
					{
					sp=(Token)match(input,LITERAL_spread,FOLLOW_LITERAL_spread_in_behavior_variable4399); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_spread.add(sp);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1746:5: finl= LITERAL_final
					{
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_variable4407); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_final.add(finl);

					}
					break;

			}

			pushFollow(FOLLOW_type_in_behavior_variable4417);
			t=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_type.add(t.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:10: (agn= ASSIGN e= expression )?
			int alt20=2;
			int LA20_0 = input.LA(1);
			if ( (LA20_0==ASSIGN) ) {
				alt20=1;
			}
			switch (alt20) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:12: agn= ASSIGN e= expression
					{
					agn=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_behavior_variable4423); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(agn);

					pushFollow(FOLLOW_expression_in_behavior_variable4427);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1748:6: (ass= assertion )?
			int alt21=2;
			int LA21_0 = input.LA(1);
			if ( (LA21_0==LASS) ) {
				alt21=1;
			}
			switch (alt21) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1748:6: ass= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_variable4437);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(ass.getTree());
					}
					break;

			}

			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_variable4446); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: e, t, c, ass, t, ass, semi, con, agn, sp, p, p, c, con, s, finl, semi, s, sp, dec, dec, finl
			// token labels: p, c, con, s, agn, semi, sp, finl
			// rule labels: ass, dec, t, e, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_p=new RewriteRuleTokenStream(adaptor,"token p",p);
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_con=new RewriteRuleTokenStream(adaptor,"token con",con);
			RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
			RewriteRuleTokenStream stream_agn=new RewriteRuleTokenStream(adaptor,"token agn",agn);
			RewriteRuleTokenStream stream_semi=new RewriteRuleTokenStream(adaptor,"token semi",semi);
			RewriteRuleTokenStream stream_sp=new RewriteRuleTokenStream(adaptor,"token sp",sp);
			RewriteRuleTokenStream stream_finl=new RewriteRuleTokenStream(adaptor,"token finl",finl);
			RewriteRuleSubtreeStream stream_ass=new RewriteRuleSubtreeStream(adaptor,"rule ass",ass!=null?ass.getTree():null);
			RewriteRuleSubtreeStream stream_dec=new RewriteRuleSubtreeStream(adaptor,"rule dec",dec!=null?dec.getTree():null);
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1750:5: -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
			if (e!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:19: ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dec.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:29: ^( TYPE[\"TYPE\"] $t)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TYPE, "TYPE"), root_2);
				adaptor.addChild(root_2, stream_t.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:48: ^( $agn $e)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_agn.nextNode(), root_2);
				adaptor.addChild(root_2, stream_e.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:62: ( $ass)?
				if ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:68: ( $p)?
				if ( stream_p.hasNext() ) {
					adaptor.addChild(root_1, stream_p.nextNode());
				}
				stream_p.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:72: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_1, stream_s.nextNode());
				}
				stream_s.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:76: ( $con)?
				if ( stream_con.hasNext() ) {
					adaptor.addChild(root_1, stream_con.nextNode());
				}
				stream_con.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:82: ( $sp)?
				if ( stream_sp.hasNext() ) {
					adaptor.addChild(root_1, stream_sp.nextNode());
				}
				stream_sp.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:87: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_semi.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1751:5: -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:8: ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dec.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:18: ^( TYPE[\"TYPE\"] $t)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TYPE, "TYPE"), root_2);
				adaptor.addChild(root_2, stream_t.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:38: ( $ass)?
				if ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:44: ( $p)?
				if ( stream_p.hasNext() ) {
					adaptor.addChild(root_1, stream_p.nextNode());
				}
				stream_p.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:48: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_1, stream_s.nextNode());
				}
				stream_s.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:52: ( $con)?
				if ( stream_con.hasNext() ) {
					adaptor.addChild(root_1, stream_con.nextNode());
				}
				stream_con.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:58: ( $sp)?
				if ( stream_sp.hasNext() ) {
					adaptor.addChild(root_1, stream_sp.nextNode());
				}
				stream_sp.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1751:63: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_semi.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.behaviorVariable,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_variable"


	public static class declarators_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "declarators"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1756:1: declarators : d= ID (c= COMMA ds+= ID )* -> {ds!=null}? ^( $c $d ( $ds)+ ) -> $d;
	public final BLESStoASTParser.declarators_return declarators() throws RecognitionException {
		BLESStoASTParser.declarators_return retval = new BLESStoASTParser.declarators_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token d=null;
		Token c=null;
		Token ds=null;
		List<Object> list_ds=null;

		BAST d_tree=null;
		BAST c_tree=null;
		BAST ds_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1757:3: (d= ID (c= COMMA ds+= ID )* -> {ds!=null}? ^( $c $d ( $ds)+ ) -> $d)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1758:24: d= ID (c= COMMA ds+= ID )*
			{
			d=(Token)match(input,ID,FOLLOW_ID_in_declarators4583); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(d);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1758:29: (c= COMMA ds+= ID )*
			loop22:
			while (true) {
				int alt22=2;
				int LA22_0 = input.LA(1);
				if ( (LA22_0==COMMA) ) {
					alt22=1;
				}

				switch (alt22) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1758:30: c= COMMA ds+= ID
					{
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_declarators4588); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					ds=(Token)match(input,ID,FOLLOW_ID_in_declarators4593); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ds);

					if (list_ds==null) list_ds=new ArrayList<Object>();
					list_ds.add(ds);
					}
					break;

				default :
					break loop22;
				}
			}

			// AST REWRITE
			// elements: ds, d, c, d
			// token labels: c, d
			// rule labels: retval
			// token list labels: ds
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
			RewriteRuleTokenStream stream_ds=new RewriteRuleTokenStream(adaptor,"token ds", list_ds);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1759:5: -> {ds!=null}? ^( $c $d ( $ds)+ )
			if (ds!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1759:20: ^( $c $d ( $ds)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_d.nextNode());
				if ( !(stream_ds.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ds.hasNext() ) {
					adaptor.addChild(root_1, stream_ds.nextNode());
				}
				stream_ds.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1760:5: -> $d
			{
				adaptor.addChild(root_0, stream_d.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "declarators"


	public static class behavior_state_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_state"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1790:1: behavior_state : i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? ) ;
	public final BLESStoASTParser.behavior_state_return behavior_state() throws RecognitionException {
		BLESStoASTParser.behavior_state_return retval = new BLESStoASTParser.behavior_state_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token init=null;
		Token com=null;
		Token finl=null;
		Token st=null;
		Token COLON14=null;
		Token SEMICOLON15=null;
		ParserRuleReturnScope i =null;
		ParserRuleReturnScope a =null;

		BAST init_tree=null;
		BAST com_tree=null;
		BAST finl_tree=null;
		BAST st_tree=null;
		BAST COLON14_tree=null;
		BAST SEMICOLON15_tree=null;
		RewriteRuleTokenStream stream_LITERAL_final=new RewriteRuleTokenStream(adaptor,"token LITERAL_final");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_LITERAL_state=new RewriteRuleTokenStream(adaptor,"token LITERAL_state");
		RewriteRuleTokenStream stream_LITERAL_initial=new RewriteRuleTokenStream(adaptor,"token LITERAL_initial");
		RewriteRuleTokenStream stream_LITERAL_complete=new RewriteRuleTokenStream(adaptor,"token LITERAL_complete");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1791:3: (i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1792:3: i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON
			{
			pushFollow(FOLLOW_identifier_in_behavior_state4677);
			i=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
			COLON14=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_state4682); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON14);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:9: (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )?
			int alt23=4;
			switch ( input.LA(1) ) {
				case LITERAL_initial:
					{
					alt23=1;
					}
					break;
				case LITERAL_complete:
					{
					alt23=2;
					}
					break;
				case LITERAL_final:
					{
					alt23=3;
					}
					break;
			}
			switch (alt23) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:10: init= LITERAL_initial
					{
					init=(Token)match(input,LITERAL_initial,FOLLOW_LITERAL_initial_in_behavior_state4687); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_initial.add(init);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:33: com= LITERAL_complete
					{
					com=(Token)match(input,LITERAL_complete,FOLLOW_LITERAL_complete_in_behavior_state4693); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complete.add(com);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:56: finl= LITERAL_final
					{
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_state4699); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_final.add(finl);

					}
					break;

			}

			st=(Token)match(input,LITERAL_state,FOLLOW_LITERAL_state_in_behavior_state4705); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_state.add(st);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:95: (a= assertion )?
			int alt24=2;
			int LA24_0 = input.LA(1);
			if ( (LA24_0==LASS) ) {
				alt24=1;
			}
			switch (alt24) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:95: a= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_state4709);
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
					}
					break;

			}

			SEMICOLON15=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_state4712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON15);

			// AST REWRITE
			// elements: a, LITERAL_state, i, finl, init, com
			// token labels: com, init, finl
			// rule labels: a, i, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_com=new RewriteRuleTokenStream(adaptor,"token com",com);
			RewriteRuleTokenStream stream_init=new RewriteRuleTokenStream(adaptor,"token init",init);
			RewriteRuleTokenStream stream_finl=new RewriteRuleTokenStream(adaptor,"token finl",finl);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1794:5: -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:8: ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_state, st, "state["+Integer.toString(st.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:89: ( $init)?
				if ( stream_init.hasNext() ) {
					adaptor.addChild(root_1, stream_init.nextNode());
				}
				stream_init.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:96: ( $com)?
				if ( stream_com.hasNext() ) {
					adaptor.addChild(root_1, stream_com.nextNode());
				}
				stream_com.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:102: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_i.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:112: ( $a)?
				if ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.behaviorState,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_state"


	public static class transitions_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "transitions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1799:1: transitions : t= LITERAL_transitions (bt+= behavior_transition )+ -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ ) ;
	public final BLESStoASTParser.transitions_return transitions() throws RecognitionException {
		BLESStoASTParser.transitions_return retval = new BLESStoASTParser.transitions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token t=null;
		List<Object> list_bt=null;
		RuleReturnScope bt = null;
		BAST t_tree=null;
		RewriteRuleTokenStream stream_LITERAL_transitions=new RewriteRuleTokenStream(adaptor,"token LITERAL_transitions");
		RewriteRuleSubtreeStream stream_behavior_transition=new RewriteRuleSubtreeStream(adaptor,"rule behavior_transition");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1800:3: (t= LITERAL_transitions (bt+= behavior_transition )+ -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1801:3: t= LITERAL_transitions (bt+= behavior_transition )+
			{
			t=(Token)match(input,LITERAL_transitions,FOLLOW_LITERAL_transitions_in_transitions4772); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_transitions.add(t);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1801:27: (bt+= behavior_transition )+
			int cnt25=0;
			loop25:
			while (true) {
				int alt25=2;
				int LA25_0 = input.LA(1);
				if ( (LA25_0==ID) ) {
					alt25=1;
				}

				switch (alt25) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1801:27: bt+= behavior_transition
					{
					pushFollow(FOLLOW_behavior_transition_in_transitions4776);
					bt=behavior_transition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_transition.add(bt.getTree());
					if (list_bt==null) list_bt=new ArrayList<Object>();
					list_bt.add(bt.getTree());
					}
					break;

				default :
					if ( cnt25 >= 1 ) break loop25;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(25, input);
					throw eee;
				}
				cnt25++;
			}

			// AST REWRITE
			// elements: LITERAL_transitions, bt
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bt
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bt=new RewriteRuleSubtreeStream(adaptor,"token bt",list_bt);
			root_0 = (BAST)adaptor.nil();
			// 1802:5: -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1802:8: ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_transitions, t, "transitions["+Integer.toString(t.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_bt.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bt.hasNext() ) {
					adaptor.addChild(root_1, stream_bt.nextTree());
				}
				stream_bt.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("If you get \"mismatched input"+
			      " '<<' expecting 'transitions'\" then you might have put a semicolon "+
			      "between an action and a Assertion, instead of afterwards.");
			    tellBNF(GrammarStrings.transitions,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "transitions"


	public static class behavior_transition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_transition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1810:1: behavior_transition : (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) ) ;
	public final BLESStoASTParser.behavior_transition_return behavior_transition() throws RecognitionException {
		BLESStoASTParser.behavior_transition_return retval = new BLESStoASTParser.behavior_transition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token x=null;
		Token semi=null;
		Token COLON16=null;
		Token COMMA17=null;
		Token RCON18=null;
		Token LCURLY19=null;
		Token RCURLY20=null;
		Token EMPTY_CURLY21=null;
		List<Object> list_ssi=null;
		ParserRuleReturnScope btl =null;
		ParserRuleReturnScope bc =null;
		ParserRuleReturnScope dsi =null;
		ParserRuleReturnScope s =null;
		ParserRuleReturnScope q =null;
		RuleReturnScope ssi = null;
		BAST x_tree=null;
		BAST semi_tree=null;
		BAST COLON16_tree=null;
		BAST COMMA17_tree=null;
		BAST RCON18_tree=null;
		BAST LCURLY19_tree=null;
		BAST RCURLY20_tree=null;
		BAST EMPTY_CURLY21_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EMPTY_CURLY=new RewriteRuleTokenStream(adaptor,"token EMPTY_CURLY");
		RewriteRuleTokenStream stream_LCON=new RewriteRuleTokenStream(adaptor,"token LCON");
		RewriteRuleTokenStream stream_RCON=new RewriteRuleTokenStream(adaptor,"token RCON");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_behavior_transition_label=new RewriteRuleSubtreeStream(adaptor,"rule behavior_transition_label");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_behavior_condition=new RewriteRuleSubtreeStream(adaptor,"rule behavior_condition");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1811:3: ( (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1812:3: (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1812:3: (btl= behavior_transition_label COLON )?
			int alt26=2;
			int LA26_0 = input.LA(1);
			if ( (LA26_0==ID) ) {
				int LA26_1 = input.LA(2);
				if ( (LA26_1==COLON||LA26_1==LBRACKET) ) {
					alt26=1;
				}
			}
			switch (alt26) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1812:5: btl= behavior_transition_label COLON
					{
					pushFollow(FOLLOW_behavior_transition_label_in_behavior_transition4823);
					btl=behavior_transition_label();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_transition_label.add(btl.getTree());
					COLON16=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_transition4825); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON16);

					}
					break;

			}

			pushFollow(FOLLOW_identifier_in_behavior_transition4835);
			ssi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(ssi.getTree());
			if (list_ssi==null) list_ssi=new ArrayList<Object>();
			list_ssi.add(ssi.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1813:36: ( COMMA ssi+= identifier )*
			loop27:
			while (true) {
				int alt27=2;
				int LA27_0 = input.LA(1);
				if ( (LA27_0==COMMA) ) {
					alt27=1;
				}

				switch (alt27) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1813:38: COMMA ssi+= identifier
					{
					COMMA17=(Token)match(input,COMMA,FOLLOW_COMMA_in_behavior_transition4839); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA17);

					pushFollow(FOLLOW_identifier_in_behavior_transition4844);
					ssi=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(ssi.getTree());
					if (list_ssi==null) list_ssi=new ArrayList<Object>();
					list_ssi.add(ssi.getTree());
					}
					break;

				default :
					break loop27;
				}
			}

			x=(Token)match(input,LCON,FOLLOW_LCON_in_behavior_transition4853); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCON.add(x);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:12: (bc= behavior_condition )?
			int alt28=2;
			int LA28_0 = input.LA(1);
			if ( (LA28_0==AADL_STRING_LITERAL||LA28_0==ID||LA28_0==INTEGER_LIT||LA28_0==LBRACKET||LA28_0==LITERAL_complex||LA28_0==LITERAL_false||LA28_0==LITERAL_in||LA28_0==LITERAL_integer||LA28_0==LITERAL_natural||(LA28_0 >= LITERAL_not && LA28_0 <= LITERAL_now)||LA28_0==LITERAL_null||LA28_0==LITERAL_on||(LA28_0 >= LITERAL_rational && LA28_0 <= LITERAL_real)||LA28_0==LITERAL_self||(LA28_0 >= LITERAL_time && LA28_0 <= LITERAL_timeout)||LA28_0==LITERAL_tops||LA28_0==LITERAL_true||LA28_0==LPAREN||LA28_0==MINUS||LA28_0==OCTOTHORPE||LA28_0==REAL_LIT) ) {
				alt28=1;
			}
			switch (alt28) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:12: bc= behavior_condition
					{
					pushFollow(FOLLOW_behavior_condition_in_behavior_transition4857);
					bc=behavior_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_condition.add(bc.getTree());
					}
					break;

			}

			RCON18=(Token)match(input,RCON,FOLLOW_RCON_in_behavior_transition4860); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCON.add(RCON18);

			pushFollow(FOLLOW_identifier_in_behavior_transition4867);
			dsi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(dsi.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:3: ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY )
			int alt29=2;
			int LA29_0 = input.LA(1);
			if ( (LA29_0==LCURLY) ) {
				alt29=1;
			}
			else if ( (LA29_0==EMPTY_CURLY) ) {
				alt29=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 29, 0, input);
				throw nvae;
			}

			switch (alt29) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:5: LCURLY s= behavior_actions RCURLY
					{
					LCURLY19=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_behavior_transition4874); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY19);

					pushFollow(FOLLOW_behavior_actions_in_behavior_transition4878);
					s=behavior_actions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_actions.add(s.getTree());
					RCURLY20=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_behavior_transition4880); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY20);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:40: EMPTY_CURLY
					{
					EMPTY_CURLY21=(Token)match(input,EMPTY_CURLY,FOLLOW_EMPTY_CURLY_in_behavior_transition4884); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EMPTY_CURLY.add(EMPTY_CURLY21);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1817:4: (q= assertion )?
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==LASS) ) {
				alt30=1;
			}
			switch (alt30) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1817:4: q= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_transition4892);
					q=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(q.getTree());
					}
					break;

			}

			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_transition4897); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: bc, s, q, dsi, ssi, btl
			// token labels: 
			// rule labels: bc, q, s, dsi, btl, retval
			// token list labels: 
			// rule list labels: ssi
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_bc=new RewriteRuleSubtreeStream(adaptor,"rule bc",bc!=null?bc.getTree():null);
			RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.getTree():null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.getTree():null);
			RewriteRuleSubtreeStream stream_dsi=new RewriteRuleSubtreeStream(adaptor,"rule dsi",dsi!=null?dsi.getTree():null);
			RewriteRuleSubtreeStream stream_btl=new RewriteRuleSubtreeStream(adaptor,"rule btl",btl!=null?btl.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ssi=new RewriteRuleSubtreeStream(adaptor,"token ssi",list_ssi);
			root_0 = (BAST)adaptor.nil();
			// 1818:5: -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1819:7: ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TRANSITION, x, "TRANSITION["+Integer.toString(x.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1820:7: ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, x, "LABEL["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1820:78: ( $btl)?
				if ( stream_btl.hasNext() ) {
					adaptor.addChild(root_2, stream_btl.nextTree());
				}
				stream_btl.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1821:7: ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SOURCE, x, "SOURCE["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				if ( !(stream_ssi.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ssi.hasNext() ) {
					adaptor.addChild(root_2, stream_ssi.nextTree());
				}
				stream_ssi.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1822:7: ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITION, x, "CONDITION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1822:86: ( $bc)?
				if ( stream_bc.hasNext() ) {
					adaptor.addChild(root_2, stream_bc.nextTree());
				}
				stream_bc.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1823:7: ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(DESTINATION, x, "DESTINATION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				adaptor.addChild(root_2, stream_dsi.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1824:7: ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ACTION, x, "ACTION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1824:80: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_2, stream_s.nextTree());
				}
				stream_s.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1825:7: ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(Q, semi, "Q["+Integer.toString(semi.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1825:76: ( $q)?
				if ( stream_q.hasNext() ) {
					adaptor.addChild(root_2, stream_q.nextTree());
				}
				stream_q.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nDo you have either behavior actions or empty curly brackets?");
			    Dump.it("Is there a space between your empty curly brackets?\nYou stink!  Take a bath.\n");
			    Dump.it("Is your execute condition grammatically-correct? ");
			    tellBNF(GrammarStrings.behaviorTransition,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition"


	public static class behavior_transition_label_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_transition_label"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1837:1: behavior_transition_label : id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )? -> ^( $id ( $lit)? ) ;
	public final BLESStoASTParser.behavior_transition_label_return behavior_transition_label() throws RecognitionException {
		BLESStoASTParser.behavior_transition_label_return retval = new BLESStoASTParser.behavior_transition_label_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lit=null;
		Token LBRACKET22=null;
		Token RBRACKET23=null;
		ParserRuleReturnScope id =null;

		BAST lit_tree=null;
		BAST LBRACKET22_tree=null;
		BAST RBRACKET23_tree=null;
		RewriteRuleTokenStream stream_INTEGER_LIT=new RewriteRuleTokenStream(adaptor,"token INTEGER_LIT");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1838:3: (id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )? -> ^( $id ( $lit)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1839:3: id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )?
			{
			pushFollow(FOLLOW_identifier_in_behavior_transition_label5061);
			id=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1839:17: ( LBRACKET lit= INTEGER_LIT RBRACKET )?
			int alt31=2;
			int LA31_0 = input.LA(1);
			if ( (LA31_0==LBRACKET) ) {
				alt31=1;
			}
			switch (alt31) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1839:19: LBRACKET lit= INTEGER_LIT RBRACKET
					{
					LBRACKET22=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_behavior_transition_label5065); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET22);

					lit=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_behavior_transition_label5069); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_INTEGER_LIT.add(lit);

					RBRACKET23=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_behavior_transition_label5071); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET23);

					}
					break;

			}

			// AST REWRITE
			// elements: id, lit
			// token labels: lit
			// rule labels: id, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lit=new RewriteRuleTokenStream(adaptor,"token lit",lit);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1840:5: -> ^( $id ( $lit)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1840:8: ^( $id ( $lit)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_id.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1840:16: ( $lit)?
				if ( stream_lit.hasNext() ) {
					adaptor.addChild(root_1, stream_lit.nextNode());
				}
				stream_lit.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition_label"


	public static class behavior_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1843:1: behavior_condition : ( dispatch_condition | execute_condition | mode_condition );
	public final BLESStoASTParser.behavior_condition_return behavior_condition() throws RecognitionException {
		BLESStoASTParser.behavior_condition_return retval = new BLESStoASTParser.behavior_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope dispatch_condition24 =null;
		ParserRuleReturnScope execute_condition25 =null;
		ParserRuleReturnScope mode_condition26 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1844:3: ( dispatch_condition | execute_condition | mode_condition )
			int alt32=3;
			int LA32_0 = input.LA(1);
			if ( (LA32_0==LITERAL_on) ) {
				int LA32_1 = input.LA(2);
				if ( (LA32_1==LITERAL_dispatch) ) {
					alt32=1;
				}
				else if ( (LA32_1==ID||LA32_1==LPAREN) ) {
					alt32=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 32, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA32_0==AADL_STRING_LITERAL||LA32_0==ID||LA32_0==INTEGER_LIT||LA32_0==LBRACKET||LA32_0==LITERAL_complex||LA32_0==LITERAL_false||LA32_0==LITERAL_in||LA32_0==LITERAL_integer||LA32_0==LITERAL_natural||(LA32_0 >= LITERAL_not && LA32_0 <= LITERAL_now)||LA32_0==LITERAL_null||(LA32_0 >= LITERAL_rational && LA32_0 <= LITERAL_real)||LA32_0==LITERAL_self||(LA32_0 >= LITERAL_time && LA32_0 <= LITERAL_timeout)||LA32_0==LITERAL_tops||LA32_0==LITERAL_true||LA32_0==LPAREN||LA32_0==MINUS||LA32_0==OCTOTHORPE||LA32_0==REAL_LIT) ) {
				alt32=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 32, 0, input);
				throw nvae;
			}

			switch (alt32) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1845:3: dispatch_condition
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_dispatch_condition_in_behavior_condition5109);
					dispatch_condition24=dispatch_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dispatch_condition24.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1845:24: execute_condition
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_execute_condition_in_behavior_condition5113);
					execute_condition25=execute_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, execute_condition25.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1845:44: mode_condition
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_mode_condition_in_behavior_condition5117);
					mode_condition26=mode_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, mode_condition26.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_condition"


	public static class execute_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "execute_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1848:1: execute_condition : expression_or_relation ;
	public final BLESStoASTParser.execute_condition_return execute_condition() throws RecognitionException {
		BLESStoASTParser.execute_condition_return retval = new BLESStoASTParser.execute_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope expression_or_relation27 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1849:3: ( expression_or_relation )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1850:15: expression_or_relation
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_expression_or_relation_in_execute_condition5135);
			expression_or_relation27=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_relation27.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "execute_condition"


	public static class mode_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "mode_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1853:1: mode_condition : LITERAL_on ^ trigger_logical_expression ;
	public final BLESStoASTParser.mode_condition_return mode_condition() throws RecognitionException {
		BLESStoASTParser.mode_condition_return retval = new BLESStoASTParser.mode_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_on28=null;
		ParserRuleReturnScope trigger_logical_expression29 =null;

		BAST LITERAL_on28_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1854:3: ( LITERAL_on ^ trigger_logical_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1855:3: LITERAL_on ^ trigger_logical_expression
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_on28=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_mode_condition5151); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_on28_tree = (BAST)adaptor.create(LITERAL_on28);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_on28_tree, root_0);
			}

			pushFollow(FOLLOW_trigger_logical_expression_in_mode_condition5154);
			trigger_logical_expression29=trigger_logical_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, trigger_logical_expression29.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mode_condition"


	public static class trigger_logical_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "trigger_logical_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1859:1: trigger_logical_expression : first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )? -> {op1!=null}? ^( $op1 $first ( $et)+ ) -> $first;
	public final BLESStoASTParser.trigger_logical_expression_return trigger_logical_expression() throws RecognitionException {
		BLESStoASTParser.trigger_logical_expression_return retval = new BLESStoASTParser.trigger_logical_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		List<Object> list_et=null;
		ParserRuleReturnScope first =null;
		ParserRuleReturnScope op1 =null;
		ParserRuleReturnScope op2 =null;
		RuleReturnScope et = null;
		RewriteRuleSubtreeStream stream_event_trigger=new RewriteRuleSubtreeStream(adaptor,"rule event_trigger");
		RewriteRuleSubtreeStream stream_logical_operator=new RewriteRuleSubtreeStream(adaptor,"rule logical_operator");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1860:3: (first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )? -> {op1!=null}? ^( $op1 $first ( $et)+ ) -> $first)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1861:3: first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )?
			{
			pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5172);
			first=event_trigger();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_event_trigger.add(first.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1861:23: (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )?
			int alt34=2;
			int LA34_0 = input.LA(1);
			if ( (LA34_0==LITERAL_and||LA34_0==LITERAL_cand||LA34_0==LITERAL_cor||LA34_0==LITERAL_or||LA34_0==LITERAL_xor) ) {
				alt34=1;
			}
			switch (alt34) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1861:25: op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)*
					{
					pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5178);
					op1=logical_operator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logical_operator.add(op1.getTree());
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5182);
					et=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_event_trigger.add(et.getTree());
					if (list_et==null) list_et=new ArrayList<Object>();
					list_et.add(et.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1862:5: (op2= logical_operator et+= event_trigger {...}?)*
					loop33:
					while (true) {
						int alt33=2;
						int LA33_0 = input.LA(1);
						if ( (LA33_0==LITERAL_and||LA33_0==LITERAL_cand||LA33_0==LITERAL_cor||LA33_0==LITERAL_or||LA33_0==LITERAL_xor) ) {
							alt33=1;
						}

						switch (alt33) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1862:6: op2= logical_operator et+= event_trigger {...}?
							{
							pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5192);
							op2=logical_operator();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logical_operator.add(op2.getTree());
							pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5196);
							et=event_trigger();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_event_trigger.add(et.getTree());
							if (list_et==null) list_et=new ArrayList<Object>();
							list_et.add(et.getTree());
							if ( !((op1==op2)) ) {
								if (state.backtracking>0) {state.failed=true; return retval;}
								throw new FailedPredicateException(input, "trigger_logical_expression", "op1==op2");
							}
							}
							break;

						default :
							break loop33;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: op1, first, first, et
			// token labels: 
			// rule labels: op1, first, retval
			// token list labels: 
			// rule list labels: et
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_op1=new RewriteRuleSubtreeStream(adaptor,"rule op1",op1!=null?op1.getTree():null);
			RewriteRuleSubtreeStream stream_first=new RewriteRuleSubtreeStream(adaptor,"rule first",first!=null?first.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_et=new RewriteRuleSubtreeStream(adaptor,"token et",list_et);
			root_0 = (BAST)adaptor.nil();
			// 1863:5: -> {op1!=null}? ^( $op1 $first ( $et)+ )
			if (op1!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:21: ^( $op1 $first ( $et)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_op1.nextNode(), root_1);
				adaptor.addChild(root_1, stream_first.nextTree());
				if ( !(stream_et.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_et.hasNext() ) {
					adaptor.addChild(root_1, stream_et.nextTree());
				}
				stream_et.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1864:5: -> $first
			{
				adaptor.addChild(root_0, stream_first.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nAll operators in trigger_logical_expression must be the same.");
			    reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trigger_logical_expression"


	public static class event_trigger_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "event_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1871:1: event_trigger : ( (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID | LPAREN ^ trigger_logical_expression RPAREN );
	public final BLESStoASTParser.event_trigger_return event_trigger() throws RecognitionException {
		BLESStoASTParser.event_trigger_return retval = new BLESStoASTParser.event_trigger_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token port=null;
		Token PERIOD30=null;
		Token PERIOD31=null;
		Token LPAREN32=null;
		Token RPAREN34=null;
		Token sub=null;
		List<Object> list_sub=null;
		ParserRuleReturnScope trigger_logical_expression33 =null;

		BAST port_tree=null;
		BAST PERIOD30_tree=null;
		BAST PERIOD31_tree=null;
		BAST LPAREN32_tree=null;
		BAST RPAREN34_tree=null;
		BAST sub_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1872:3: ( (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID | LPAREN ^ trigger_logical_expression RPAREN )
			int alt37=2;
			int LA37_0 = input.LA(1);
			if ( (LA37_0==ID) ) {
				alt37=1;
			}
			else if ( (LA37_0==LPAREN) ) {
				alt37=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 37, 0, input);
				throw nvae;
			}

			switch (alt37) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:3: (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:3: (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )?
					int alt36=2;
					int LA36_0 = input.LA(1);
					if ( (LA36_0==ID) ) {
						int LA36_1 = input.LA(2);
						if ( (LA36_1==PERIOD) ) {
							alt36=1;
						}
					}
					switch (alt36) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:5: sub+= ID PERIOD ^ (sub+= ID PERIOD )*
							{
							sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5267); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							sub_tree = (BAST)adaptor.create(sub);
							adaptor.addChild(root_0, sub_tree);
							}

							if (list_sub==null) list_sub=new ArrayList<Object>();
							list_sub.add(sub);
							PERIOD30=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5269); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD30_tree = (BAST)adaptor.create(PERIOD30);
							root_0 = (BAST)adaptor.becomeRoot(PERIOD30_tree, root_0);
							}

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:21: (sub+= ID PERIOD )*
							loop35:
							while (true) {
								int alt35=2;
								int LA35_0 = input.LA(1);
								if ( (LA35_0==ID) ) {
									int LA35_1 = input.LA(2);
									if ( (LA35_1==PERIOD) ) {
										alt35=1;
									}

								}

								switch (alt35) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:23: sub+= ID PERIOD
									{
									sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5276); if (state.failed) return retval;
									if ( state.backtracking==0 ) {
									sub_tree = (BAST)adaptor.create(sub);
									adaptor.addChild(root_0, sub_tree);
									}

									if (list_sub==null) list_sub=new ArrayList<Object>();
									list_sub.add(sub);
									PERIOD31=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5278); if (state.failed) return retval;
									if ( state.backtracking==0 ) {
									PERIOD31_tree = (BAST)adaptor.create(PERIOD31);
									adaptor.addChild(root_0, PERIOD31_tree);
									}

									}
									break;

								default :
									break loop35;
								}
							}

							}
							break;

					}

					port=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5288); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					port_tree = (BAST)adaptor.create(port);
					adaptor.addChild(root_0, port_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1874:5: LPAREN ^ trigger_logical_expression RPAREN
					{
					root_0 = (BAST)adaptor.nil();


					LPAREN32=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_trigger5294); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LPAREN32_tree = (BAST)adaptor.create(LPAREN32);
					root_0 = (BAST)adaptor.becomeRoot(LPAREN32_tree, root_0);
					}

					pushFollow(FOLLOW_trigger_logical_expression_in_event_trigger5297);
					trigger_logical_expression33=trigger_logical_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, trigger_logical_expression33.getTree());

					RPAREN34=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_trigger5299); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RPAREN34_tree = (BAST)adaptor.create(RPAREN34);
					adaptor.addChild(root_0, RPAREN34_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "event_trigger"


	public static class logical_operator_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logical_operator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1877:1: logical_operator : ( LITERAL_and | LITERAL_or | LITERAL_xor | LITERAL_cand | LITERAL_cor );
	public final BLESStoASTParser.logical_operator_return logical_operator() throws RecognitionException {
		BLESStoASTParser.logical_operator_return retval = new BLESStoASTParser.logical_operator_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set35=null;

		BAST set35_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1878:3: ( LITERAL_and | LITERAL_or | LITERAL_xor | LITERAL_cand | LITERAL_cor )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set35=input.LT(1);
			if ( input.LA(1)==LITERAL_and||input.LA(1)==LITERAL_cand||input.LA(1)==LITERAL_cor||input.LA(1)==LITERAL_or||input.LA(1)==LITERAL_xor ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set35));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logical_operator"


	public static class subprogram_behavior_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subprogram_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1888:1: subprogram_behavior : ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )? -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? ) -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? ) -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? ) -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? ) ;
	public final BLESStoASTParser.subprogram_behavior_return subprogram_behavior() throws RecognitionException {
		BLESStoASTParser.subprogram_behavior_return retval = new BLESStoASTParser.subprogram_behavior_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token no_proof=null;
		Token pr=null;
		Token po=null;
		Token ANNEX_START36=null;
		Token ANNEX_END37=null;
		ParserRuleReturnScope ac =null;
		ParserRuleReturnScope p1 =null;
		ParserRuleReturnScope p2 =null;
		ParserRuleReturnScope elq =null;

		BAST no_proof_tree=null;
		BAST pr_tree=null;
		BAST po_tree=null;
		BAST ANNEX_START36_tree=null;
		BAST ANNEX_END37_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_LITERAL_pre=new RewriteRuleTokenStream(adaptor,"token LITERAL_pre");
		RewriteRuleTokenStream stream_LITERAL_post=new RewriteRuleTokenStream(adaptor,"token LITERAL_post");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleTokenStream stream_DO_NOT_PROVE=new RewriteRuleTokenStream(adaptor,"token DO_NOT_PROVE");
		RewriteRuleSubtreeStream stream_assert_clause=new RewriteRuleSubtreeStream(adaptor,"rule assert_clause");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1889:3: ( ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )? -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? ) -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? ) -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? ) -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1890:3: ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1890:3: ( ANNEX_START )?
			int alt38=2;
			int LA38_0 = input.LA(1);
			if ( (LA38_0==ANNEX_START) ) {
				alt38=1;
			}
			switch (alt38) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1890:3: ANNEX_START
					{
					ANNEX_START36=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_subprogram_behavior5361); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START36);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1891:11: (no_proof= DO_NOT_PROVE )?
			int alt39=2;
			int LA39_0 = input.LA(1);
			if ( (LA39_0==DO_NOT_PROVE) ) {
				alt39=1;
			}
			switch (alt39) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1891:11: no_proof= DO_NOT_PROVE
					{
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5368); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DO_NOT_PROVE.add(no_proof);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1893:5: (ac= assert_clause )?
			int alt40=2;
			int LA40_0 = input.LA(1);
			if ( (LA40_0==LITERAL_assert) ) {
				alt40=1;
			}
			switch (alt40) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1893:5: ac= assert_clause
					{
					pushFollow(FOLLOW_assert_clause_in_subprogram_behavior5376);
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assert_clause.add(ac.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1894:3: (pr= LITERAL_pre p1= assertion )?
			int alt41=2;
			int LA41_0 = input.LA(1);
			if ( (LA41_0==LITERAL_pre) ) {
				alt41=1;
			}
			switch (alt41) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1894:5: pr= LITERAL_pre p1= assertion
					{
					pr=(Token)match(input,LITERAL_pre,FOLLOW_LITERAL_pre_in_subprogram_behavior5385); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_pre.add(pr);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5389);
					p1=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(p1.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1895:3: (po= LITERAL_post p2= assertion )?
			int alt42=2;
			int LA42_0 = input.LA(1);
			if ( (LA42_0==LITERAL_post) ) {
				alt42=1;
			}
			switch (alt42) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1895:5: po= LITERAL_post p2= assertion
					{
					po=(Token)match(input,LITERAL_post,FOLLOW_LITERAL_post_in_subprogram_behavior5400); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_post.add(po);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5404);
					p2=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(p2.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_existential_lattice_quantification_in_subprogram_behavior5413);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1897:3: ( ANNEX_END )?
			int alt43=2;
			int LA43_0 = input.LA(1);
			if ( (LA43_0==ANNEX_END) ) {
				alt43=1;
			}
			switch (alt43) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1897:3: ANNEX_END
					{
					ANNEX_END37=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_subprogram_behavior5417); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END37);

					}
					break;

			}

			// AST REWRITE
			// elements: ac, p1, pr, elq, ac, po, no_proof, pr, ac, elq, elq, no_proof, p2, elq, p2, ac, no_proof, po, no_proof, p1
			// token labels: pr, no_proof, po
			// rule labels: p1, ac, p2, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_pr=new RewriteRuleTokenStream(adaptor,"token pr",pr);
			RewriteRuleTokenStream stream_no_proof=new RewriteRuleTokenStream(adaptor,"token no_proof",no_proof);
			RewriteRuleTokenStream stream_po=new RewriteRuleTokenStream(adaptor,"token po",po);
			RewriteRuleSubtreeStream stream_p1=new RewriteRuleSubtreeStream(adaptor,"rule p1",p1!=null?p1.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"rule ac",ac!=null?ac.getTree():null);
			RewriteRuleSubtreeStream stream_p2=new RewriteRuleSubtreeStream(adaptor,"rule p2",p2!=null?p2.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1899:5: -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? )
			if (pr==null & po==null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:31: ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:61: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1900:5: -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? )
			if (pr!=null & po==null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1900:31: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1900:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1900:55: ^( $pr $p1)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_pr.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1900:73: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1901:5: -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? )
			if (pr==null & po!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:31: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:55: ^( $po $p2)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_po.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p2.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:72: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1902:5: -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:8: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:28: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:32: ^( $pr $p1)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_pr.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:43: ^( $po $p2)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_po.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p2.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:60: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subprogramBehavior,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subprogram_behavior"


	public static class asserted_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "asserted_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1907:1: asserted_action : (pre= assertion )? s= action (post= assertion )? -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) ) ;
	public final BLESStoASTParser.asserted_action_return asserted_action() throws RecognitionException {
		BLESStoASTParser.asserted_action_return retval = new BLESStoASTParser.asserted_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope pre =null;
		ParserRuleReturnScope s =null;
		ParserRuleReturnScope post =null;

		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1909:3: ( (pre= assertion )? s= action (post= assertion )? -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1910:3: (pre= assertion )? s= action (post= assertion )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1910:6: (pre= assertion )?
			int alt44=2;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==LASS) ) {
				alt44=1;
			}
			switch (alt44) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1910:6: pre= assertion
					{
					pushFollow(FOLLOW_assertion_in_asserted_action5577);
					pre=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(pre.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_action_in_asserted_action5586);
			s=action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_action.add(s.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:7: (post= assertion )?
			int alt45=2;
			int LA45_0 = input.LA(1);
			if ( (LA45_0==LASS) ) {
				alt45=1;
			}
			switch (alt45) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:7: post= assertion
					{
					pushFollow(FOLLOW_assertion_in_asserted_action5592);
					post=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(post.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: pre, post, s
			// token labels: 
			// rule labels: pre, s, post, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_pre=new RewriteRuleSubtreeStream(adaptor,"rule pre",pre!=null?pre.getTree():null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.getTree():null);
			RewriteRuleSubtreeStream stream_post=new RewriteRuleSubtreeStream(adaptor,"rule post",post!=null?post.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1913:5: -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1914:5: ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ACTION, (s!=null?((BAST)s.getTree()):null).getToken(), "ACTION["+Integer.toString((s!=null?((BAST)s.getTree()):null).getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1915:9: ^( P[\"P\"] ( $pre)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(P, "P"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1915:20: ( $pre)?
				if ( stream_pre.hasNext() ) {
					adaptor.addChild(root_2, stream_pre.nextTree());
				}
				stream_pre.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1916:9: ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(S, (s!=null?((BAST)s.getTree()):null).getToken(), "S["+Integer.toString((s!=null?((BAST)s.getTree()):null).getLine()+startingLine)+"]"), root_2);
				adaptor.addChild(root_2, stream_s.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1917:9: ^( Q[\"Q\"] ( $post)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(Q, "Q"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1917:20: ( $post)?
				if ( stream_post.hasNext() ) {
					adaptor.addChild(root_2, stream_post.nextTree());
				}
				stream_post.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(s!=null?((BAST)s.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertedAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "asserted_action"


	public static class action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1923:1: action : ( basic_action | alternative | while_loop | for_loop | do_until_loop | existential_lattice_quantification | universal_lattice_quantification );
	public final BLESStoASTParser.action_return action() throws RecognitionException {
		BLESStoASTParser.action_return retval = new BLESStoASTParser.action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope basic_action38 =null;
		ParserRuleReturnScope alternative39 =null;
		ParserRuleReturnScope while_loop40 =null;
		ParserRuleReturnScope for_loop41 =null;
		ParserRuleReturnScope do_until_loop42 =null;
		ParserRuleReturnScope existential_lattice_quantification43 =null;
		ParserRuleReturnScope universal_lattice_quantification44 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1924:3: ( basic_action | alternative | while_loop | for_loop | do_until_loop | existential_lattice_quantification | universal_lattice_quantification )
			int alt46=7;
			switch ( input.LA(1) ) {
			case ID:
			case LITERAL_computation:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_pause:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_when:
			case LPAREN:
				{
				alt46=1;
				}
				break;
			case LITERAL_if:
				{
				alt46=2;
				}
				break;
			case LITERAL_while:
				{
				alt46=3;
				}
				break;
			case LITERAL_for:
				{
				alt46=4;
				}
				break;
			case LITERAL_do:
				{
				alt46=5;
				}
				break;
			case LCURLY:
			case LITERAL_declare:
				{
				alt46=6;
				}
				break;
			case LITERAL_forall:
				{
				alt46=7;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 46, 0, input);
				throw nvae;
			}
			switch (alt46) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1925:3: basic_action
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_basic_action_in_action5713);
					basic_action38=basic_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, basic_action38.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1926:5: alternative
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_alternative_in_action5719);
					alternative39=alternative();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, alternative39.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1927:5: while_loop
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_while_loop_in_action5725);
					while_loop40=while_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, while_loop40.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1928:5: for_loop
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_for_loop_in_action5731);
					for_loop41=for_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, for_loop41.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1929:5: do_until_loop
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_do_until_loop_in_action5737);
					do_until_loop42=do_until_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, do_until_loop42.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1930:5: existential_lattice_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_existential_lattice_quantification_in_action5743);
					existential_lattice_quantification43=existential_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, existential_lattice_quantification43.getTree());

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1931:5: universal_lattice_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_universal_lattice_quantification_in_action5749);
					universal_lattice_quantification44=universal_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, universal_lattice_quantification44.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.action,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "action"


	public static class alternative_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "alternative"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1936:1: alternative : lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi -> ^( $lif ( $alt)+ ) ;
	public final BLESStoASTParser.alternative_return alternative() throws RecognitionException {
		BLESStoASTParser.alternative_return retval = new BLESStoASTParser.alternative_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lif=null;
		Token string_literal45=null;
		Token LITERAL_fi46=null;
		List<Object> list_alt=null;
		RuleReturnScope alt = null;
		BAST lif_tree=null;
		BAST string_literal45_tree=null;
		BAST LITERAL_fi46_tree=null;
		RewriteRuleTokenStream stream_LITERAL_fi=new RewriteRuleTokenStream(adaptor,"token LITERAL_fi");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_BOX=new RewriteRuleTokenStream(adaptor,"token BOX");
		RewriteRuleSubtreeStream stream_guarded_action=new RewriteRuleSubtreeStream(adaptor,"rule guarded_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1937:3: (lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi -> ^( $lif ( $alt)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1938:3: lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi
			{
			lif=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_alternative5776); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_if.add(lif);

			pushFollow(FOLLOW_guarded_action_in_alternative5784);
			alt=guarded_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_guarded_action.add(alt.getTree());
			if (list_alt==null) list_alt=new ArrayList<Object>();
			list_alt.add(alt.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1941:3: ( '[]' alt+= guarded_action )+
			int cnt47=0;
			loop47:
			while (true) {
				int alt47=2;
				int LA47_0 = input.LA(1);
				if ( (LA47_0==BOX) ) {
					alt47=1;
				}

				switch (alt47) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1941:5: '[]' alt+= guarded_action
					{
					string_literal45=(Token)match(input,BOX,FOLLOW_BOX_in_alternative5790); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_BOX.add(string_literal45);

					pushFollow(FOLLOW_guarded_action_in_alternative5794);
					alt=guarded_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_guarded_action.add(alt.getTree());
					if (list_alt==null) list_alt=new ArrayList<Object>();
					list_alt.add(alt.getTree());
					}
					break;

				default :
					if ( cnt47 >= 1 ) break loop47;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(47, input);
					throw eee;
				}
				cnt47++;
			}

			LITERAL_fi46=(Token)match(input,LITERAL_fi,FOLLOW_LITERAL_fi_in_alternative5802); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_fi.add(LITERAL_fi46);

			// AST REWRITE
			// elements: lif, alt
			// token labels: lif
			// rule labels: retval
			// token list labels: 
			// rule list labels: alt
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lif=new RewriteRuleTokenStream(adaptor,"token lif",lif);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_alt=new RewriteRuleSubtreeStream(adaptor,"token alt",list_alt);
			root_0 = (BAST)adaptor.nil();
			// 1943:5: -> ^( $lif ( $alt)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1943:8: ^( $lif ( $alt)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lif.nextNode(), root_1);
				if ( !(stream_alt.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_alt.hasNext() ) {
					adaptor.addChild(root_1, stream_alt.nextTree());
				}
				stream_alt.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.alternative,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "alternative"


	public static class guarded_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "guarded_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1949:1: guarded_action : LPAREN ! expression_or_relation GUARD ^ asserted_action ;
	public final BLESStoASTParser.guarded_action_return guarded_action() throws RecognitionException {
		BLESStoASTParser.guarded_action_return retval = new BLESStoASTParser.guarded_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN47=null;
		Token GUARD49=null;
		ParserRuleReturnScope expression_or_relation48 =null;
		ParserRuleReturnScope asserted_action50 =null;

		BAST LPAREN47_tree=null;
		BAST GUARD49_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1950:3: ( LPAREN ! expression_or_relation GUARD ^ asserted_action )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1951:3: LPAREN ! expression_or_relation GUARD ^ asserted_action
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN47=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_guarded_action5845); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_guarded_action5849);
			expression_or_relation48=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_relation48.getTree());

			GUARD49=(Token)match(input,GUARD,FOLLOW_GUARD_in_guarded_action5851); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			GUARD49_tree = (BAST)adaptor.create(GUARD49);
			root_0 = (BAST)adaptor.becomeRoot(GUARD49_tree, root_0);
			}

			pushFollow(FOLLOW_asserted_action_in_guarded_action5854);
			asserted_action50=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, asserted_action50.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.guardedAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "guarded_action"


	public static class universal_lattice_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "universal_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1956:1: universal_lattice_quantification : lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification -> ^( $lf $lv ^( $li $r) $elq) ;
	public final BLESStoASTParser.universal_lattice_quantification_return universal_lattice_quantification() throws RecognitionException {
		BLESStoASTParser.universal_lattice_quantification_return retval = new BLESStoASTParser.universal_lattice_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lf=null;
		Token li=null;
		ParserRuleReturnScope lv =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope elq =null;

		BAST lf_tree=null;
		BAST li_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_forall=new RewriteRuleTokenStream(adaptor,"token LITERAL_forall");
		RewriteRuleSubtreeStream stream_lattice_variables=new RewriteRuleSubtreeStream(adaptor,"rule lattice_variables");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_range=new RewriteRuleSubtreeStream(adaptor,"rule range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1957:3: (lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification -> ^( $lf $lv ^( $li $r) $elq) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1958:3: lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification
			{
			lf=(Token)match(input,LITERAL_forall,FOLLOW_LITERAL_forall_in_universal_lattice_quantification5881); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_forall.add(lf);

			pushFollow(FOLLOW_lattice_variables_in_universal_lattice_quantification5890);
			lv=lattice_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_lattice_variables.add(lv.getTree());
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_universal_lattice_quantification5894); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_range_in_universal_lattice_quantification5898);
			r=range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_range.add(r.getTree());
			pushFollow(FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5907);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// AST REWRITE
			// elements: lv, r, lf, li, elq
			// token labels: lf, li
			// rule labels: r, lv, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lf=new RewriteRuleTokenStream(adaptor,"token lf",lf);
			RewriteRuleTokenStream stream_li=new RewriteRuleTokenStream(adaptor,"token li",li);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
			RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1962:5: -> ^( $lf $lv ^( $li $r) $elq)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1962:8: ^( $lf $lv ^( $li $r) $elq)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lf.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lv.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1962:18: ^( $li $r)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_li.nextNode(), root_2);
				adaptor.addChild(root_2, stream_r.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.ulq,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_lattice_quantification"


	public static class lattice_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "lattice_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1967:1: lattice_variables : i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )? -> {com!=null}? ^( $com $i1 ( $i)+ ) -> $i1;
	public final BLESStoASTParser.lattice_variables_return lattice_variables() throws RecognitionException {
		BLESStoASTParser.lattice_variables_return retval = new BLESStoASTParser.lattice_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token com=null;
		Token COMMA51=null;
		List<Object> list_i=null;
		ParserRuleReturnScope i1 =null;
		RuleReturnScope i = null;
		BAST com_tree=null;
		BAST COMMA51_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1968:3: (i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )? -> {com!=null}? ^( $com $i1 ( $i)+ ) -> $i1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:3: i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )?
			{
			pushFollow(FOLLOW_identifier_in_lattice_variables5958);
			i1=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:17: (com= COMMA i+= identifier ( COMMA i+= identifier )* )?
			int alt49=2;
			int LA49_0 = input.LA(1);
			if ( (LA49_0==COMMA) ) {
				alt49=1;
			}
			switch (alt49) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:18: com= COMMA i+= identifier ( COMMA i+= identifier )*
					{
					com=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5963); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(com);

					pushFollow(FOLLOW_identifier_in_lattice_variables5967);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:42: ( COMMA i+= identifier )*
					loop48:
					while (true) {
						int alt48=2;
						int LA48_0 = input.LA(1);
						if ( (LA48_0==COMMA) ) {
							alt48=1;
						}

						switch (alt48) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:43: COMMA i+= identifier
							{
							COMMA51=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5970); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA51);

							pushFollow(FOLLOW_identifier_in_lattice_variables5974);
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							break loop48;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: i1, i, i1, com
			// token labels: com
			// rule labels: i1, retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_com=new RewriteRuleTokenStream(adaptor,"token com",com);
			RewriteRuleSubtreeStream stream_i1=new RewriteRuleSubtreeStream(adaptor,"rule i1",i1!=null?i1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (BAST)adaptor.nil();
			// 1970:5: -> {com!=null}? ^( $com $i1 ( $i)+ )
			if (com!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1970:20: ^( $com $i1 ( $i)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_com.nextNode(), root_1);
				adaptor.addChild(root_1, stream_i1.nextTree());
				if ( !(stream_i.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_i.hasNext() ) {
					adaptor.addChild(root_1, stream_i.nextTree());
				}
				stream_i.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1971:5: -> $i1
			{
				adaptor.addChild(root_0, stream_i1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lattice_variables"


	public static class while_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "while_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1976:1: while_loop : lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq) ;
	public final BLESStoASTParser.while_loop_return while_loop() throws RecognitionException {
		BLESStoASTParser.while_loop_return retval = new BLESStoASTParser.while_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lw=null;
		Token LPAREN52=null;
		Token RPAREN53=null;
		Token LITERAL_invariant54=null;
		Token LITERAL_bound55=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope bd =null;
		ParserRuleReturnScope elq =null;

		BAST lw_tree=null;
		BAST LPAREN52_tree=null;
		BAST RPAREN53_tree=null;
		BAST LITERAL_invariant54_tree=null;
		BAST LITERAL_bound55_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_bound=new RewriteRuleTokenStream(adaptor,"token LITERAL_bound");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_LITERAL_while=new RewriteRuleTokenStream(adaptor,"token LITERAL_while");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1977:3: (lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1978:3: lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification
			{
			lw=(Token)match(input,LITERAL_while,FOLLOW_LITERAL_while_in_while_loop6036); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_while.add(lw);

			LPAREN52=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_while_loop6042); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN52);

			pushFollow(FOLLOW_expression_or_relation_in_while_loop6047);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
			RPAREN53=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_while_loop6049); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN53);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1981:3: ( LITERAL_invariant inv= assertion )?
			int alt50=2;
			int LA50_0 = input.LA(1);
			if ( (LA50_0==LITERAL_invariant) ) {
				alt50=1;
			}
			switch (alt50) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1981:5: LITERAL_invariant inv= assertion
					{
					LITERAL_invariant54=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_while_loop6056); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant54);

					pushFollow(FOLLOW_assertion_in_while_loop6060);
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1982:3: ( LITERAL_bound bd= expression )?
			int alt51=2;
			int LA51_0 = input.LA(1);
			if ( (LA51_0==LITERAL_bound) ) {
				alt51=1;
			}
			switch (alt51) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1982:5: LITERAL_bound bd= expression
					{
					LITERAL_bound55=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_while_loop6069); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound55);

					pushFollow(FOLLOW_expression_in_while_loop6074);
					bd=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(bd.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_existential_lattice_quantification_in_while_loop6085);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// AST REWRITE
			// elements: inv, bd, elq, be, lw
			// token labels: lw
			// rule labels: inv, bd, be, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lw=new RewriteRuleTokenStream(adaptor,"token lw",lw);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_bd=new RewriteRuleSubtreeStream(adaptor,"rule bd",bd!=null?bd.getTree():null);
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1984:5: -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:8: ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lw.nextNode(), root_1);
				adaptor.addChild(root_1, stream_be.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:18: ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, lw, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:48: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:54: ^( BOUND[$lw,\"BOUND\"] ( $bd)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BOUND, lw, "BOUND"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:76: ( $bd)?
				if ( stream_bd.hasNext() ) {
					adaptor.addChild(root_2, stream_bd.nextTree());
				}
				stream_bd.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.whileLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "while_loop"


	public static class for_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "for_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1989:1: for_loop : lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act) ;
	public final BLESStoASTParser.for_loop_return for_loop() throws RecognitionException {
		BLESStoASTParser.for_loop_return retval = new BLESStoASTParser.for_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lf=null;
		Token li=null;
		Token DOTDOT56=null;
		Token LITERAL_invariant57=null;
		Token LCURLY58=null;
		Token RCURLY59=null;
		ParserRuleReturnScope a =null;
		ParserRuleReturnScope lb =null;
		ParserRuleReturnScope ub =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope act =null;

		BAST lf_tree=null;
		BAST li_tree=null;
		BAST DOTDOT56_tree=null;
		BAST LITERAL_invariant57_tree=null;
		BAST LCURLY58_tree=null;
		BAST RCURLY59_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_for=new RewriteRuleTokenStream(adaptor,"token LITERAL_for");
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1990:3: (lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1991:3: lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY
			{
			lf=(Token)match(input,LITERAL_for,FOLLOW_LITERAL_for_in_for_loop6150); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_for.add(lf);

			pushFollow(FOLLOW_identifier_in_for_loop6158);
			a=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_for_loop6163); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_expression_in_for_loop6168);
			lb=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(lb.getTree());
			DOTDOT56=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_for_loop6170); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT56);

			pushFollow(FOLLOW_expression_in_for_loop6175);
			ub=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(ub.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1996:3: ( LITERAL_invariant inv= assertion )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==LITERAL_invariant) ) {
				alt52=1;
			}
			switch (alt52) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1996:5: LITERAL_invariant inv= assertion
					{
					LITERAL_invariant57=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_for_loop6184); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant57);

					pushFollow(FOLLOW_assertion_in_for_loop6188);
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			LCURLY58=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_for_loop6195); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY58);

			pushFollow(FOLLOW_behavior_actions_in_for_loop6200);
			act=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_behavior_actions.add(act.getTree());
			RCURLY59=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_for_loop6202); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY59);

			// AST REWRITE
			// elements: a, act, ub, lb, lf, li, inv
			// token labels: lf, li
			// rule labels: inv, a, act, lb, ub, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lf=new RewriteRuleTokenStream(adaptor,"token lf",lf);
			RewriteRuleTokenStream stream_li=new RewriteRuleTokenStream(adaptor,"token li",li);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
			RewriteRuleSubtreeStream stream_act=new RewriteRuleSubtreeStream(adaptor,"rule act",act!=null?act.getTree():null);
			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,"rule lb",lb!=null?lb.getTree():null);
			RewriteRuleSubtreeStream stream_ub=new RewriteRuleSubtreeStream(adaptor,"rule ub",ub!=null?ub.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1999:5: -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1999:7: ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lf.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1999:16: ^( $li $lb $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_li.nextNode(), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1999:31: ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, lf, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1999:61: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_act.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.forLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_loop"


	public static class do_until_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "do_until_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2004:1: do_until_loop : ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba) ;
	public final BLESStoASTParser.do_until_loop_return do_until_loop() throws RecognitionException {
		BLESStoASTParser.do_until_loop_return retval = new BLESStoASTParser.do_until_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ld=null;
		Token lu=null;
		Token LITERAL_invariant60=null;
		Token LITERAL_bound61=null;
		Token LPAREN62=null;
		Token RPAREN63=null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope bd =null;
		ParserRuleReturnScope ba =null;
		ParserRuleReturnScope be =null;

		BAST ld_tree=null;
		BAST lu_tree=null;
		BAST LITERAL_invariant60_tree=null;
		BAST LITERAL_bound61_tree=null;
		BAST LPAREN62_tree=null;
		BAST RPAREN63_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_bound=new RewriteRuleTokenStream(adaptor,"token LITERAL_bound");
		RewriteRuleTokenStream stream_LITERAL_until=new RewriteRuleTokenStream(adaptor,"token LITERAL_until");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_LITERAL_do=new RewriteRuleTokenStream(adaptor,"token LITERAL_do");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2005:3: (ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2006:3: ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN
			{
			ld=(Token)match(input,LITERAL_do,FOLLOW_LITERAL_do_in_do_until_loop6272); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_do.add(ld);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2008:3: ( LITERAL_invariant inv= assertion )?
			int alt53=2;
			int LA53_0 = input.LA(1);
			if ( (LA53_0==LITERAL_invariant) ) {
				alt53=1;
			}
			switch (alt53) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2008:5: LITERAL_invariant inv= assertion
					{
					LITERAL_invariant60=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_do_until_loop6280); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant60);

					pushFollow(FOLLOW_assertion_in_do_until_loop6284);
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2009:3: ( LITERAL_bound bd= expression )?
			int alt54=2;
			int LA54_0 = input.LA(1);
			if ( (LA54_0==LITERAL_bound) ) {
				alt54=1;
			}
			switch (alt54) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2009:5: LITERAL_bound bd= expression
					{
					LITERAL_bound61=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_do_until_loop6293); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound61);

					pushFollow(FOLLOW_expression_in_do_until_loop6298);
					bd=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(bd.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_behavior_actions_in_do_until_loop6309);
			ba=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_behavior_actions.add(ba.getTree());
			lu=(Token)match(input,LITERAL_until,FOLLOW_LITERAL_until_in_do_until_loop6315); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_until.add(lu);

			LPAREN62=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_do_until_loop6317); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN62);

			pushFollow(FOLLOW_expression_or_relation_in_do_until_loop6322);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
			RPAREN63=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_do_until_loop6324); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN63);

			// AST REWRITE
			// elements: be, bd, lu, ld, inv, ba
			// token labels: ld, lu
			// rule labels: inv, bd, be, retval, ba
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_ld=new RewriteRuleTokenStream(adaptor,"token ld",ld);
			RewriteRuleTokenStream stream_lu=new RewriteRuleTokenStream(adaptor,"token lu",lu);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_bd=new RewriteRuleSubtreeStream(adaptor,"rule bd",bd!=null?bd.getTree():null);
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ba=new RewriteRuleSubtreeStream(adaptor,"rule ba",ba!=null?ba.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2012:5: -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2012:7: ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_ld.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2012:13: ^( $lu $be)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_lu.nextNode(), root_2);
				adaptor.addChild(root_2, stream_be.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2012:24: ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, ld, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2012:54: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2012:60: ^( BOUND[$ld,\"BOUND\"] ( $bd)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BOUND, ld, "BOUND"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2012:82: ( $bd)?
				if ( stream_bd.hasNext() ) {
					adaptor.addChild(root_2, stream_bd.nextTree());
				}
				stream_bd.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.doUntilLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "do_until_loop"


	public static class basic_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "basic_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2017:1: basic_action : ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception );
	public final BLESStoASTParser.basic_action_return basic_action() throws RecognitionException {
		BLESStoASTParser.basic_action_return retval = new BLESStoASTParser.basic_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_skip64=null;
		Token LITERAL_setmode68=null;
		ParserRuleReturnScope assignment65 =null;
		ParserRuleReturnScope communication_action66 =null;
		ParserRuleReturnScope computation_action67 =null;
		ParserRuleReturnScope identifier69 =null;
		ParserRuleReturnScope when_throw70 =null;
		ParserRuleReturnScope combinable_operation71 =null;
		ParserRuleReturnScope simultaneous_assignment72 =null;
		ParserRuleReturnScope issue_exception73 =null;

		BAST LITERAL_skip64_tree=null;
		BAST LITERAL_setmode68_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2018:3: ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception )
			int alt55=9;
			alt55 = dfa55.predict(input);
			switch (alt55) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2019:3: LITERAL_skip
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_skip64=(Token)match(input,LITERAL_skip,FOLLOW_LITERAL_skip_in_basic_action6394); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_skip64_tree = (BAST)adaptor.create(LITERAL_skip64);
					adaptor.addChild(root_0, LITERAL_skip64_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2020:5: assignment
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_assignment_in_basic_action6400);
					assignment65=assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assignment65.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2022:5: communication_action
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_communication_action_in_basic_action6407);
					communication_action66=communication_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, communication_action66.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2023:5: computation_action
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_computation_action_in_basic_action6414);
					computation_action67=computation_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, computation_action67.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2024:5: LITERAL_setmode identifier
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_setmode68=(Token)match(input,LITERAL_setmode,FOLLOW_LITERAL_setmode_in_basic_action6420); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_setmode68_tree = (BAST)adaptor.create(LITERAL_setmode68);
					adaptor.addChild(root_0, LITERAL_setmode68_tree);
					}

					pushFollow(FOLLOW_identifier_in_basic_action6423);
					identifier69=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier69.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2025:5: when_throw
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_when_throw_in_basic_action6429);
					when_throw70=when_throw();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, when_throw70.getTree());

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2026:5: combinable_operation
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_combinable_operation_in_basic_action6435);
					combinable_operation71=combinable_operation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, combinable_operation71.getTree());

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2027:5: simultaneous_assignment
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_simultaneous_assignment_in_basic_action6441);
					simultaneous_assignment72=simultaneous_assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, simultaneous_assignment72.getTree());

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2028:5: issue_exception
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_issue_exception_in_basic_action6447);
					issue_exception73=issue_exception();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, issue_exception73.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.basicAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "basic_action"


	public static class assignment_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2033:1: assignment : nt= name_tick a= ASSIGN eort= expression_or_record_term -> ^( $a $nt $eort) ;
	public final BLESStoASTParser.assignment_return assignment() throws RecognitionException {
		BLESStoASTParser.assignment_return retval = new BLESStoASTParser.assignment_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		ParserRuleReturnScope nt =null;
		ParserRuleReturnScope eort =null;

		BAST a_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression_or_record_term=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_record_term");
		RewriteRuleSubtreeStream stream_name_tick=new RewriteRuleSubtreeStream(adaptor,"rule name_tick");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2034:3: (nt= name_tick a= ASSIGN eort= expression_or_record_term -> ^( $a $nt $eort) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2035:2: nt= name_tick a= ASSIGN eort= expression_or_record_term
			{
			pushFollow(FOLLOW_name_tick_in_assignment6474);
			nt=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name_tick.add(nt.getTree());
			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignment6478); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_assignment6482);
			eort=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_record_term.add(eort.getTree());
			// AST REWRITE
			// elements: nt, eort, a
			// token labels: a
			// rule labels: eort, nt, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_eort=new RewriteRuleSubtreeStream(adaptor,"rule eort",eort!=null?eort.getTree():null);
			RewriteRuleSubtreeStream stream_nt=new RewriteRuleSubtreeStream(adaptor,"rule nt",nt!=null?nt.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2036:5: -> ^( $a $nt $eort)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2036:8: ^( $a $nt $eort)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				adaptor.addChild(root_1, stream_nt.nextTree());
				adaptor.addChild(root_1, stream_eort.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignment"


	public static class name_tick_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "name_tick"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2044:1: name_tick : name ( TICK ^)? ;
	public final BLESStoASTParser.name_tick_return name_tick() throws RecognitionException {
		BLESStoASTParser.name_tick_return retval = new BLESStoASTParser.name_tick_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK75=null;
		ParserRuleReturnScope name74 =null;

		BAST TICK75_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2045:3: ( name ( TICK ^)? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2046:17: name ( TICK ^)?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_name_in_name_tick6526);
			name74=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, name74.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2046:22: ( TICK ^)?
			int alt56=2;
			int LA56_0 = input.LA(1);
			if ( (LA56_0==TICK) ) {
				alt56=1;
			}
			switch (alt56) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2046:24: TICK ^
					{
					TICK75=(Token)match(input,TICK,FOLLOW_TICK_in_name_tick6530); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TICK75_tree = (BAST)adaptor.create(TICK75);
					root_0 = (BAST)adaptor.becomeRoot(TICK75_tree, root_0);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name_tick"


	public static class expression_or_record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2049:1: expression_or_record_term : (e= expression |rt= record_term |any= LITERAL_any );
	public final BLESStoASTParser.expression_or_record_term_return expression_or_record_term() throws RecognitionException {
		BLESStoASTParser.expression_or_record_term_return retval = new BLESStoASTParser.expression_or_record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token any=null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope rt =null;

		BAST any_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2050:3: (e= expression |rt= record_term |any= LITERAL_any )
			int alt57=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt57=1;
				}
				break;
			case LPAREN:
				{
				int LA57_2 = input.LA(2);
				if ( (LA57_2==AADL_STRING_LITERAL||LA57_2==INTEGER_LIT||LA57_2==LBRACKET||LA57_2==LITERAL_complex||LA57_2==LITERAL_false||LA57_2==LITERAL_if||LA57_2==LITERAL_in||LA57_2==LITERAL_integer||LA57_2==LITERAL_natural||(LA57_2 >= LITERAL_not && LA57_2 <= LITERAL_now)||LA57_2==LITERAL_null||(LA57_2 >= LITERAL_rational && LA57_2 <= LITERAL_real)||LA57_2==LITERAL_self||(LA57_2 >= LITERAL_time && LA57_2 <= LITERAL_timeout)||LA57_2==LITERAL_tops||LA57_2==LITERAL_true||LA57_2==LPAREN||LA57_2==MINUS||LA57_2==OCTOTHORPE||LA57_2==REAL_LIT) ) {
					alt57=1;
				}
				else if ( (LA57_2==ID) ) {
					int LA57_4 = input.LA(3);
					if ( ((LA57_4 >= AL && LA57_4 <= AM)||LA57_4==DIVIDE||LA57_4==DOUBLE_COLON||LA57_4==EQ||LA57_4==EXP||LA57_4==GT||LA57_4==LBRACKET||LA57_4==LITERAL_and||LA57_4==LITERAL_cand||LA57_4==LITERAL_cor||LA57_4==LITERAL_mod||LA57_4==LITERAL_or||LA57_4==LITERAL_rem||LA57_4==LITERAL_xor||LA57_4==LT||LA57_4==MINUS||LA57_4==NEQ||LA57_4==OCTOTHORPE||(LA57_4 >= PERIOD && LA57_4 <= PLUS)||(LA57_4 >= QQ && LA57_4 <= QUESTION)||LA57_4==RPAREN||LA57_4==TICK||LA57_4==TIMES) ) {
						alt57=1;
					}
					else if ( (LA57_4==ARROW) ) {
						alt57=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 57, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 57, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_any:
				{
				alt57=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 57, 0, input);
				throw nvae;
			}
			switch (alt57) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2051:3: e= expression
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_expression_in_expression_or_record_term6554);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, e.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2051:18: rt= record_term
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_record_term_in_expression_or_record_term6560);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rt.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2051:35: any= LITERAL_any
					{
					root_0 = (BAST)adaptor.nil();


					any=(Token)match(input,LITERAL_any,FOLLOW_LITERAL_any_in_expression_or_record_term6566); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					any_tree = (BAST)adaptor.create(any);
					adaptor.addChild(root_0, any_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_record_term"


	public static class record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2054:1: record_term : LPAREN ^ (prv+= record_value )+ RPAREN ;
	public final BLESStoASTParser.record_term_return record_term() throws RecognitionException {
		BLESStoASTParser.record_term_return retval = new BLESStoASTParser.record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN76=null;
		Token RPAREN77=null;
		List<Object> list_prv=null;
		RuleReturnScope prv = null;
		BAST LPAREN76_tree=null;
		BAST RPAREN77_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2055:3: ( LPAREN ^ (prv+= record_value )+ RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2056:3: LPAREN ^ (prv+= record_value )+ RPAREN
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN76=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_term6581); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LPAREN76_tree = (BAST)adaptor.create(LPAREN76);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN76_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2056:14: (prv+= record_value )+
			int cnt58=0;
			loop58:
			while (true) {
				int alt58=2;
				int LA58_0 = input.LA(1);
				if ( (LA58_0==ID) ) {
					alt58=1;
				}

				switch (alt58) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2056:14: prv+= record_value
					{
					pushFollow(FOLLOW_record_value_in_record_term6586);
					prv=record_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, prv.getTree());

					if (list_prv==null) list_prv=new ArrayList<Object>();
					list_prv.add(prv.getTree());
					}
					break;

				default :
					if ( cnt58 >= 1 ) break loop58;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(58, input);
					throw eee;
				}
				cnt58++;
			}

			RPAREN77=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_term6589); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RPAREN77_tree = (BAST)adaptor.create(RPAREN77);
			adaptor.addChild(root_0, RPAREN77_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_term"


	public static class record_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2059:1: record_value : identifier ARROW ^ value SEMICOLON !;
	public final BLESStoASTParser.record_value_return record_value() throws RecognitionException {
		BLESStoASTParser.record_value_return retval = new BLESStoASTParser.record_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ARROW79=null;
		Token SEMICOLON81=null;
		ParserRuleReturnScope identifier78 =null;
		ParserRuleReturnScope value80 =null;

		BAST ARROW79_tree=null;
		BAST SEMICOLON81_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2060:3: ( identifier ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2061:20: identifier ARROW ^ value SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_identifier_in_record_value6607);
			identifier78=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier78.getTree());

			ARROW79=(Token)match(input,ARROW,FOLLOW_ARROW_in_record_value6609); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ARROW79_tree = (BAST)adaptor.create(ARROW79);
			root_0 = (BAST)adaptor.becomeRoot(ARROW79_tree, root_0);
			}

			pushFollow(FOLLOW_value_in_record_value6612);
			value80=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value80.getTree());

			SEMICOLON81=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_value6614); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_value"


	public static class simultaneous_assignment_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "simultaneous_assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2064:1: simultaneous_assignment : LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) ) ;
	public final BLESStoASTParser.simultaneous_assignment_return simultaneous_assignment() throws RecognitionException {
		BLESStoASTParser.simultaneous_assignment_return retval = new BLESStoASTParser.simultaneous_assignment_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token left_comma=null;
		Token a=null;
		Token right_comma=null;
		Token LPAREN82=null;
		Token RPAREN83=null;
		List<Object> list_lhs=null;
		List<Object> list_rhs=null;
		RuleReturnScope lhs = null;
		RuleReturnScope rhs = null;
		BAST left_comma_tree=null;
		BAST a_tree=null;
		BAST right_comma_tree=null;
		BAST LPAREN82_tree=null;
		BAST RPAREN83_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression_or_record_term=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_record_term");
		RewriteRuleSubtreeStream stream_name_tick=new RewriteRuleSubtreeStream(adaptor,"rule name_tick");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2083:3: ( LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2084:3: LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN
			{
			LPAREN82=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_simultaneous_assignment6640); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN82);

			pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6644);
			lhs=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name_tick.add(lhs.getTree());
			if (list_lhs==null) list_lhs=new ArrayList<Object>();
			list_lhs.add(lhs.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2084:25: (left_comma= COMMA lhs+= name_tick )+
			int cnt59=0;
			loop59:
			while (true) {
				int alt59=2;
				int LA59_0 = input.LA(1);
				if ( (LA59_0==COMMA) ) {
					alt59=1;
				}

				switch (alt59) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2084:27: left_comma= COMMA lhs+= name_tick
					{
					left_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6650); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(left_comma);

					pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6654);
					lhs=name_tick();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name_tick.add(lhs.getTree());
					if (list_lhs==null) list_lhs=new ArrayList<Object>();
					list_lhs.add(lhs.getTree());
					}
					break;

				default :
					if ( cnt59 >= 1 ) break loop59;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(59, input);
					throw eee;
				}
				cnt59++;
			}

			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_simultaneous_assignment6664); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6668);
			rhs=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_record_term.add(rhs.getTree());
			if (list_rhs==null) list_rhs=new ArrayList<Object>();
			list_rhs.add(rhs.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2085:43: (right_comma= COMMA rhs+= expression_or_record_term )+
			int cnt60=0;
			loop60:
			while (true) {
				int alt60=2;
				int LA60_0 = input.LA(1);
				if ( (LA60_0==COMMA) ) {
					alt60=1;
				}

				switch (alt60) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2085:45: right_comma= COMMA rhs+= expression_or_record_term
					{
					right_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6674); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(right_comma);

					pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6678);
					rhs=expression_or_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_record_term.add(rhs.getTree());
					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}
					break;

				default :
					if ( cnt60 >= 1 ) break loop60;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(60, input);
					throw eee;
				}
				cnt60++;
			}

			RPAREN83=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_simultaneous_assignment6683); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN83);

			// AST REWRITE
			// elements: left_comma, a, right_comma, lhs, rhs
			// token labels: a, right_comma, left_comma
			// rule labels: retval
			// token list labels: 
			// rule list labels: lhs, rhs
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleTokenStream stream_right_comma=new RewriteRuleTokenStream(adaptor,"token right_comma",right_comma);
			RewriteRuleTokenStream stream_left_comma=new RewriteRuleTokenStream(adaptor,"token left_comma",left_comma);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"token lhs",list_lhs);
			RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"token rhs",list_rhs);
			root_0 = (BAST)adaptor.nil();
			// 2086:5: -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2086:8: ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2086:13: ^( $left_comma ( $lhs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_left_comma.nextNode(), root_2);
				if ( !(stream_lhs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_lhs.hasNext() ) {
					adaptor.addChild(root_2, stream_lhs.nextTree());
				}
				stream_lhs.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2086:36: ^( $right_comma ( $rhs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_right_comma.nextNode(), root_2);
				if ( !(stream_rhs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_rhs.hasNext() ) {
					adaptor.addChild(root_2, stream_rhs.nextTree());
				}
				stream_rhs.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {
			    if (retval.tree==null) throw new YouIdiot("No retval.tree in simultaneous_assignment");
			    if (!retval.tree.hasType(BLESStoASTLexer.ASSIGN)) throw new YouIdiot(
			      "retval.tree must be := for simulatneous assignmen",retval.tree);
			    if (retval.tree.getChildCount()!=2) throw new YouIdiot(" := must have two children",retval.tree);
			    BAST lhc=(BAST)retval.tree.getChild(0); 
			    BAST rhc=(BAST)retval.tree.getChild(1); 
			    if (!lhc.hasType(BLESStoASTLexer.COMMA) || !rhc.hasType(BLESStoASTLexer.COMMA))
			      throw new YouIdiot(" children of := must be ,",retval.tree);
			    if (lhc.getChildCount()!=rhc.getChildCount())
			      {
			      Dump.it("\n\nBoth sides of simulatneous assignment must have equal number of terms:  "+
			          lhc.getChildCount()+" is not "+rhc.getChildCount());
			      throw new YouIdiot("simultaneous assignment "+
			      (lhc.getChildCount()>rhc.getChildCount()?"more variables than expressions":"more expressions than variables")
			      ,retval.tree);
			      }
			  }
		}
		catch (YouIdiot yi) {
			yi.handleException();
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simultaneous_assignment"


	public static class issue_exception_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "issue_exception"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2090:1: issue_exception : LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !;
	public final BLESStoASTParser.issue_exception_return issue_exception() throws RecognitionException {
		BLESStoASTParser.issue_exception_return retval = new BLESStoASTParser.issue_exception_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token message=null;
		Token LITERAL_exception84=null;
		Token LPAREN85=null;
		Token COMMA86=null;
		Token RPAREN87=null;
		ParserRuleReturnScope exception_state =null;

		BAST message_tree=null;
		BAST LITERAL_exception84_tree=null;
		BAST LPAREN85_tree=null;
		BAST COMMA86_tree=null;
		BAST RPAREN87_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2091:3: ( LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2092:3: LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_exception84=(Token)match(input,LITERAL_exception,FOLLOW_LITERAL_exception_in_issue_exception6745); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_exception84_tree = (BAST)adaptor.create(LITERAL_exception84);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_exception84_tree, root_0);
			}

			LPAREN85=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_issue_exception6748); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2093:3: (exception_state= identifier COMMA !)?
			int alt61=2;
			int LA61_0 = input.LA(1);
			if ( (LA61_0==ID) ) {
				alt61=1;
			}
			switch (alt61) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2093:5: exception_state= identifier COMMA !
					{
					pushFollow(FOLLOW_identifier_in_issue_exception6758);
					exception_state=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exception_state.getTree());

					COMMA86=(Token)match(input,COMMA,FOLLOW_COMMA_in_issue_exception6760); if (state.failed) return retval;
					}
					break;

			}

			message=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_issue_exception6768); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			message_tree = (BAST)adaptor.create(message);
			adaptor.addChild(root_0, message_tree);
			}

			RPAREN87=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_issue_exception6770); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "issue_exception"


	public static class computation_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "computation_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2097:1: computation_action : LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !;
	public final BLESStoASTParser.computation_action_return computation_action() throws RecognitionException {
		BLESStoASTParser.computation_action_return retval = new BLESStoASTParser.computation_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_computation88=null;
		Token LPAREN89=null;
		Token COMMA91=null;
		Token RPAREN93=null;
		ParserRuleReturnScope behavior_time90 =null;
		ParserRuleReturnScope behavior_time92 =null;

		BAST LITERAL_computation88_tree=null;
		BAST LPAREN89_tree=null;
		BAST COMMA91_tree=null;
		BAST RPAREN93_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2098:3: ( LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2099:3: LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_computation88=(Token)match(input,LITERAL_computation,FOLLOW_LITERAL_computation_in_computation_action6799); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_computation88_tree = (BAST)adaptor.create(LITERAL_computation88);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_computation88_tree, root_0);
			}

			LPAREN89=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_computation_action6806); if (state.failed) return retval;
			pushFollow(FOLLOW_behavior_time_in_computation_action6809);
			behavior_time90=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time90.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2101:25: ( COMMA ! behavior_time )?
			int alt62=2;
			int LA62_0 = input.LA(1);
			if ( (LA62_0==COMMA) ) {
				alt62=1;
			}
			switch (alt62) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2101:27: COMMA ! behavior_time
					{
					COMMA91=(Token)match(input,COMMA,FOLLOW_COMMA_in_computation_action6813); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_time_in_computation_action6816);
					behavior_time92=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time92.getTree());

					}
					break;

			}

			RPAREN93=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_computation_action6824); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "computation_action"


	public static class behavior_time_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_time"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2109:1: behavior_time : duration= expression u= time_unit -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u) ;
	public final BLESStoASTParser.behavior_time_return behavior_time() throws RecognitionException {
		BLESStoASTParser.behavior_time_return retval = new BLESStoASTParser.behavior_time_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope duration =null;
		ParserRuleReturnScope u =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_time_unit=new RewriteRuleSubtreeStream(adaptor,"rule time_unit");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2111:3: (duration= expression u= time_unit -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2112:3: duration= expression u= time_unit
			{
			pushFollow(FOLLOW_expression_in_behavior_time6855);
			duration=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(duration.getTree());
			pushFollow(FOLLOW_time_unit_in_behavior_time6860);
			u=time_unit();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_time_unit.add(u.getTree());
			// AST REWRITE
			// elements: u, duration
			// token labels: 
			// rule labels: duration, u, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_duration=new RewriteRuleSubtreeStream(adaptor,"rule duration",duration!=null?duration.getTree():null);
			RewriteRuleSubtreeStream stream_u=new RewriteRuleSubtreeStream(adaptor,"rule u",u!=null?u.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2113:5: -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2113:8: ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BEHAVIOR_TIME, "BEHAVIOR_TIME"), root_1);
				adaptor.addChild(root_1, stream_duration.nextTree());
				adaptor.addChild(root_1, stream_u.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(duration!=null?((BAST)duration.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_time"


	public static class time_unit_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_unit"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2118:1: time_unit : ( LITERAL_ps | LITERAL_ns | LITERAL_us | LITERAL_ms | LITERAL_sec | LITERAL_min | LITERAL_hr );
	public final BLESStoASTParser.time_unit_return time_unit() throws RecognitionException {
		BLESStoASTParser.time_unit_return retval = new BLESStoASTParser.time_unit_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set94=null;

		BAST set94_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2119:3: ( LITERAL_ps | LITERAL_ns | LITERAL_us | LITERAL_ms | LITERAL_sec | LITERAL_min | LITERAL_hr )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set94=input.LT(1);
			if ( input.LA(1)==LITERAL_hr||input.LA(1)==LITERAL_min||input.LA(1)==LITERAL_ms||input.LA(1)==LITERAL_ns||input.LA(1)==LITERAL_ps||input.LA(1)==LITERAL_sec||input.LA(1)==LITERAL_us ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set94));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_unit"


	public static class communication_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "communication_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2123:1: communication_action : (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause);
	public final BLESStoASTParser.communication_action_return communication_action() throws RecognitionException {
		BLESStoASTParser.communication_action_return retval = new BLESStoASTParser.communication_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token pause=null;
		ParserRuleReturnScope pc =null;
		ParserRuleReturnScope po =null;
		ParserRuleReturnScope pi =null;

		BAST pause_tree=null;
		RewriteRuleTokenStream stream_LITERAL_pause=new RewriteRuleTokenStream(adaptor,"token LITERAL_pause");
		RewriteRuleSubtreeStream stream_port_input=new RewriteRuleSubtreeStream(adaptor,"rule port_input");
		RewriteRuleSubtreeStream stream_port_output=new RewriteRuleSubtreeStream(adaptor,"rule port_output");
		RewriteRuleSubtreeStream stream_procedure_call=new RewriteRuleSubtreeStream(adaptor,"rule procedure_call");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2124:3: (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause)
			int alt63=4;
			alt63 = dfa63.predict(input);
			switch (alt63) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2125:3: pc= procedure_call
					{
					pushFollow(FOLLOW_procedure_call_in_communication_action6950);
					pc=procedure_call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_procedure_call.add(pc.getTree());
					// AST REWRITE
					// elements: pc
					// token labels: 
					// rule labels: pc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_pc=new RewriteRuleSubtreeStream(adaptor,"rule pc",pc!=null?pc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2126:5: -> $pc
					{
						adaptor.addChild(root_0, stream_pc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2128:3: po= port_output
					{
					pushFollow(FOLLOW_port_output_in_communication_action6968);
					po=port_output();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_output.add(po.getTree());
					// AST REWRITE
					// elements: po
					// token labels: 
					// rule labels: retval, po
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_po=new RewriteRuleSubtreeStream(adaptor,"rule po",po!=null?po.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2129:5: -> $po
					{
						adaptor.addChild(root_0, stream_po.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2131:3: pi= port_input
					{
					pushFollow(FOLLOW_port_input_in_communication_action6986);
					pi=port_input();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_input.add(pi.getTree());
					// AST REWRITE
					// elements: pi
					// token labels: 
					// rule labels: pi, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_pi=new RewriteRuleSubtreeStream(adaptor,"rule pi",pi!=null?pi.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2132:5: -> $pi
					{
						adaptor.addChild(root_0, stream_pi.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2134:3: pause= LITERAL_pause
					{
					pause=(Token)match(input,LITERAL_pause,FOLLOW_LITERAL_pause_in_communication_action7004); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_pause.add(pause);

					// AST REWRITE
					// elements: pause
					// token labels: pause
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_pause=new RewriteRuleTokenStream(adaptor,"token pause",pause);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2135:5: -> $pause
					{
						adaptor.addChild(root_0, stream_pause.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "communication_action"


	public static class procedure_call_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "procedure_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2138:1: procedure_call : p= identifier LPAREN (spb= formal_actual_list )? RPAREN -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? ) ;
	public final BLESStoASTParser.procedure_call_return procedure_call() throws RecognitionException {
		BLESStoASTParser.procedure_call_return retval = new BLESStoASTParser.procedure_call_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN95=null;
		Token RPAREN96=null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope spb =null;

		BAST LPAREN95_tree=null;
		BAST RPAREN96_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_formal_actual_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_actual_list");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2140:3: (p= identifier LPAREN (spb= formal_actual_list )? RPAREN -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2141:27: p= identifier LPAREN (spb= formal_actual_list )? RPAREN
			{
			pushFollow(FOLLOW_identifier_in_procedure_call7041);
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
			LPAREN95=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_procedure_call7045); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN95);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2141:61: (spb= formal_actual_list )?
			int alt64=2;
			int LA64_0 = input.LA(1);
			if ( (LA64_0==AADL_STRING_LITERAL||LA64_0==ID||LA64_0==INTEGER_LIT||LA64_0==LBRACKET||LA64_0==LITERAL_false||LA64_0==LITERAL_self||LA64_0==LITERAL_true||LA64_0==LPAREN||LA64_0==OCTOTHORPE||LA64_0==REAL_LIT) ) {
				alt64=1;
			}
			switch (alt64) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2141:61: spb= formal_actual_list
					{
					pushFollow(FOLLOW_formal_actual_list_in_procedure_call7049);
					spb=formal_actual_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_formal_actual_list.add(spb.getTree());
					}
					break;

			}

			RPAREN96=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_procedure_call7052); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN96);

			// AST REWRITE
			// elements: spb, p
			// token labels: 
			// rule labels: p, spb, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
			RewriteRuleSubtreeStream stream_spb=new RewriteRuleSubtreeStream(adaptor,"rule spb",spb!=null?spb.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2142:5: -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2142:8: ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PROCEDURE_CALL, (p!=null?((BAST)p.getTree()):null).getToken(), "PROCEDURE_CALL["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_p.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2144:18: ( $spb)?
				if ( stream_spb.hasNext() ) {
					adaptor.addChild(root_1, stream_spb.nextTree());
				}
				stream_spb.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(p!=null?((BAST)p.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  Dump.it("RecognitionException caught by BLESStoAST.procedure_call");
			  Dump.it("Did you forget \"formal:actual\" in your subprogram invocation, "+HelpfulHints.getIdiot()+"?");
			//    tellBNF(GrammarStrings.procedureCall,re,retval.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "procedure_call"


	public static class port_output_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_output"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2153:1: port_output : pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )? -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? ) ;
	public final BLESStoASTParser.port_output_return port_output() throws RecognitionException {
		BLESStoASTParser.port_output_return retval = new BLESStoASTParser.port_output_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token EXCLAMATION97=null;
		Token LPAREN98=null;
		Token RPAREN99=null;
		ParserRuleReturnScope pn =null;
		ParserRuleReturnScope be =null;

		BAST EXCLAMATION97_tree=null;
		BAST LPAREN98_tree=null;
		BAST RPAREN99_tree=null;
		RewriteRuleTokenStream stream_EXCLAMATION=new RewriteRuleTokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2155:3: (pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )? -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2156:5: pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )?
			{
			pushFollow(FOLLOW_port_name_in_port_output7109);
			pn=port_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_port_name.add(pn.getTree());
			EXCLAMATION97=(Token)match(input,EXCLAMATION,FOLLOW_EXCLAMATION_in_port_output7111); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EXCLAMATION.add(EXCLAMATION97);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2156:30: ( LPAREN be= expression_or_relation RPAREN )?
			int alt65=2;
			int LA65_0 = input.LA(1);
			if ( (LA65_0==LPAREN) ) {
				alt65=1;
			}
			switch (alt65) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2156:32: LPAREN be= expression_or_relation RPAREN
					{
					LPAREN98=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_output7115); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN98);

					pushFollow(FOLLOW_expression_or_relation_in_port_output7119);
					be=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
					RPAREN99=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_output7121); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN99);

					}
					break;

			}

			// AST REWRITE
			// elements: be, pn
			// token labels: 
			// rule labels: be, pn, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_pn=new RewriteRuleSubtreeStream(adaptor,"rule pn",pn!=null?pn.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2157:5: -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2157:8: ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PORT_OUTPUT, (pn!=null?((BAST)pn.getTree()):null).getToken(), "PORT_OUTPUT["+Integer.toString((pn!=null?((BAST)pn.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_pn.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2159:19: ( $be)?
				if ( stream_be.hasNext() ) {
					adaptor.addChild(root_1, stream_be.nextTree());
				}
				stream_be.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(pn!=null?((BAST)pn.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_output"


	public static class port_input_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_input"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2163:1: port_input : pn2= port_name QUESTION LPAREN n= name RPAREN -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n) ;
	public final BLESStoASTParser.port_input_return port_input() throws RecognitionException {
		BLESStoASTParser.port_input_return retval = new BLESStoASTParser.port_input_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token QUESTION100=null;
		Token LPAREN101=null;
		Token RPAREN102=null;
		ParserRuleReturnScope pn2 =null;
		ParserRuleReturnScope n =null;

		BAST QUESTION100_tree=null;
		BAST LPAREN101_tree=null;
		BAST RPAREN102_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2165:3: (pn2= port_name QUESTION LPAREN n= name RPAREN -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2166:5: pn2= port_name QUESTION LPAREN n= name RPAREN
			{
			pushFollow(FOLLOW_port_name_in_port_input7179);
			pn2=port_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_port_name.add(pn2.getTree());
			QUESTION100=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_port_input7181); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION100);

			LPAREN101=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_input7183); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN101);

			pushFollow(FOLLOW_name_in_port_input7188);
			n=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(n.getTree());
			RPAREN102=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_input7190); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN102);

			// AST REWRITE
			// elements: pn2, n
			// token labels: 
			// rule labels: pn2, n, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_pn2=new RewriteRuleSubtreeStream(adaptor,"rule pn2",pn2!=null?pn2.getTree():null);
			RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,"rule n",n!=null?n.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2167:6: -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2167:9: ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PORT_INPUT, (pn2!=null?((BAST)pn2.getTree()):null).getToken(), "PORT_INPUT["+Integer.toString((pn2!=null?((BAST)pn2.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_pn2.nextTree());
				adaptor.addChild(root_1, stream_n.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(pn2!=null?((BAST)pn2.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_input"


	public static class port_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2174:1: port_name : ( identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )? | identifier LBRACKET ^ INTEGER_LIT RBRACKET );
	public final BLESStoASTParser.port_name_return port_name() throws RecognitionException {
		BLESStoASTParser.port_name_return retval = new BLESStoASTParser.port_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token PERIOD104=null;
		Token PERIOD106=null;
		Token LBRACKET109=null;
		Token INTEGER_LIT110=null;
		Token RBRACKET111=null;
		ParserRuleReturnScope identifier103 =null;
		ParserRuleReturnScope identifier105 =null;
		ParserRuleReturnScope identifier107 =null;
		ParserRuleReturnScope identifier108 =null;

		BAST PERIOD104_tree=null;
		BAST PERIOD106_tree=null;
		BAST LBRACKET109_tree=null;
		BAST INTEGER_LIT110_tree=null;
		BAST RBRACKET111_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2175:3: ( identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )? | identifier LBRACKET ^ INTEGER_LIT RBRACKET )
			int alt68=2;
			int LA68_0 = input.LA(1);
			if ( (LA68_0==ID) ) {
				int LA68_1 = input.LA(2);
				if ( (LA68_1==EXCLAMATION||LA68_1==PERIOD||LA68_1==QUESTION||LA68_1==TICK) ) {
					alt68=1;
				}
				else if ( (LA68_1==LBRACKET) ) {
					alt68=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 68, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 68, 0, input);
				throw nvae;
			}

			switch (alt68) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2176:12: identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )?
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_port_name7233);
					identifier103=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier103.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2176:23: ( PERIOD ^ identifier ( PERIOD ! identifier )* )?
					int alt67=2;
					int LA67_0 = input.LA(1);
					if ( (LA67_0==PERIOD) ) {
						alt67=1;
					}
					switch (alt67) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2176:24: PERIOD ^ identifier ( PERIOD ! identifier )*
							{
							PERIOD104=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7236); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD104_tree = (BAST)adaptor.create(PERIOD104);
							root_0 = (BAST)adaptor.becomeRoot(PERIOD104_tree, root_0);
							}

							pushFollow(FOLLOW_identifier_in_port_name7239);
							identifier105=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier105.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2176:43: ( PERIOD ! identifier )*
							loop66:
							while (true) {
								int alt66=2;
								int LA66_0 = input.LA(1);
								if ( (LA66_0==PERIOD) ) {
									alt66=1;
								}

								switch (alt66) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2176:44: PERIOD ! identifier
									{
									PERIOD106=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7242); if (state.failed) return retval;
									pushFollow(FOLLOW_identifier_in_port_name7245);
									identifier107=identifier();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier107.getTree());

									}
									break;

								default :
									break loop66;
								}
							}

							}
							break;

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:12: identifier LBRACKET ^ INTEGER_LIT RBRACKET
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_port_name7259);
					identifier108=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier108.getTree());

					LBRACKET109=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_port_name7261); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LBRACKET109_tree = (BAST)adaptor.create(LBRACKET109);
					root_0 = (BAST)adaptor.becomeRoot(LBRACKET109_tree, root_0);
					}

					INTEGER_LIT110=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_port_name7265); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					INTEGER_LIT110_tree = (BAST)adaptor.create(INTEGER_LIT110);
					adaptor.addChild(root_0, INTEGER_LIT110_tree);
					}

					RBRACKET111=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_port_name7267); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RBRACKET111_tree = (BAST)adaptor.create(RBRACKET111);
					adaptor.addChild(root_0, RBRACKET111_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_name"


	public static class formal_actual_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_actual_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2181:1: formal_actual_list : fa= formal_actual (c= COMMA fa2+= formal_actual )* -> {c!=null}? ^( $c $fa ( $fa2)+ ) -> $fa;
	public final BLESStoASTParser.formal_actual_list_return formal_actual_list() throws RecognitionException {
		BLESStoASTParser.formal_actual_list_return retval = new BLESStoASTParser.formal_actual_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		List<Object> list_fa2=null;
		ParserRuleReturnScope fa =null;
		RuleReturnScope fa2 = null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal_actual=new RewriteRuleSubtreeStream(adaptor,"rule formal_actual");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2182:3: (fa= formal_actual (c= COMMA fa2+= formal_actual )* -> {c!=null}? ^( $c $fa ( $fa2)+ ) -> $fa)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2183:3: fa= formal_actual (c= COMMA fa2+= formal_actual )*
			{
			pushFollow(FOLLOW_formal_actual_in_formal_actual_list7286);
			fa=formal_actual();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_formal_actual.add(fa.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2183:20: (c= COMMA fa2+= formal_actual )*
			loop69:
			while (true) {
				int alt69=2;
				int LA69_0 = input.LA(1);
				if ( (LA69_0==COMMA) ) {
					alt69=1;
				}

				switch (alt69) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2183:22: c= COMMA fa2+= formal_actual
					{
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_actual_list7292); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_formal_actual_in_formal_actual_list7296);
					fa2=formal_actual();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_formal_actual.add(fa2.getTree());
					if (list_fa2==null) list_fa2=new ArrayList<Object>();
					list_fa2.add(fa2.getTree());
					}
					break;

				default :
					break loop69;
				}
			}

			// AST REWRITE
			// elements: fa, fa2, fa, c
			// token labels: c
			// rule labels: fa, retval
			// token list labels: 
			// rule list labels: fa2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_fa=new RewriteRuleSubtreeStream(adaptor,"rule fa",fa!=null?fa.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_fa2=new RewriteRuleSubtreeStream(adaptor,"token fa2",list_fa2);
			root_0 = (BAST)adaptor.nil();
			// 2184:5: -> {c!=null}? ^( $c $fa ( $fa2)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2184:19: ^( $c $fa ( $fa2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_fa.nextTree());
				if ( !(stream_fa2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_fa2.hasNext() ) {
					adaptor.addChild(root_1, stream_fa2.nextTree());
				}
				stream_fa2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2185:5: -> $fa
			{
				adaptor.addChild(root_0, stream_fa.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual_list"


	public static class formal_actual_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_actual"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2188:1: formal_actual : ( identifier COLON ^)? actual_parameter ;
	public final BLESStoASTParser.formal_actual_return formal_actual() throws RecognitionException {
		BLESStoASTParser.formal_actual_return retval = new BLESStoASTParser.formal_actual_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COLON113=null;
		ParserRuleReturnScope identifier112 =null;
		ParserRuleReturnScope actual_parameter114 =null;

		BAST COLON113_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2189:3: ( ( identifier COLON ^)? actual_parameter )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2190:3: ( identifier COLON ^)? actual_parameter
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2190:3: ( identifier COLON ^)?
			int alt70=2;
			int LA70_0 = input.LA(1);
			if ( (LA70_0==ID) ) {
				int LA70_1 = input.LA(2);
				if ( (LA70_1==COLON) ) {
					alt70=1;
				}
			}
			switch (alt70) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2190:26: identifier COLON ^
					{
					pushFollow(FOLLOW_identifier_in_formal_actual7351);
					identifier112=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier112.getTree());

					COLON113=(Token)match(input,COLON,FOLLOW_COLON_in_formal_actual7353); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COLON113_tree = (BAST)adaptor.create(COLON113);
					root_0 = (BAST)adaptor.becomeRoot(COLON113_tree, root_0);
					}

					}
					break;

			}

			pushFollow(FOLLOW_actual_parameter_in_formal_actual7359);
			actual_parameter114=actual_parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, actual_parameter114.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual"


	public static class actual_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "actual_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2193:1: actual_parameter : ( name | value_constant | parenthesized_subexpression );
	public final BLESStoASTParser.actual_parameter_return actual_parameter() throws RecognitionException {
		BLESStoASTParser.actual_parameter_return retval = new BLESStoASTParser.actual_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope name115 =null;
		ParserRuleReturnScope value_constant116 =null;
		ParserRuleReturnScope parenthesized_subexpression117 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2194:3: ( name | value_constant | parenthesized_subexpression )
			int alt71=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				switch ( input.LA(2) ) {
				case COMMA:
				case LBRACKET:
				case RPAREN:
					{
					alt71=1;
					}
					break;
				case PERIOD:
					{
					int LA71_5 = input.LA(3);
					if ( (LA71_5==ID) ) {
						int LA71_6 = input.LA(4);
						if ( (LA71_6==COMMA||LA71_6==LBRACKET||LA71_6==PERIOD||LA71_6==RPAREN) ) {
							alt71=1;
						}
						else if ( (LA71_6==OCTOTHORPE) ) {
							alt71=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 71, 6, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 71, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

					}
					break;
				case DOUBLE_COLON:
				case OCTOTHORPE:
				case TICK:
					{
					alt71=2;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 71, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
				}
				break;
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_self:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt71=2;
				}
				break;
			case LPAREN:
				{
				alt71=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 71, 0, input);
				throw nvae;
			}
			switch (alt71) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2195:17: name
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_name_in_actual_parameter7378);
					name115=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, name115.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2196:6: value_constant
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_value_constant_in_actual_parameter7386);
					value_constant116=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, value_constant116.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2197:6: parenthesized_subexpression
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_parenthesized_subexpression_in_actual_parameter7394);
					parenthesized_subexpression117=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_subexpression117.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_parameter"


	public static class existential_lattice_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "existential_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2200:1: existential_lattice_quantification : ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )? ;
	public final BLESStoASTParser.existential_lattice_quantification_return existential_lattice_quantification() throws RecognitionException {
		BLESStoASTParser.existential_lattice_quantification_return retval = new BLESStoASTParser.existential_lattice_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LCURLY119=null;
		Token RCURLY121=null;
		ParserRuleReturnScope quantified_variables118 =null;
		ParserRuleReturnScope behavior_actions120 =null;
		ParserRuleReturnScope timeout_clause122 =null;
		ParserRuleReturnScope catch_clause123 =null;

		BAST LCURLY119_tree=null;
		BAST RCURLY121_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2201:3: ( ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2202:3: ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2202:3: ( quantified_variables )?
			int alt72=2;
			int LA72_0 = input.LA(1);
			if ( (LA72_0==LITERAL_declare) ) {
				alt72=1;
			}
			switch (alt72) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2202:3: quantified_variables
					{
					pushFollow(FOLLOW_quantified_variables_in_existential_lattice_quantification7420);
					quantified_variables118=quantified_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, quantified_variables118.getTree());

					}
					break;

			}

			LCURLY119=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_existential_lattice_quantification7425); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LCURLY119_tree = (BAST)adaptor.create(LCURLY119);
			root_0 = (BAST)adaptor.becomeRoot(LCURLY119_tree, root_0);
			}

			pushFollow(FOLLOW_behavior_actions_in_existential_lattice_quantification7429);
			behavior_actions120=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_actions120.getTree());

			RCURLY121=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_existential_lattice_quantification7431); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RCURLY121_tree = (BAST)adaptor.create(RCURLY121);
			adaptor.addChild(root_0, RCURLY121_tree);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2204:3: ( timeout_clause )?
			int alt73=2;
			int LA73_0 = input.LA(1);
			if ( (LA73_0==LITERAL_timeout) ) {
				alt73=1;
			}
			switch (alt73) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2204:3: timeout_clause
					{
					pushFollow(FOLLOW_timeout_clause_in_existential_lattice_quantification7437);
					timeout_clause122=timeout_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, timeout_clause122.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2205:3: ( catch_clause )?
			int alt74=2;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==LITERAL_catch) ) {
				alt74=1;
			}
			switch (alt74) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2205:3: catch_clause
					{
					pushFollow(FOLLOW_catch_clause_in_existential_lattice_quantification7442);
					catch_clause123=catch_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clause123.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.elq,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_lattice_quantification"


	public static class catch_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "catch_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2210:1: catch_clause : LITERAL_catch ^ ( catch_clause_term )+ ;
	public final BLESStoASTParser.catch_clause_return catch_clause() throws RecognitionException {
		BLESStoASTParser.catch_clause_return retval = new BLESStoASTParser.catch_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_catch124=null;
		ParserRuleReturnScope catch_clause_term125 =null;

		BAST LITERAL_catch124_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2211:3: ( LITERAL_catch ^ ( catch_clause_term )+ )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2212:3: LITERAL_catch ^ ( catch_clause_term )+
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_catch124=(Token)match(input,LITERAL_catch,FOLLOW_LITERAL_catch_in_catch_clause7466); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_catch124_tree = (BAST)adaptor.create(LITERAL_catch124);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_catch124_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2212:18: ( catch_clause_term )+
			int cnt75=0;
			loop75:
			while (true) {
				int alt75=2;
				int LA75_0 = input.LA(1);
				if ( (LA75_0==LPAREN) ) {
					alt75=1;
				}

				switch (alt75) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2212:18: catch_clause_term
					{
					pushFollow(FOLLOW_catch_clause_term_in_catch_clause7469);
					catch_clause_term125=catch_clause_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clause_term125.getTree());

					}
					break;

				default :
					if ( cnt75 >= 1 ) break loop75;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(75, input);
					throw eee;
				}
				cnt75++;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause"


	public static class timeout_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timeout_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2215:1: timeout_clause : LITERAL_timeout ^ behavior_time ;
	public final BLESStoASTParser.timeout_clause_return timeout_clause() throws RecognitionException {
		BLESStoASTParser.timeout_clause_return retval = new BLESStoASTParser.timeout_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_timeout126=null;
		ParserRuleReturnScope behavior_time127 =null;

		BAST LITERAL_timeout126_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2216:3: ( LITERAL_timeout ^ behavior_time )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2217:3: LITERAL_timeout ^ behavior_time
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_timeout126=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_timeout_clause7485); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_timeout126_tree = (BAST)adaptor.create(LITERAL_timeout126);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout126_tree, root_0);
			}

			pushFollow(FOLLOW_behavior_time_in_timeout_clause7488);
			behavior_time127=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time127.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timeout_clause"


	public static class catch_clause_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "catch_clause_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2220:1: catch_clause_term : LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN -> {a!=null}? ^( $c $a $ba) -> ^( $c ( $ei)+ $ba) ;
	public final BLESStoASTParser.catch_clause_term_return catch_clause_term() throws RecognitionException {
		BLESStoASTParser.catch_clause_term_return retval = new BLESStoASTParser.catch_clause_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		Token c=null;
		Token LPAREN128=null;
		Token RPAREN129=null;
		List<Object> list_ei=null;
		ParserRuleReturnScope ba =null;
		RuleReturnScope ei = null;
		BAST a_tree=null;
		BAST c_tree=null;
		BAST LPAREN128_tree=null;
		BAST RPAREN129_tree=null;
		RewriteRuleTokenStream stream_LITERAL_all=new RewriteRuleTokenStream(adaptor,"token LITERAL_all");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_basic_action=new RewriteRuleSubtreeStream(adaptor,"rule basic_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2221:3: ( LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN -> {a!=null}? ^( $c $a $ba) -> ^( $c ( $ei)+ $ba) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:3: LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN
			{
			LPAREN128=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_catch_clause_term7509); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN128);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:10: ( (ei+= identifier )+ |a= LITERAL_all )
			int alt77=2;
			int LA77_0 = input.LA(1);
			if ( (LA77_0==ID) ) {
				alt77=1;
			}
			else if ( (LA77_0==LITERAL_all) ) {
				alt77=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 77, 0, input);
				throw nvae;
			}

			switch (alt77) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:12: (ei+= identifier )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:14: (ei+= identifier )+
					int cnt76=0;
					loop76:
					while (true) {
						int alt76=2;
						int LA76_0 = input.LA(1);
						if ( (LA76_0==ID) ) {
							alt76=1;
						}

						switch (alt76) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:14: ei+= identifier
							{
							pushFollow(FOLLOW_identifier_in_catch_clause_term7516);
							ei=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ei.getTree());
							if (list_ei==null) list_ei=new ArrayList<Object>();
							list_ei.add(ei.getTree());
							}
							break;

						default :
							if ( cnt76 >= 1 ) break loop76;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(76, input);
							throw eee;
						}
						cnt76++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:44: a= LITERAL_all
					{
					a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_catch_clause_term7523); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_all.add(a);

					}
					break;

			}

			c=(Token)match(input,COLON,FOLLOW_COLON_in_catch_clause_term7529); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			pushFollow(FOLLOW_basic_action_in_catch_clause_term7533);
			ba=basic_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_basic_action.add(ba.getTree());
			RPAREN129=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_catch_clause_term7535); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN129);

			// AST REWRITE
			// elements: c, ei, ba, a, ba, c
			// token labels: a, c
			// rule labels: retval, ba
			// token list labels: 
			// rule list labels: ei
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ba=new RewriteRuleSubtreeStream(adaptor,"rule ba",ba!=null?ba.getTree():null);
			RewriteRuleSubtreeStream stream_ei=new RewriteRuleSubtreeStream(adaptor,"token ei",list_ei);
			root_0 = (BAST)adaptor.nil();
			// 2223:5: -> {a!=null}? ^( $c $a $ba)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2223:19: ^( $c $a $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a.nextNode());
				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2224:5: -> ^( $c ( $ei)+ $ba)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:8: ^( $c ( $ei)+ $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				if ( !(stream_ei.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ei.hasNext() ) {
					adaptor.addChild(root_1, stream_ei.nextTree());
				}
				stream_ei.reset();

				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause_term"


	public static class when_throw_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "when_throw"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2227:1: when_throw : LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier ;
	public final BLESStoASTParser.when_throw_return when_throw() throws RecognitionException {
		BLESStoASTParser.when_throw_return retval = new BLESStoASTParser.when_throw_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_when130=null;
		Token LPAREN131=null;
		Token RPAREN133=null;
		Token LITERAL_throw134=null;
		ParserRuleReturnScope expression132 =null;
		ParserRuleReturnScope identifier135 =null;

		BAST LITERAL_when130_tree=null;
		BAST LPAREN131_tree=null;
		BAST RPAREN133_tree=null;
		BAST LITERAL_throw134_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2228:3: ( LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2229:3: LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_when130=(Token)match(input,LITERAL_when,FOLLOW_LITERAL_when_in_when_throw7591); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_when130_tree = (BAST)adaptor.create(LITERAL_when130);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_when130_tree, root_0);
			}

			LPAREN131=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_when_throw7594); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_when_throw7598);
			expression132=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression132.getTree());

			RPAREN133=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_when_throw7600); if (state.failed) return retval;
			LITERAL_throw134=(Token)match(input,LITERAL_throw,FOLLOW_LITERAL_throw_in_when_throw7603); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_throw134_tree = (BAST)adaptor.create(LITERAL_throw134);
			adaptor.addChild(root_0, LITERAL_throw134_tree);
			}

			pushFollow(FOLLOW_identifier_in_when_throw7606);
			identifier135=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier135.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "when_throw"


	public static class combinable_operation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "combinable_operation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2232:1: combinable_operation : ( LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !);
	public final BLESStoASTParser.combinable_operation_return combinable_operation() throws RecognitionException {
		BLESStoASTParser.combinable_operation_return retval = new BLESStoASTParser.combinable_operation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_fetchadd136=null;
		Token LPAREN137=null;
		Token COMMA139=null;
		Token COMMA141=null;
		Token RPAREN143=null;
		Token LITERAL_fetchor144=null;
		Token LPAREN145=null;
		Token COMMA147=null;
		Token COMMA149=null;
		Token RPAREN151=null;
		Token LITERAL_fetchand152=null;
		Token LPAREN153=null;
		Token COMMA155=null;
		Token COMMA157=null;
		Token RPAREN159=null;
		Token LITERAL_fetchxor160=null;
		Token LPAREN161=null;
		Token COMMA163=null;
		Token COMMA165=null;
		Token RPAREN167=null;
		Token LITERAL_swap168=null;
		Token LPAREN169=null;
		Token COMMA171=null;
		Token COMMA173=null;
		Token RPAREN175=null;
		ParserRuleReturnScope variable_name138 =null;
		ParserRuleReturnScope expression140 =null;
		ParserRuleReturnScope identifier142 =null;
		ParserRuleReturnScope variable_name146 =null;
		ParserRuleReturnScope expression148 =null;
		ParserRuleReturnScope identifier150 =null;
		ParserRuleReturnScope variable_name154 =null;
		ParserRuleReturnScope expression156 =null;
		ParserRuleReturnScope identifier158 =null;
		ParserRuleReturnScope variable_name162 =null;
		ParserRuleReturnScope expression164 =null;
		ParserRuleReturnScope identifier166 =null;
		ParserRuleReturnScope variable_name170 =null;
		ParserRuleReturnScope variable_name172 =null;
		ParserRuleReturnScope identifier174 =null;

		BAST LITERAL_fetchadd136_tree=null;
		BAST LPAREN137_tree=null;
		BAST COMMA139_tree=null;
		BAST COMMA141_tree=null;
		BAST RPAREN143_tree=null;
		BAST LITERAL_fetchor144_tree=null;
		BAST LPAREN145_tree=null;
		BAST COMMA147_tree=null;
		BAST COMMA149_tree=null;
		BAST RPAREN151_tree=null;
		BAST LITERAL_fetchand152_tree=null;
		BAST LPAREN153_tree=null;
		BAST COMMA155_tree=null;
		BAST COMMA157_tree=null;
		BAST RPAREN159_tree=null;
		BAST LITERAL_fetchxor160_tree=null;
		BAST LPAREN161_tree=null;
		BAST COMMA163_tree=null;
		BAST COMMA165_tree=null;
		BAST RPAREN167_tree=null;
		BAST LITERAL_swap168_tree=null;
		BAST LPAREN169_tree=null;
		BAST COMMA171_tree=null;
		BAST COMMA173_tree=null;
		BAST RPAREN175_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2233:3: ( LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !)
			int alt83=5;
			switch ( input.LA(1) ) {
			case LITERAL_fetchadd:
				{
				alt83=1;
				}
				break;
			case LITERAL_fetchor:
				{
				alt83=2;
				}
				break;
			case LITERAL_fetchand:
				{
				alt83=3;
				}
				break;
			case LITERAL_fetchxor:
				{
				alt83=4;
				}
				break;
			case LITERAL_swap:
				{
				alt83=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 83, 0, input);
				throw nvae;
			}
			switch (alt83) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2234:3: LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchadd136=(Token)match(input,LITERAL_fetchadd,FOLLOW_LITERAL_fetchadd_in_combinable_operation7621); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchadd136_tree = (BAST)adaptor.create(LITERAL_fetchadd136);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchadd136_tree, root_0);
					}

					LPAREN137=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7624); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7628);
					variable_name138=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name138.getTree());

					COMMA139=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7630); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7641);
					expression140=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression140.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2235:32: ( COMMA ! identifier )?
					int alt78=2;
					int LA78_0 = input.LA(1);
					if ( (LA78_0==COMMA) ) {
						alt78=1;
					}
					switch (alt78) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2235:34: COMMA ! identifier
							{
							COMMA141=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7645); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7649);
							identifier142=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier142.getTree());

							}
							break;

					}

					RPAREN143=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7654); if (state.failed) return retval;
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2237:3: LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchor144=(Token)match(input,LITERAL_fetchor,FOLLOW_LITERAL_fetchor_in_combinable_operation7663); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchor144_tree = (BAST)adaptor.create(LITERAL_fetchor144);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchor144_tree, root_0);
					}

					LPAREN145=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7666); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7670);
					variable_name146=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name146.getTree());

					COMMA147=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7672); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7683);
					expression148=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression148.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2238:30: ( COMMA ! identifier )?
					int alt79=2;
					int LA79_0 = input.LA(1);
					if ( (LA79_0==COMMA) ) {
						alt79=1;
					}
					switch (alt79) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2238:32: COMMA ! identifier
							{
							COMMA149=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7687); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7691);
							identifier150=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier150.getTree());

							}
							break;

					}

					RPAREN151=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7696); if (state.failed) return retval;
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2240:3: LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchand152=(Token)match(input,LITERAL_fetchand,FOLLOW_LITERAL_fetchand_in_combinable_operation7705); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchand152_tree = (BAST)adaptor.create(LITERAL_fetchand152);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchand152_tree, root_0);
					}

					LPAREN153=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7708); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7712);
					variable_name154=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name154.getTree());

					COMMA155=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7714); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7725);
					expression156=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression156.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2241:30: ( COMMA ! identifier )?
					int alt80=2;
					int LA80_0 = input.LA(1);
					if ( (LA80_0==COMMA) ) {
						alt80=1;
					}
					switch (alt80) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2241:32: COMMA ! identifier
							{
							COMMA157=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7729); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7733);
							identifier158=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier158.getTree());

							}
							break;

					}

					RPAREN159=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7738); if (state.failed) return retval;
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2243:3: LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchxor160=(Token)match(input,LITERAL_fetchxor,FOLLOW_LITERAL_fetchxor_in_combinable_operation7747); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchxor160_tree = (BAST)adaptor.create(LITERAL_fetchxor160);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchxor160_tree, root_0);
					}

					LPAREN161=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7750); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7754);
					variable_name162=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name162.getTree());

					COMMA163=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7756); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7767);
					expression164=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression164.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2244:30: ( COMMA ! identifier )?
					int alt81=2;
					int LA81_0 = input.LA(1);
					if ( (LA81_0==COMMA) ) {
						alt81=1;
					}
					switch (alt81) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2244:32: COMMA ! identifier
							{
							COMMA165=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7771); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7775);
							identifier166=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier166.getTree());

							}
							break;

					}

					RPAREN167=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7780); if (state.failed) return retval;
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2246:3: LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_swap168=(Token)match(input,LITERAL_swap,FOLLOW_LITERAL_swap_in_combinable_operation7789); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_swap168_tree = (BAST)adaptor.create(LITERAL_swap168);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_swap168_tree, root_0);
					}

					LPAREN169=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7793); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7797);
					variable_name170=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name170.getTree());

					COMMA171=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7799); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7810);
					variable_name172=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name172.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2247:35: ( COMMA ! identifier )?
					int alt82=2;
					int LA82_0 = input.LA(1);
					if ( (LA82_0==COMMA) ) {
						alt82=1;
					}
					switch (alt82) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2247:37: COMMA ! identifier
							{
							COMMA173=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7814); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7818);
							identifier174=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier174.getTree());

							}
							break;

					}

					RPAREN175=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7823); if (state.failed) return retval;
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "combinable_operation"


	public static class behavior_actions_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_actions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2250:1: behavior_actions : aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )? -> {c!=null}? ^( $c $aa ( $as)+ ) -> {amp!=null}? ^( $amp $aa ( $ac)+ ) -> $aa;
	public final BLESStoASTParser.behavior_actions_return behavior_actions() throws RecognitionException {
		BLESStoASTParser.behavior_actions_return retval = new BLESStoASTParser.behavior_actions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token amp=null;
		Token SEMICOLON176=null;
		Token AMPERSAND177=null;
		List<Object> list_as=null;
		List<Object> list_ac=null;
		ParserRuleReturnScope aa =null;
		RuleReturnScope as = null;
		RuleReturnScope ac = null;
		BAST c_tree=null;
		BAST amp_tree=null;
		BAST SEMICOLON176_tree=null;
		BAST AMPERSAND177_tree=null;
		RewriteRuleTokenStream stream_AMPERSAND=new RewriteRuleTokenStream(adaptor,"token AMPERSAND");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_asserted_action=new RewriteRuleSubtreeStream(adaptor,"rule asserted_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2251:3: (aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )? -> {c!=null}? ^( $c $aa ( $as)+ ) -> {amp!=null}? ^( $amp $aa ( $ac)+ ) -> $aa)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2252:3: aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )?
			{
			pushFollow(FOLLOW_asserted_action_in_behavior_actions7846);
			aa=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_asserted_action.add(aa.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2253:5: ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )?
			int alt86=3;
			int LA86_0 = input.LA(1);
			if ( (LA86_0==SEMICOLON) ) {
				alt86=1;
			}
			else if ( (LA86_0==AMPERSAND) ) {
				alt86=2;
			}
			switch (alt86) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:5: (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:5: (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:7: c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )*
					{
					c=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7862); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SEMICOLON.add(c);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7866);
					as=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asserted_action.add(as.getTree());
					if (list_as==null) list_as=new ArrayList<Object>();
					list_as.add(as.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:39: ( SEMICOLON as+= asserted_action )*
					loop84:
					while (true) {
						int alt84=2;
						int LA84_0 = input.LA(1);
						if ( (LA84_0==SEMICOLON) ) {
							alt84=1;
						}

						switch (alt84) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:41: SEMICOLON as+= asserted_action
							{
							SEMICOLON176=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7870); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON176);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7874);
							as=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_asserted_action.add(as.getTree());
							if (list_as==null) list_as=new ArrayList<Object>();
							list_as.add(as.getTree());
							}
							break;

						default :
							break loop84;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:5: (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:5: (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:7: amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )*
					{
					amp=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7895); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AMPERSAND.add(amp);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7899);
					ac=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asserted_action.add(ac.getTree());
					if (list_ac==null) list_ac=new ArrayList<Object>();
					list_ac.add(ac.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:41: ( AMPERSAND ac+= asserted_action )*
					loop85:
					while (true) {
						int alt85=2;
						int LA85_0 = input.LA(1);
						if ( (LA85_0==AMPERSAND) ) {
							alt85=1;
						}

						switch (alt85) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:43: AMPERSAND ac+= asserted_action
							{
							AMPERSAND177=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7903); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_AMPERSAND.add(AMPERSAND177);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7907);
							ac=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_asserted_action.add(ac.getTree());
							if (list_ac==null) list_ac=new ArrayList<Object>();
							list_ac.add(ac.getTree());
							}
							break;

						default :
							break loop85;
						}
					}

					}

					}
					break;

			}

			// AST REWRITE
			// elements: ac, aa, aa, c, amp, as, aa
			// token labels: c, amp
			// rule labels: aa, retval
			// token list labels: 
			// rule list labels: ac, as
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_amp=new RewriteRuleTokenStream(adaptor,"token amp",amp);
			RewriteRuleSubtreeStream stream_aa=new RewriteRuleSubtreeStream(adaptor,"rule aa",aa!=null?aa.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"token ac",list_ac);
			RewriteRuleSubtreeStream stream_as=new RewriteRuleSubtreeStream(adaptor,"token as",list_as);
			root_0 = (BAST)adaptor.nil();
			// 2258:5: -> {c!=null}? ^( $c $aa ( $as)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:19: ^( $c $aa ( $as)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aa.nextTree());
				if ( !(stream_as.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_as.hasNext() ) {
					adaptor.addChild(root_1, stream_as.nextTree());
				}
				stream_as.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2259:5: -> {amp!=null}? ^( $amp $aa ( $ac)+ )
			if (amp!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2259:21: ^( $amp $aa ( $ac)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_amp.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aa.nextTree());
				if ( !(stream_ac.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2260:5: -> $aa
			{
				adaptor.addChild(root_0, stream_aa.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.behaviorActions,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_actions"


	public static class name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2269:1: name : pn1= partial_name (d= PERIOD pn2+= partial_name )* -> {d!=null}? ^( $d $pn1 ( $pn2)+ ) -> $pn1;
	public final BLESStoASTParser.name_return name() throws RecognitionException {
		BLESStoASTParser.name_return retval = new BLESStoASTParser.name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token d=null;
		List<Object> list_pn2=null;
		ParserRuleReturnScope pn1 =null;
		RuleReturnScope pn2 = null;
		BAST d_tree=null;
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleSubtreeStream stream_partial_name=new RewriteRuleSubtreeStream(adaptor,"rule partial_name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2270:3: (pn1= partial_name (d= PERIOD pn2+= partial_name )* -> {d!=null}? ^( $d $pn1 ( $pn2)+ ) -> $pn1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2270:5: pn1= partial_name (d= PERIOD pn2+= partial_name )*
			{
			pushFollow(FOLLOW_partial_name_in_name8002);
			pn1=partial_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_partial_name.add(pn1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2270:22: (d= PERIOD pn2+= partial_name )*
			loop87:
			while (true) {
				int alt87=2;
				int LA87_0 = input.LA(1);
				if ( (LA87_0==PERIOD) ) {
					alt87=1;
				}

				switch (alt87) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2270:24: d= PERIOD pn2+= partial_name
					{
					d=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_name8008); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERIOD.add(d);

					pushFollow(FOLLOW_partial_name_in_name8012);
					pn2=partial_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_partial_name.add(pn2.getTree());
					if (list_pn2==null) list_pn2=new ArrayList<Object>();
					list_pn2.add(pn2.getTree());
					}
					break;

				default :
					break loop87;
				}
			}

			// AST REWRITE
			// elements: pn1, pn2, pn1, d
			// token labels: d
			// rule labels: pn1, retval
			// token list labels: 
			// rule list labels: pn2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
			RewriteRuleSubtreeStream stream_pn1=new RewriteRuleSubtreeStream(adaptor,"rule pn1",pn1!=null?pn1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_pn2=new RewriteRuleSubtreeStream(adaptor,"token pn2",list_pn2);
			root_0 = (BAST)adaptor.nil();
			// 2272:5: -> {d!=null}? ^( $d $pn1 ( $pn2)+ )
			if (d!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2272:19: ^( $d $pn1 ( $pn2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_d.nextNode(), root_1);
				adaptor.addChild(root_1, stream_pn1.nextTree());
				if ( !(stream_pn2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_pn2.hasNext() ) {
					adaptor.addChild(root_1, stream_pn2.nextTree());
				}
				stream_pn2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2273:5: -> $pn1
			{
				adaptor.addChild(root_0, stream_pn1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.name,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name"


	public static class partial_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "partial_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2278:1: partial_name : identifier ( LBRACKET index+= expression_or_range RBRACKET )* -> {index!=null}? ^( identifier ( $index)+ ) -> identifier ;
	public final BLESStoASTParser.partial_name_return partial_name() throws RecognitionException {
		BLESStoASTParser.partial_name_return retval = new BLESStoASTParser.partial_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET179=null;
		Token RBRACKET180=null;
		List<Object> list_index=null;
		ParserRuleReturnScope identifier178 =null;
		RuleReturnScope index = null;
		BAST LBRACKET179_tree=null;
		BAST RBRACKET180_tree=null;
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_expression_or_range=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2279:3: ( identifier ( LBRACKET index+= expression_or_range RBRACKET )* -> {index!=null}? ^( identifier ( $index)+ ) -> identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2280:3: identifier ( LBRACKET index+= expression_or_range RBRACKET )*
			{
			pushFollow(FOLLOW_identifier_in_partial_name8079);
			identifier178=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(identifier178.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2281:3: ( LBRACKET index+= expression_or_range RBRACKET )*
			loop88:
			while (true) {
				int alt88=2;
				int LA88_0 = input.LA(1);
				if ( (LA88_0==LBRACKET) ) {
					alt88=1;
				}

				switch (alt88) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2281:5: LBRACKET index+= expression_or_range RBRACKET
					{
					LBRACKET179=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_partial_name8088); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET179);

					pushFollow(FOLLOW_expression_or_range_in_partial_name8092);
					index=expression_or_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_range.add(index.getTree());
					if (list_index==null) list_index=new ArrayList<Object>();
					list_index.add(index.getTree());
					RBRACKET180=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_partial_name8094); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET180);

					}
					break;

				default :
					break loop88;
				}
			}

			// AST REWRITE
			// elements: index, identifier, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: index
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"token index",list_index);
			root_0 = (BAST)adaptor.nil();
			// 2282:3: -> {index!=null}? ^( identifier ( $index)+ )
			if (index!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2282:21: ^( identifier ( $index)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_identifier.nextNode(), root_1);
				if ( !(stream_index.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_index.hasNext() ) {
					adaptor.addChild(root_1, stream_index.nextTree());
				}
				stream_index.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2283:3: -> identifier
			{
				adaptor.addChild(root_0, stream_identifier.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "partial_name"


	public static class parameter_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2286:1: parameter_list : e1= expression_or_range (c= COMMA e2+= expression_or_range )* -> {c!=null}? ^( $c $e1 ( $e2)+ ) -> $e1;
	public final BLESStoASTParser.parameter_list_return parameter_list() throws RecognitionException {
		BLESStoASTParser.parameter_list_return retval = new BLESStoASTParser.parameter_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		List<Object> list_e2=null;
		ParserRuleReturnScope e1 =null;
		RuleReturnScope e2 = null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression_or_range=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2287:3: (e1= expression_or_range (c= COMMA e2+= expression_or_range )* -> {c!=null}? ^( $c $e1 ( $e2)+ ) -> $e1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2288:3: e1= expression_or_range (c= COMMA e2+= expression_or_range )*
			{
			pushFollow(FOLLOW_expression_or_range_in_parameter_list8143);
			e1=expression_or_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_range.add(e1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2289:3: (c= COMMA e2+= expression_or_range )*
			loop89:
			while (true) {
				int alt89=2;
				int LA89_0 = input.LA(1);
				if ( (LA89_0==COMMA) ) {
					alt89=1;
				}

				switch (alt89) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2289:5: c= COMMA e2+= expression_or_range
					{
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_parameter_list8152); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_expression_or_range_in_parameter_list8156);
					e2=expression_or_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_range.add(e2.getTree());
					if (list_e2==null) list_e2=new ArrayList<Object>();
					list_e2.add(e2.getTree());
					}
					break;

				default :
					break loop89;
				}
			}

			// AST REWRITE
			// elements: e2, c, e1, e1
			// token labels: c
			// rule labels: e1, retval
			// token list labels: 
			// rule list labels: e2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"token e2",list_e2);
			root_0 = (BAST)adaptor.nil();
			// 2290:5: -> {c!=null}? ^( $c $e1 ( $e2)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2290:19: ^( $c $e1 ( $e2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_e1.nextTree());
				if ( !(stream_e2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_e2.hasNext() ) {
					adaptor.addChild(root_1, stream_e2.nextTree());
				}
				stream_e2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2291:5: -> $e1
			{
				adaptor.addChild(root_0, stream_e1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.parameterList,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameter_list"


	public static class expression_or_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2296:1: expression_or_range : expression ( range_symbol ^ expression )? ;
	public final BLESStoASTParser.expression_or_range_return expression_or_range() throws RecognitionException {
		BLESStoASTParser.expression_or_range_return retval = new BLESStoASTParser.expression_or_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope expression181 =null;
		ParserRuleReturnScope range_symbol182 =null;
		ParserRuleReturnScope expression183 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2297:3: ( expression ( range_symbol ^ expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2298:3: expression ( range_symbol ^ expression )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_expression_in_expression_or_range8218);
			expression181=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression181.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2298:14: ( range_symbol ^ expression )?
			int alt90=2;
			int LA90_0 = input.LA(1);
			if ( ((LA90_0 >= COMMACOMMA && LA90_0 <= COMMADOT)||(LA90_0 >= DOTCOMMA && LA90_0 <= DOTDOT)) ) {
				alt90=1;
			}
			switch (alt90) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2298:16: range_symbol ^ expression
					{
					pushFollow(FOLLOW_range_symbol_in_expression_or_range8222);
					range_symbol182=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol182.getTree(), root_0);
					pushFollow(FOLLOW_expression_in_expression_or_range8225);
					expression183=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression183.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expressionOrRange,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_range"


	public static class variable_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variable_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2303:1: variable_name : name ;
	public final BLESStoASTParser.variable_name_return variable_name() throws RecognitionException {
		BLESStoASTParser.variable_name_return retval = new BLESStoASTParser.variable_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope name184 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2304:3: ( name )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2304:5: name
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_name_in_variable_name8252);
			name184=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, name184.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variable_name"


	public static class expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2312:1: expression : a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.expression_return expression() throws RecognitionException {
		BLESStoASTParser.expression_return retval = new BLESStoASTParser.expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_cor=new RewriteRuleTokenStream(adaptor,"token LITERAL_cor");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleTokenStream stream_LITERAL_cand=new RewriteRuleTokenStream(adaptor,"token LITERAL_cand");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2314:3: (a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2315:3: a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |)
			{
			pushFollow(FOLLOW_subexpression_in_expression8278);
			a1=subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2316:3: ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |)
			int alt96=13;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt96=1;
				}
				break;
			case TIMES:
				{
				alt96=2;
				}
				break;
			case MINUS:
				{
				alt96=3;
				}
				break;
			case DIVIDE:
				{
				alt96=4;
				}
				break;
			case LITERAL_mod:
				{
				alt96=5;
				}
				break;
			case LITERAL_rem:
				{
				alt96=6;
				}
				break;
			case EXP:
				{
				alt96=7;
				}
				break;
			case LITERAL_and:
				{
				alt96=8;
				}
				break;
			case LITERAL_or:
				{
				alt96=9;
				}
				break;
			case LITERAL_xor:
				{
				alt96=10;
				}
				break;
			case LITERAL_cand:
				{
				alt96=11;
				}
				break;
			case LITERAL_cor:
				{
				alt96=12;
				}
				break;
			case EOF:
			case AMPERSAND:
			case BOX:
			case COLON:
			case COMMA:
			case COMMACOMMA:
			case COMMADOT:
			case DOTCOMMA:
			case DOTDOT:
			case GUARD:
			case ID:
			case LASS:
			case LCURLY:
			case LITERAL_computation:
			case LITERAL_declare:
			case LITERAL_do:
			case LITERAL_else:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_fi:
			case LITERAL_for:
			case LITERAL_forall:
			case LITERAL_hr:
			case LITERAL_if:
			case LITERAL_invariant:
			case LITERAL_min:
			case LITERAL_ms:
			case LITERAL_ns:
			case LITERAL_pause:
			case LITERAL_ps:
			case LITERAL_sec:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_until:
			case LITERAL_us:
			case LITERAL_when:
			case LITERAL_while:
			case LPAREN:
			case RBRACKET:
			case RCON:
			case RCURLY:
			case RPAREN:
			case SEMICOLON:
				{
				alt96=13;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 96, 0, input);
				throw nvae;
			}
			switch (alt96) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2318:3: (o= PLUS a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2318:3: (o= PLUS a+= subexpression )+
					int cnt91=0;
					loop91:
					while (true) {
						int alt91=2;
						int LA91_0 = input.LA(1);
						if ( (LA91_0==PLUS) ) {
							alt91=1;
						}

						switch (alt91) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2318:5: o= PLUS a+= subexpression
							{
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_expression8294); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8298);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt91 >= 1 ) break loop91;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(91, input);
							throw eee;
						}
						cnt91++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:3: (o= TIMES a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:3: (o= TIMES a+= subexpression )+
					int cnt92=0;
					loop92:
					while (true) {
						int alt92=2;
						int LA92_0 = input.LA(1);
						if ( (LA92_0==TIMES) ) {
							alt92=1;
						}

						switch (alt92) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:5: o= TIMES a+= subexpression
							{
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_expression8314); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8318);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt92 >= 1 ) break loop92;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(92, input);
							throw eee;
						}
						cnt92++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:3: o= MINUS a+= subexpression
					{
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_expression8332); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8336);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2324:3: o= DIVIDE a+= subexpression
					{
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_expression8347); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8351);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2326:3: o= LITERAL_mod a+= subexpression
					{
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_expression8362); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8366);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2328:3: o= LITERAL_rem a+= subexpression
					{
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_expression8377); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8381);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2330:3: o= EXP a+= subexpression
					{
					o=(Token)match(input,EXP,FOLLOW_EXP_in_expression8392); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8396);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2332:3: (o= LITERAL_and a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2332:3: (o= LITERAL_and a+= subexpression )+
					int cnt93=0;
					loop93:
					while (true) {
						int alt93=2;
						int LA93_0 = input.LA(1);
						if ( (LA93_0==LITERAL_and) ) {
							alt93=1;
						}

						switch (alt93) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2332:5: o= LITERAL_and a+= subexpression
							{
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_expression8409); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8413);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt93 >= 1 ) break loop93;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(93, input);
							throw eee;
						}
						cnt93++;
					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:3: (o= LITERAL_or a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:3: (o= LITERAL_or a+= subexpression )+
					int cnt94=0;
					loop94:
					while (true) {
						int alt94=2;
						int LA94_0 = input.LA(1);
						if ( (LA94_0==LITERAL_or) ) {
							alt94=1;
						}

						switch (alt94) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:5: o= LITERAL_or a+= subexpression
							{
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_expression8429); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8433);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt94 >= 1 ) break loop94;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(94, input);
							throw eee;
						}
						cnt94++;
					}

					}
					break;
				case 10 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:3: (o= LITERAL_xor a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:3: (o= LITERAL_xor a+= subexpression )+
					int cnt95=0;
					loop95:
					while (true) {
						int alt95=2;
						int LA95_0 = input.LA(1);
						if ( (LA95_0==LITERAL_xor) ) {
							alt95=1;
						}

						switch (alt95) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:5: o= LITERAL_xor a+= subexpression
							{
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_expression8449); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8453);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt95 >= 1 ) break loop95;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(95, input);
							throw eee;
						}
						cnt95++;
					}

					}
					break;
				case 11 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:3: o= LITERAL_cand a+= subexpression
					{
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_expression8467); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8471);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 12 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2340:3: o= LITERAL_cor a+= subexpression
					{
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_expression8482); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8486);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 13 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2342:3: 
					{
					}
					break;

			}

			// AST REWRITE
			// elements: a1, a1, a, o
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2344:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2344:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2346:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2351:1: subexpression : ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc);
	public final BLESStoASTParser.subexpression_return subexpression() throws RecognitionException {
		BLESStoASTParser.subexpression_return retval = new BLESStoASTParser.subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		Token n=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope tc =null;
		ParserRuleReturnScope fc =null;

		BAST m_tree=null;
		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_function_call=new RewriteRuleSubtreeStream(adaptor,"rule function_call");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_type_conversion=new RewriteRuleSubtreeStream(adaptor,"rule type_conversion");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2353:3: ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc)
			int alt99=3;
			alt99 = dfa99.predict(input);
			switch (alt99) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2354:3: (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2354:3: (m= MINUS |n= LITERAL_not )?
					int alt97=3;
					int LA97_0 = input.LA(1);
					if ( (LA97_0==MINUS) ) {
						alt97=1;
					}
					else if ( (LA97_0==LITERAL_not) ) {
						alt97=2;
					}
					switch (alt97) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2354:5: m= MINUS
							{
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_subexpression8558); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(m);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2354:15: n= LITERAL_not
							{
							n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subexpression8564); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

							}
							break;

					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2355:3: (v= value |ps= parenthesized_subexpression )
					int alt98=2;
					int LA98_0 = input.LA(1);
					if ( (LA98_0==AADL_STRING_LITERAL||LA98_0==ID||LA98_0==INTEGER_LIT||LA98_0==LBRACKET||LA98_0==LITERAL_false||LA98_0==LITERAL_in||LA98_0==LITERAL_now||LA98_0==LITERAL_null||LA98_0==LITERAL_self||LA98_0==LITERAL_timeout||LA98_0==LITERAL_tops||LA98_0==LITERAL_true||LA98_0==OCTOTHORPE||LA98_0==REAL_LIT) ) {
						alt98=1;
					}
					else if ( (LA98_0==LPAREN) ) {
						alt98=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 98, 0, input);
						throw nvae;
					}

					switch (alt98) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2355:5: v= value
							{
							pushFollow(FOLLOW_value_in_subexpression8576);
							v=value();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_value.add(v.getTree());
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2355:15: ps= parenthesized_subexpression
							{
							pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression8582);
							ps=parenthesized_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: n, ps, v, v, n, v, ps, ps
					// token labels: n
					// rule labels: ps, v, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
					RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2356:5: -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v)
					if (m!=null&&v!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2356:28: ^( UNARY_MINUS[$m] $v)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_v.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2357:5: -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps)
					if (m!=null&&ps!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2357:29: ^( UNARY_MINUS[$m] $ps)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_ps.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2358:5: -> {n!=null&&v!=null}? ^( $n $v)
					if (n!=null&&v!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2358:28: ^( $n $v)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_v.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2359:5: -> {n!=null&&ps!=null}? ^( $n $ps)
					if (n!=null&&ps!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2359:29: ^( $n $ps)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ps.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2360:5: -> {v!=null}? $v
					if (v!=null) {
						adaptor.addChild(root_0, stream_v.nextTree());
					}

					else // 2361:5: -> $ps
					{
						adaptor.addChild(root_0, stream_ps.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2362:5: tc= type_conversion
					{
					pushFollow(FOLLOW_type_conversion_in_subexpression8682);
					tc=type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_conversion.add(tc.getTree());
					// AST REWRITE
					// elements: tc
					// token labels: 
					// rule labels: retval, tc
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_tc=new RewriteRuleSubtreeStream(adaptor,"rule tc",tc!=null?tc.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2363:5: -> $tc
					{
						adaptor.addChild(root_0, stream_tc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2365:3: fc= function_call
					{
					pushFollow(FOLLOW_function_call_in_subexpression8702);
					fc=function_call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_function_call.add(fc.getTree());
					// AST REWRITE
					// elements: fc
					// token labels: 
					// rule labels: fc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_fc=new RewriteRuleSubtreeStream(adaptor,"rule fc",fc!=null?fc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2365:20: -> $fc
					{
						adaptor.addChild(root_0, stream_fc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subexpression"


	public static class type_conversion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2370:1: type_conversion : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression -> ^( $n $ps) ;
	public final BLESStoASTParser.type_conversion_return type_conversion() throws RecognitionException {
		BLESStoASTParser.type_conversion_return retval = new BLESStoASTParser.type_conversion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2371:2: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression -> ^( $n $ps) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2372:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2372:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt100=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt100=1;
				}
				break;
			case LITERAL_integer:
				{
				alt100=2;
				}
				break;
			case LITERAL_rational:
				{
				alt100=3;
				}
				break;
			case LITERAL_real:
				{
				alt100=4;
				}
				break;
			case LITERAL_complex:
				{
				alt100=5;
				}
				break;
			case LITERAL_time:
				{
				alt100=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 100, 0, input);
				throw nvae;
			}
			switch (alt100) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2372:4: n= LITERAL_natural
					{
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_type_conversion8732); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2373:3: n= LITERAL_integer
					{
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_type_conversion8741); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2374:3: n= LITERAL_rational
					{
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_type_conversion8750); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2375:3: n= LITERAL_real
					{
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_type_conversion8759); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2376:3: n= LITERAL_complex
					{
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_type_conversion8768); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2377:3: n= LITERAL_time
					{
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_type_conversion8776); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion8785);
			ps=parenthesized_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
			// AST REWRITE
			// elements: ps, n
			// token labels: n
			// rule labels: ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2379:5: -> ^( $n $ps)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2379:8: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_conversion"


	public static class assertion_type_conversion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2383:1: assertion_type_conversion : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression -> ^( $n $ps) ;
	public final BLESStoASTParser.assertion_type_conversion_return assertion_type_conversion() throws RecognitionException {
		BLESStoASTParser.assertion_type_conversion_return retval = new BLESStoASTParser.assertion_type_conversion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_parenthesized_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2384:2: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression -> ^( $n $ps) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2385:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2385:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt101=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt101=1;
				}
				break;
			case LITERAL_integer:
				{
				alt101=2;
				}
				break;
			case LITERAL_rational:
				{
				alt101=3;
				}
				break;
			case LITERAL_real:
				{
				alt101=4;
				}
				break;
			case LITERAL_complex:
				{
				alt101=5;
				}
				break;
			case LITERAL_time:
				{
				alt101=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 101, 0, input);
				throw nvae;
			}
			switch (alt101) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2385:4: n= LITERAL_natural
					{
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type_conversion8816); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2386:3: n= LITERAL_integer
					{
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type_conversion8825); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2387:3: n= LITERAL_rational
					{
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type_conversion8834); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2388:3: n= LITERAL_real
					{
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type_conversion8843); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2389:3: n= LITERAL_complex
					{
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type_conversion8852); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2390:3: n= LITERAL_time
					{
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type_conversion8860); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8869);
			ps=parenthesized_assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parenthesized_assertion_expression.add(ps.getTree());
			// AST REWRITE
			// elements: ps, n
			// token labels: n
			// rule labels: ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2392:5: -> ^( $n $ps)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2392:8: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type_conversion"


	public static class boolean_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2396:1: boolean_expression : a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.boolean_expression_return boolean_expression() throws RecognitionException {
		BLESStoASTParser.boolean_expression_return retval = new BLESStoASTParser.boolean_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_cor=new RewriteRuleTokenStream(adaptor,"token LITERAL_cor");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleTokenStream stream_LITERAL_cand=new RewriteRuleTokenStream(adaptor,"token LITERAL_cand");
		RewriteRuleSubtreeStream stream_boolean_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2398:3: (a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2399:3: a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |)
			{
			pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8904);
			a1=boolean_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_boolean_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2400:3: ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |)
			int alt105=6;
			switch ( input.LA(1) ) {
			case LITERAL_and:
				{
				alt105=1;
				}
				break;
			case LITERAL_or:
				{
				alt105=2;
				}
				break;
			case LITERAL_xor:
				{
				alt105=3;
				}
				break;
			case LITERAL_cand:
				{
				alt105=4;
				}
				break;
			case LITERAL_cor:
				{
				alt105=5;
				}
				break;
			case LITERAL_then:
			case QQ:
			case RPAREN:
				{
				alt105=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 105, 0, input);
				throw nvae;
			}
			switch (alt105) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2402:3: (o= LITERAL_and a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2402:3: (o= LITERAL_and a+= boolean_subexpression )+
					int cnt102=0;
					loop102:
					while (true) {
						int alt102=2;
						int LA102_0 = input.LA(1);
						if ( (LA102_0==LITERAL_and) ) {
							alt102=1;
						}

						switch (alt102) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2402:5: o= LITERAL_and a+= boolean_subexpression
							{
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_boolean_expression8920); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8924);
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt102 >= 1 ) break loop102;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(102, input);
							throw eee;
						}
						cnt102++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:3: (o= LITERAL_or a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:3: (o= LITERAL_or a+= boolean_subexpression )+
					int cnt103=0;
					loop103:
					while (true) {
						int alt103=2;
						int LA103_0 = input.LA(1);
						if ( (LA103_0==LITERAL_or) ) {
							alt103=1;
						}

						switch (alt103) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:5: o= LITERAL_or a+= boolean_subexpression
							{
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_boolean_expression8940); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8944);
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt103 >= 1 ) break loop103;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(103, input);
							throw eee;
						}
						cnt103++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:3: (o= LITERAL_xor a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:3: (o= LITERAL_xor a+= boolean_subexpression )+
					int cnt104=0;
					loop104:
					while (true) {
						int alt104=2;
						int LA104_0 = input.LA(1);
						if ( (LA104_0==LITERAL_xor) ) {
							alt104=1;
						}

						switch (alt104) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:5: o= LITERAL_xor a+= boolean_subexpression
							{
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_boolean_expression8960); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8964);
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt104 >= 1 ) break loop104;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(104, input);
							throw eee;
						}
						cnt104++;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:3: o= LITERAL_cand a+= boolean_subexpression
					{
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_boolean_expression8978); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8982);
					a=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2410:3: o= LITERAL_cor a+= boolean_subexpression
					{
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_boolean_expression8993); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8997);
					a=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2412:3: 
					{
					}
					break;

			}

			// AST REWRITE
			// elements: a1, o, a1, a
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2414:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2414:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2416:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression"


	public static class boolean_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2421:1: boolean_subexpression : (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps;
	public final BLESStoASTParser.boolean_subexpression_return boolean_subexpression() throws RecognitionException {
		BLESStoASTParser.boolean_subexpression_return retval = new BLESStoASTParser.boolean_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2423:3: ( (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2424:3: (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2424:3: (n= LITERAL_not )?
			int alt106=2;
			int LA106_0 = input.LA(1);
			if ( (LA106_0==LITERAL_not) ) {
				alt106=1;
			}
			switch (alt106) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2424:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_boolean_subexpression9069); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2425:3: (v= value |ps= parenthesized_subexpression )
			int alt107=2;
			int LA107_0 = input.LA(1);
			if ( (LA107_0==AADL_STRING_LITERAL||LA107_0==ID||LA107_0==INTEGER_LIT||LA107_0==LBRACKET||LA107_0==LITERAL_false||LA107_0==LITERAL_in||LA107_0==LITERAL_now||LA107_0==LITERAL_null||LA107_0==LITERAL_self||LA107_0==LITERAL_timeout||LA107_0==LITERAL_tops||LA107_0==LITERAL_true||LA107_0==OCTOTHORPE||LA107_0==REAL_LIT) ) {
				alt107=1;
			}
			else if ( (LA107_0==LPAREN) ) {
				alt107=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 107, 0, input);
				throw nvae;
			}

			switch (alt107) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2425:5: v= value
					{
					pushFollow(FOLLOW_value_in_boolean_subexpression9081);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2425:15: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_boolean_subexpression9087);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: v, n, v, ps, n, ps
			// token labels: n
			// rule labels: ps, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2426:5: -> {n!=null&&v!=null}? ^( $n $v)
			if (n!=null&&v!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2426:28: ^( $n $v)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_v.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2427:5: -> {n!=null&&ps!=null}? ^( $n $ps)
			if (n!=null&&ps!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2427:29: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2428:5: -> {v!=null}? $v
			if (v!=null) {
				adaptor.addChild(root_0, stream_v.nextTree());
			}

			else // 2429:5: -> $ps
			{
				adaptor.addChild(root_0, stream_ps.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_subexpression"


	public static class numeric_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2434:1: numeric_expression : a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.numeric_expression_return numeric_expression() throws RecognitionException {
		BLESStoASTParser.numeric_expression_return retval = new BLESStoASTParser.numeric_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_numeric_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule numeric_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2436:3: (a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2437:3: a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |)
			{
			pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9172);
			a1=numeric_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2438:3: ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |)
			int alt110=8;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt110=1;
				}
				break;
			case TIMES:
				{
				alt110=2;
				}
				break;
			case MINUS:
				{
				alt110=3;
				}
				break;
			case DIVIDE:
				{
				alt110=4;
				}
				break;
			case LITERAL_mod:
				{
				alt110=5;
				}
				break;
			case LITERAL_rem:
				{
				alt110=6;
				}
				break;
			case EXP:
				{
				alt110=7;
				}
				break;
			case COMMACOMMA:
			case COMMADOT:
			case DOTCOMMA:
			case DOTDOT:
			case LCURLY:
			case LITERAL_declare:
				{
				alt110=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 110, 0, input);
				throw nvae;
			}
			switch (alt110) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2440:3: (o= PLUS a+= numeric_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2440:3: (o= PLUS a+= numeric_subexpression )+
					int cnt108=0;
					loop108:
					while (true) {
						int alt108=2;
						int LA108_0 = input.LA(1);
						if ( (LA108_0==PLUS) ) {
							alt108=1;
						}

						switch (alt108) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2440:5: o= PLUS a+= numeric_subexpression
							{
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_numeric_expression9188); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9192);
							a=numeric_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt108 >= 1 ) break loop108;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(108, input);
							throw eee;
						}
						cnt108++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:3: (o= TIMES a+= numeric_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:3: (o= TIMES a+= numeric_subexpression )+
					int cnt109=0;
					loop109:
					while (true) {
						int alt109=2;
						int LA109_0 = input.LA(1);
						if ( (LA109_0==TIMES) ) {
							alt109=1;
						}

						switch (alt109) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:5: o= TIMES a+= numeric_subexpression
							{
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_numeric_expression9208); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9212);
							a=numeric_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt109 >= 1 ) break loop109;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(109, input);
							throw eee;
						}
						cnt109++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:3: o= MINUS a+= numeric_subexpression
					{
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_expression9226); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9230);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2446:3: o= DIVIDE a+= numeric_subexpression
					{
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_numeric_expression9241); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9245);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2448:3: o= LITERAL_mod a+= numeric_subexpression
					{
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_numeric_expression9256); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9260);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2450:3: o= LITERAL_rem a+= numeric_subexpression
					{
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_numeric_expression9271); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9275);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2452:3: o= EXP a+= numeric_subexpression
					{
					o=(Token)match(input,EXP,FOLLOW_EXP_in_numeric_expression9286); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9290);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2454:3: 
					{
					}
					break;

			}

			// AST REWRITE
			// elements: o, a, a1, a1
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2456:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2456:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2458:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			     tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_expression"


	public static class numeric_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2464:1: numeric_subexpression : (m= MINUS )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {v!=null}? $v -> $ps;
	public final BLESStoASTParser.numeric_subexpression_return numeric_subexpression() throws RecognitionException {
		BLESStoASTParser.numeric_subexpression_return retval = new BLESStoASTParser.numeric_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;

		BAST m_tree=null;
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2466:3: ( (m= MINUS )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {v!=null}? $v -> $ps)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2467:3: (m= MINUS )? (v= value |ps= parenthesized_subexpression )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2467:3: (m= MINUS )?
			int alt111=2;
			int LA111_0 = input.LA(1);
			if ( (LA111_0==MINUS) ) {
				alt111=1;
			}
			switch (alt111) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2467:5: m= MINUS
					{
					m=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_subexpression9362); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(m);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2468:3: (v= value |ps= parenthesized_subexpression )
			int alt112=2;
			int LA112_0 = input.LA(1);
			if ( (LA112_0==AADL_STRING_LITERAL||LA112_0==ID||LA112_0==INTEGER_LIT||LA112_0==LBRACKET||LA112_0==LITERAL_false||LA112_0==LITERAL_in||LA112_0==LITERAL_now||LA112_0==LITERAL_null||LA112_0==LITERAL_self||LA112_0==LITERAL_timeout||LA112_0==LITERAL_tops||LA112_0==LITERAL_true||LA112_0==OCTOTHORPE||LA112_0==REAL_LIT) ) {
				alt112=1;
			}
			else if ( (LA112_0==LPAREN) ) {
				alt112=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 112, 0, input);
				throw nvae;
			}

			switch (alt112) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2468:5: v= value
					{
					pushFollow(FOLLOW_value_in_numeric_subexpression9374);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2468:15: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_numeric_subexpression9380);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: v, v, ps, ps
			// token labels: 
			// rule labels: ps, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2469:5: -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v)
			if (m!=null&&v!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2469:28: ^( UNARY_MINUS[$m] $v)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
				adaptor.addChild(root_1, stream_v.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2470:5: -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps)
			if (m!=null&&ps!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2470:29: ^( UNARY_MINUS[$m] $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2471:5: -> {v!=null}? $v
			if (v!=null) {
				adaptor.addChild(root_0, stream_v.nextTree());
			}

			else // 2472:5: -> $ps
			{
				adaptor.addChild(root_0, stream_ps.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_subexpression"


	public static class parenthesized_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2478:1: parenthesized_subexpression : ( ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression -> $ce| ( LPAREN case_choice )=>ce= case_expression -> $ce|lp= LPAREN eor= expression_or_relation rp= RPAREN -> ^( $lp $eor $rp) );
	public final BLESStoASTParser.parenthesized_subexpression_return parenthesized_subexpression() throws RecognitionException {
		BLESStoASTParser.parenthesized_subexpression_return retval = new BLESStoASTParser.parenthesized_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope ce =null;
		ParserRuleReturnScope eor =null;

		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_conditional_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_expression");
		RewriteRuleSubtreeStream stream_case_expression=new RewriteRuleSubtreeStream(adaptor,"rule case_expression");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2480:3: ( ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression -> $ce| ( LPAREN case_choice )=>ce= case_expression -> $ce|lp= LPAREN eor= expression_or_relation rp= RPAREN -> ^( $lp $eor $rp) )
			int alt113=3;
			int LA113_0 = input.LA(1);
			if ( (LA113_0==LPAREN) ) {
				int LA113_1 = input.LA(2);
				if ( (synpred1_BLESStoAST()) ) {
					alt113=1;
				}
				else if ( (synpred2_BLESStoAST()) ) {
					alt113=2;
				}
				else if ( (true) ) {
					alt113=3;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 113, 0, input);
				throw nvae;
			}

			switch (alt113) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression
					{
					pushFollow(FOLLOW_conditional_expression_in_parenthesized_subexpression9482);
					ce=conditional_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_expression.add(ce.getTree());
					// AST REWRITE
					// elements: ce
					// token labels: 
					// rule labels: ce, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ce=new RewriteRuleSubtreeStream(adaptor,"rule ce",ce!=null?ce.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2483:5: -> $ce
					{
						adaptor.addChild(root_0, stream_ce.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:3: ( LPAREN case_choice )=>ce= case_expression
					{
					pushFollow(FOLLOW_case_expression_in_parenthesized_subexpression9512);
					ce=case_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_expression.add(ce.getTree());
					// AST REWRITE
					// elements: ce
					// token labels: 
					// rule labels: ce, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ce=new RewriteRuleSubtreeStream(adaptor,"rule ce",ce!=null?ce.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2487:5: -> $ce
					{
						adaptor.addChild(root_0, stream_ce.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2489:3: lp= LPAREN eor= expression_or_relation rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_subexpression9531); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_expression_or_relation_in_parenthesized_subexpression9535);
					eor=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_relation.add(eor.getTree());
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_subexpression9539); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: rp, eor, lp
					// token labels: lp, rp
					// rule labels: eor, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_eor=new RewriteRuleSubtreeStream(adaptor,"rule eor",eor!=null?eor.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2490:5: -> ^( $lp $eor $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2490:8: ^( $lp $eor $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_eor.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_subexpression"


	public static class case_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "case_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2493:1: case_expression : lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN -> ^( CASE_EXPRESSION ( $cc)+ ) ;
	public final BLESStoASTParser.case_expression_return case_expression() throws RecognitionException {
		BLESStoASTParser.case_expression_return retval = new BLESStoASTParser.case_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token c=null;
		Token COMMA185=null;
		Token RPAREN186=null;
		List<Object> list_cc=null;
		RuleReturnScope cc = null;
		BAST lp_tree=null;
		BAST c_tree=null;
		BAST COMMA185_tree=null;
		BAST RPAREN186_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_case_choice=new RewriteRuleSubtreeStream(adaptor,"rule case_choice");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2494:3: (lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN -> ^( CASE_EXPRESSION ( $cc)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2495:3: lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN
			{
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_expression9576); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			pushFollow(FOLLOW_case_choice_in_case_expression9580);
			cc=case_choice();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
			if (list_cc==null) list_cc=new ArrayList<Object>();
			list_cc.add(cc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2495:29: (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2495:31: c= COMMA cc+= case_choice ( COMMA cc+= case_choice )*
			{
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9586); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_case_choice_in_case_expression9590);
			cc=case_choice();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
			if (list_cc==null) list_cc=new ArrayList<Object>();
			list_cc.add(cc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2495:55: ( COMMA cc+= case_choice )*
			loop114:
			while (true) {
				int alt114=2;
				int LA114_0 = input.LA(1);
				if ( (LA114_0==COMMA) ) {
					alt114=1;
				}

				switch (alt114) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2495:57: COMMA cc+= case_choice
					{
					COMMA185=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9594); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA185);

					pushFollow(FOLLOW_case_choice_in_case_expression9598);
					cc=case_choice();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
					if (list_cc==null) list_cc=new ArrayList<Object>();
					list_cc.add(cc.getTree());
					}
					break;

				default :
					break loop114;
				}
			}

			}

			RPAREN186=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_expression9605); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN186);

			// AST REWRITE
			// elements: cc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: cc
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_cc=new RewriteRuleSubtreeStream(adaptor,"token cc",list_cc);
			root_0 = (BAST)adaptor.nil();
			// 2496:5: -> ^( CASE_EXPRESSION ( $cc)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2496:8: ^( CASE_EXPRESSION ( $cc)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CASE_EXPRESSION, "CASE_EXPRESSION"), root_1);
				if ( !(stream_cc.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_cc.hasNext() ) {
					adaptor.addChild(root_1, stream_cc.nextTree());
				}
				stream_cc.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_expression"


	public static class case_choice_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "case_choice"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2500:1: case_choice : LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression ;
	public final BLESStoASTParser.case_choice_return case_choice() throws RecognitionException {
		BLESStoASTParser.case_choice_return retval = new BLESStoASTParser.case_choice_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN187=null;
		Token RPAREN188=null;
		Token IMP189=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope exp =null;

		BAST LPAREN187_tree=null;
		BAST RPAREN188_tree=null;
		BAST IMP189_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2501:3: ( LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2502:3: LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN187=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_choice9642); if (state.failed) return retval;
			pushFollow(FOLLOW_boolean_expression_or_relation_in_case_choice9647);
			be=boolean_expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, be.getTree());

			RPAREN188=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_choice9649); if (state.failed) return retval;
			IMP189=(Token)match(input,IMP,FOLLOW_IMP_in_case_choice9652); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			IMP189_tree = (BAST)adaptor.create(IMP189);
			root_0 = (BAST)adaptor.becomeRoot(IMP189_tree, root_0);
			}

			pushFollow(FOLLOW_expression_in_case_choice9657);
			exp=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, exp.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_choice"


	public static class conditional_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2505:1: conditional_expression : ( LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN -> ^( CONDITIONAL[$then] $be $t $f) | LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN -> ^( CONDITIONAL[$q] $be $t $f) );
	public final BLESStoASTParser.conditional_expression_return conditional_expression() throws RecognitionException {
		BLESStoASTParser.conditional_expression_return retval = new BLESStoASTParser.conditional_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token then=null;
		Token q=null;
		Token LPAREN190=null;
		Token LITERAL_if191=null;
		Token LITERAL_else192=null;
		Token RPAREN193=null;
		Token LPAREN194=null;
		Token COLON195=null;
		Token RPAREN196=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope f =null;

		BAST then_tree=null;
		BAST q_tree=null;
		BAST LPAREN190_tree=null;
		BAST LITERAL_if191_tree=null;
		BAST LITERAL_else192_tree=null;
		BAST RPAREN193_tree=null;
		BAST LPAREN194_tree=null;
		BAST COLON195_tree=null;
		BAST RPAREN196_tree=null;
		RewriteRuleTokenStream stream_QQ=new RewriteRuleTokenStream(adaptor,"token QQ");
		RewriteRuleTokenStream stream_LITERAL_else=new RewriteRuleTokenStream(adaptor,"token LITERAL_else");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_then=new RewriteRuleTokenStream(adaptor,"token LITERAL_then");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_boolean_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2506:3: ( LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN -> ^( CONDITIONAL[$then] $be $t $f) | LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN -> ^( CONDITIONAL[$q] $be $t $f) )
			int alt115=2;
			int LA115_0 = input.LA(1);
			if ( (LA115_0==LPAREN) ) {
				int LA115_1 = input.LA(2);
				if ( (LA115_1==LITERAL_if) ) {
					alt115=1;
				}
				else if ( (LA115_1==AADL_STRING_LITERAL||LA115_1==ID||LA115_1==INTEGER_LIT||LA115_1==LBRACKET||LA115_1==LITERAL_complex||LA115_1==LITERAL_false||LA115_1==LITERAL_in||LA115_1==LITERAL_integer||LA115_1==LITERAL_natural||(LA115_1 >= LITERAL_not && LA115_1 <= LITERAL_now)||LA115_1==LITERAL_null||(LA115_1 >= LITERAL_rational && LA115_1 <= LITERAL_real)||LA115_1==LITERAL_self||(LA115_1 >= LITERAL_time && LA115_1 <= LITERAL_timeout)||LA115_1==LITERAL_tops||LA115_1==LITERAL_true||LA115_1==LPAREN||LA115_1==MINUS||LA115_1==OCTOTHORPE||LA115_1==REAL_LIT) ) {
					alt115=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 115, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 115, 0, input);
				throw nvae;
			}

			switch (alt115) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2507:3: LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN
					{
					LPAREN190=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9672); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN190);

					LITERAL_if191=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_expression9674); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if191);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9678);
					be=boolean_expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression_or_relation.add(be.getTree());
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_expression9682); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_expression_in_conditional_expression9687);
					t=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(t.getTree());
					LITERAL_else192=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_expression9689); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else192);

					pushFollow(FOLLOW_expression_in_conditional_expression9694);
					f=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(f.getTree());
					RPAREN193=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9696); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN193);

					// AST REWRITE
					// elements: be, t, f
					// token labels: 
					// rule labels: be, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2508:5: -> ^( CONDITIONAL[$then] $be $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2508:8: ^( CONDITIONAL[$then] $be $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, then), root_1);
						adaptor.addChild(root_1, stream_be.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2510:3: LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN
					{
					LPAREN194=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9726); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN194);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9730);
					be=boolean_expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression_or_relation.add(be.getTree());
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_expression9734); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_expression_in_conditional_expression9739);
					t=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(t.getTree());
					COLON195=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_expression9741); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON195);

					pushFollow(FOLLOW_expression_in_conditional_expression9746);
					f=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(f.getTree());
					RPAREN196=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9748); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN196);

					// AST REWRITE
					// elements: t, f, be
					// token labels: 
					// rule labels: be, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2511:5: -> ^( CONDITIONAL[$q] $be $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2511:8: ^( CONDITIONAL[$q] $be $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, q), root_1);
						adaptor.addChild(root_1, stream_be.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_expression"


	public static class value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2514:1: value : (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops);
	public final BLESStoASTParser.value_return value() throws RecognitionException {
		BLESStoASTParser.value_return retval = new BLESStoASTParser.value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token q=null;
		Token tf=null;
		Token f=null;
		Token tc=null;
		Token c=null;
		Token u=null;
		Token li=null;
		Token timeout=null;
		Token nu=null;
		Token now=null;
		Token tops=null;
		Token string_literal197=null;
		Token LPAREN198=null;
		Token RPAREN199=null;
		List<Object> list_i=null;
		ParserRuleReturnScope vc =null;
		ParserRuleReturnScope pn =null;
		ParserRuleReturnScope nam =null;
		RuleReturnScope i = null;
		BAST q_tree=null;
		BAST tf_tree=null;
		BAST f_tree=null;
		BAST tc_tree=null;
		BAST c_tree=null;
		BAST u_tree=null;
		BAST li_tree=null;
		BAST timeout_tree=null;
		BAST nu_tree=null;
		BAST now_tree=null;
		BAST tops_tree=null;
		BAST string_literal197_tree=null;
		BAST LPAREN198_tree=null;
		BAST RPAREN199_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mode=new RewriteRuleTokenStream(adaptor,"token LITERAL_mode");
		RewriteRuleTokenStream stream_LITERAL_null=new RewriteRuleTokenStream(adaptor,"token LITERAL_null");
		RewriteRuleTokenStream stream_LITERAL_count=new RewriteRuleTokenStream(adaptor,"token LITERAL_count");
		RewriteRuleTokenStream stream_LITERAL_now=new RewriteRuleTokenStream(adaptor,"token LITERAL_now");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_timeout=new RewriteRuleTokenStream(adaptor,"token LITERAL_timeout");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_TICK=new RewriteRuleTokenStream(adaptor,"token TICK");
		RewriteRuleTokenStream stream_LITERAL_fresh=new RewriteRuleTokenStream(adaptor,"token LITERAL_fresh");
		RewriteRuleTokenStream stream_LITERAL_updated=new RewriteRuleTokenStream(adaptor,"token LITERAL_updated");
		RewriteRuleTokenStream stream_LITERAL_tops=new RewriteRuleTokenStream(adaptor,"token LITERAL_tops");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_value_constant=new RewriteRuleSubtreeStream(adaptor,"rule value_constant");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2515:3: (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops)
			int alt118=8;
			alt118 = dfa118.predict(input);
			switch (alt118) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2516:3: vc= value_constant
					{
					pushFollow(FOLLOW_value_constant_in_value9788);
					vc=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value_constant.add(vc.getTree());
					// AST REWRITE
					// elements: vc
					// token labels: 
					// rule labels: vc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_vc=new RewriteRuleSubtreeStream(adaptor,"rule vc",vc!=null?vc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2516:21: -> $vc
					{
						adaptor.addChild(root_0, stream_vc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated )
					{
					pushFollow(FOLLOW_port_name_in_value9840);
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_name.add(pn.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2521:16: (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated )
					int alt116=4;
					int LA116_0 = input.LA(1);
					if ( (LA116_0==QUESTION) ) {
						alt116=1;
					}
					else if ( (LA116_0==TICK) ) {
						switch ( input.LA(2) ) {
						case LITERAL_fresh:
							{
							alt116=2;
							}
							break;
						case LITERAL_count:
							{
							alt116=3;
							}
							break;
						case LITERAL_updated:
							{
							alt116=4;
							}
							break;
						default:
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 116, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 116, 0, input);
						throw nvae;
					}

					switch (alt116) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2521:18: q= QUESTION
							{
							q=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_value9846); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_QUESTION.add(q);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2521:31: tf= TICK f= LITERAL_fresh
							{
							tf=(Token)match(input,TICK,FOLLOW_TICK_in_value9852); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tf);

							f=(Token)match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_value9856); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_fresh.add(f);

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2521:57: tc= TICK c= LITERAL_count
							{
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9862); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							c=(Token)match(input,LITERAL_count,FOLLOW_LITERAL_count_in_value9866); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_count.add(c);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2521:84: tc= TICK u= LITERAL_updated
							{
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9873); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							u=(Token)match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_value9877); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_updated.add(u);

							}
							break;

					}

					// AST REWRITE
					// elements: c, pn, tc, f, u, pn, tf, tc, pn, q, pn
					// token labels: q, tf, c, u, f, tc
					// rule labels: pn, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_q=new RewriteRuleTokenStream(adaptor,"token q",q);
					RewriteRuleTokenStream stream_tf=new RewriteRuleTokenStream(adaptor,"token tf",tf);
					RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
					RewriteRuleTokenStream stream_u=new RewriteRuleTokenStream(adaptor,"token u",u);
					RewriteRuleTokenStream stream_f=new RewriteRuleTokenStream(adaptor,"token f",f);
					RewriteRuleTokenStream stream_tc=new RewriteRuleTokenStream(adaptor,"token tc",tc);
					RewriteRuleSubtreeStream stream_pn=new RewriteRuleSubtreeStream(adaptor,"rule pn",pn!=null?pn.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2522:5: -> {$f!=null}? ^( $tf $pn $f)
					if (f!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:20: ^( $tf $pn $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tf.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_f.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2523:5: -> {$c!=null}? ^( $tc $pn $c)
					if (c!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2523:20: ^( $tc $pn $c)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_c.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2524:5: -> {$u!=null}? ^( $tc $pn $u)
					if (u!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:20: ^( $tc $pn $u)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_u.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2525:5: -> ^( $q $pn)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:8: ^( $q $pn)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_q.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2530:3: nam= name
					{
					pushFollow(FOLLOW_name_in_value9972);
					nam=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(nam.getTree());
					// AST REWRITE
					// elements: nam
					// token labels: 
					// rule labels: nam, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_nam=new RewriteRuleSubtreeStream(adaptor,"rule nam",nam!=null?nam.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2530:12: -> $nam
					{
						adaptor.addChild(root_0, stream_nam.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2532:3: li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN
					{
					li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_value9987); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

					string_literal197=(Token)match(input,LITERAL_mode,FOLLOW_LITERAL_mode_in_value9989); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mode.add(string_literal197);

					LPAREN198=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_value9991); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN198);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2532:41: (i+= identifier )+
					int cnt117=0;
					loop117:
					while (true) {
						int alt117=2;
						int LA117_0 = input.LA(1);
						if ( (LA117_0==ID) ) {
							alt117=1;
						}

						switch (alt117) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2532:41: i+= identifier
							{
							pushFollow(FOLLOW_identifier_in_value9996);
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							if ( cnt117 >= 1 ) break loop117;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(117, input);
							throw eee;
						}
						cnt117++;
					}

					RPAREN199=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_value9999); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN199);

					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: i
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
					root_0 = (BAST)adaptor.nil();
					// 2533:5: -> ^( INMODE[$li,\"in mode\"] ( $i)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2533:8: ^( INMODE[$li,\"in mode\"] ( $i)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INMODE, li, "in mode"), root_1);
						if ( !(stream_i.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_i.hasNext() ) {
							adaptor.addChild(root_1, stream_i.nextTree());
						}
						stream_i.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2535:3: timeout= LITERAL_timeout
					{
					timeout=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_value10025); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_timeout.add(timeout);

					// AST REWRITE
					// elements: timeout
					// token labels: timeout
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_timeout=new RewriteRuleTokenStream(adaptor,"token timeout",timeout);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2535:27: -> $timeout
					{
						adaptor.addChild(root_0, stream_timeout.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2537:3: nu= LITERAL_null
					{
					nu=(Token)match(input,LITERAL_null,FOLLOW_LITERAL_null_in_value10040); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_null.add(nu);

					// AST REWRITE
					// elements: nu
					// token labels: nu
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_nu=new RewriteRuleTokenStream(adaptor,"token nu",nu);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2537:19: -> $nu
					{
						adaptor.addChild(root_0, stream_nu.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2539:3: now= LITERAL_now
					{
					now=(Token)match(input,LITERAL_now,FOLLOW_LITERAL_now_in_value10055); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_now.add(now);

					// AST REWRITE
					// elements: now
					// token labels: now
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_now=new RewriteRuleTokenStream(adaptor,"token now",now);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2539:19: -> $now
					{
						adaptor.addChild(root_0, stream_now.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2541:3: tops= LITERAL_tops
					{
					tops=(Token)match(input,LITERAL_tops,FOLLOW_LITERAL_tops_in_value10070); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_tops.add(tops);

					// AST REWRITE
					// elements: tops
					// token labels: tops
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_tops=new RewriteRuleTokenStream(adaptor,"token tops",tops);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2541:21: -> $tops
					{
						adaptor.addChild(root_0, stream_tops.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.value,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value"


	public static class value_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "value_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2546:1: value_constant : ( LITERAL_true | LITERAL_false | numeric_constant | AADL_STRING_LITERAL | enumeration_value );
	public final BLESStoASTParser.value_constant_return value_constant() throws RecognitionException {
		BLESStoASTParser.value_constant_return retval = new BLESStoASTParser.value_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_true200=null;
		Token LITERAL_false201=null;
		Token AADL_STRING_LITERAL203=null;
		ParserRuleReturnScope numeric_constant202 =null;
		ParserRuleReturnScope enumeration_value204 =null;

		BAST LITERAL_true200_tree=null;
		BAST LITERAL_false201_tree=null;
		BAST AADL_STRING_LITERAL203_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2547:3: ( LITERAL_true | LITERAL_false | numeric_constant | AADL_STRING_LITERAL | enumeration_value )
			int alt119=5;
			switch ( input.LA(1) ) {
			case LITERAL_true:
				{
				alt119=1;
				}
				break;
			case LITERAL_false:
				{
				alt119=2;
				}
				break;
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_self:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt119=3;
				}
				break;
			case ID:
				{
				int LA119_4 = input.LA(2);
				if ( (LA119_4==DOUBLE_COLON||LA119_4==OCTOTHORPE||LA119_4==PERIOD) ) {
					alt119=3;
				}
				else if ( (LA119_4==TICK) ) {
					alt119=5;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 119, 4, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				alt119=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 119, 0, input);
				throw nvae;
			}
			switch (alt119) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2548:3: LITERAL_true
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_true200=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_value_constant10098); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_true200_tree = (BAST)adaptor.create(LITERAL_true200);
					adaptor.addChild(root_0, LITERAL_true200_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2548:18: LITERAL_false
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_false201=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_value_constant10102); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_false201_tree = (BAST)adaptor.create(LITERAL_false201);
					adaptor.addChild(root_0, LITERAL_false201_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2549:5: numeric_constant
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_numeric_constant_in_value_constant10108);
					numeric_constant202=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_constant202.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2550:5: AADL_STRING_LITERAL
					{
					root_0 = (BAST)adaptor.nil();


					AADL_STRING_LITERAL203=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_value_constant10114); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AADL_STRING_LITERAL203_tree = (BAST)adaptor.create(AADL_STRING_LITERAL203);
					adaptor.addChild(root_0, AADL_STRING_LITERAL203_tree);
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2551:5: enumeration_value
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_enumeration_value_in_value_constant10120);
					enumeration_value204=enumeration_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_value204.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.value,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value_constant"


	public static class enumeration_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2557:1: enumeration_value : enum_type= identifier tick= TICK enum_value= identifier -> ^( $tick $enum_type $enum_value) ;
	public final BLESStoASTParser.enumeration_value_return enumeration_value() throws RecognitionException {
		BLESStoASTParser.enumeration_value_return retval = new BLESStoASTParser.enumeration_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token tick=null;
		ParserRuleReturnScope enum_type =null;
		ParserRuleReturnScope enum_value =null;

		BAST tick_tree=null;
		RewriteRuleTokenStream stream_TICK=new RewriteRuleTokenStream(adaptor,"token TICK");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2558:3: (enum_type= identifier tick= TICK enum_value= identifier -> ^( $tick $enum_type $enum_value) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2559:3: enum_type= identifier tick= TICK enum_value= identifier
			{
			pushFollow(FOLLOW_identifier_in_enumeration_value10151);
			enum_type=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(enum_type.getTree());
			tick=(Token)match(input,TICK,FOLLOW_TICK_in_enumeration_value10155); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TICK.add(tick);

			pushFollow(FOLLOW_identifier_in_enumeration_value10159);
			enum_value=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(enum_value.getTree());
			// AST REWRITE
			// elements: tick, enum_type, enum_value
			// token labels: tick
			// rule labels: enum_type, enum_value, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_tick=new RewriteRuleTokenStream(adaptor,"token tick",tick);
			RewriteRuleSubtreeStream stream_enum_type=new RewriteRuleSubtreeStream(adaptor,"rule enum_type",enum_type!=null?enum_type.getTree():null);
			RewriteRuleSubtreeStream stream_enum_value=new RewriteRuleSubtreeStream(adaptor,"rule enum_value",enum_value!=null?enum_value.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2560:5: -> ^( $tick $enum_type $enum_value)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2560:8: ^( $tick $enum_type $enum_value)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_tick.nextNode(), root_1);
				adaptor.addChild(root_1, stream_enum_type.nextTree());
				adaptor.addChild(root_1, stream_enum_value.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_value"


	public static class property_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2563:1: property : ( property_constant | property_reference );
	public final BLESStoASTParser.property_return property() throws RecognitionException {
		BLESStoASTParser.property_return retval = new BLESStoASTParser.property_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope property_constant205 =null;
		ParserRuleReturnScope property_reference206 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2564:3: ( property_constant | property_reference )
			int alt120=2;
			int LA120_0 = input.LA(1);
			if ( (LA120_0==ID) ) {
				int LA120_1 = input.LA(2);
				if ( (LA120_1==DOUBLE_COLON) ) {
					int LA120_3 = input.LA(3);
					if ( (LA120_3==ID) ) {
						int LA120_4 = input.LA(4);
						if ( (LA120_4==EOF||(LA120_4 >= AL && LA120_4 <= ANNEX_END)||LA120_4==AT_SIGN||(LA120_4 >= BOX && LA120_4 <= CARET)||(LA120_4 >= COLON && LA120_4 <= COMMADOT)||LA120_4==DIVIDE||(LA120_4 >= DOTCOMMA && LA120_4 <= DOTDOT)||LA120_4==EQ||LA120_4==EXP||(LA120_4 >= GT && LA120_4 <= GUARD)||(LA120_4 >= ID && LA120_4 <= IMP)||LA120_4==LASS||LA120_4==LCURLY||LA120_4==LITERAL_and||LA120_4==LITERAL_are||LA120_4==LITERAL_cand||LA120_4==LITERAL_computation||LA120_4==LITERAL_cor||LA120_4==LITERAL_declare||(LA120_4 >= LITERAL_do && LA120_4 <= LITERAL_else)||LA120_4==LITERAL_exception||(LA120_4 >= LITERAL_fetchadd && LA120_4 <= LITERAL_fi)||(LA120_4 >= LITERAL_for && LA120_4 <= LITERAL_forall)||(LA120_4 >= LITERAL_hr && LA120_4 <= LITERAL_iff)||(LA120_4 >= LITERAL_implies && LA120_4 <= LITERAL_in)||LA120_4==LITERAL_invariant||(LA120_4 >= LITERAL_min && LA120_4 <= LITERAL_mod)||LA120_4==LITERAL_ms||LA120_4==LITERAL_ns||LA120_4==LITERAL_of||LA120_4==LITERAL_or||LA120_4==LITERAL_pause||LA120_4==LITERAL_ps||LA120_4==LITERAL_rem||LA120_4==LITERAL_sec||LA120_4==LITERAL_setmode||LA120_4==LITERAL_skip||LA120_4==LITERAL_swap||(LA120_4 >= LITERAL_that && LA120_4 <= LITERAL_then)||LA120_4==LITERAL_until||LA120_4==LITERAL_us||(LA120_4 >= LITERAL_when && LA120_4 <= LITERAL_while)||(LA120_4 >= LITERAL_xor && LA120_4 <= LT)||LA120_4==MINUS||LA120_4==NEQ||LA120_4==PLUS||LA120_4==QQ||LA120_4==RASS||(LA120_4 >= RBRACKET && LA120_4 <= RCURLY)||LA120_4==RPAREN||LA120_4==SEMICOLON||LA120_4==TICK||LA120_4==TIMES) ) {
							alt120=1;
						}
						else if ( (LA120_4==DOUBLE_COLON||LA120_4==OCTOTHORPE||LA120_4==PERIOD) ) {
							alt120=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 120, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 120, 3, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}
				else if ( (LA120_1==OCTOTHORPE||LA120_1==PERIOD) ) {
					alt120=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 120, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA120_0==LITERAL_self||LA120_0==OCTOTHORPE) ) {
				alt120=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 120, 0, input);
				throw nvae;
			}

			switch (alt120) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2565:3: property_constant
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_property_constant_in_property10195);
					property_constant205=property_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property_constant205.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2565:23: property_reference
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_property_reference_in_property10199);
					property_reference206=property_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property_reference206.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property"


	public static class property_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2568:1: property_constant : ps= identifier dc= DOUBLE_COLON ^p= identifier ;
	public final BLESStoASTParser.property_constant_return property_constant() throws RecognitionException {
		BLESStoASTParser.property_constant_return retval = new BLESStoASTParser.property_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dc=null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope p =null;

		BAST dc_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2569:3: (ps= identifier dc= DOUBLE_COLON ^p= identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2570:3: ps= identifier dc= DOUBLE_COLON ^p= identifier
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_identifier_in_property_constant10217);
			ps=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ps.getTree());

			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_constant10221); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			dc_tree = (BAST)adaptor.create(dc);
			root_0 = (BAST)adaptor.becomeRoot(dc_tree, root_0);
			}

			pushFollow(FOLLOW_identifier_in_property_constant10227);
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, p.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_constant"


	public static class property_reference_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2573:1: property_reference : (oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $pname ( $field)* ) |self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $self $pname ( $field)* ) |component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $component $pname ( $field)* ) );
	public final BLESStoASTParser.property_reference_return property_reference() throws RecognitionException {
		BLESStoASTParser.property_reference_return retval = new BLESStoASTParser.property_reference_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token oc=null;
		Token self=null;
		List<Object> list_field=null;
		ParserRuleReturnScope pname =null;
		ParserRuleReturnScope component =null;
		RuleReturnScope field = null;
		BAST oc_tree=null;
		BAST self_tree=null;
		RewriteRuleTokenStream stream_LITERAL_self=new RewriteRuleTokenStream(adaptor,"token LITERAL_self");
		RewriteRuleTokenStream stream_OCTOTHORPE=new RewriteRuleTokenStream(adaptor,"token OCTOTHORPE");
		RewriteRuleSubtreeStream stream_unique_component_classifier_reference=new RewriteRuleSubtreeStream(adaptor,"rule unique_component_classifier_reference");
		RewriteRuleSubtreeStream stream_property_field=new RewriteRuleSubtreeStream(adaptor,"rule property_field");
		RewriteRuleSubtreeStream stream_property_name=new RewriteRuleSubtreeStream(adaptor,"rule property_name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2574:3: (oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $pname ( $field)* ) |self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $self $pname ( $field)* ) |component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $component $pname ( $field)* ) )
			int alt124=3;
			switch ( input.LA(1) ) {
			case OCTOTHORPE:
				{
				alt124=1;
				}
				break;
			case LITERAL_self:
				{
				alt124=2;
				}
				break;
			case ID:
				{
				alt124=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 124, 0, input);
				throw nvae;
			}
			switch (alt124) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2575:3: oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10244); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10248);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2577:5: (field+= property_field )*
					loop121:
					while (true) {
						int alt121=2;
						int LA121_0 = input.LA(1);
						if ( (LA121_0==LBRACKET||LA121_0==PERIOD) ) {
							alt121=1;
						}

						switch (alt121) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2577:7: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference10263);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop121;
						}
					}

					// AST REWRITE
					// elements: field, oc, pname
					// token labels: oc
					// rule labels: pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2578:5: -> ^( $oc $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2578:8: ^( $oc $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2578:22: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2580:5: self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
					self=(Token)match(input,LITERAL_self,FOLLOW_LITERAL_self_in_property_reference10293); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_self.add(self);

					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10297); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10301);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2580:57: (field+= property_field )*
					loop122:
					while (true) {
						int alt122=2;
						int LA122_0 = input.LA(1);
						if ( (LA122_0==LBRACKET||LA122_0==PERIOD) ) {
							alt122=1;
						}

						switch (alt122) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2580:59: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference10307);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop122;
						}
					}

					// AST REWRITE
					// elements: field, oc, self, pname
					// token labels: oc, self
					// rule labels: pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleTokenStream stream_self=new RewriteRuleTokenStream(adaptor,"token self",self);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2581:5: -> ^( $oc $self $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2581:8: ^( $oc $self $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_self.nextNode());
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2581:28: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2584:5: component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
					pushFollow(FOLLOW_unique_component_classifier_reference_in_property_reference10341);
					component=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unique_component_classifier_reference.add(component.getTree());
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10345); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10349);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2585:5: (field+= property_field )*
					loop123:
					while (true) {
						int alt123=2;
						int LA123_0 = input.LA(1);
						if ( (LA123_0==LBRACKET||LA123_0==PERIOD) ) {
							alt123=1;
						}

						switch (alt123) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2585:7: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference10359);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop123;
						}
					}

					// AST REWRITE
					// elements: pname, component, field, oc
					// token labels: oc
					// rule labels: component, pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleSubtreeStream stream_component=new RewriteRuleSubtreeStream(adaptor,"rule component",component!=null?component.getTree():null);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2586:5: -> ^( $oc $component $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2586:8: ^( $oc $component $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_component.nextTree());
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2586:33: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_reference"


	public static class property_field_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2589:1: property_field : ( LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET | PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound ) );
	public final BLESStoASTParser.property_field_return property_field() throws RecognitionException {
		BLESStoASTParser.property_field_return retval = new BLESStoASTParser.property_field_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET207=null;
		Token set208=null;
		Token RBRACKET209=null;
		Token PERIOD210=null;
		Token set211=null;

		BAST LBRACKET207_tree=null;
		BAST set208_tree=null;
		BAST RBRACKET209_tree=null;
		BAST PERIOD210_tree=null;
		BAST set211_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2590:3: ( LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET | PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound ) )
			int alt125=2;
			int LA125_0 = input.LA(1);
			if ( (LA125_0==LBRACKET) ) {
				alt125=1;
			}
			else if ( (LA125_0==PERIOD) ) {
				alt125=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 125, 0, input);
				throw nvae;
			}

			switch (alt125) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2591:3: LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET
					{
					root_0 = (BAST)adaptor.nil();


					LBRACKET207=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_property_field10399); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LBRACKET207_tree = (BAST)adaptor.create(LBRACKET207);
					root_0 = (BAST)adaptor.becomeRoot(LBRACKET207_tree, root_0);
					}

					set208=input.LT(1);
					if ( input.LA(1)==ID||input.LA(1)==INTEGER_LIT ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set208));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					RBRACKET209=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_property_field10410); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RBRACKET209_tree = (BAST)adaptor.create(RBRACKET209);
					adaptor.addChild(root_0, RBRACKET209_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2593:3: PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound )
					{
					root_0 = (BAST)adaptor.nil();


					PERIOD210=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_property_field10418); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					PERIOD210_tree = (BAST)adaptor.create(PERIOD210);
					root_0 = (BAST)adaptor.becomeRoot(PERIOD210_tree, root_0);
					}

					set211=input.LT(1);
					if ( input.LA(1)==ID||input.LA(1)==LITERAL_lower_bound||input.LA(1)==LITERAL_upper_bound ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set211));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_field"


	public static class property_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2596:1: property_name : ps= identifier dc= DOUBLE_COLON p= identifier -> ^( $dc $ps $p) ;
	public final BLESStoASTParser.property_name_return property_name() throws RecognitionException {
		BLESStoASTParser.property_name_return retval = new BLESStoASTParser.property_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dc=null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope p =null;

		BAST dc_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2597:3: (ps= identifier dc= DOUBLE_COLON p= identifier -> ^( $dc $ps $p) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2598:3: ps= identifier dc= DOUBLE_COLON p= identifier
			{
			pushFollow(FOLLOW_identifier_in_property_name10447);
			ps=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(ps.getTree());
			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_name10451); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(dc);

			pushFollow(FOLLOW_identifier_in_property_name10456);
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
			// AST REWRITE
			// elements: dc, ps, p
			// token labels: dc
			// rule labels: p, ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dc=new RewriteRuleTokenStream(adaptor,"token dc",dc);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2599:5: -> ^( $dc $ps $p)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2599:8: ^( $dc $ps $p)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dc.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_1, stream_p.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_name"


	public static class numeric_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2603:1: numeric_constant : ( INTEGER_LIT | REAL_LIT | rational_literal | complex_literal | property );
	public final BLESStoASTParser.numeric_constant_return numeric_constant() throws RecognitionException {
		BLESStoASTParser.numeric_constant_return retval = new BLESStoASTParser.numeric_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token INTEGER_LIT212=null;
		Token REAL_LIT213=null;
		ParserRuleReturnScope rational_literal214 =null;
		ParserRuleReturnScope complex_literal215 =null;
		ParserRuleReturnScope property216 =null;

		BAST INTEGER_LIT212_tree=null;
		BAST REAL_LIT213_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2604:3: ( INTEGER_LIT | REAL_LIT | rational_literal | complex_literal | property )
			int alt126=5;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt126=1;
				}
				break;
			case REAL_LIT:
				{
				alt126=2;
				}
				break;
			case LBRACKET:
				{
				switch ( input.LA(2) ) {
				case MINUS:
					{
					int LA126_5 = input.LA(3);
					if ( (LA126_5==INTEGER_LIT) ) {
						alt126=3;
					}
					else if ( (LA126_5==REAL_LIT) ) {
						alt126=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 126, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

					}
					break;
				case INTEGER_LIT:
					{
					alt126=3;
					}
					break;
				case REAL_LIT:
					{
					alt126=4;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 126, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
				}
				break;
			case ID:
			case LITERAL_self:
			case OCTOTHORPE:
				{
				alt126=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 126, 0, input);
				throw nvae;
			}
			switch (alt126) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2605:3: INTEGER_LIT
					{
					root_0 = (BAST)adaptor.nil();


					INTEGER_LIT212=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_numeric_constant10494); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					INTEGER_LIT212_tree = (BAST)adaptor.create(INTEGER_LIT212);
					adaptor.addChild(root_0, INTEGER_LIT212_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2606:5: REAL_LIT
					{
					root_0 = (BAST)adaptor.nil();


					REAL_LIT213=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_numeric_constant10501); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					REAL_LIT213_tree = (BAST)adaptor.create(REAL_LIT213);
					adaptor.addChild(root_0, REAL_LIT213_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2608:3: rational_literal
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_rational_literal_in_numeric_constant10510);
					rational_literal214=rational_literal();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rational_literal214.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2608:22: complex_literal
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_complex_literal_in_numeric_constant10514);
					complex_literal215=complex_literal();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, complex_literal215.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2609:5: property
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_property_in_numeric_constant10520);
					property216=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property216.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_constant"


	public static class expression_or_relation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2612:1: expression_or_relation : ( ( LPAREN ID ARROW )=>rt= record_term -> $rt| ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= expression -> $e);
	public final BLESStoASTParser.expression_or_relation_return expression_or_relation() throws RecognitionException {
		BLESStoASTParser.expression_or_relation_return retval = new BLESStoASTParser.expression_or_relation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_record_term=new RewriteRuleSubtreeStream(adaptor,"rule record_term");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2614:3: ( ( LPAREN ID ARROW )=>rt= record_term -> $rt| ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= expression -> $e)
			int alt127=3;
			switch ( input.LA(1) ) {
			case LPAREN:
				{
				int LA127_1 = input.LA(2);
				if ( (synpred4_BLESStoAST()) ) {
					alt127=1;
				}
				else if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case MINUS:
				{
				int LA127_2 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_not:
				{
				int LA127_3 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_true:
				{
				int LA127_4 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_false:
				{
				int LA127_5 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case INTEGER_LIT:
				{
				int LA127_6 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case REAL_LIT:
				{
				int LA127_7 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LBRACKET:
				{
				int LA127_8 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case ID:
				{
				int LA127_9 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case OCTOTHORPE:
				{
				int LA127_10 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_self:
				{
				int LA127_11 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				int LA127_12 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_in:
				{
				int LA127_13 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_timeout:
				{
				int LA127_14 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_null:
				{
				int LA127_15 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_now:
				{
				int LA127_16 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_tops:
				{
				int LA127_17 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_natural:
				{
				int LA127_18 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA127_19 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA127_20 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_real:
				{
				int LA127_21 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA127_22 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_time:
				{
				int LA127_23 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 127, 0, input);
				throw nvae;
			}
			switch (alt127) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2615:3: ( LPAREN ID ARROW )=>rt= record_term
					{
					pushFollow(FOLLOW_record_term_in_expression_or_relation10552);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_term.add(rt.getTree());
					// AST REWRITE
					// elements: rt
					// token labels: 
					// rule labels: rt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rt=new RewriteRuleSubtreeStream(adaptor,"rule rt",rt!=null?rt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2617:5: -> $rt
					{
						adaptor.addChild(root_0, stream_rt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2619:3: ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression
					{
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10582);
					e1=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e1.getTree());
					pushFollow(FOLLOW_relation_symbol_in_expression_or_relation10591);
					rs=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(rs.getTree());
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10595);
					e2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e2.getTree());
					// AST REWRITE
					// elements: e1, e2, rs
					// token labels: 
					// rule labels: rs, e1, e2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
					RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2622:5: -> ^( $rs $e1 $e2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2622:8: ^( $rs $e1 $e2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_e1.nextTree());
						adaptor.addChild(root_1, stream_e2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2624:3: e= expression
					{
					pushFollow(FOLLOW_expression_in_expression_or_relation10623);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2625:3: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expressionOrRelation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_relation"


	public static class boolean_expression_or_relation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2631:1: boolean_expression_or_relation : ( ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= boolean_expression -> $e);
	public final BLESStoASTParser.boolean_expression_or_relation_return boolean_expression_or_relation() throws RecognitionException {
		BLESStoASTParser.boolean_expression_or_relation_return retval = new BLESStoASTParser.boolean_expression_or_relation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_boolean_expression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2633:3: ( ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= boolean_expression -> $e)
			int alt128=2;
			int LA128_0 = input.LA(1);
			if ( (LA128_0==MINUS) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_not) ) {
				int LA128_2 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_true) ) {
				int LA128_3 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_false) ) {
				int LA128_4 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==INTEGER_LIT) ) {
				int LA128_5 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==REAL_LIT) ) {
				int LA128_6 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LBRACKET) ) {
				int LA128_7 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==ID) ) {
				int LA128_8 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==OCTOTHORPE) ) {
				int LA128_9 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_self) ) {
				int LA128_10 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==AADL_STRING_LITERAL) ) {
				int LA128_11 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_in) ) {
				int LA128_12 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_timeout) ) {
				int LA128_13 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_null) ) {
				int LA128_14 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_now) ) {
				int LA128_15 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_tops) ) {
				int LA128_16 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LPAREN) ) {
				int LA128_17 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_natural) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_integer) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_rational) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_real) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_complex) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_time) && (synpred6_BLESStoAST())) {
				alt128=1;
			}

			switch (alt128) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2634:3: ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression
					{
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10672);
					e1=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e1.getTree());
					pushFollow(FOLLOW_relation_symbol_in_boolean_expression_or_relation10682);
					rs=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(rs.getTree());
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10686);
					e2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e2.getTree());
					// AST REWRITE
					// elements: e1, e2, rs
					// token labels: 
					// rule labels: rs, e1, e2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
					RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2639:3: -> ^( $rs $e1 $e2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2639:6: ^( $rs $e1 $e2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_e1.nextTree());
						adaptor.addChild(root_1, stream_e2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2641:3: e= boolean_expression
					{
					pushFollow(FOLLOW_boolean_expression_in_boolean_expression_or_relation10713);
					e=boolean_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2642:3: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			      tellBNF(GrammarStrings.expressionOrRelation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression_or_relation"


	public static class function_call_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "function_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2649:1: function_call : (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? ) ;
	public final BLESStoASTParser.function_call_return function_call() throws RecognitionException {
		BLESStoASTParser.function_call_return retval = new BLESStoASTParser.function_call_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token DOUBLE_COLON217=null;
		Token RPAREN218=null;
		List<Object> list_p=null;
		ParserRuleReturnScope id =null;
		ParserRuleReturnScope fp =null;
		RuleReturnScope p = null;
		BAST lp_tree=null;
		BAST DOUBLE_COLON217_tree=null;
		BAST RPAREN218_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_function_parameters=new RewriteRuleSubtreeStream(adaptor,"rule function_parameters");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2651:3: ( (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2652:3: (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2652:3: (p+= identifier DOUBLE_COLON )+
			int cnt129=0;
			loop129:
			while (true) {
				int alt129=2;
				int LA129_0 = input.LA(1);
				if ( (LA129_0==ID) ) {
					int LA129_1 = input.LA(2);
					if ( (LA129_1==DOUBLE_COLON) ) {
						alt129=1;
					}

				}

				switch (alt129) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2652:17: p+= identifier DOUBLE_COLON
					{
					pushFollow(FOLLOW_identifier_in_function_call10762);
					p=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
					if (list_p==null) list_p=new ArrayList<Object>();
					list_p.add(p.getTree());
					DOUBLE_COLON217=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_function_call10764); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON217);

					}
					break;

				default :
					if ( cnt129 >= 1 ) break loop129;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(129, input);
					throw eee;
				}
				cnt129++;
			}

			pushFollow(FOLLOW_identifier_in_function_call10774);
			id=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_function_call10778); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2653:42: (fp= function_parameters )?
			int alt130=2;
			int LA130_0 = input.LA(1);
			if ( (LA130_0==ID) ) {
				alt130=1;
			}
			switch (alt130) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2653:42: fp= function_parameters
					{
					pushFollow(FOLLOW_function_parameters_in_function_call10782);
					fp=function_parameters();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_function_parameters.add(fp.getTree());
					}
					break;

			}

			RPAREN218=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_function_call10785); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN218);

			// AST REWRITE
			// elements: fp, DOUBLE_COLON, id, p
			// token labels: 
			// rule labels: fp, id, retval
			// token list labels: 
			// rule list labels: p
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_fp=new RewriteRuleSubtreeStream(adaptor,"rule fp",fp!=null?fp.getTree():null);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"token p",list_p);
			root_0 = (BAST)adaptor.nil();
			// 2654:3: -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:6: ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(FUNCTION_CALL, lp, "FUNCTION_CALL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:43: ^( DOUBLE_COLON ( $p)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_2);
				if ( !(stream_p.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_p.hasNext() ) {
					adaptor.addChild(root_2, stream_p.nextTree());
				}
				stream_p.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_id.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:68: ( $fp)?
				if ( stream_fp.hasNext() ) {
					adaptor.addChild(root_1, stream_fp.nextTree());
				}
				stream_fp.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(id!=null?((BAST)id.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.functionCall,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_call"


	public static class function_parameters_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "function_parameters"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2663:1: function_parameters :param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )? ;
	public final BLESStoASTParser.function_parameters_return function_parameters() throws RecognitionException {
		BLESStoASTParser.function_parameters_return retval = new BLESStoASTParser.function_parameters_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA219=null;
		Token COMMA220=null;
		List<Object> list_param=null;
		RuleReturnScope param = null;
		BAST COMMA219_tree=null;
		BAST COMMA220_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2664:3: (param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2665:3: param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10844);
			param=formal_expression_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

			if (list_param==null) list_param=new ArrayList<Object>();
			list_param.add(param.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2665:33: ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )?
			int alt132=2;
			int LA132_0 = input.LA(1);
			if ( (LA132_0==COMMA) ) {
				alt132=1;
			}
			switch (alt132) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2665:35: COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )*
					{
					COMMA219=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10848); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA219_tree = (BAST)adaptor.create(COMMA219);
					root_0 = (BAST)adaptor.becomeRoot(COMMA219_tree, root_0);
					}

					pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10854);
					param=formal_expression_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

					if (list_param==null) list_param=new ArrayList<Object>();
					list_param.add(param.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2666:5: ( COMMA param+= formal_expression_pair )*
					loop131:
					while (true) {
						int alt131=2;
						int LA131_0 = input.LA(1);
						if ( (LA131_0==COMMA) ) {
							alt131=1;
						}

						switch (alt131) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2666:7: COMMA param+= formal_expression_pair
							{
							COMMA220=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10864); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							COMMA220_tree = (BAST)adaptor.create(COMMA220);
							adaptor.addChild(root_0, COMMA220_tree);
							}

							pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10869);
							param=formal_expression_pair();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

							if (list_param==null) list_param=new ArrayList<Object>();
							list_param.add(param.getTree());
							}
							break;

						default :
							break loop131;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_parameters"


	public static class formal_expression_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_expression_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2669:1: formal_expression_pair : formal= ID COLON ^actual= expression ;
	public final BLESStoASTParser.formal_expression_pair_return formal_expression_pair() throws RecognitionException {
		BLESStoASTParser.formal_expression_pair_return retval = new BLESStoASTParser.formal_expression_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token formal=null;
		Token COLON221=null;
		ParserRuleReturnScope actual =null;

		BAST formal_tree=null;
		BAST COLON221_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2670:3: (formal= ID COLON ^actual= expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2671:3: formal= ID COLON ^actual= expression
			{
			root_0 = (BAST)adaptor.nil();


			formal=(Token)match(input,ID,FOLLOW_ID_in_formal_expression_pair10891); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			formal_tree = (BAST)adaptor.create(formal);
			adaptor.addChild(root_0, formal_tree);
			}

			COLON221=(Token)match(input,COLON,FOLLOW_COLON_in_formal_expression_pair10893); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			COLON221_tree = (BAST)adaptor.create(COLON221);
			root_0 = (BAST)adaptor.becomeRoot(COLON221_tree, root_0);
			}

			pushFollow(FOLLOW_expression_in_formal_expression_pair10898);
			actual=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, actual.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_expression_pair"


	public static class type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2676:1: type : (tn= type_name -> $tn|et= enumeration_type -> $et|nt= number_type -> $nt|at= array_type -> $at|rt= record_type -> $rt|vt= variant_type -> $vt|b= LITERAL_boolean -> $b|s= LITERAL_string -> $s);
	public final BLESStoASTParser.type_return type() throws RecognitionException {
		BLESStoASTParser.type_return retval = new BLESStoASTParser.type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token b=null;
		Token s=null;
		ParserRuleReturnScope tn =null;
		ParserRuleReturnScope et =null;
		ParserRuleReturnScope nt =null;
		ParserRuleReturnScope at =null;
		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope vt =null;

		BAST b_tree=null;
		BAST s_tree=null;
		RewriteRuleTokenStream stream_LITERAL_string=new RewriteRuleTokenStream(adaptor,"token LITERAL_string");
		RewriteRuleTokenStream stream_LITERAL_boolean=new RewriteRuleTokenStream(adaptor,"token LITERAL_boolean");
		RewriteRuleSubtreeStream stream_type_name=new RewriteRuleSubtreeStream(adaptor,"rule type_name");
		RewriteRuleSubtreeStream stream_enumeration_type=new RewriteRuleSubtreeStream(adaptor,"rule enumeration_type");
		RewriteRuleSubtreeStream stream_variant_type=new RewriteRuleSubtreeStream(adaptor,"rule variant_type");
		RewriteRuleSubtreeStream stream_number_type=new RewriteRuleSubtreeStream(adaptor,"rule number_type");
		RewriteRuleSubtreeStream stream_array_type=new RewriteRuleSubtreeStream(adaptor,"rule array_type");
		RewriteRuleSubtreeStream stream_record_type=new RewriteRuleSubtreeStream(adaptor,"rule record_type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2677:3: (tn= type_name -> $tn|et= enumeration_type -> $et|nt= number_type -> $nt|at= array_type -> $at|rt= record_type -> $rt|vt= variant_type -> $vt|b= LITERAL_boolean -> $b|s= LITERAL_string -> $s)
			int alt133=8;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt133=1;
				}
				break;
			case LITERAL_enumeration:
				{
				alt133=2;
				}
				break;
			case LITERAL_complex:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
				{
				alt133=3;
				}
				break;
			case LITERAL_array:
				{
				alt133=4;
				}
				break;
			case LITERAL_record:
				{
				alt133=5;
				}
				break;
			case LITERAL_variant:
				{
				alt133=6;
				}
				break;
			case LITERAL_boolean:
				{
				alt133=7;
				}
				break;
			case LITERAL_string:
				{
				alt133=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 133, 0, input);
				throw nvae;
			}
			switch (alt133) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2679:3: tn= type_name
					{
					pushFollow(FOLLOW_type_name_in_type10923);
					tn=type_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_name.add(tn.getTree());
					// AST REWRITE
					// elements: tn
					// token labels: 
					// rule labels: tn, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_tn=new RewriteRuleSubtreeStream(adaptor,"rule tn",tn!=null?tn.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2680:5: -> $tn
					{
						adaptor.addChild(root_0, stream_tn.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2682:3: et= enumeration_type
					{
					pushFollow(FOLLOW_enumeration_type_in_type10942);
					et=enumeration_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumeration_type.add(et.getTree());
					// AST REWRITE
					// elements: et
					// token labels: 
					// rule labels: retval, et
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_et=new RewriteRuleSubtreeStream(adaptor,"rule et",et!=null?et.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2683:5: -> $et
					{
						adaptor.addChild(root_0, stream_et.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2685:3: nt= number_type
					{
					pushFollow(FOLLOW_number_type_in_type10961);
					nt=number_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_number_type.add(nt.getTree());
					// AST REWRITE
					// elements: nt
					// token labels: 
					// rule labels: nt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_nt=new RewriteRuleSubtreeStream(adaptor,"rule nt",nt!=null?nt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2686:5: -> $nt
					{
						adaptor.addChild(root_0, stream_nt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2688:3: at= array_type
					{
					pushFollow(FOLLOW_array_type_in_type10980);
					at=array_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_array_type.add(at.getTree());
					// AST REWRITE
					// elements: at
					// token labels: 
					// rule labels: at, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_at=new RewriteRuleSubtreeStream(adaptor,"rule at",at!=null?at.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2689:5: -> $at
					{
						adaptor.addChild(root_0, stream_at.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2691:3: rt= record_type
					{
					pushFollow(FOLLOW_record_type_in_type10999);
					rt=record_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_type.add(rt.getTree());
					// AST REWRITE
					// elements: rt
					// token labels: 
					// rule labels: rt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rt=new RewriteRuleSubtreeStream(adaptor,"rule rt",rt!=null?rt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2692:5: -> $rt
					{
						adaptor.addChild(root_0, stream_rt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2694:3: vt= variant_type
					{
					pushFollow(FOLLOW_variant_type_in_type11018);
					vt=variant_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_variant_type.add(vt.getTree());
					// AST REWRITE
					// elements: vt
					// token labels: 
					// rule labels: vt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_vt=new RewriteRuleSubtreeStream(adaptor,"rule vt",vt!=null?vt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2695:5: -> $vt
					{
						adaptor.addChild(root_0, stream_vt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2700:3: b= LITERAL_boolean
					{
					b=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_type11040); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_boolean.add(b);

					// AST REWRITE
					// elements: b
					// token labels: b
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_b=new RewriteRuleTokenStream(adaptor,"token b",b);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2700:21: -> $b
					{
						adaptor.addChild(root_0, stream_b.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2702:3: s= LITERAL_string
					{
					s=(Token)match(input,LITERAL_string,FOLLOW_LITERAL_string_in_type11055); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_string.add(s);

					// AST REWRITE
					// elements: s
					// token labels: s
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2702:20: -> $s
					{
						adaptor.addChild(root_0, stream_s.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			  Dump.it("\n"+(saidTypeError?"That ":"Some ")+Global.dope+
			  " made "+(saidTypeError?"another":"an")+" error in grammar of a \"type\".\n");
			  Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  tellBNF(GrammarStrings.type,re,retval.tree);
			//  Dump.it("RecognitionException suppressed ");
			//  if ((retval!=null)&&(retval.getTree()!=null))
			//    Dump.it(((BAST)retval.getTree()).toStringTree());
			  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type"


	public static class enumeration_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2715:1: enumeration_type : LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
	public final BLESStoASTParser.enumeration_type_return enumeration_type() throws RecognitionException {
		BLESStoASTParser.enumeration_type_return retval = new BLESStoASTParser.enumeration_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_enumeration222=null;
		Token LPAREN223=null;
		Token COMMA225=null;
		Token RPAREN227=null;
		ParserRuleReturnScope identifier224 =null;
		ParserRuleReturnScope identifier226 =null;

		BAST LITERAL_enumeration222_tree=null;
		BAST LPAREN223_tree=null;
		BAST COMMA225_tree=null;
		BAST RPAREN227_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2716:3: ( LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2717:2: LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_enumeration222=(Token)match(input,LITERAL_enumeration,FOLLOW_LITERAL_enumeration_in_enumeration_type11084); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_enumeration222_tree = (BAST)adaptor.create(LITERAL_enumeration222);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_enumeration222_tree, root_0);
			}

			LPAREN223=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_enumeration_type11087); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_enumeration_type11092);
			identifier224=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier224.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2718:4: ( COMMA ! identifier )*
			loop134:
			while (true) {
				int alt134=2;
				int LA134_0 = input.LA(1);
				if ( (LA134_0==COMMA) ) {
					alt134=1;
				}

				switch (alt134) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2718:5: COMMA ! identifier
					{
					COMMA225=(Token)match(input,COMMA,FOLLOW_COMMA_in_enumeration_type11098); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_enumeration_type11101);
					identifier226=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier226.getTree());

					}
					break;

				default :
					break loop134;
				}
			}

			RPAREN227=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_enumeration_type11105); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			 Dump.it("Did you forget commas between your enumeration literals?");
			  Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.enumerationType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_type"


	public static class number_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "number_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2748:1: number_type : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )? -> {u!=null}? ^( $n ^( $u $ud) ( $r)? ) -> ^( $n ( $r)? ) ;
	public final BLESStoASTParser.number_type_return number_type() throws RecognitionException {
		BLESStoASTParser.number_type_return retval = new BLESStoASTParser.number_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token u=null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope ud =null;

		BAST n_tree=null;
		BAST u_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_units=new RewriteRuleTokenStream(adaptor,"token LITERAL_units");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_number_range=new RewriteRuleSubtreeStream(adaptor,"rule number_range");
		RewriteRuleSubtreeStream stream_units_designator=new RewriteRuleSubtreeStream(adaptor,"rule units_designator");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2749:3: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )? -> {u!=null}? ^( $n ^( $u $ud) ( $r)? ) -> ^( $n ( $r)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2750:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2750:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt135=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt135=1;
				}
				break;
			case LITERAL_integer:
				{
				alt135=2;
				}
				break;
			case LITERAL_rational:
				{
				alt135=3;
				}
				break;
			case LITERAL_real:
				{
				alt135=4;
				}
				break;
			case LITERAL_complex:
				{
				alt135=5;
				}
				break;
			case LITERAL_time:
				{
				alt135=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 135, 0, input);
				throw nvae;
			}
			switch (alt135) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2750:4: n= LITERAL_natural
					{
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_number_type11160); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2751:3: n= LITERAL_integer
					{
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_number_type11169); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2752:3: n= LITERAL_rational
					{
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_number_type11178); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2753:3: n= LITERAL_real
					{
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_number_type11187); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2754:3: n= LITERAL_complex
					{
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_number_type11196); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2755:3: n= LITERAL_time
					{
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_number_type11204); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2756:4: (r= number_range )?
			int alt136=2;
			int LA136_0 = input.LA(1);
			if ( (LA136_0==LBRACKET) ) {
				alt136=1;
			}
			switch (alt136) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2756:4: r= number_range
					{
					pushFollow(FOLLOW_number_range_in_number_type11212);
					r=number_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_number_range.add(r.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2756:19: (u= LITERAL_units ud= units_designator )?
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==LITERAL_units) ) {
				alt137=1;
			}
			switch (alt137) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2756:21: u= LITERAL_units ud= units_designator
					{
					u=(Token)match(input,LITERAL_units,FOLLOW_LITERAL_units_in_number_type11219); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_units.add(u);

					pushFollow(FOLLOW_units_designator_in_number_type11223);
					ud=units_designator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_units_designator.add(ud.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: n, n, u, r, ud, r
			// token labels: u, n
			// rule labels: r, retval, ud
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_u=new RewriteRuleTokenStream(adaptor,"token u",u);
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ud=new RewriteRuleSubtreeStream(adaptor,"rule ud",ud!=null?ud.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2757:4: -> {u!=null}? ^( $n ^( $u $ud) ( $r)? )
			if (u!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2757:18: ^( $n ^( $u $ud) ( $r)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2757:23: ^( $u $ud)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_u.nextNode(), root_2);
				adaptor.addChild(root_2, stream_ud.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2757:34: ( $r)?
				if ( stream_r.hasNext() ) {
					adaptor.addChild(root_1, stream_r.nextTree());
				}
				stream_r.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2758:4: -> ^( $n ( $r)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:7: ^( $n ( $r)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:13: ( $r)?
				if ( stream_r.hasNext() ) {
					adaptor.addChild(root_1, stream_r.nextTree());
				}
				stream_r.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.numberType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_type"


	public static class number_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2763:1: number_range : LBRACKET ! constant_number_range RBRACKET !;
	public final BLESStoASTParser.number_range_return number_range() throws RecognitionException {
		BLESStoASTParser.number_range_return retval = new BLESStoASTParser.number_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET228=null;
		Token RBRACKET230=null;
		ParserRuleReturnScope constant_number_range229 =null;

		BAST LBRACKET228_tree=null;
		BAST RBRACKET230_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2764:3: ( LBRACKET ! constant_number_range RBRACKET !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2765:3: LBRACKET ! constant_number_range RBRACKET !
			{
			root_0 = (BAST)adaptor.nil();


			LBRACKET228=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_number_range11288); if (state.failed) return retval;
			pushFollow(FOLLOW_constant_number_range_in_number_range11291);
			constant_number_range229=constant_number_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_number_range229.getTree());

			RBRACKET230=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_number_range11293); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_range"


	public static class constant_number_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "constant_number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2768:1: constant_number_range : (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) ) -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub) -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) ) -> ^( $dd $lb $ub) ;
	public final BLESStoASTParser.constant_number_range_return constant_number_range() throws RecognitionException {
		BLESStoASTParser.constant_number_range_return retval = new BLESStoASTParser.constant_number_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lb_um=null;
		Token dd=null;
		Token ub_um=null;
		ParserRuleReturnScope lb =null;
		ParserRuleReturnScope ub =null;

		BAST lb_um_tree=null;
		BAST dd_tree=null;
		BAST ub_um_tree=null;
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_numeric_constant=new RewriteRuleSubtreeStream(adaptor,"rule numeric_constant");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2769:3: ( (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) ) -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub) -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) ) -> ^( $dd $lb $ub) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:3: (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:8: (lb_um= MINUS )?
			int alt138=2;
			int LA138_0 = input.LA(1);
			if ( (LA138_0==MINUS) ) {
				alt138=1;
			}
			switch (alt138) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:8: lb_um= MINUS
					{
					lb_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11311); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(lb_um);

					}
					break;

			}

			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11316);
			lb=numeric_constant();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_constant.add(lb.getTree());
			dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range11320); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(dd);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:51: (ub_um= MINUS )?
			int alt139=2;
			int LA139_0 = input.LA(1);
			if ( (LA139_0==MINUS) ) {
				alt139=1;
			}
			switch (alt139) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:51: ub_um= MINUS
					{
					ub_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11324); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(ub_um);

					}
					break;

			}

			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11329);
			ub=numeric_constant();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_constant.add(ub.getTree());
			// AST REWRITE
			// elements: lb, dd, dd, ub, dd, ub, dd, ub, lb, ub, lb, lb
			// token labels: dd
			// rule labels: lb, ub, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dd=new RewriteRuleTokenStream(adaptor,"token dd",dd);
			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,"rule lb",lb!=null?lb.getTree():null);
			RewriteRuleSubtreeStream stream_ub=new RewriteRuleSubtreeStream(adaptor,"rule ub",ub!=null?ub.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2771:3: -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) )
			if ((lb_um!=null)&&(ub_um!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2771:38: ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2771:44: ^( UNARY_MINUS[$lb_um] $lb)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, lb_um), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2771:71: ^( UNARY_MINUS[$ub_um] $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, ub_um), root_2);
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2772:3: -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub)
			if (lb_um!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:21: ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:27: ^( UNARY_MINUS[$lb_um] $lb)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, lb_um), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_ub.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2773:3: -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) )
			if (ub_um!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2773:21: ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lb.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2773:31: ^( UNARY_MINUS[$ub_um] $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, ub_um), root_2);
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2774:3: -> ^( $dd $lb $ub)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2774:6: ^( $dd $lb $ub)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lb.nextTree());
				adaptor.addChild(root_1, stream_ub.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constant_number_range"


	public static class units_designator_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "units_designator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2777:1: units_designator : ( identifier | time_unit );
	public final BLESStoASTParser.units_designator_return units_designator() throws RecognitionException {
		BLESStoASTParser.units_designator_return retval = new BLESStoASTParser.units_designator_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope identifier231 =null;
		ParserRuleReturnScope time_unit232 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2778:3: ( identifier | time_unit )
			int alt140=2;
			int LA140_0 = input.LA(1);
			if ( (LA140_0==ID) ) {
				alt140=1;
			}
			else if ( (LA140_0==LITERAL_hr||LA140_0==LITERAL_min||LA140_0==LITERAL_ms||LA140_0==LITERAL_ns||LA140_0==LITERAL_ps||LA140_0==LITERAL_sec||LA140_0==LITERAL_us) ) {
				alt140=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 140, 0, input);
				throw nvae;
			}

			switch (alt140) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2779:34: identifier
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_units_designator11443);
					identifier231=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier231.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2780:5: time_unit
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_time_unit_in_units_designator11449);
					time_unit232=time_unit();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_unit232.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.unitsDesignator,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "units_designator"


	public static class unique_component_classifier_reference_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "unique_component_classifier_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2795:1: unique_component_classifier_reference : (p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )? -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) ) -> ^( DOUBLE_COLON ( $p)+ ) |dci= identifier ( PERIOD ii= identifier )? -> {ii!=null}? ^( PERIOD $dci $ii) -> $dci);
	public final BLESStoASTParser.unique_component_classifier_reference_return unique_component_classifier_reference() throws RecognitionException {
		BLESStoASTParser.unique_component_classifier_reference_return retval = new BLESStoASTParser.unique_component_classifier_reference_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token DOUBLE_COLON233=null;
		Token PERIOD234=null;
		Token PERIOD235=null;
		List<Object> list_p=null;
		ParserRuleReturnScope ii =null;
		ParserRuleReturnScope dci =null;
		RuleReturnScope p = null;
		BAST DOUBLE_COLON233_tree=null;
		BAST PERIOD234_tree=null;
		BAST PERIOD235_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2796:3: (p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )? -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) ) -> ^( DOUBLE_COLON ( $p)+ ) |dci= identifier ( PERIOD ii= identifier )? -> {ii!=null}? ^( PERIOD $dci $ii) -> $dci)
			int alt144=2;
			int LA144_0 = input.LA(1);
			if ( (LA144_0==ID) ) {
				int LA144_1 = input.LA(2);
				if ( (LA144_1==DOUBLE_COLON) ) {
					alt144=1;
				}
				else if ( (LA144_1==LITERAL_in||LA144_1==LITERAL_of||LA144_1==LITERAL_that||LA144_1==OCTOTHORPE||LA144_1==PERIOD) ) {
					alt144=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 144, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 144, 0, input);
				throw nvae;
			}

			switch (alt144) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2797:3: p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )?
					{
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11489);
					p=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
					if (list_p==null) list_p=new ArrayList<Object>();
					list_p.add(p.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2797:29: ( DOUBLE_COLON p+= identifier )+
					int cnt141=0;
					loop141:
					while (true) {
						int alt141=2;
						int LA141_0 = input.LA(1);
						if ( (LA141_0==DOUBLE_COLON) ) {
							alt141=1;
						}

						switch (alt141) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2797:31: DOUBLE_COLON p+= identifier
							{
							DOUBLE_COLON233=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11493); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON233);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11498);
							p=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
							if (list_p==null) list_p=new ArrayList<Object>();
							list_p.add(p.getTree());
							}
							break;

						default :
							if ( cnt141 >= 1 ) break loop141;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(141, input);
							throw eee;
						}
						cnt141++;
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2798:5: ( PERIOD ii= identifier )?
					int alt142=2;
					int LA142_0 = input.LA(1);
					if ( (LA142_0==PERIOD) ) {
						alt142=1;
					}
					switch (alt142) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2798:7: PERIOD ii= identifier
							{
							PERIOD234=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11510); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD234);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11515);
							ii=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ii.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: PERIOD, ii, p, DOUBLE_COLON, DOUBLE_COLON, p
					// token labels: 
					// rule labels: ii, retval
					// token list labels: 
					// rule list labels: p
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ii=new RewriteRuleSubtreeStream(adaptor,"rule ii",ii!=null?ii.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"token p",list_p);
					root_0 = (BAST)adaptor.nil();
					// 2799:5: -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) )
					if (ii!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2799:20: ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_1);
						if ( !(stream_p.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_p.hasNext() ) {
							adaptor.addChild(root_1, stream_p.nextTree());
						}
						stream_p.reset();

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2799:40: ^( PERIOD $ii)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_PERIOD.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ii.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2800:5: -> ^( DOUBLE_COLON ( $p)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2800:8: ^( DOUBLE_COLON ( $p)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_1);
						if ( !(stream_p.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_p.hasNext() ) {
							adaptor.addChild(root_1, stream_p.nextTree());
						}
						stream_p.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2805:3: dci= identifier ( PERIOD ii= identifier )?
					{
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11573);
					dci=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(dci.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2806:5: ( PERIOD ii= identifier )?
					int alt143=2;
					int LA143_0 = input.LA(1);
					if ( (LA143_0==PERIOD) ) {
						alt143=1;
					}
					switch (alt143) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2806:7: PERIOD ii= identifier
							{
							PERIOD235=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11581); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD235);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11586);
							ii=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ii.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: PERIOD, dci, dci, ii
					// token labels: 
					// rule labels: ii, dci, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ii=new RewriteRuleSubtreeStream(adaptor,"rule ii",ii!=null?ii.getTree():null);
					RewriteRuleSubtreeStream stream_dci=new RewriteRuleSubtreeStream(adaptor,"rule dci",dci!=null?dci.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2807:5: -> {ii!=null}? ^( PERIOD $dci $ii)
					if (ii!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2807:20: ^( PERIOD $dci $ii)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_PERIOD.nextNode(), root_1);
						adaptor.addChild(root_1, stream_dci.nextTree());
						adaptor.addChild(root_1, stream_ii.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2808:5: -> $dci
					{
						adaptor.addChild(root_0, stream_dci.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("\nIs this a unique_component_classifier_reference?\n");
			//    tellBNF(GrammarStrings.subcomponent,re,$subcomponent.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unique_component_classifier_reference"


	public static class type_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2816:1: type_name : p= ID (dc= DOUBLE_COLON ^x= ID )? ;
	public final BLESStoASTParser.type_name_return type_name() throws RecognitionException {
		BLESStoASTParser.type_name_return retval = new BLESStoASTParser.type_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token p=null;
		Token dc=null;
		Token x=null;

		BAST p_tree=null;
		BAST dc_tree=null;
		BAST x_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2817:3: (p= ID (dc= DOUBLE_COLON ^x= ID )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2819:3: p= ID (dc= DOUBLE_COLON ^x= ID )?
			{
			root_0 = (BAST)adaptor.nil();


			p=(Token)match(input,ID,FOLLOW_ID_in_type_name11662); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			p_tree = (BAST)adaptor.create(p);
			adaptor.addChild(root_0, p_tree);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2819:8: (dc= DOUBLE_COLON ^x= ID )?
			int alt145=2;
			int LA145_0 = input.LA(1);
			if ( (LA145_0==DOUBLE_COLON) ) {
				alt145=1;
			}
			switch (alt145) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2819:9: dc= DOUBLE_COLON ^x= ID
					{
					dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_type_name11667); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					dc_tree = (BAST)adaptor.create(dc);
					root_0 = (BAST)adaptor.becomeRoot(dc_tree, root_0);
					}

					x=(Token)match(input,ID,FOLLOW_ID_in_type_name11672); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x_tree = (BAST)adaptor.create(x);
					adaptor.addChild(root_0, x_tree);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.typeName,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_name"


	public static class array_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "array_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2824:1: array_type : LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type ;
	public final BLESStoASTParser.array_type_return array_type() throws RecognitionException {
		BLESStoASTParser.array_type_return retval = new BLESStoASTParser.array_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_array236=null;
		Token LBRACKET237=null;
		Token RBRACKET239=null;
		Token LITERAL_of240=null;
		ParserRuleReturnScope array_range_list238 =null;
		ParserRuleReturnScope type241 =null;

		BAST LITERAL_array236_tree=null;
		BAST LBRACKET237_tree=null;
		BAST RBRACKET239_tree=null;
		BAST LITERAL_of240_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2825:3: ( LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2826:3: LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_array236=(Token)match(input,LITERAL_array,FOLLOW_LITERAL_array_in_array_type11699); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_array236_tree = (BAST)adaptor.create(LITERAL_array236);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_array236_tree, root_0);
			}

			LBRACKET237=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_array_type11702); if (state.failed) return retval;
			pushFollow(FOLLOW_array_range_list_in_array_type11705);
			array_range_list238=array_range_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, array_range_list238.getTree());

			RBRACKET239=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_array_type11707); if (state.failed) return retval;
			LITERAL_of240=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_array_type11710); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_of240_tree = (BAST)adaptor.create(LITERAL_of240);
			adaptor.addChild(root_0, LITERAL_of240_tree);
			}

			pushFollow(FOLLOW_type_in_array_type11712);
			type241=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type241.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.arrayType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_type"


	public static class record_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2832:1: record_type : LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !;
	public final BLESStoASTParser.record_type_return record_type() throws RecognitionException {
		BLESStoASTParser.record_type_return retval = new BLESStoASTParser.record_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_record242=null;
		Token LPAREN243=null;
		Token RPAREN245=null;
		ParserRuleReturnScope record_field244 =null;

		BAST LITERAL_record242_tree=null;
		BAST LPAREN243_tree=null;
		BAST RPAREN245_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2833:3: ( LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2834:3: LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_record242=(Token)match(input,LITERAL_record,FOLLOW_LITERAL_record_in_record_type11739); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_record242_tree = (BAST)adaptor.create(LITERAL_record242);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_record242_tree, root_0);
			}

			LPAREN243=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_type11742); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2834:27: ( record_field )+
			int cnt146=0;
			loop146:
			while (true) {
				int alt146=2;
				int LA146_0 = input.LA(1);
				if ( (LA146_0==ID) ) {
					alt146=1;
				}

				switch (alt146) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2834:27: record_field
					{
					pushFollow(FOLLOW_record_field_in_record_type11745);
					record_field244=record_field();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_field244.getTree());

					}
					break;

				default :
					if ( cnt146 >= 1 ) break loop146;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(146, input);
					throw eee;
				}
				cnt146++;
			}

			RPAREN245=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_type11748); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.recordType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_type"


	public static class record_field_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2839:1: record_field : identifier COLON ^ type SEMICOLON !;
	public final BLESStoASTParser.record_field_return record_field() throws RecognitionException {
		BLESStoASTParser.record_field_return retval = new BLESStoASTParser.record_field_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COLON247=null;
		Token SEMICOLON249=null;
		ParserRuleReturnScope identifier246 =null;
		ParserRuleReturnScope type248 =null;

		BAST COLON247_tree=null;
		BAST SEMICOLON249_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2840:3: ( identifier COLON ^ type SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2841:22: identifier COLON ^ type SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_identifier_in_record_field11777);
			identifier246=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier246.getTree());

			COLON247=(Token)match(input,COLON,FOLLOW_COLON_in_record_field11779); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			COLON247_tree = (BAST)adaptor.create(COLON247);
			root_0 = (BAST)adaptor.becomeRoot(COLON247_tree, root_0);
			}

			pushFollow(FOLLOW_type_in_record_field11782);
			type248=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type248.getTree());

			SEMICOLON249=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_field11784); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("\nDid you forget a ; after a record or variant field?\n");
			    tellBNF(GrammarStrings.recordField,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_field"


	public static class array_range_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "array_range_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2851:1: array_range_list : natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )? ;
	public final BLESStoASTParser.array_range_list_return array_range_list() throws RecognitionException {
		BLESStoASTParser.array_range_list_return retval = new BLESStoASTParser.array_range_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA251=null;
		Token COMMA253=null;
		ParserRuleReturnScope natural_range250 =null;
		ParserRuleReturnScope natural_range252 =null;
		ParserRuleReturnScope natural_range254 =null;

		BAST COMMA251_tree=null;
		BAST COMMA253_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2852:3: ( natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2853:3: natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_natural_range_in_array_range_list11814);
			natural_range250=natural_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range250.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2853:17: ( COMMA ^ natural_range ( COMMA ! natural_range )* )?
			int alt148=2;
			int LA148_0 = input.LA(1);
			if ( (LA148_0==COMMA) ) {
				alt148=1;
			}
			switch (alt148) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2853:19: COMMA ^ natural_range ( COMMA ! natural_range )*
					{
					COMMA251=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11818); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA251_tree = (BAST)adaptor.create(COMMA251);
					root_0 = (BAST)adaptor.becomeRoot(COMMA251_tree, root_0);
					}

					pushFollow(FOLLOW_natural_range_in_array_range_list11821);
					natural_range252=natural_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range252.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2853:40: ( COMMA ! natural_range )*
					loop147:
					while (true) {
						int alt147=2;
						int LA147_0 = input.LA(1);
						if ( (LA147_0==COMMA) ) {
							alt147=1;
						}

						switch (alt147) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2853:42: COMMA ! natural_range
							{
							COMMA253=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11825); if (state.failed) return retval;
							pushFollow(FOLLOW_natural_range_in_array_range_list11828);
							natural_range254=natural_range();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range254.getTree());

							}
							break;

						default :
							break loop147;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.arrayRangeList,re);
			      tellBNF(GrammarStrings.arrayRangeList,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_range_list"


	public static class natural_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "natural_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2860:1: natural_range : (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )? ;
	public final BLESStoASTParser.natural_range_return natural_range() throws RecognitionException {
		BLESStoASTParser.natural_range_return retval = new BLESStoASTParser.natural_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ilb=null;
		Token dd=null;
		Token iub=null;
		ParserRuleReturnScope elb =null;
		ParserRuleReturnScope pnlb =null;
		ParserRuleReturnScope eub =null;
		ParserRuleReturnScope pnub =null;

		BAST ilb_tree=null;
		BAST dd_tree=null;
		BAST iub_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2861:3: ( (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2862:3: (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2862:3: (ilb= INTEGER_LIT |elb= identifier |pnlb= property )
			int alt149=3;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt149=1;
				}
				break;
			case ID:
				{
				int LA149_2 = input.LA(2);
				if ( (LA149_2==COMMA||LA149_2==DOTDOT||LA149_2==RBRACKET) ) {
					alt149=2;
				}
				else if ( (LA149_2==DOUBLE_COLON||LA149_2==OCTOTHORPE||LA149_2==PERIOD) ) {
					alt149=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 149, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_self:
			case OCTOTHORPE:
				{
				alt149=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 149, 0, input);
				throw nvae;
			}
			switch (alt149) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2862:5: ilb= INTEGER_LIT
					{
					ilb=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11865); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ilb_tree = (BAST)adaptor.create(ilb);
					adaptor.addChild(root_0, ilb_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2862:23: elb= identifier
					{
					pushFollow(FOLLOW_identifier_in_natural_range11871);
					elb=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, elb.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2862:40: pnlb= property
					{
					pushFollow(FOLLOW_property_in_natural_range11877);
					pnlb=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, pnlb.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:3: (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )?
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==DOTDOT) ) {
				alt151=1;
			}
			switch (alt151) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:5: dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property )
					{
					dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_natural_range11887); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					dd_tree = (BAST)adaptor.create(dd);
					root_0 = (BAST)adaptor.becomeRoot(dd_tree, root_0);
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:16: (iub= INTEGER_LIT |eub= identifier |pnub= property )
					int alt150=3;
					switch ( input.LA(1) ) {
					case INTEGER_LIT:
						{
						alt150=1;
						}
						break;
					case ID:
						{
						int LA150_2 = input.LA(2);
						if ( (LA150_2==COMMA||LA150_2==RBRACKET) ) {
							alt150=2;
						}
						else if ( (LA150_2==DOUBLE_COLON||LA150_2==OCTOTHORPE||LA150_2==PERIOD) ) {
							alt150=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 150, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					case LITERAL_self:
					case OCTOTHORPE:
						{
						alt150=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 150, 0, input);
						throw nvae;
					}
					switch (alt150) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:18: iub= INTEGER_LIT
							{
							iub=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11894); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							iub_tree = (BAST)adaptor.create(iub);
							adaptor.addChild(root_0, iub_tree);
							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:36: eub= identifier
							{
							pushFollow(FOLLOW_identifier_in_natural_range11900);
							eub=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, eub.getTree());

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:53: pnub= property
							{
							pushFollow(FOLLOW_property_in_natural_range11906);
							pnub=property();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, pnub.getTree());

							}
							break;

					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.naturalRange,re);
			      tellBNF(GrammarStrings.naturalRange,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "natural_range"


	public static class variant_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variant_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2875:1: variant_type : LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !;
	public final BLESStoASTParser.variant_type_return variant_type() throws RecognitionException {
		BLESStoASTParser.variant_type_return retval = new BLESStoASTParser.variant_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_variant255=null;
		Token LPAREN256=null;
		Token RPAREN258=null;
		ParserRuleReturnScope record_field257 =null;

		BAST LITERAL_variant255_tree=null;
		BAST LPAREN256_tree=null;
		BAST RPAREN258_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2876:3: ( LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2877:3: LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_variant255=(Token)match(input,LITERAL_variant,FOLLOW_LITERAL_variant_in_variant_type11943); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_variant255_tree = (BAST)adaptor.create(LITERAL_variant255);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_variant255_tree, root_0);
			}

			LPAREN256=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_variant_type11951); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2878:13: ( record_field )+
			int cnt152=0;
			loop152:
			while (true) {
				int alt152=2;
				int LA152_0 = input.LA(1);
				if ( (LA152_0==ID) ) {
					alt152=1;
				}

				switch (alt152) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2878:13: record_field
					{
					pushFollow(FOLLOW_record_field_in_variant_type11954);
					record_field257=record_field();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_field257.getTree());

					}
					break;

				default :
					if ( cnt152 >= 1 ) break loop152;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(152, input);
					throw eee;
				}
				cnt152++;
			}

			RPAREN258=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_variant_type11957); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.variantType,re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variant_type"


	public static class assertion_annex_subclause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_annex_subclause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2885:1: assertion_annex_subclause : ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )? ;
	public final BLESStoASTParser.assertion_annex_subclause_return assertion_annex_subclause() throws RecognitionException {
		BLESStoASTParser.assertion_annex_subclause_return retval = new BLESStoASTParser.assertion_annex_subclause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START259=null;
		Token ANNEX_END260=null;
		List<Object> list_a=null;
		ParserRuleReturnScope p =null;
		RuleReturnScope a = null;
		BAST ANNEX_START259_tree=null;
		BAST ANNEX_END260_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2886:3: ( ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2887:3: ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2887:3: ( ANNEX_START )?
			int alt153=2;
			int LA153_0 = input.LA(1);
			if ( (LA153_0==ANNEX_START) ) {
				alt153=1;
			}
			switch (alt153) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2887:3: ANNEX_START
					{
					ANNEX_START259=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_subclause11986); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START259);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2888:3: ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) )
			int alt155=2;
			int LA155_0 = input.LA(1);
			if ( (LA155_0==LASS) ) {
				alt155=1;
			}
			else if ( (LA155_0==AADL_STRING_LITERAL||LA155_0==ID||LA155_0==INTEGER_LIT||LA155_0==LBRACKET||LA155_0==LITERAL_abs||LA155_0==LITERAL_all||LA155_0==LITERAL_complex||LA155_0==LITERAL_def||LA155_0==LITERAL_exists||LA155_0==LITERAL_false||LA155_0==LITERAL_in||LA155_0==LITERAL_integer||LA155_0==LITERAL_natural||(LA155_0 >= LITERAL_not && LA155_0 <= LITERAL_now)||LA155_0==LITERAL_null||(LA155_0 >= LITERAL_rational && LA155_0 <= LITERAL_real)||LA155_0==LITERAL_self||LA155_0==LITERAL_stop||(LA155_0 >= LITERAL_time && LA155_0 <= LITERAL_timeout)||LA155_0==LITERAL_tops||LA155_0==LITERAL_true||LA155_0==LPAREN||LA155_0==MINUS||LA155_0==OCTOTHORPE||LA155_0==REAL_LIT) ) {
				alt155=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 155, 0, input);
				throw nvae;
			}

			switch (alt155) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2889:3: (a+= assertion )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2889:4: (a+= assertion )+
					int cnt154=0;
					loop154:
					while (true) {
						int alt154=2;
						int LA154_0 = input.LA(1);
						if ( (LA154_0==LASS) ) {
							alt154=1;
						}

						switch (alt154) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2889:4: a+= assertion
							{
							pushFollow(FOLLOW_assertion_in_assertion_annex_subclause11997);
							a=assertion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt154 >= 1 ) break loop154;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(154, input);
							throw eee;
						}
						cnt154++;
					}

					// AST REWRITE
					// elements: a
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: a
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
					root_0 = (BAST)adaptor.nil();
					// 2890:5: -> ^( ASSERTION_ANNEX ( $a)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2890:8: ^( ASSERTION_ANNEX ( $a)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
						if ( !(stream_a.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_a.hasNext() ) {
							adaptor.addChild(root_1, stream_a.nextTree());
						}
						stream_a.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2891:5: p= predicate
					{
					pushFollow(FOLLOW_predicate_in_assertion_annex_subclause12020);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					// AST REWRITE
					// elements: p
					// token labels: 
					// rule labels: p, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2892:5: -> ^( ASSERTION_ANNEX $p)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2892:8: ^( ASSERTION_ANNEX $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2894:3: ( ANNEX_END )?
			int alt156=2;
			int LA156_0 = input.LA(1);
			if ( (LA156_0==ANNEX_END) ) {
				alt156=1;
			}
			switch (alt156) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2894:3: ANNEX_END
					{
					ANNEX_END260=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_subclause12041); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END260);

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertionAnnexSubclause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_subclause"


	public static class assertion_annex_library_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_annex_library"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2901:1: assertion_annex_library : ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )? ;
	public final BLESStoASTParser.assertion_annex_library_return assertion_annex_library() throws RecognitionException {
		BLESStoASTParser.assertion_annex_library_return retval = new BLESStoASTParser.assertion_annex_library_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START261=null;
		Token ANNEX_END262=null;
		List<Object> list_a=null;
		RuleReturnScope a = null;
		BAST ANNEX_START261_tree=null;
		BAST ANNEX_END262_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2902:3: ( ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2903:3: ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2903:3: ( ANNEX_START )?
			int alt157=2;
			int LA157_0 = input.LA(1);
			if ( (LA157_0==ANNEX_START) ) {
				alt157=1;
			}
			switch (alt157) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2903:3: ANNEX_START
					{
					ANNEX_START261=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_library12069); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START261);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2904:3: ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2905:3: (a+= assertion )+
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2905:4: (a+= assertion )+
			int cnt158=0;
			loop158:
			while (true) {
				int alt158=2;
				int LA158_0 = input.LA(1);
				if ( (LA158_0==LASS) ) {
					alt158=1;
				}

				switch (alt158) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2905:4: a+= assertion
					{
					pushFollow(FOLLOW_assertion_in_assertion_annex_library12080);
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;

				default :
					if ( cnt158 >= 1 ) break loop158;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(158, input);
					throw eee;
				}
				cnt158++;
			}

			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2906:5: -> ^( ASSERTION_ANNEX ( $a)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2906:8: ^( ASSERTION_ANNEX ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2908:3: ( ANNEX_END )?
			int alt159=2;
			int LA159_0 = input.LA(1);
			if ( (LA159_0==ANNEX_END) ) {
				alt159=1;
			}
			switch (alt159) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2908:3: ANNEX_END
					{
					ANNEX_END262=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_library12103); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END262);

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertionAnnexLibrary,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_library"


	public static class assertion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2913:1: assertion : ll= LASS !ab= assertion_body RASS !;
	public final BLESStoASTParser.assertion_return assertion() throws RecognitionException {
		BLESStoASTParser.assertion_return retval = new BLESStoASTParser.assertion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ll=null;
		Token RASS263=null;
		ParserRuleReturnScope ab =null;

		BAST ll_tree=null;
		BAST RASS263_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2915:3: (ll= LASS !ab= assertion_body RASS !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2916:3: ll= LASS !ab= assertion_body RASS !
			{
			root_0 = (BAST)adaptor.nil();


			ll=(Token)match(input,LASS,FOLLOW_LASS_in_assertion12133); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_body_in_assertion12138);
			ab=assertion_body();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ab.getTree());

			RASS263=(Token)match(input,RASS,FOLLOW_RASS_in_assertion12140); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (MismatchedTokenException mte) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(mte,(BAST)retval.getTree());
			    tellBNF("\ntry using more parentheses near line "+
			      Integer.toString(ll.getLine()+startingLine)+", as if you\'re not parenthetic enough already"+
			      "\n",mte,retval.tree);
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.AssertionBNF,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion"


	public static class assertion_body_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_body"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2929:1: assertion_body : ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) );
	public final BLESStoASTParser.assertion_body_return assertion_body() throws RecognitionException {
		BLESStoASTParser.assertion_body_return retval = new BLESStoASTParser.assertion_body_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token cln=null;
		Token COLON264=null;
		Token ASSIGN265=null;
		Token ASSIGN266=null;
		ParserRuleReturnScope a =null;
		ParserRuleReturnScope lv1 =null;
		ParserRuleReturnScope ae =null;
		ParserRuleReturnScope lv =null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope p3 =null;

		BAST cln_tree=null;
		BAST COLON264_tree=null;
		BAST ASSIGN265_tree=null;
		BAST ASSIGN266_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion_enumeration=new RewriteRuleSubtreeStream(adaptor,"rule assertion_enumeration");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_formal_assertion_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_assertion_parameter_list");
		RewriteRuleSubtreeStream stream_assertion_function_value=new RewriteRuleSubtreeStream(adaptor,"rule assertion_function_value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2936:3: ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) )
			int alt162=6;
			alt162 = dfa162.predict(input);
			switch (alt162) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2938:3: (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2938:3: (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2938:5: a= identifier cln= COLON lv1= identifier ae= assertion_enumeration
					{
					pushFollow(FOLLOW_identifier_in_assertion_body12195);
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12199); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					pushFollow(FOLLOW_identifier_in_assertion_body12203);
					lv1=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(lv1.getTree());
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12207);
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_enumeration.add(ae.getTree());
					}

					// AST REWRITE
					// elements: lv1, a, ae
					// token labels: 
					// rule labels: a, ae, lv1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
					RewriteRuleSubtreeStream stream_lv1=new RewriteRuleSubtreeStream(adaptor,"rule lv1",lv1!=null?lv1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2939:5: -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2939:8: ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ENUMERATION, (a!=null?((BAST)a.getTree()):null).getToken(), "ASSERTION_ENUMERATION["+Integer.toString((a!=null?((BAST)a.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2941:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2941:22: ^( PARAMETERS $lv1)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv1.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_ae.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2944:3: ae= assertion_enumeration
					{
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12263);
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_enumeration.add(ae.getTree());
					// AST REWRITE
					// elements: ae
					// token labels: 
					// rule labels: ae, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2945:5: -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2945:8: ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ENUMERATION, (ae!=null?((BAST)ae.getTree()):null).getToken(), "ASSERTION_ENUMERATION["+Integer.toString((ae!=null?((BAST)ae.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_ae.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2948:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2948:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2948:5: a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate
					{
					pushFollow(FOLLOW_identifier_in_assertion_body12290);
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12294); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2948:30: (lv= formal_assertion_parameter_list )?
					int alt160=2;
					int LA160_0 = input.LA(1);
					if ( (LA160_0==ID) ) {
						alt160=1;
					}
					switch (alt160) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2948:30: lv= formal_assertion_parameter_list
							{
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12298);
							lv=formal_assertion_parameter_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_formal_assertion_parameter_list.add(lv.getTree());
							}
							break;

					}

					COLON264=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12301); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON264);

					pushFollow(FOLLOW_predicate_in_assertion_body12305);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					}

					// AST REWRITE
					// elements: a, p, p, a, lv
					// token labels: 
					// rule labels: p, a, lv, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2949:5: -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p)
					if (lv!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2949:20: ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p!=null?((BAST)p.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:22: ^( PARAMETERS $lv)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2951:5: -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2951:9: ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p!=null?((BAST)p.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2952:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:5: a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value
					{
					pushFollow(FOLLOW_identifier_in_assertion_body12397);
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12401); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:30: (lv= formal_assertion_parameter_list )?
					int alt161=2;
					int LA161_0 = input.LA(1);
					if ( (LA161_0==ID) ) {
						alt161=1;
					}
					switch (alt161) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:30: lv= formal_assertion_parameter_list
							{
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12405);
							lv=formal_assertion_parameter_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_formal_assertion_parameter_list.add(lv.getTree());
							}
							break;

					}

					ASSIGN265=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12408); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN265);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12412);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_value.add(e.getTree());
					}

					// AST REWRITE
					// elements: a, lv, e, a, e
					// token labels: 
					// rule labels: a, e, lv, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2955:5: -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e)
					if (lv!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2955:20: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2957:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2957:22: ^( PARAMETERS $lv)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2958:5: -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2958:8: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2960:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2965:5: ( ASSIGN e= assertion_function_value )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2965:5: ( ASSIGN e= assertion_function_value )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2965:7: ASSIGN e= assertion_function_value
					{
					ASSIGN266=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12503); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN266);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12507);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_value.add(e.getTree());
					}

					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2966:5: -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2966:8: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2970:5: p3= predicate
					{
					pushFollow(FOLLOW_predicate_in_assertion_body12543);
					p3=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p3.getTree());
					// AST REWRITE
					// elements: p3
					// token labels: 
					// rule labels: p3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p3=new RewriteRuleSubtreeStream(adaptor,"rule p3",p3!=null?p3.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2971:5: -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2971:8: ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p3!=null?((BAST)p3.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p3!=null?((BAST)p3.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_p3.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (YouIdiot yi) {
			yi.handleException();
		}
		catch (RecognitionException re) {
			 
			    Dump.it("Could you be missing parentheses?");
			    tellBNF(GrammarStrings.assertionBody,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_body"


	public static class formal_assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2980:1: formal_assertion_parameter : ID TILDE ^ type_name ;
	public final BLESStoASTParser.formal_assertion_parameter_return formal_assertion_parameter() throws RecognitionException {
		BLESStoASTParser.formal_assertion_parameter_return retval = new BLESStoASTParser.formal_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID267=null;
		Token TILDE268=null;
		ParserRuleReturnScope type_name269 =null;

		BAST ID267_tree=null;
		BAST TILDE268_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2981:3: ( ID TILDE ^ type_name )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2982:17: ID TILDE ^ type_name
			{
			root_0 = (BAST)adaptor.nil();


			ID267=(Token)match(input,ID,FOLLOW_ID_in_formal_assertion_parameter12594); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID267_tree = (BAST)adaptor.create(ID267);
			adaptor.addChild(root_0, ID267_tree);
			}

			TILDE268=(Token)match(input,TILDE,FOLLOW_TILDE_in_formal_assertion_parameter12596); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			TILDE268_tree = (BAST)adaptor.create(TILDE268);
			root_0 = (BAST)adaptor.becomeRoot(TILDE268_tree, root_0);
			}

			pushFollow(FOLLOW_type_name_in_formal_assertion_parameter12599);
			type_name269=type_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type_name269.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter"


	public static class formal_assertion_parameter_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_assertion_parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2985:1: formal_assertion_parameter_list : formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )? ;
	public final BLESStoASTParser.formal_assertion_parameter_list_return formal_assertion_parameter_list() throws RecognitionException {
		BLESStoASTParser.formal_assertion_parameter_list_return retval = new BLESStoASTParser.formal_assertion_parameter_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA271=null;
		Token COMMA273=null;
		ParserRuleReturnScope formal_assertion_parameter270 =null;
		ParserRuleReturnScope formal_assertion_parameter272 =null;
		ParserRuleReturnScope formal_assertion_parameter274 =null;

		BAST COMMA271_tree=null;
		BAST COMMA273_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2986:3: ( formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2987:3: formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12615);
			formal_assertion_parameter270=formal_assertion_parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter270.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2987:30: ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )?
			int alt164=2;
			int LA164_0 = input.LA(1);
			if ( (LA164_0==COMMA) ) {
				alt164=1;
			}
			switch (alt164) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2987:32: COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )*
					{
					COMMA271=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12619); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA271_tree = (BAST)adaptor.create(COMMA271);
					root_0 = (BAST)adaptor.becomeRoot(COMMA271_tree, root_0);
					}

					pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12622);
					formal_assertion_parameter272=formal_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter272.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2988:6: ( COMMA formal_assertion_parameter )*
					loop163:
					while (true) {
						int alt163=2;
						int LA163_0 = input.LA(1);
						if ( (LA163_0==COMMA) ) {
							alt163=1;
						}

						switch (alt163) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2988:8: COMMA formal_assertion_parameter
							{
							COMMA273=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12631); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							COMMA273_tree = (BAST)adaptor.create(COMMA273);
							adaptor.addChild(root_0, COMMA273_tree);
							}

							pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12633);
							formal_assertion_parameter274=formal_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter274.getTree());

							}
							break;

						default :
							break loop163;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter_list"


	public static class assertion_function_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_function_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2991:1: assertion_function_value : ( ( parenthesized_predicate IMP )=>cae= conditional_assertion_function -> $cae|e= assertion_expression -> $e);
	public final BLESStoASTParser.assertion_function_value_return assertion_function_value() throws RecognitionException {
		BLESStoASTParser.assertion_function_value_return retval = new BLESStoASTParser.assertion_function_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope cae =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_conditional_assertion_function=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_function");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2992:3: ( ( parenthesized_predicate IMP )=>cae= conditional_assertion_function -> $cae|e= assertion_expression -> $e)
			int alt165=2;
			int LA165_0 = input.LA(1);
			if ( (LA165_0==LPAREN) ) {
				int LA165_1 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt165=1;
				}
				else if ( (true) ) {
					alt165=2;
				}

			}
			else if ( (LA165_0==AADL_STRING_LITERAL||LA165_0==ID||LA165_0==INTEGER_LIT||LA165_0==LBRACKET||LA165_0==LITERAL_abs||LA165_0==LITERAL_complex||LA165_0==LITERAL_false||LA165_0==LITERAL_in||LA165_0==LITERAL_integer||LA165_0==LITERAL_natural||LA165_0==LITERAL_now||(LA165_0 >= LITERAL_null && LA165_0 <= LITERAL_numberof)||LA165_0==LITERAL_product||(LA165_0 >= LITERAL_rational && LA165_0 <= LITERAL_real)||LA165_0==LITERAL_self||LA165_0==LITERAL_sum||(LA165_0 >= LITERAL_time && LA165_0 <= LITERAL_timeout)||LA165_0==LITERAL_tops||LA165_0==LITERAL_true||LA165_0==MINUS||LA165_0==OCTOTHORPE||LA165_0==REAL_LIT) ) {
				alt165=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 165, 0, input);
				throw nvae;
			}

			switch (alt165) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2993:3: ( parenthesized_predicate IMP )=>cae= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_assertion_function_value12667);
					cae=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_function.add(cae.getTree());
					// AST REWRITE
					// elements: cae
					// token labels: 
					// rule labels: cae, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cae=new RewriteRuleSubtreeStream(adaptor,"rule cae",cae!=null?cae.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2995:5: -> $cae
					{
						adaptor.addChild(root_0, stream_cae.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2997:3: e= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_assertion_function_value12686);
					e=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2998:5: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_value"


	public static class conditional_assertion_function_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_assertion_function"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3001:1: conditional_assertion_function : ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN ) -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ ) ;
	public final BLESStoASTParser.conditional_assertion_function_return conditional_assertion_function() throws RecognitionException {
		BLESStoASTParser.conditional_assertion_function_return retval = new BLESStoASTParser.conditional_assertion_function_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token LPAREN275=null;
		Token COMMA276=null;
		Token RPAREN277=null;
		List<Object> list_cvp=null;
		RuleReturnScope cvp = null;
		BAST c_tree=null;
		BAST LPAREN275_tree=null;
		BAST COMMA276_tree=null;
		BAST RPAREN277_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_condition_value_pair=new RewriteRuleSubtreeStream(adaptor,"rule condition_value_pair");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3002:3: ( ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN ) -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3003:3: ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3003:3: ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3003:5: LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN
			{
			LPAREN275=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_function12712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN275);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12719);
			cvp=condition_value_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
			if (list_cvp==null) list_cvp=new ArrayList<Object>();
			list_cvp.add(cvp.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3004:30: (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3004:32: c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )*
			{
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12725); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12729);
			cvp=condition_value_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
			if (list_cvp==null) list_cvp=new ArrayList<Object>();
			list_cvp.add(cvp.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3005:4: ( COMMA cvp+= condition_value_pair )*
			loop166:
			while (true) {
				int alt166=2;
				int LA166_0 = input.LA(1);
				if ( (LA166_0==COMMA) ) {
					alt166=1;
				}

				switch (alt166) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3005:5: COMMA cvp+= condition_value_pair
					{
					COMMA276=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12736); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA276);

					pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12740);
					cvp=condition_value_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
					if (list_cvp==null) list_cvp=new ArrayList<Object>();
					list_cvp.add(cvp.getTree());
					}
					break;

				default :
					break loop166;
				}
			}

			}

			RPAREN277=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_function12750); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN277);

			}

			// AST REWRITE
			// elements: cvp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: cvp
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_cvp=new RewriteRuleSubtreeStream(adaptor,"token cvp",list_cvp);
			root_0 = (BAST)adaptor.nil();
			// 3007:5: -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3007:8: ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL_FUNCTION, c), root_1);
				if ( !(stream_cvp.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_cvp.hasNext() ) {
					adaptor.addChild(root_1, stream_cvp.nextTree());
				}
				stream_cvp.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_function"


	public static class condition_value_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "condition_value_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3011:1: condition_value_pair : parenthesized_predicate IMP ^ assertion_expression ;
	public final BLESStoASTParser.condition_value_pair_return condition_value_pair() throws RecognitionException {
		BLESStoASTParser.condition_value_pair_return retval = new BLESStoASTParser.condition_value_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token IMP279=null;
		ParserRuleReturnScope parenthesized_predicate278 =null;
		ParserRuleReturnScope assertion_expression280 =null;

		BAST IMP279_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3012:3: ( parenthesized_predicate IMP ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3013:3: parenthesized_predicate IMP ^ assertion_expression
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_parenthesized_predicate_in_condition_value_pair12791);
			parenthesized_predicate278=parenthesized_predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_predicate278.getTree());

			IMP279=(Token)match(input,IMP,FOLLOW_IMP_in_condition_value_pair12793); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			IMP279_tree = (BAST)adaptor.create(IMP279);
			root_0 = (BAST)adaptor.becomeRoot(IMP279_tree, root_0);
			}

			pushFollow(FOLLOW_assertion_expression_in_condition_value_pair12796);
			assertion_expression280=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression280.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "condition_value_pair"


	public static class assertion_enumeration_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_enumeration"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3016:1: assertion_enumeration : ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) );
	public final BLESStoASTParser.assertion_enumeration_return assertion_enumeration() throws RecognitionException {
		BLESStoASTParser.assertion_enumeration_return retval = new BLESStoASTParser.assertion_enumeration_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token PLUS_ARROW281=null;
		Token COMMA283=null;
		Token PLUS_ARROW285=null;
		ParserRuleReturnScope enumeration_pair282 =null;
		ParserRuleReturnScope enumeration_pair284 =null;
		ParserRuleReturnScope predicate_invocation286 =null;

		BAST PLUS_ARROW281_tree=null;
		BAST COMMA283_tree=null;
		BAST PLUS_ARROW285_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3017:3: ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) )
			int alt168=2;
			int LA168_0 = input.LA(1);
			if ( (LA168_0==PLUS_ARROW) ) {
				int LA168_1 = input.LA(2);
				if ( (LA168_1==ID) ) {
					int LA168_2 = input.LA(3);
					if ( (LA168_2==IMP) ) {
						alt168=1;
					}
					else if ( (LA168_2==LPAREN) ) {
						alt168=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 168, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 168, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 168, 0, input);
				throw nvae;
			}

			switch (alt168) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:3: ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* )
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:3: ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:4: PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )*
					{
					PLUS_ARROW281=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12814); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					PLUS_ARROW281_tree = (BAST)adaptor.create(PLUS_ARROW281);
					root_0 = (BAST)adaptor.becomeRoot(PLUS_ARROW281_tree, root_0);
					}

					pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12817);
					enumeration_pair282=enumeration_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_pair282.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:33: ( COMMA ! enumeration_pair )*
					loop167:
					while (true) {
						int alt167=2;
						int LA167_0 = input.LA(1);
						if ( (LA167_0==COMMA) ) {
							alt167=1;
						}

						switch (alt167) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:34: COMMA ! enumeration_pair
							{
							COMMA283=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_enumeration12820); if (state.failed) return retval;
							pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12823);
							enumeration_pair284=enumeration_pair();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_pair284.getTree());

							}
							break;

						default :
							break loop167;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:3: ( PLUS_ARROW ^ predicate_invocation )
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:3: ( PLUS_ARROW ^ predicate_invocation )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:4: PLUS_ARROW ^ predicate_invocation
					{
					PLUS_ARROW285=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12838); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					PLUS_ARROW285_tree = (BAST)adaptor.create(PLUS_ARROW285);
					root_0 = (BAST)adaptor.becomeRoot(PLUS_ARROW285_tree, root_0);
					}

					pushFollow(FOLLOW_predicate_invocation_in_assertion_enumeration12841);
					predicate_invocation286=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate_invocation286.getTree());

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_enumeration"


	public static class enumeration_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3023:1: enumeration_pair : ID ^ IMP ! predicate ;
	public final BLESStoASTParser.enumeration_pair_return enumeration_pair() throws RecognitionException {
		BLESStoASTParser.enumeration_pair_return retval = new BLESStoASTParser.enumeration_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID287=null;
		Token IMP288=null;
		ParserRuleReturnScope predicate289 =null;

		BAST ID287_tree=null;
		BAST IMP288_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3024:3: ( ID ^ IMP ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3025:27: ID ^ IMP ! predicate
			{
			root_0 = (BAST)adaptor.nil();


			ID287=(Token)match(input,ID,FOLLOW_ID_in_enumeration_pair12860); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID287_tree = (BAST)adaptor.create(ID287);
			root_0 = (BAST)adaptor.becomeRoot(ID287_tree, root_0);
			}

			IMP288=(Token)match(input,IMP,FOLLOW_IMP_in_enumeration_pair12863); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_enumeration_pair12866);
			predicate289=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate289.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_pair"


	public static class universal_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "universal_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3028:1: universal_quantification : a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate ;
	public final BLESStoASTParser.universal_quantification_return universal_quantification() throws RecognitionException {
		BLESStoASTParser.universal_quantification_return retval = new BLESStoASTParser.universal_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		Token r=null;
		ParserRuleReturnScope logic_variables290 =null;
		ParserRuleReturnScope logic_variable_domain291 =null;
		ParserRuleReturnScope predicate292 =null;

		BAST a_tree=null;
		BAST r_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3029:3: (a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3030:3: a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate
			{
			root_0 = (BAST)adaptor.nil();


			a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_universal_quantification12885); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			a_tree = (BAST)adaptor.create(a);
			root_0 = (BAST)adaptor.becomeRoot(a_tree, root_0);
			}

			pushFollow(FOLLOW_logic_variables_in_universal_quantification12888);
			logic_variables290=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variables290.getTree());

			pushFollow(FOLLOW_logic_variable_domain_in_universal_quantification12890);
			logic_variable_domain291=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variable_domain291.getTree());

			r=(Token)match(input,LITERAL_are,FOLLOW_LITERAL_are_in_universal_quantification12894); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_universal_quantification12897);
			predicate292=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate292.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			   Dump.it("RecognitionException caught by BLESStoAST.universal_quantification");
			   Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
			    tellBNF(GrammarStrings.universalQuantification,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_quantification"


	public static class existential_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "existential_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3038:1: existential_quantification : e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate ;
	public final BLESStoASTParser.existential_quantification_return existential_quantification() throws RecognitionException {
		BLESStoASTParser.existential_quantification_return retval = new BLESStoASTParser.existential_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token e=null;
		Token t=null;
		ParserRuleReturnScope logic_variables293 =null;
		ParserRuleReturnScope logic_variable_domain294 =null;
		ParserRuleReturnScope predicate295 =null;

		BAST e_tree=null;
		BAST t_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3039:3: (e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3040:3: e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate
			{
			root_0 = (BAST)adaptor.nil();


			e=(Token)match(input,LITERAL_exists,FOLLOW_LITERAL_exists_in_existential_quantification12923); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			e_tree = (BAST)adaptor.create(e);
			root_0 = (BAST)adaptor.becomeRoot(e_tree, root_0);
			}

			pushFollow(FOLLOW_logic_variables_in_existential_quantification12926);
			logic_variables293=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variables293.getTree());

			pushFollow(FOLLOW_logic_variable_domain_in_existential_quantification12928);
			logic_variable_domain294=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variable_domain294.getTree());

			t=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_existential_quantification12932); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_existential_quantification12935);
			predicate295=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate295.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("RecognitionException caught by BLESStoAST.existential_quantification");
			    tellBNF(GrammarStrings.existentialQuantification,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_quantification"


	public static class logic_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logic_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3047:1: logic_variables :i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) ;
	public final BLESStoASTParser.logic_variables_return logic_variables() throws RecognitionException {
		BLESStoASTParser.logic_variables_return retval = new BLESStoASTParser.logic_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token coln=null;
		Token COMMA296=null;
		List<Object> list_i=null;
		ParserRuleReturnScope aty =null;
		RuleReturnScope i = null;
		BAST coln_tree=null;
		BAST COMMA296_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion_type=new RewriteRuleSubtreeStream(adaptor,"rule assertion_type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3048:3: (i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:3: i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type
			{
			pushFollow(FOLLOW_identifier_in_logic_variables12963);
			i=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
			if (list_i==null) list_i=new ArrayList<Object>();
			list_i.add(i.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:17: ( COMMA i+= identifier )*
			loop169:
			while (true) {
				int alt169=2;
				int LA169_0 = input.LA(1);
				if ( (LA169_0==COMMA) ) {
					alt169=1;
				}

				switch (alt169) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:18: COMMA i+= identifier
					{
					COMMA296=(Token)match(input,COMMA,FOLLOW_COMMA_in_logic_variables12966); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA296);

					pushFollow(FOLLOW_identifier_in_logic_variables12970);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTree());
					}
					break;

				default :
					break loop169;
				}
			}

			coln=(Token)match(input,COLON,FOLLOW_COLON_in_logic_variables12976); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(coln);

			pushFollow(FOLLOW_assertion_type_in_logic_variables12980);
			aty=assertion_type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion_type.add(aty.getTree());
			// AST REWRITE
			// elements: aty, i, coln
			// token labels: coln
			// rule labels: aty, retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_coln=new RewriteRuleTokenStream(adaptor,"token coln",coln);
			RewriteRuleSubtreeStream stream_aty=new RewriteRuleSubtreeStream(adaptor,"rule aty",aty!=null?aty.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (BAST)adaptor.nil();
			// 3050:5: -> ^( $coln $aty ( $i)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3050:8: ^( $coln $aty ( $i)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_coln.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aty.nextTree());
				if ( !(stream_i.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_i.hasNext() ) {
					adaptor.addChild(root_1, stream_i.nextTree());
				}
				stream_i.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("RecognitionException caught by BLESStoAST.logic_variables");
			    tellBNF(GrammarStrings.logicVariables,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variables"


	public static class logic_variable_domain_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logic_variable_domain"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3058:1: logic_variable_domain : i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) ;
	public final BLESStoASTParser.logic_variable_domain_return logic_variable_domain() throws RecognitionException {
		BLESStoASTParser.logic_variable_domain_return retval = new BLESStoASTParser.logic_variable_domain_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token i=null;
		ParserRuleReturnScope l =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope predicate297 =null;

		BAST i_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleSubtreeStream stream_range_symbol=new RewriteRuleSubtreeStream(adaptor,"rule range_symbol");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3059:3: (i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3060:3: i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			{
			i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_logic_variable_domain13032); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3061:3: ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			int alt170=2;
			int LA170_0 = input.LA(1);
			if ( (LA170_0==LITERAL_sum) && (synpred8_BLESStoAST())) {
				alt170=1;
			}
			else if ( (LA170_0==LITERAL_product) && (synpred8_BLESStoAST())) {
				alt170=1;
			}
			else if ( (LA170_0==LITERAL_numberof) && (synpred8_BLESStoAST())) {
				alt170=1;
			}
			else if ( (LA170_0==MINUS) ) {
				int LA170_4 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_abs) ) {
				int LA170_5 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_true) ) {
				int LA170_6 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_false) ) {
				int LA170_7 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==INTEGER_LIT) ) {
				int LA170_8 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==REAL_LIT) ) {
				int LA170_9 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LBRACKET) ) {
				int LA170_10 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==ID) ) {
				int LA170_11 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==OCTOTHORPE) ) {
				int LA170_12 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_self) ) {
				int LA170_13 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==AADL_STRING_LITERAL) ) {
				int LA170_14 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_in) ) {
				int LA170_15 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_timeout) ) {
				int LA170_16 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_null) ) {
				int LA170_17 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_now) ) {
				int LA170_18 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_tops) ) {
				int LA170_19 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LPAREN) ) {
				int LA170_20 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_natural) ) {
				int LA170_21 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_integer) ) {
				int LA170_22 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_rational) ) {
				int LA170_23 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_real) ) {
				int LA170_24 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_complex) ) {
				int LA170_25 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_time) ) {
				int LA170_26 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_all||LA170_0==LITERAL_def||LA170_0==LITERAL_exists||LA170_0==LITERAL_not||LA170_0==LITERAL_stop) ) {
				alt170=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 170, 0, input);
				throw nvae;
			}

			switch (alt170) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3062:5: ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13061);
					l=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(l.getTree());
					pushFollow(FOLLOW_range_symbol_in_logic_variable_domain13065);
					rs=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_range_symbol.add(rs.getTree());
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13069);
					r=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(r.getTree());
					// AST REWRITE
					// elements: l, i, rs, r
					// token labels: i
					// rule labels: rs, r, l, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
					RewriteRuleSubtreeStream stream_l=new RewriteRuleSubtreeStream(adaptor,"rule l",l!=null?l.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3064:5: -> ^( $i ^( $rs $l $r) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:8: ^( $i ^( $rs $l $r) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:13: ^( $rs $l $r)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_2);
						adaptor.addChild(root_2, stream_l.nextTree());
						adaptor.addChild(root_2, stream_r.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3066:3: predicate
					{
					pushFollow(FOLLOW_predicate_in_logic_variable_domain13104);
					predicate297=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(predicate297.getTree());
					// AST REWRITE
					// elements: predicate, i
					// token labels: i
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3067:5: -> ^( $i predicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3067:8: ^( $i predicate )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						adaptor.addChild(root_1, stream_predicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (MismatchedTokenException re) {
			Dump.it("MismatchedTokenException caught by BLESStoAST.logic_variable_domain");
			    Dump.it("\ntry bounding your quantification, eat less food too\n");
			    tellBNF(GrammarStrings.logicVariableDomain,re,retval.tree);
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.logic_variable_domain");
			    tellBNF(GrammarStrings.logicVariableDomain,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variable_domain"


	public static class predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3077:1: predicate : ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? );
	public final BLESStoASTParser.predicate_return predicate() throws RecognitionException {
		BLESStoASTParser.predicate_return retval = new BLESStoASTParser.predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token imp=null;
		Token i=null;
		Token a=null;
		Token LITERAL_and301=null;
		Token LITERAL_and303=null;
		Token LITERAL_or305=null;
		Token LITERAL_or307=null;
		Token LITERAL_xor309=null;
		Token LITERAL_xor311=null;
		ParserRuleReturnScope universal_quantification298 =null;
		ParserRuleReturnScope existential_quantification299 =null;
		ParserRuleReturnScope subpredicate300 =null;
		ParserRuleReturnScope subpredicate302 =null;
		ParserRuleReturnScope subpredicate304 =null;
		ParserRuleReturnScope subpredicate306 =null;
		ParserRuleReturnScope subpredicate308 =null;
		ParserRuleReturnScope subpredicate310 =null;
		ParserRuleReturnScope subpredicate312 =null;
		ParserRuleReturnScope subpredicate313 =null;
		ParserRuleReturnScope subpredicate314 =null;
		ParserRuleReturnScope subpredicate315 =null;

		BAST imp_tree=null;
		BAST i_tree=null;
		BAST a_tree=null;
		BAST LITERAL_and301_tree=null;
		BAST LITERAL_and303_tree=null;
		BAST LITERAL_or305_tree=null;
		BAST LITERAL_or307_tree=null;
		BAST LITERAL_xor309_tree=null;
		BAST LITERAL_xor311_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3078:3: ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? )
			int alt175=3;
			switch ( input.LA(1) ) {
			case LITERAL_all:
				{
				alt175=1;
				}
				break;
			case LITERAL_exists:
				{
				alt175=2;
				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_def:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_stop:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt175=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 175, 0, input);
				throw nvae;
			}
			switch (alt175) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3079:3: universal_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_universal_quantification_in_predicate13164);
					universal_quantification298=universal_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, universal_quantification298.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3081:3: existential_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_existential_quantification_in_predicate13172);
					existential_quantification299=existential_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, existential_quantification299.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3083:3: subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_subpredicate_in_predicate13181);
					subpredicate300=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate300.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3084:5: ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
					int alt174=7;
					switch ( input.LA(1) ) {
						case LITERAL_and:
							{
							alt174=1;
							}
							break;
						case LITERAL_or:
							{
							alt174=2;
							}
							break;
						case LITERAL_xor:
							{
							alt174=3;
							}
							break;
						case LITERAL_implies:
							{
							alt174=4;
							}
							break;
						case LITERAL_iff:
							{
							alt174=5;
							}
							break;
						case IMP:
							{
							alt174=6;
							}
							break;
					}
					switch (alt174) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3085:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3085:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3085:7: LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )*
							{
							LITERAL_and301=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13199); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_and301_tree = (BAST)adaptor.create(LITERAL_and301);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_and301_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13202);
							subpredicate302=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate302.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3085:33: ( LITERAL_and ! subpredicate )*
							loop171:
							while (true) {
								int alt171=2;
								int LA171_0 = input.LA(1);
								if ( (LA171_0==LITERAL_and) ) {
									alt171=1;
								}

								switch (alt171) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3085:35: LITERAL_and ! subpredicate
									{
									LITERAL_and303=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13206); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13209);
									subpredicate304=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate304.getTree());

									}
									break;

								default :
									break loop171;
								}
							}

							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:7: LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )*
							{
							LITERAL_or305=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13229); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_or305_tree = (BAST)adaptor.create(LITERAL_or305);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_or305_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13232);
							subpredicate306=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate306.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:32: ( LITERAL_or ! subpredicate )*
							loop172:
							while (true) {
								int alt172=2;
								int LA172_0 = input.LA(1);
								if ( (LA172_0==LITERAL_or) ) {
									alt172=1;
								}

								switch (alt172) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:34: LITERAL_or ! subpredicate
									{
									LITERAL_or307=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13236); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13239);
									subpredicate308=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate308.getTree());

									}
									break;

								default :
									break loop172;
								}
							}

							}

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:7: LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )*
							{
							LITERAL_xor309=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13262); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_xor309_tree = (BAST)adaptor.create(LITERAL_xor309);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_xor309_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13265);
							subpredicate310=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate310.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:33: ( LITERAL_xor ! subpredicate )*
							loop173:
							while (true) {
								int alt173=2;
								int LA173_0 = input.LA(1);
								if ( (LA173_0==LITERAL_xor) ) {
									alt173=1;
								}

								switch (alt173) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:35: LITERAL_xor ! subpredicate
									{
									LITERAL_xor311=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13269); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13272);
									subpredicate312=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate312.getTree());

									}
									break;

								default :
									break loop173;
								}
							}

							}

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3091:5: imp= LITERAL_implies ^ subpredicate
							{
							imp=(Token)match(input,LITERAL_implies,FOLLOW_LITERAL_implies_in_predicate13294); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							imp_tree = (BAST)adaptor.create(imp);
							root_0 = (BAST)adaptor.becomeRoot(imp_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13297);
							subpredicate313=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate313.getTree());

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3093:5: i= LITERAL_iff ^ subpredicate
							{
							i=(Token)match(input,LITERAL_iff,FOLLOW_LITERAL_iff_in_predicate13316); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							i_tree = (BAST)adaptor.create(i);
							root_0 = (BAST)adaptor.becomeRoot(i_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13319);
							subpredicate314=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate314.getTree());

							}
							break;
						case 6 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3095:5: a= IMP ^ subpredicate
							{
							a=(Token)match(input,IMP,FOLLOW_IMP_in_predicate13337); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							a_tree = (BAST)adaptor.create(a);
							root_0 = (BAST)adaptor.becomeRoot(a_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13340);
							subpredicate315=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate315.getTree());

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.predicate");
			    tellBNF(GrammarStrings.predicate,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate"


	public static class subpredicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subpredicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3102:1: subpredicate : (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) ;
	public final BLESStoASTParser.subpredicate_return subpredicate() throws RecognitionException {
		BLESStoASTParser.subpredicate_return retval = new BLESStoASTParser.subpredicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token i=null;
		Token pe=null;
		Token tr=null;
		Token fa=null;
		Token st=null;
		Token d=null;
		ParserRuleReturnScope lhs =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope rhs =null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope ra =null;
		ParserRuleReturnScope target =null;
		ParserRuleReturnScope increment =null;
		ParserRuleReturnScope definedLogicVariable =null;
		ParserRuleReturnScope predicate_invocation316 =null;
		ParserRuleReturnScope timed_predicate317 =null;

		BAST n_tree=null;
		BAST i_tree=null;
		BAST pe_tree=null;
		BAST tr_tree=null;
		BAST fa_tree=null;
		BAST st_tree=null;
		BAST d_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_def=new RewriteRuleTokenStream(adaptor,"token LITERAL_def");
		RewriteRuleTokenStream stream_LITERAL_stop=new RewriteRuleTokenStream(adaptor,"token LITERAL_stop");
		RewriteRuleTokenStream stream_LITERAL_true=new RewriteRuleTokenStream(adaptor,"token LITERAL_true");
		RewriteRuleTokenStream stream_LITERAL_false=new RewriteRuleTokenStream(adaptor,"token LITERAL_false");
		RewriteRuleTokenStream stream_PLUS_EQUALS=new RewriteRuleTokenStream(adaptor,"token PLUS_EQUALS");
		RewriteRuleSubtreeStream stream_assertion_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_subexpression");
		RewriteRuleSubtreeStream stream_assertion_range=new RewriteRuleSubtreeStream(adaptor,"rule assertion_range");
		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_predicate_invocation=new RewriteRuleSubtreeStream(adaptor,"rule predicate_invocation");
		RewriteRuleSubtreeStream stream_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule assertion_parameter");
		RewriteRuleSubtreeStream stream_timed_predicate=new RewriteRuleSubtreeStream(adaptor,"rule timed_predicate");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3104:3: ( (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3105:3: (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3105:3: (n= LITERAL_not )?
			int alt176=2;
			int LA176_0 = input.LA(1);
			if ( (LA176_0==LITERAL_not) ) {
				alt176=1;
			}
			switch (alt176) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3105:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subpredicate13382); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3106:3: ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			int alt177=9;
			switch ( input.LA(1) ) {
			case MINUS:
				{
				int LA177_1 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_abs:
				{
				int LA177_2 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_true:
				{
				int LA177_3 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (true) ) {
					alt177=4;
				}

				}
				break;
			case LITERAL_false:
				{
				int LA177_4 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (true) ) {
					alt177=5;
				}

				}
				break;
			case INTEGER_LIT:
				{
				int LA177_5 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 5, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case REAL_LIT:
				{
				int LA177_6 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 6, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LBRACKET:
				{
				int LA177_7 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 7, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				int LA177_8 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=3;
				}
				else if ( (synpred12_BLESStoAST()) ) {
					alt177=7;
				}
				else if ( (true) ) {
					alt177=8;
				}

				}
				break;
			case OCTOTHORPE:
				{
				int LA177_9 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 9, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_self:
				{
				int LA177_10 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 10, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				int LA177_11 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 11, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_in:
				{
				int LA177_12 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 12, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_timeout:
				{
				int LA177_13 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 13, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_null:
				{
				int LA177_14 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 14, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_now:
				{
				int LA177_15 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 15, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_tops:
				{
				int LA177_16 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 16, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				int LA177_17 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (true) ) {
					alt177=8;
				}

				}
				break;
			case LITERAL_natural:
				{
				int LA177_18 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 18, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA177_19 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 19, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA177_20 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 20, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_real:
				{
				int LA177_21 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 21, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA177_22 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 22, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_time:
				{
				int LA177_23 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 23, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_stop:
				{
				alt177=6;
				}
				break;
			case LITERAL_def:
				{
				alt177=9;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 177, 0, input);
				throw nvae;
			}
			switch (alt177) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:3: ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13412);
					lhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(lhs.getTree());
					pushFollow(FOLLOW_relation_symbol_in_subpredicate13416);
					r=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(r.getTree());
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13420);
					rhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(rhs.getTree());
					// AST REWRITE
					// elements: rhs, n, rhs, lhs, r, lhs, r
					// token labels: n
					// rule labels: r, lhs, rhs, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
					RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs",lhs!=null?lhs.getTree():null);
					RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"rule rhs",rhs!=null?rhs.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3109:6: -> {n!=null}? ^( $n ^( $r $lhs $rhs) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:20: ^( $n ^( $r $lhs $rhs) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:26: ^( $r $lhs $rhs)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_r.nextNode(), root_2);
						adaptor.addChild(root_2, stream_lhs.nextTree());
						adaptor.addChild(root_2, stream_rhs.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3110:5: -> ^( $r $lhs $rhs)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:8: ^( $r $lhs $rhs)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_r.nextNode(), root_1);
						adaptor.addChild(root_1, stream_lhs.nextTree());
						adaptor.addChild(root_1, stream_rhs.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:3: ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13495);
					p=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(p.getTree());
					i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_subpredicate13499); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

					pushFollow(FOLLOW_assertion_range_in_subpredicate13503);
					ra=assertion_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_range.add(ra.getTree());
					// AST REWRITE
					// elements: n, p, i, i, p, ra, ra
					// token labels: i, n
					// rule labels: p, retval, ra
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ra=new RewriteRuleSubtreeStream(adaptor,"rule ra",ra!=null?ra.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3117:6: -> {n!=null}? ^( $n ^( $i $p $ra) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3117:20: ^( $n ^( $i $p $ra) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3117:26: ^( $i $p $ra)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						adaptor.addChild(root_2, stream_p.nextTree());
						adaptor.addChild(root_2, stream_ra.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3118:5: -> ^( $i $p $ra)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3118:8: ^( $i $p $ra)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_ra.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3120:3: ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression
					{
					pushFollow(FOLLOW_name_in_subpredicate13571);
					target=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(target.getTree());
					pe=(Token)match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_subpredicate13575); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS_EQUALS.add(pe);

					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13581);
					increment=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(increment.getTree());
					// AST REWRITE
					// elements: increment, target, pe
					// token labels: pe
					// rule labels: increment, retval, target
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_pe=new RewriteRuleTokenStream(adaptor,"token pe",pe);
					RewriteRuleSubtreeStream stream_increment=new RewriteRuleSubtreeStream(adaptor,"rule increment",increment!=null?increment.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target",target!=null?target.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3122:5: -> {n!=null}?
					if (n!=null) {
						root_0 = null;
					}

					else // 3123:5: -> ^( $pe $target $increment)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3123:8: ^( $pe $target $increment)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_pe.nextNode(), root_1);
						adaptor.addChild(root_1, stream_target.nextTree());
						adaptor.addChild(root_1, stream_increment.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3125:5: tr= LITERAL_true
					{
					tr=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_subpredicate13623); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_true.add(tr);

					// AST REWRITE
					// elements: tr, n, tr
					// token labels: tr, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_tr=new RewriteRuleTokenStream(adaptor,"token tr",tr);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3126:5: -> {n!=null}? ^( $n $tr)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3126:19: ^( $n $tr)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_tr.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3127:5: -> $tr
					{
						adaptor.addChild(root_0, stream_tr.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3128:5: fa= LITERAL_false
					{
					fa=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_subpredicate13661); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_false.add(fa);

					// AST REWRITE
					// elements: fa, fa, n
					// token labels: fa, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_fa=new RewriteRuleTokenStream(adaptor,"token fa",fa);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3129:5: -> {n!=null}? ^( $n $fa)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3129:19: ^( $n $fa)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_fa.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3130:5: -> $fa
					{
						adaptor.addChild(root_0, stream_fa.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3131:5: st= LITERAL_stop
					{
					st=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_subpredicate13697); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_stop.add(st);

					// AST REWRITE
					// elements: st, n, st
					// token labels: st, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_st=new RewriteRuleTokenStream(adaptor,"token st",st);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3132:5: -> {n!=null}? ^( $n $st)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3132:19: ^( $n $st)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_st.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3133:5: -> $st
					{
						adaptor.addChild(root_0, stream_st.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3134:5: ( ID LPAREN )=> predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_subpredicate13742);
					predicate_invocation316=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate_invocation.add(predicate_invocation316.getTree());
					// AST REWRITE
					// elements: predicate_invocation, n, predicate_invocation
					// token labels: n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3136:5: -> {n!=null}? ^( $n predicate_invocation )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3136:19: ^( $n predicate_invocation )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_predicate_invocation.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3137:5: -> predicate_invocation
					{
						adaptor.addChild(root_0, stream_predicate_invocation.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3139:3: timed_predicate
					{
					pushFollow(FOLLOW_timed_predicate_in_subpredicate13776);
					timed_predicate317=timed_predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_timed_predicate.add(timed_predicate317.getTree());
					// AST REWRITE
					// elements: n, timed_predicate, timed_predicate
					// token labels: n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3140:5: -> {n!=null}? ^( $n timed_predicate )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3140:19: ^( $n timed_predicate )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_timed_predicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3141:5: -> timed_predicate
					{
						adaptor.addChild(root_0, stream_timed_predicate.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3144:3: d= LITERAL_def definedLogicVariable= assertion_parameter
					{
					d=(Token)match(input,LITERAL_def,FOLLOW_LITERAL_def_in_subpredicate13813); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_def.add(d);

					pushFollow(FOLLOW_assertion_parameter_in_subpredicate13817);
					definedLogicVariable=assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_parameter.add(definedLogicVariable.getTree());
					// AST REWRITE
					// elements: definedLogicVariable, d
					// token labels: d
					// rule labels: definedLogicVariable, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
					RewriteRuleSubtreeStream stream_definedLogicVariable=new RewriteRuleSubtreeStream(adaptor,"rule definedLogicVariable",definedLogicVariable!=null?definedLogicVariable.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3145:5: -> ^( $d $definedLogicVariable)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3145:8: ^( $d $definedLogicVariable)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_d.nextNode(), root_1);
						adaptor.addChild(root_1, stream_definedLogicVariable.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.subpredicate");
			    tellBNF(GrammarStrings.predicateAtom,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subpredicate"


	public static class timed_predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timed_predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3153:1: timed_predicate : ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
	public final BLESStoASTParser.timed_predicate_return timed_predicate() throws RecognitionException {
		BLESStoASTParser.timed_predicate_return retval = new BLESStoASTParser.timed_predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK321=null;
		Token AT_SIGN322=null;
		Token CARET324=null;
		ParserRuleReturnScope name318 =null;
		ParserRuleReturnScope parenthesized_predicate319 =null;
		ParserRuleReturnScope predicate_invocation320 =null;
		ParserRuleReturnScope time_subexpression323 =null;
		ParserRuleReturnScope period_shift325 =null;

		BAST TICK321_tree=null;
		BAST AT_SIGN322_tree=null;
		BAST CARET324_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3154:3: ( ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3155:3: ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3155:3: ( name | parenthesized_predicate | predicate_invocation )
			int alt178=3;
			int LA178_0 = input.LA(1);
			if ( (LA178_0==ID) ) {
				int LA178_1 = input.LA(2);
				if ( (LA178_1==EOF||LA178_1==ANNEX_END||LA178_1==AT_SIGN||LA178_1==CARET||(LA178_1 >= COLON && LA178_1 <= COMMADOT)||(LA178_1 >= DOTCOMMA && LA178_1 <= DOTDOT)||LA178_1==IMP||LA178_1==LBRACKET||LA178_1==LITERAL_and||LA178_1==LITERAL_are||LA178_1==LITERAL_else||LA178_1==LITERAL_iff||LA178_1==LITERAL_implies||LA178_1==LITERAL_of||LA178_1==LITERAL_or||(LA178_1 >= LITERAL_that && LA178_1 <= LITERAL_then)||LA178_1==LITERAL_xor||LA178_1==PERIOD||LA178_1==QQ||LA178_1==RASS||LA178_1==RPAREN||LA178_1==TICK) ) {
					alt178=1;
				}
				else if ( (LA178_1==LPAREN) ) {
					alt178=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA178_0==LPAREN) ) {
				alt178=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 178, 0, input);
				throw nvae;
			}

			switch (alt178) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3155:4: name
					{
					pushFollow(FOLLOW_name_in_timed_predicate13866);
					name318=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, name318.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3155:11: parenthesized_predicate
					{
					pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate13870);
					parenthesized_predicate319=parenthesized_predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_predicate319.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3155:37: predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_timed_predicate13874);
					predicate_invocation320=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate_invocation320.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3156:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			int alt179=4;
			switch ( input.LA(1) ) {
				case TICK:
					{
					alt179=1;
					}
					break;
				case AT_SIGN:
					{
					alt179=2;
					}
					break;
				case CARET:
					{
					alt179=3;
					}
					break;
			}
			switch (alt179) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3156:4: TICK ^
					{
					TICK321=(Token)match(input,TICK,FOLLOW_TICK_in_timed_predicate13880); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TICK321_tree = (BAST)adaptor.create(TICK321);
					root_0 = (BAST)adaptor.becomeRoot(TICK321_tree, root_0);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN322=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_predicate13888); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AT_SIGN322_tree = (BAST)adaptor.create(AT_SIGN322);
					root_0 = (BAST)adaptor.becomeRoot(AT_SIGN322_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_timed_predicate13891);
					time_subexpression323=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_subexpression323.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:6: CARET ^ period_shift
					{
					CARET324=(Token)match(input,CARET,FOLLOW_CARET_in_timed_predicate13900); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					CARET324_tree = (BAST)adaptor.create(CARET324);
					root_0 = (BAST)adaptor.becomeRoot(CARET324_tree, root_0);
					}

					pushFollow(FOLLOW_period_shift_in_timed_predicate13903);
					period_shift325=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, period_shift325.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.timed_predicate");
			    tellBNF(GrammarStrings.timeExpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_predicate"


	public static class parenthesized_predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3165:1: parenthesized_predicate : LPAREN ^ predicate RPAREN ;
	public final BLESStoASTParser.parenthesized_predicate_return parenthesized_predicate() throws RecognitionException {
		BLESStoASTParser.parenthesized_predicate_return retval = new BLESStoASTParser.parenthesized_predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN326=null;
		Token RPAREN328=null;
		ParserRuleReturnScope predicate327 =null;

		BAST LPAREN326_tree=null;
		BAST RPAREN328_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3166:3: ( LPAREN ^ predicate RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3167:3: LPAREN ^ predicate RPAREN
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN326=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_predicate13941); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LPAREN326_tree = (BAST)adaptor.create(LPAREN326);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN326_tree, root_0);
			}

			pushFollow(FOLLOW_predicate_in_parenthesized_predicate13944);
			predicate327=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate327.getTree());

			RPAREN328=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_predicate13946); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RPAREN328_tree = (BAST)adaptor.create(RPAREN328);
			adaptor.addChild(root_0, RPAREN328_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_predicate"


	public static class floatingAtom_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "floatingAtom"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3170:1: floatingAtom : value ;
	public final BLESStoASTParser.floatingAtom_return floatingAtom() throws RecognitionException {
		BLESStoASTParser.floatingAtom_return retval = new BLESStoASTParser.floatingAtom_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope value329 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3171:3: ( value )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3172:3: value
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_value_in_floatingAtom13966);
			value329=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value329.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "floatingAtom"


	public static class period_shift_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "period_shift"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3175:1: period_shift : (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) );
	public final BLESStoASTParser.period_shift_return period_shift() throws RecognitionException {
		BLESStoASTParser.period_shift_return retval = new BLESStoASTParser.period_shift_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m2=null;
		Token lp=null;
		Token mia=null;
		Token rp=null;
		Token dia=null;
		Token pia=null;
		Token tia=null;
		Token PLUS330=null;
		Token TIMES331=null;
		List<Object> list_ia3=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope x =null;
		ParserRuleReturnScope ia =null;
		ParserRuleReturnScope ia2 =null;
		RuleReturnScope ia3 = null;
		BAST m2_tree=null;
		BAST lp_tree=null;
		BAST mia_tree=null;
		BAST rp_tree=null;
		BAST dia_tree=null;
		BAST pia_tree=null;
		BAST tia_tree=null;
		BAST PLUS330_tree=null;
		BAST TIMES331_tree=null;
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleSubtreeStream stream_period_shift=new RewriteRuleSubtreeStream(adaptor,"rule period_shift");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3177:3: (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) )
			int alt183=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt183=1;
				}
				break;
			case MINUS:
				{
				alt183=2;
				}
				break;
			case LPAREN:
				{
				alt183=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 183, 0, input);
				throw nvae;
			}
			switch (alt183) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3181:3: v= value
					{
					pushFollow(FOLLOW_value_in_period_shift13994);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					// AST REWRITE
					// elements: v
					// token labels: 
					// rule labels: v, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3183:3: -> $v
					{
						adaptor.addChild(root_0, stream_v.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3185:3: m2= MINUS x= period_shift
					{
					m2=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14012); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(m2);

					pushFollow(FOLLOW_period_shift_in_period_shift14016);
					x=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_period_shift.add(x.getTree());
					// AST REWRITE
					// elements: x
					// token labels: 
					// rule labels: x, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3186:3: -> ^( UNARY_MINUS[$m2] $x)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3186:6: ^( UNARY_MINUS[$m2] $x)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m2), root_1);
						adaptor.addChild(root_1, stream_x.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3191:3: lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_period_shift14042); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_period_shift_in_period_shift14046);
					ia=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_period_shift.add(ia.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3192:5: (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					int alt182=5;
					switch ( input.LA(1) ) {
					case MINUS:
						{
						alt182=1;
						}
						break;
					case DIVIDE:
						{
						alt182=2;
						}
						break;
					case PLUS:
						{
						alt182=3;
						}
						break;
					case TIMES:
						{
						alt182=4;
						}
						break;
					case RPAREN:
						{
						alt182=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 182, 0, input);
						throw nvae;
					}
					switch (alt182) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3192:7: mia= MINUS ia2= period_shift rp= RPAREN
							{
							mia=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14057); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(mia);

							pushFollow(FOLLOW_period_shift_in_period_shift14061);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14065); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3194:5: dia= DIVIDE ia2= period_shift rp= RPAREN
							{
							dia=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_period_shift14079); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(dia);

							pushFollow(FOLLOW_period_shift_in_period_shift14083);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14087); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3196:5: pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN
							{
							pia=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14101); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(pia);

							pushFollow(FOLLOW_period_shift_in_period_shift14105);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3196:31: ( PLUS ia3+= period_shift )*
							loop180:
							while (true) {
								int alt180=2;
								int LA180_0 = input.LA(1);
								if ( (LA180_0==PLUS) ) {
									alt180=1;
								}

								switch (alt180) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3196:32: PLUS ia3+= period_shift
									{
									PLUS330=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14108); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS330);

									pushFollow(FOLLOW_period_shift_in_period_shift14112);
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop180;
								}
							}

							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14118); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3198:5: tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN
							{
							tia=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14134); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(tia);

							pushFollow(FOLLOW_period_shift_in_period_shift14138);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3198:32: ( TIMES ia3+= period_shift )*
							loop181:
							while (true) {
								int alt181=2;
								int LA181_0 = input.LA(1);
								if ( (LA181_0==TIMES) ) {
									alt181=1;
								}

								switch (alt181) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3198:33: TIMES ia3+= period_shift
									{
									TIMES331=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14141); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES331);

									pushFollow(FOLLOW_period_shift_in_period_shift14145);
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop181;
								}
							}

							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14151); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3200:5: rp= RPAREN
							{
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14167); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;

					}

					// AST REWRITE
					// elements: rp, pia, lp, mia, ia2, ia3, ia, ia2, lp, lp, tia, rp, dia, ia2, ia, rp, ia2, ia, lp, rp, ia, ia3, lp, rp, ia
					// token labels: lp, mia, pia, tia, dia, rp
					// rule labels: ia, ia2, retval
					// token list labels: 
					// rule list labels: ia3
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_mia=new RewriteRuleTokenStream(adaptor,"token mia",mia);
					RewriteRuleTokenStream stream_pia=new RewriteRuleTokenStream(adaptor,"token pia",pia);
					RewriteRuleTokenStream stream_tia=new RewriteRuleTokenStream(adaptor,"token tia",tia);
					RewriteRuleTokenStream stream_dia=new RewriteRuleTokenStream(adaptor,"token dia",dia);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_ia=new RewriteRuleSubtreeStream(adaptor,"rule ia",ia!=null?ia.getTree():null);
					RewriteRuleSubtreeStream stream_ia2=new RewriteRuleSubtreeStream(adaptor,"rule ia2",ia2!=null?ia2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ia3=new RewriteRuleSubtreeStream(adaptor,"token ia3",list_ia3);
					root_0 = (BAST)adaptor.nil();
					// 3202:3: -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp)
					if (mia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3202:19: ^( $lp ^( $mia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3202:25: ^( $mia $ia $ia2)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_mia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3203:3: -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp)
					if (dia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3203:19: ^( $lp ^( $dia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3203:25: ^( $dia $ia $ia2)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_dia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3204:3: -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
					if (pia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3204:19: ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3204:25: ^( $pia $ia $ia2 ( $ia3)* )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_pia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3204:42: ( $ia3)*
						while ( stream_ia3.hasNext() ) {
							adaptor.addChild(root_2, stream_ia3.nextTree());
						}
						stream_ia3.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3205:3: -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
					if (tia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:19: ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:25: ^( $tia $ia $ia2 ( $ia3)* )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_tia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:42: ( $ia3)*
						while ( stream_ia3.hasNext() ) {
							adaptor.addChild(root_2, stream_ia3.nextTree());
						}
						stream_ia3.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3206:3: -> ^( $lp $ia $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3206:6: ^( $lp $ia $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ia.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    if ((re.getUnexpectedType()==BLESStoASTLexer.TICK)||(re.getUnexpectedType()==BLESStoASTLexer.CARET))
			      Dump.it("^ and ' are not allowed in integer atoms on rhs of ^");
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("RecognitionException caught by BLESStoAST.period_shift");
			//    tellBNF(GrammarStrings.predicateInvocation,re,$predicate_invocation.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "period_shift"


	public static class predicate_invocation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "predicate_invocation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3218:1: predicate_invocation : (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) );
	public final BLESStoASTParser.predicate_invocation_return predicate_invocation() throws RecognitionException {
		BLESStoASTParser.predicate_invocation_return retval = new BLESStoASTParser.predicate_invocation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token RPAREN332=null;
		Token RPAREN333=null;
		Token COMMA334=null;
		Token RPAREN335=null;
		List<Object> list_params=null;
		ParserRuleReturnScope i =null;
		ParserRuleReturnScope exp =null;
		RuleReturnScope params = null;
		BAST lp_tree=null;
		BAST RPAREN332_tree=null;
		BAST RPAREN333_tree=null;
		BAST COMMA334_tree=null;
		BAST RPAREN335_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_actual_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule actual_assertion_parameter");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3220:3: (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) )
			int alt185=3;
			int LA185_0 = input.LA(1);
			if ( (LA185_0==ID) ) {
				int LA185_1 = input.LA(2);
				if ( (LA185_1==LPAREN) ) {
					switch ( input.LA(3) ) {
					case RPAREN:
						{
						alt185=1;
						}
						break;
					case AADL_STRING_LITERAL:
					case INTEGER_LIT:
					case LBRACKET:
					case LITERAL_abs:
					case LITERAL_complex:
					case LITERAL_false:
					case LITERAL_in:
					case LITERAL_integer:
					case LITERAL_natural:
					case LITERAL_now:
					case LITERAL_null:
					case LITERAL_numberof:
					case LITERAL_product:
					case LITERAL_rational:
					case LITERAL_real:
					case LITERAL_self:
					case LITERAL_sum:
					case LITERAL_time:
					case LITERAL_timeout:
					case LITERAL_tops:
					case LITERAL_true:
					case LPAREN:
					case MINUS:
					case OCTOTHORPE:
					case REAL_LIT:
						{
						alt185=2;
						}
						break;
					case ID:
						{
						int LA185_5 = input.LA(4);
						if ( (LA185_5==AT_SIGN||LA185_5==CARET||LA185_5==DIVIDE||LA185_5==DOUBLE_COLON||LA185_5==EXP||LA185_5==LBRACKET||LA185_5==LITERAL_mod||LA185_5==LITERAL_rem||LA185_5==LPAREN||LA185_5==MINUS||LA185_5==OCTOTHORPE||(LA185_5 >= PERIOD && LA185_5 <= PLUS)||LA185_5==QUESTION||LA185_5==RPAREN||LA185_5==TICK||LA185_5==TIMES) ) {
							alt185=2;
						}
						else if ( (LA185_5==COLON) ) {
							alt185=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 185, 5, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 185, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 185, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 185, 0, input);
				throw nvae;
			}

			switch (alt185) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3221:3: i= identifier lp= LPAREN RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14335);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14339); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					RPAREN332=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14341); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN332);

					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: i, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3222:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3222:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_i.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3225:3: i= identifier lp= LPAREN exp= assertion_expression RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14376);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14380); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_predicate_invocation14384);
					exp=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(exp.getTree());
					RPAREN333=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14386); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN333);

					// AST REWRITE
					// elements: i, exp
					// token labels: 
					// rule labels: i, exp, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp",exp!=null?exp.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3226:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3226:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3227:9: ^( $i $exp)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						adaptor.addChild(root_2, stream_exp.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3229:3: i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14429);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14433); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14437);
					params=actual_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(params.getTree());
					if (list_params==null) list_params=new ArrayList<Object>();
					list_params.add(params.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3229:61: ( COMMA params+= actual_assertion_parameter )*
					loop184:
					while (true) {
						int alt184=2;
						int LA184_0 = input.LA(1);
						if ( (LA184_0==COMMA) ) {
							alt184=1;
						}

						switch (alt184) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3229:63: COMMA params+= actual_assertion_parameter
							{
							COMMA334=(Token)match(input,COMMA,FOLLOW_COMMA_in_predicate_invocation14441); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA334);

							pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14445);
							params=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(params.getTree());
							if (list_params==null) list_params=new ArrayList<Object>();
							list_params.add(params.getTree());
							}
							break;

						default :
							break loop184;
						}
					}

					RPAREN335=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14451); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN335);

					// AST REWRITE
					// elements: params, i
					// token labels: 
					// rule labels: i, retval
					// token list labels: 
					// rule list labels: params
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"token params",list_params);
					root_0 = (BAST)adaptor.nil();
					// 3230:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3230:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3231:9: ^( $i ( $params)+ )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						if ( !(stream_params.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_params.hasNext() ) {
							adaptor.addChild(root_2, stream_params.nextTree());
						}
						stream_params.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(i!=null?((BAST)i.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  Dump.it("RecognitionException caught by BLESStoAST.predicate_invocation"+
			  "\n\nDid you forget that parameters must be of the form \"formal:assertion_expression\"?");
			    tellBNF(GrammarStrings.predicateInvocation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate_invocation"


	public static class actual_assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "actual_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3239:1: actual_assertion_parameter : formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) ;
	public final BLESStoASTParser.actual_assertion_parameter_return actual_assertion_parameter() throws RecognitionException {
		BLESStoASTParser.actual_assertion_parameter_return retval = new BLESStoASTParser.actual_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token formal=null;
		Token c=null;
		ParserRuleReturnScope actual =null;

		BAST formal_tree=null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3240:3: (formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3241:3: formal= ID c= COLON actual= assertion_expression
			{
			formal=(Token)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter14508); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(formal);

			c=(Token)match(input,COLON,FOLLOW_COLON_in_actual_assertion_parameter14512); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			pushFollow(FOLLOW_assertion_expression_in_actual_assertion_parameter14516);
			actual=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
			// AST REWRITE
			// elements: actual, formal
			// token labels: formal
			// rule labels: actual, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_formal=new RewriteRuleTokenStream(adaptor,"token formal",formal);
			RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 3242:5: -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3242:8: ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETER, c, "PARAMETER["+(formal!=null?formal.getText():null)+"]"), root_1);
				adaptor.addChild(root_1, stream_formal.nextNode());
				adaptor.addChild(root_1, stream_actual.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_assertion_parameter"


	public static class range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3262:1: range : numeric_expression range_symbol ^ numeric_expression ;
	public final BLESStoASTParser.range_return range() throws RecognitionException {
		BLESStoASTParser.range_return retval = new BLESStoASTParser.range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope numeric_expression336 =null;
		ParserRuleReturnScope range_symbol337 =null;
		ParserRuleReturnScope numeric_expression338 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3263:3: ( numeric_expression range_symbol ^ numeric_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3264:3: numeric_expression range_symbol ^ numeric_expression
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_numeric_expression_in_range14562);
			numeric_expression336=numeric_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_expression336.getTree());

			pushFollow(FOLLOW_range_symbol_in_range14564);
			range_symbol337=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol337.getTree(), root_0);
			pushFollow(FOLLOW_numeric_expression_in_range14567);
			numeric_expression338=numeric_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_expression338.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nDid you forget to put spaces around your range symbol?\n");
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.range");
			    tellBNF(GrammarStrings.range,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range"


	public static class assertion_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3274:1: assertion_range : assertion_expression range_symbol ^ assertion_expression ;
	public final BLESStoASTParser.assertion_range_return assertion_range() throws RecognitionException {
		BLESStoASTParser.assertion_range_return retval = new BLESStoASTParser.assertion_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope assertion_expression339 =null;
		ParserRuleReturnScope range_symbol340 =null;
		ParserRuleReturnScope assertion_expression341 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3275:3: ( assertion_expression range_symbol ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3276:3: assertion_expression range_symbol ^ assertion_expression
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_assertion_expression_in_assertion_range14593);
			assertion_expression339=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression339.getTree());

			pushFollow(FOLLOW_range_symbol_in_assertion_range14595);
			range_symbol340=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol340.getTree(), root_0);
			pushFollow(FOLLOW_assertion_expression_in_assertion_range14598);
			assertion_expression341=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression341.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.assertion_range");
			    tellBNF(GrammarStrings.range,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_range"


	public static class assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3283:1: assertion_expression options {backtrack=true; } : ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) );
	public final BLESStoASTParser.assertion_expression_return assertion_expression() throws RecognitionException {
		BLESStoASTParser.assertion_expression_return retval = new BLESStoASTParser.assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_sum342=null;
		Token LITERAL_of345=null;
		Token LITERAL_product347=null;
		Token LITERAL_of350=null;
		Token LITERAL_numberof352=null;
		Token LITERAL_that355=null;
		Token PLUS358=null;
		Token TIMES360=null;
		Token MINUS362=null;
		Token DIVIDE364=null;
		Token EXP366=null;
		Token LITERAL_mod368=null;
		Token LITERAL_rem370=null;
		ParserRuleReturnScope logic_variables343 =null;
		ParserRuleReturnScope logic_variable_domain344 =null;
		ParserRuleReturnScope assertion_expression346 =null;
		ParserRuleReturnScope logic_variables348 =null;
		ParserRuleReturnScope logic_variable_domain349 =null;
		ParserRuleReturnScope assertion_expression351 =null;
		ParserRuleReturnScope logic_variables353 =null;
		ParserRuleReturnScope logic_variable_domain354 =null;
		ParserRuleReturnScope subpredicate356 =null;
		ParserRuleReturnScope assertion_subexpression357 =null;
		ParserRuleReturnScope assertion_subexpression359 =null;
		ParserRuleReturnScope assertion_subexpression361 =null;
		ParserRuleReturnScope assertion_subexpression363 =null;
		ParserRuleReturnScope assertion_subexpression365 =null;
		ParserRuleReturnScope assertion_subexpression367 =null;
		ParserRuleReturnScope assertion_subexpression369 =null;
		ParserRuleReturnScope assertion_subexpression371 =null;

		BAST LITERAL_sum342_tree=null;
		BAST LITERAL_of345_tree=null;
		BAST LITERAL_product347_tree=null;
		BAST LITERAL_of350_tree=null;
		BAST LITERAL_numberof352_tree=null;
		BAST LITERAL_that355_tree=null;
		BAST PLUS358_tree=null;
		BAST TIMES360_tree=null;
		BAST MINUS362_tree=null;
		BAST DIVIDE364_tree=null;
		BAST EXP366_tree=null;
		BAST LITERAL_mod368_tree=null;
		BAST LITERAL_rem370_tree=null;
		RewriteRuleTokenStream stream_LITERAL_of=new RewriteRuleTokenStream(adaptor,"token LITERAL_of");
		RewriteRuleTokenStream stream_LITERAL_numberof=new RewriteRuleTokenStream(adaptor,"token LITERAL_numberof");
		RewriteRuleTokenStream stream_LITERAL_that=new RewriteRuleTokenStream(adaptor,"token LITERAL_that");
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_product=new RewriteRuleTokenStream(adaptor,"token LITERAL_product");
		RewriteRuleTokenStream stream_LITERAL_sum=new RewriteRuleTokenStream(adaptor,"token LITERAL_sum");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_logic_variables=new RewriteRuleSubtreeStream(adaptor,"rule logic_variables");
		RewriteRuleSubtreeStream stream_subpredicate=new RewriteRuleSubtreeStream(adaptor,"rule subpredicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_assertion_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_subexpression");
		RewriteRuleSubtreeStream stream_logic_variable_domain=new RewriteRuleSubtreeStream(adaptor,"rule logic_variable_domain");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3285:3: ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) )
			int alt192=4;
			switch ( input.LA(1) ) {
			case LITERAL_sum:
				{
				alt192=1;
				}
				break;
			case LITERAL_product:
				{
				alt192=2;
				}
				break;
			case LITERAL_numberof:
				{
				alt192=3;
				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt192=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 192, 0, input);
				throw nvae;
			}
			switch (alt192) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3286:3: LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_sum342=(Token)match(input,LITERAL_sum,FOLLOW_LITERAL_sum_in_assertion_expression14633); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_sum.add(LITERAL_sum342);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14635);
					logic_variables343=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables343.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3286:31: ( logic_variable_domain )?
					int alt186=2;
					int LA186_0 = input.LA(1);
					if ( (LA186_0==LITERAL_in) ) {
						alt186=1;
					}
					switch (alt186) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3286:33: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14639);
							logic_variable_domain344=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain344.getTree());
							}
							break;

					}

					LITERAL_of345=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14644); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of345);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14646);
					assertion_expression346=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(assertion_expression346.getTree());
					// AST REWRITE
					// elements: LITERAL_sum, assertion_expression, logic_variable_domain, LITERAL_of, logic_variables
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3287:5: -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3287:8: ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_sum.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3287:39: ( logic_variable_domain )?
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_of.nextNode());
						adaptor.addChild(root_1, stream_assertion_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3289:3: LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_product347=(Token)match(input,LITERAL_product,FOLLOW_LITERAL_product_in_assertion_expression14678); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_product.add(LITERAL_product347);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14680);
					logic_variables348=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables348.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3289:35: ( logic_variable_domain )?
					int alt187=2;
					int LA187_0 = input.LA(1);
					if ( (LA187_0==LITERAL_in) ) {
						alt187=1;
					}
					switch (alt187) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3289:37: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14684);
							logic_variable_domain349=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain349.getTree());
							}
							break;

					}

					LITERAL_of350=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14689); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of350);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14691);
					assertion_expression351=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(assertion_expression351.getTree());
					// AST REWRITE
					// elements: LITERAL_product, logic_variable_domain, logic_variables, LITERAL_of, assertion_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3290:5: -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3290:8: ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_product.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3290:43: ( logic_variable_domain )?
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_of.nextNode());
						adaptor.addChild(root_1, stream_assertion_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:3: LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate
					{
					LITERAL_numberof352=(Token)match(input,LITERAL_numberof,FOLLOW_LITERAL_numberof_in_assertion_expression14721); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_numberof.add(LITERAL_numberof352);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14723);
					logic_variables353=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables353.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:36: ( logic_variable_domain )?
					int alt188=2;
					int LA188_0 = input.LA(1);
					if ( (LA188_0==LITERAL_in) ) {
						alt188=1;
					}
					switch (alt188) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:38: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14727);
							logic_variable_domain354=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain354.getTree());
							}
							break;

					}

					LITERAL_that355=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_assertion_expression14732); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_that.add(LITERAL_that355);

					pushFollow(FOLLOW_subpredicate_in_assertion_expression14734);
					subpredicate356=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subpredicate.add(subpredicate356.getTree());
					// AST REWRITE
					// elements: logic_variable_domain, subpredicate, logic_variables, LITERAL_numberof, LITERAL_that
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3293:5: -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3293:8: ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_numberof.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3293:44: ( logic_variable_domain )?
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_that.nextNode());
						adaptor.addChild(root_1, stream_subpredicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:3: assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
					{
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14768);
					assertion_subexpression357=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression357.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3296:3: ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
					int alt191=8;
					switch ( input.LA(1) ) {
					case PLUS:
						{
						alt191=1;
						}
						break;
					case TIMES:
						{
						alt191=2;
						}
						break;
					case MINUS:
						{
						alt191=3;
						}
						break;
					case DIVIDE:
						{
						alt191=4;
						}
						break;
					case EXP:
						{
						alt191=5;
						}
						break;
					case LITERAL_mod:
						{
						alt191=6;
						}
						break;
					case LITERAL_rem:
						{
						alt191=7;
						}
						break;
					case EOF:
					case ANNEX_END:
					case COLON:
					case COMMA:
					case COMMACOMMA:
					case COMMADOT:
					case DOTCOMMA:
					case DOTDOT:
					case IMP:
					case LITERAL_and:
					case LITERAL_are:
					case LITERAL_else:
					case LITERAL_iff:
					case LITERAL_implies:
					case LITERAL_of:
					case LITERAL_or:
					case LITERAL_that:
					case LITERAL_then:
					case LITERAL_xor:
					case QQ:
					case RASS:
					case RPAREN:
						{
						alt191=8;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 191, 0, input);
						throw nvae;
					}
					switch (alt191) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:3: ( PLUS assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:3: ( PLUS assertion_subexpression )+
							int cnt189=0;
							loop189:
							while (true) {
								int alt189=2;
								int LA189_0 = input.LA(1);
								if ( (LA189_0==PLUS) ) {
									alt189=1;
								}

								switch (alt189) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:5: PLUS assertion_subexpression
									{
									PLUS358=(Token)match(input,PLUS,FOLLOW_PLUS_in_assertion_expression14782); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS358);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14784);
									assertion_subexpression359=assertion_subexpression();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression359.getTree());
									}
									break;

								default :
									if ( cnt189 >= 1 ) break loop189;
									if (state.backtracking>0) {state.failed=true; return retval;}
									EarlyExitException eee = new EarlyExitException(189, input);
									throw eee;
								}
								cnt189++;
							}

							// AST REWRITE
							// elements: PLUS, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3298:5: -> ^( PLUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3298:8: ^( PLUS ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_PLUS.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:3: ( TIMES assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:3: ( TIMES assertion_subexpression )+
							int cnt190=0;
							loop190:
							while (true) {
								int alt190=2;
								int LA190_0 = input.LA(1);
								if ( (LA190_0==TIMES) ) {
									alt190=1;
								}

								switch (alt190) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:5: TIMES assertion_subexpression
									{
									TIMES360=(Token)match(input,TIMES,FOLLOW_TIMES_in_assertion_expression14817); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES360);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14819);
									assertion_subexpression361=assertion_subexpression();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression361.getTree());
									}
									break;

								default :
									if ( cnt190 >= 1 ) break loop190;
									if (state.backtracking>0) {state.failed=true; return retval;}
									EarlyExitException eee = new EarlyExitException(190, input);
									throw eee;
								}
								cnt190++;
							}

							// AST REWRITE
							// elements: TIMES, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3301:5: -> ^( TIMES ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3301:8: ^( TIMES ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_TIMES.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3303:3: MINUS assertion_subexpression
							{
							MINUS362=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_expression14853); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(MINUS362);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14855);
							assertion_subexpression363=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression363.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, MINUS
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3304:5: -> ^( MINUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3304:8: ^( MINUS ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_MINUS.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3306:3: DIVIDE assertion_subexpression
							{
							DIVIDE364=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_assertion_expression14886); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(DIVIDE364);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14888);
							assertion_subexpression365=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression365.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, DIVIDE
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3307:5: -> ^( DIVIDE ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3307:8: ^( DIVIDE ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_DIVIDE.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3309:3: EXP assertion_subexpression
							{
							EXP366=(Token)match(input,EXP,FOLLOW_EXP_in_assertion_expression14920); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EXP.add(EXP366);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14922);
							assertion_subexpression367=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression367.getTree());
							// AST REWRITE
							// elements: EXP, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3310:5: -> ^( EXP ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3310:8: ^( EXP ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_EXP.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 6 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3312:3: LITERAL_mod assertion_subexpression
							{
							LITERAL_mod368=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_assertion_expression14954); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_mod.add(LITERAL_mod368);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14956);
							assertion_subexpression369=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression369.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, LITERAL_mod
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3313:5: -> ^( LITERAL_mod ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3313:8: ^( LITERAL_mod ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_mod.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 7 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3315:3: LITERAL_rem assertion_subexpression
							{
							LITERAL_rem370=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_assertion_expression14981); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_rem.add(LITERAL_rem370);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14983);
							assertion_subexpression371=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression371.getTree());
							// AST REWRITE
							// elements: LITERAL_rem, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3316:5: -> ^( LITERAL_rem ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3316:8: ^( LITERAL_rem ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_rem.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 8 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3318:5: 
							{
							// AST REWRITE
							// elements: assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3318:5: -> assertion_subexpression
							{
								adaptor.addChild(root_0, stream_assertion_subexpression.nextTree());
							}


							retval.tree = root_0;
							}

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_expression"


	public static class assertion_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3326:1: assertion_subexpression : ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc);
	public final BLESStoASTParser.assertion_subexpression_return assertion_subexpression() throws RecognitionException {
		BLESStoASTParser.assertion_subexpression_return retval = new BLESStoASTParser.assertion_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		Token abs=null;
		ParserRuleReturnScope ts =null;
		ParserRuleReturnScope atc =null;

		BAST m_tree=null;
		BAST abs_tree=null;
		RewriteRuleTokenStream stream_LITERAL_abs=new RewriteRuleTokenStream(adaptor,"token LITERAL_abs");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_timed_expression=new RewriteRuleSubtreeStream(adaptor,"rule timed_expression");
		RewriteRuleSubtreeStream stream_assertion_type_conversion=new RewriteRuleSubtreeStream(adaptor,"rule assertion_type_conversion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3327:3: ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc)
			int alt194=2;
			int LA194_0 = input.LA(1);
			if ( (LA194_0==AADL_STRING_LITERAL||LA194_0==ID||LA194_0==INTEGER_LIT||LA194_0==LBRACKET||LA194_0==LITERAL_abs||LA194_0==LITERAL_false||LA194_0==LITERAL_in||LA194_0==LITERAL_now||LA194_0==LITERAL_null||LA194_0==LITERAL_self||LA194_0==LITERAL_timeout||LA194_0==LITERAL_tops||LA194_0==LITERAL_true||LA194_0==LPAREN||LA194_0==MINUS||LA194_0==OCTOTHORPE||LA194_0==REAL_LIT) ) {
				alt194=1;
			}
			else if ( (LA194_0==LITERAL_complex||LA194_0==LITERAL_integer||LA194_0==LITERAL_natural||(LA194_0 >= LITERAL_rational && LA194_0 <= LITERAL_real)||LA194_0==LITERAL_time) ) {
				alt194=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 194, 0, input);
				throw nvae;
			}

			switch (alt194) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3328:3: (m= MINUS |abs= LITERAL_abs )? ts= timed_expression
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3328:3: (m= MINUS |abs= LITERAL_abs )?
					int alt193=3;
					int LA193_0 = input.LA(1);
					if ( (LA193_0==MINUS) ) {
						alt193=1;
					}
					else if ( (LA193_0==LITERAL_abs) ) {
						alt193=2;
					}
					switch (alt193) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3328:5: m= MINUS
							{
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_subexpression15043); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(m);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3328:15: abs= LITERAL_abs
							{
							abs=(Token)match(input,LITERAL_abs,FOLLOW_LITERAL_abs_in_assertion_subexpression15049); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_abs.add(abs);

							}
							break;

					}

					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression15069);
					ts=timed_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_timed_expression.add(ts.getTree());
					// AST REWRITE
					// elements: ts, ts, ts, abs
					// token labels: abs
					// rule labels: retval, ts
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_abs=new RewriteRuleTokenStream(adaptor,"token abs",abs);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ts=new RewriteRuleSubtreeStream(adaptor,"rule ts",ts!=null?ts.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3356:5: -> {m!=null}? ^( UNARY_MINUS[$m] $ts)
					if (m!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3356:19: ^( UNARY_MINUS[$m] $ts)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_ts.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3357:5: -> {abs!=null}? ^( $abs $ts)
					if (abs!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3357:21: ^( $abs $ts)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_abs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ts.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3358:5: -> $ts
					{
						adaptor.addChild(root_0, stream_ts.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3364:6: atc= assertion_type_conversion
					{
					pushFollow(FOLLOW_assertion_type_conversion_in_assertion_subexpression15129);
					atc=assertion_type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_type_conversion.add(atc.getTree());
					// AST REWRITE
					// elements: atc
					// token labels: 
					// rule labels: atc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_atc=new RewriteRuleSubtreeStream(adaptor,"rule atc",atc!=null?atc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3365:5: -> $atc
					{
						adaptor.addChild(root_0, stream_atc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.assertion_subexpression");
			    tellBNF(GrammarStrings.predicateSubexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_subexpression"


	public static class timed_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timed_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3372:1: timed_expression : vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
	public final BLESStoASTParser.timed_expression_return timed_expression() throws RecognitionException {
		BLESStoASTParser.timed_expression_return retval = new BLESStoASTParser.timed_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK373=null;
		Token AT_SIGN374=null;
		Token CARET376=null;
		ParserRuleReturnScope vpa372 =null;
		ParserRuleReturnScope time_subexpression375 =null;
		ParserRuleReturnScope period_shift377 =null;

		BAST TICK373_tree=null;
		BAST AT_SIGN374_tree=null;
		BAST CARET376_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3373:3: ( vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3374:3: vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_vpa_in_timed_expression15162);
			vpa372=vpa();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, vpa372.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3375:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			int alt195=4;
			switch ( input.LA(1) ) {
				case TICK:
					{
					alt195=1;
					}
					break;
				case AT_SIGN:
					{
					alt195=2;
					}
					break;
				case CARET:
					{
					alt195=3;
					}
					break;
			}
			switch (alt195) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3375:4: TICK ^
					{
					TICK373=(Token)match(input,TICK,FOLLOW_TICK_in_timed_expression15167); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TICK373_tree = (BAST)adaptor.create(TICK373);
					root_0 = (BAST)adaptor.becomeRoot(TICK373_tree, root_0);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3376:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN374=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_expression15175); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AT_SIGN374_tree = (BAST)adaptor.create(AT_SIGN374);
					root_0 = (BAST)adaptor.becomeRoot(AT_SIGN374_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_timed_expression15178);
					time_subexpression375=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_subexpression375.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3377:6: CARET ^ period_shift
					{
					CARET376=(Token)match(input,CARET,FOLLOW_CARET_in_timed_expression15187); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					CARET376_tree = (BAST)adaptor.create(CARET376);
					root_0 = (BAST)adaptor.becomeRoot(CARET376_tree, root_0);
					}

					pushFollow(FOLLOW_period_shift_in_timed_expression15190);
					period_shift377=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, period_shift377.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_expression"


	public static class vpa_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "vpa"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3381:1: vpa : (v= value | parenthesized_assertion_expression | assertion_function_invocation );
	public final BLESStoASTParser.vpa_return vpa() throws RecognitionException {
		BLESStoASTParser.vpa_return retval = new BLESStoASTParser.vpa_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope v =null;
		ParserRuleReturnScope parenthesized_assertion_expression378 =null;
		ParserRuleReturnScope assertion_function_invocation379 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3382:3: (v= value | parenthesized_assertion_expression | assertion_function_invocation )
			int alt196=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt196=1;
				}
				break;
			case ID:
				{
				int LA196_2 = input.LA(2);
				if ( (LA196_2==LPAREN) ) {
					alt196=3;
				}
				else if ( (LA196_2==EOF||(LA196_2 >= AL && LA196_2 <= AM)||LA196_2==ANNEX_END||LA196_2==AT_SIGN||LA196_2==CARET||(LA196_2 >= COLON && LA196_2 <= COMMADOT)||LA196_2==DIVIDE||(LA196_2 >= DOTCOMMA && LA196_2 <= DOUBLE_COLON)||LA196_2==EQ||LA196_2==EXP||LA196_2==GT||LA196_2==IMP||LA196_2==LBRACKET||LA196_2==LITERAL_and||LA196_2==LITERAL_are||LA196_2==LITERAL_else||LA196_2==LITERAL_iff||(LA196_2 >= LITERAL_implies && LA196_2 <= LITERAL_in)||LA196_2==LITERAL_mod||LA196_2==LITERAL_of||LA196_2==LITERAL_or||LA196_2==LITERAL_rem||(LA196_2 >= LITERAL_that && LA196_2 <= LITERAL_then)||LA196_2==LITERAL_xor||LA196_2==LT||LA196_2==MINUS||LA196_2==NEQ||LA196_2==OCTOTHORPE||(LA196_2 >= PERIOD && LA196_2 <= PLUS)||(LA196_2 >= QQ && LA196_2 <= RASS)||LA196_2==RPAREN||LA196_2==TICK||LA196_2==TIMES) ) {
					alt196=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 196, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt196=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 196, 0, input);
				throw nvae;
			}
			switch (alt196) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3383:3: v= value
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_value_in_vpa15218);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, v.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3385:3: parenthesized_assertion_expression
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_parenthesized_assertion_expression_in_vpa15228);
					parenthesized_assertion_expression378=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_assertion_expression378.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3387:3: assertion_function_invocation
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_assertion_function_invocation_in_vpa15238);
					assertion_function_invocation379=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_function_invocation379.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vpa"


	public static class time_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3390:1: time_expression : lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? ;
	public final BLESStoASTParser.time_expression_return time_expression() throws RecognitionException {
		BLESStoASTParser.time_expression_return retval = new BLESStoASTParser.time_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token sym=null;
		Token PLUS380=null;
		Token TIMES381=null;
		List<Object> list_rhs=null;
		ParserRuleReturnScope lhs =null;
		RuleReturnScope rhs = null;
		BAST sym_tree=null;
		BAST PLUS380_tree=null;
		BAST TIMES381_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3391:3: (lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3392:3: lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_time_subexpression_in_time_expression15255);
			lhs=time_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, lhs.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3393:3: ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
			int alt199=8;
			switch ( input.LA(1) ) {
				case PLUS:
					{
					alt199=1;
					}
					break;
				case TIMES:
					{
					alt199=2;
					}
					break;
				case MINUS:
					{
					alt199=3;
					}
					break;
				case DIVIDE:
					{
					alt199=4;
					}
					break;
				case EXP:
					{
					alt199=5;
					}
					break;
				case LITERAL_mod:
					{
					alt199=6;
					}
					break;
				case LITERAL_rem:
					{
					alt199=7;
					}
					break;
			}
			switch (alt199) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3394:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3394:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3394:4: sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )*
					{
					sym=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15266); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15271);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3394:38: ( PLUS rhs+= time_subexpression )*
					loop197:
					while (true) {
						int alt197=2;
						int LA197_0 = input.LA(1);
						if ( (LA197_0==PLUS) ) {
							alt197=1;
						}

						switch (alt197) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3394:40: PLUS rhs+= time_subexpression
							{
							PLUS380=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15275); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PLUS380_tree = (BAST)adaptor.create(PLUS380);
							adaptor.addChild(root_0, PLUS380_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15279);
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop197;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:4: sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )*
					{
					sym=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15294); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15299);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:39: ( TIMES rhs+= time_subexpression )*
					loop198:
					while (true) {
						int alt198=2;
						int LA198_0 = input.LA(1);
						if ( (LA198_0==TIMES) ) {
							alt198=1;
						}

						switch (alt198) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:41: TIMES rhs+= time_subexpression
							{
							TIMES381=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15303); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							TIMES381_tree = (BAST)adaptor.create(TIMES381);
							adaptor.addChild(root_0, TIMES381_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15307);
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop198;
						}
					}

					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3398:3: (sym= MINUS ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3398:3: (sym= MINUS ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3398:4: sym= MINUS ^rhs+= time_subexpression
					{
					sym=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_expression15322); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15327);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3400:3: (sym= DIVIDE ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3400:3: (sym= DIVIDE ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3400:4: sym= DIVIDE ^rhs+= time_subexpression
					{
					sym=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_time_expression15340); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15345);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3402:3: (sym= EXP ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3402:3: (sym= EXP ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3402:4: sym= EXP ^rhs+= time_subexpression
					{
					sym=(Token)match(input,EXP,FOLLOW_EXP_in_time_expression15358); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15363);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:4: sym= LITERAL_mod ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_time_expression15376); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15381);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:4: sym= LITERAL_rem ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_time_expression15394); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15399);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_expression"


	public static class time_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3410:1: time_subexpression : (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) ;
	public final BLESStoASTParser.time_subexpression_return time_subexpression() throws RecognitionException {
		BLESStoASTParser.time_subexpression_return retval = new BLESStoASTParser.time_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token um=null;
		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope val =null;
		ParserRuleReturnScope afi =null;
		ParserRuleReturnScope exp =null;

		BAST um_tree=null;
		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_time_expression=new RewriteRuleSubtreeStream(adaptor,"rule time_expression");
		RewriteRuleSubtreeStream stream_assertion_function_invocation=new RewriteRuleSubtreeStream(adaptor,"rule assertion_function_invocation");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3411:3: ( (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3412:3: (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3412:3: (um= MINUS )?
			int alt200=2;
			int LA200_0 = input.LA(1);
			if ( (LA200_0==MINUS) ) {
				alt200=1;
			}
			switch (alt200) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3412:4: um= MINUS
					{
					um=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_subexpression15426); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(um);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3413:3: (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
			int alt201=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt201=1;
				}
				break;
			case ID:
				{
				int LA201_2 = input.LA(2);
				if ( (LA201_2==LPAREN) ) {
					alt201=2;
				}
				else if ( (LA201_2==EOF||(LA201_2 >= AL && LA201_2 <= AM)||LA201_2==ANNEX_END||(LA201_2 >= COLON && LA201_2 <= COMMADOT)||LA201_2==DIVIDE||(LA201_2 >= DOTCOMMA && LA201_2 <= DOUBLE_COLON)||LA201_2==EQ||LA201_2==EXP||LA201_2==GT||LA201_2==IMP||LA201_2==LBRACKET||LA201_2==LITERAL_and||LA201_2==LITERAL_are||LA201_2==LITERAL_else||LA201_2==LITERAL_iff||(LA201_2 >= LITERAL_implies && LA201_2 <= LITERAL_in)||LA201_2==LITERAL_mod||LA201_2==LITERAL_of||LA201_2==LITERAL_or||LA201_2==LITERAL_rem||(LA201_2 >= LITERAL_that && LA201_2 <= LITERAL_then)||LA201_2==LITERAL_xor||LA201_2==LT||LA201_2==MINUS||LA201_2==NEQ||LA201_2==OCTOTHORPE||(LA201_2 >= PERIOD && LA201_2 <= PLUS)||(LA201_2 >= QQ && LA201_2 <= RASS)||LA201_2==RPAREN||LA201_2==TICK||LA201_2==TIMES) ) {
					alt201=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 201, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt201=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 201, 0, input);
				throw nvae;
			}
			switch (alt201) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3413:5: val= value
					{
					pushFollow(FOLLOW_value_in_time_subexpression15436);
					val=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(val.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3414:5: afi= assertion_function_invocation
					{
					pushFollow(FOLLOW_assertion_function_invocation_in_time_subexpression15444);
					afi=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_invocation.add(afi.getTree());
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3415:5: lp= LPAREN exp= time_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_time_subexpression15453); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_time_expression_in_time_subexpression15457);
					exp=time_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_time_expression.add(exp.getTree());
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_time_subexpression15461); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					}
					break;

			}

			// AST REWRITE
			// elements: val, val, rp, lp, lp, exp, rp, afi, afi, exp
			// token labels: lp, rp
			// rule labels: val, afi, exp, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
			RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
			RewriteRuleSubtreeStream stream_val=new RewriteRuleSubtreeStream(adaptor,"rule val",val!=null?val.getTree():null);
			RewriteRuleSubtreeStream stream_afi=new RewriteRuleSubtreeStream(adaptor,"rule afi",afi!=null?afi.getTree():null);
			RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp",exp!=null?exp.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 3417:5: -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val)
			if ((um!=null)&&(val!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3417:35: ^( UNARY_MINUS[$um] $val)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				adaptor.addChild(root_1, stream_val.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3418:5: -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi)
			if ((um!=null)&&(afi!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3418:35: ^( UNARY_MINUS[$um] $afi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				adaptor.addChild(root_1, stream_afi.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3419:5: -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
			if ((um!=null)&&(lp!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3419:34: ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3419:53: ^( $lp $exp $rp)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_2);
				adaptor.addChild(root_2, stream_exp.nextTree());
				adaptor.addChild(root_2, stream_rp.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3420:5: -> {val!=null}? $val
			if (val!=null) {
				adaptor.addChild(root_0, stream_val.nextTree());
			}

			else // 3421:5: -> {afi!=null}? $afi
			if (afi!=null) {
				adaptor.addChild(root_0, stream_afi.nextTree());
			}

			else // 3422:5: -> ^( $lp $exp $rp)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:8: ^( $lp $exp $rp)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
				adaptor.addChild(root_1, stream_exp.nextTree());
				adaptor.addChild(root_1, stream_rp.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_subexpression"


	public static class assertion_function_invocation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_function_invocation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3425:1: assertion_function_invocation : (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) );
	public final BLESStoASTParser.assertion_function_invocation_return assertion_function_invocation() throws RecognitionException {
		BLESStoASTParser.assertion_function_invocation_return retval = new BLESStoASTParser.assertion_function_invocation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token assertion_function_identifier=null;
		Token lp=null;
		Token RPAREN382=null;
		Token COMMA383=null;
		Token RPAREN384=null;
		List<Object> list_list=null;
		ParserRuleReturnScope actual =null;
		RuleReturnScope list = null;
		BAST assertion_function_identifier_tree=null;
		BAST lp_tree=null;
		BAST RPAREN382_tree=null;
		BAST COMMA383_tree=null;
		BAST RPAREN384_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_actual_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule actual_assertion_parameter");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3426:3: (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) )
			int alt204=2;
			int LA204_0 = input.LA(1);
			if ( (LA204_0==ID) ) {
				int LA204_1 = input.LA(2);
				if ( (LA204_1==LPAREN) ) {
					int LA204_2 = input.LA(3);
					if ( (LA204_2==AADL_STRING_LITERAL||LA204_2==INTEGER_LIT||LA204_2==LBRACKET||LA204_2==LITERAL_abs||LA204_2==LITERAL_complex||LA204_2==LITERAL_false||LA204_2==LITERAL_in||LA204_2==LITERAL_integer||LA204_2==LITERAL_natural||LA204_2==LITERAL_now||(LA204_2 >= LITERAL_null && LA204_2 <= LITERAL_numberof)||LA204_2==LITERAL_product||(LA204_2 >= LITERAL_rational && LA204_2 <= LITERAL_real)||LA204_2==LITERAL_self||LA204_2==LITERAL_sum||(LA204_2 >= LITERAL_time && LA204_2 <= LITERAL_timeout)||LA204_2==LITERAL_tops||LA204_2==LITERAL_true||LA204_2==LPAREN||LA204_2==MINUS||LA204_2==OCTOTHORPE||LA204_2==REAL_LIT||LA204_2==RPAREN) ) {
						alt204=1;
					}
					else if ( (LA204_2==ID) ) {
						int LA204_4 = input.LA(4);
						if ( (LA204_4==AT_SIGN||LA204_4==CARET||LA204_4==DIVIDE||LA204_4==DOUBLE_COLON||LA204_4==EXP||LA204_4==LBRACKET||LA204_4==LITERAL_mod||LA204_4==LITERAL_rem||LA204_4==LPAREN||LA204_4==MINUS||LA204_4==OCTOTHORPE||(LA204_4 >= PERIOD && LA204_4 <= PLUS)||LA204_4==QUESTION||LA204_4==RPAREN||LA204_4==TICK||LA204_4==TIMES) ) {
							alt204=1;
						}
						else if ( (LA204_4==COLON) ) {
							alt204=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 204, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 204, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 204, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 204, 0, input);
				throw nvae;
			}

			switch (alt204) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3427:3: assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15581); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15585); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3427:52: (actual= assertion_expression )?
					int alt202=2;
					int LA202_0 = input.LA(1);
					if ( (LA202_0==AADL_STRING_LITERAL||LA202_0==ID||LA202_0==INTEGER_LIT||LA202_0==LBRACKET||LA202_0==LITERAL_abs||LA202_0==LITERAL_complex||LA202_0==LITERAL_false||LA202_0==LITERAL_in||LA202_0==LITERAL_integer||LA202_0==LITERAL_natural||LA202_0==LITERAL_now||(LA202_0 >= LITERAL_null && LA202_0 <= LITERAL_numberof)||LA202_0==LITERAL_product||(LA202_0 >= LITERAL_rational && LA202_0 <= LITERAL_real)||LA202_0==LITERAL_self||LA202_0==LITERAL_sum||(LA202_0 >= LITERAL_time && LA202_0 <= LITERAL_timeout)||LA202_0==LITERAL_tops||LA202_0==LITERAL_true||LA202_0==LPAREN||LA202_0==MINUS||LA202_0==OCTOTHORPE||LA202_0==REAL_LIT) ) {
						alt202=1;
					}
					switch (alt202) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3427:52: actual= assertion_expression
							{
							pushFollow(FOLLOW_assertion_expression_in_assertion_function_invocation15589);
							actual=assertion_expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
							}
							break;

					}

					RPAREN382=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15592); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN382);

					// AST REWRITE
					// elements: assertion_function_identifier, actual
					// token labels: assertion_function_identifier
					// rule labels: actual, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_assertion_function_identifier=new RewriteRuleTokenStream(adaptor,"token assertion_function_identifier",assertion_function_identifier);
					RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3428:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3428:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3429:9: ^( $assertion_function_identifier ( $actual)? )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3429:45: ( $actual)?
						if ( stream_actual.hasNext() ) {
							adaptor.addChild(root_2, stream_actual.nextTree());
						}
						stream_actual.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3431:3: assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15639); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15643); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15652);
					list=actual_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(list.getTree());
					if (list_list==null) list_list=new ArrayList<Object>();
					list_list.add(list.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:38: ( COMMA list+= actual_assertion_parameter )*
					loop203:
					while (true) {
						int alt203=2;
						int LA203_0 = input.LA(1);
						if ( (LA203_0==COMMA) ) {
							alt203=1;
						}

						switch (alt203) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:40: COMMA list+= actual_assertion_parameter
							{
							COMMA383=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_function_invocation15656); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA383);

							pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15660);
							list=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(list.getTree());
							if (list_list==null) list_list=new ArrayList<Object>();
							list_list.add(list.getTree());
							}
							break;

						default :
							break loop203;
						}
					}

					RPAREN384=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15665); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN384);

					// AST REWRITE
					// elements: assertion_function_identifier, list
					// token labels: assertion_function_identifier
					// rule labels: retval
					// token list labels: 
					// rule list labels: list
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_assertion_function_identifier=new RewriteRuleTokenStream(adaptor,"token assertion_function_identifier",assertion_function_identifier);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_list=new RewriteRuleSubtreeStream(adaptor,"token list",list_list);
					root_0 = (BAST)adaptor.nil();
					// 3433:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3433:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3434:9: ^( $assertion_function_identifier ( $list)+ )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						if ( !(stream_list.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_list.hasNext() ) {
							adaptor.addChild(root_2, stream_list.nextTree());
						}
						stream_list.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("Did you forget the formal identifier when invoking an assertion-function?");
			  Dump.it("actual_assertion_parameter ::= formal_identifier : actual_assertion_expression"); 
			  throw re;
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_invocation"


	public static class parenthesized_assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3441:1: parenthesized_assertion_expression : ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) );
	public final BLESStoASTParser.parenthesized_assertion_expression_return parenthesized_assertion_expression() throws RecognitionException {
		BLESStoASTParser.parenthesized_assertion_expression_return retval = new BLESStoASTParser.parenthesized_assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope cpe =null;
		ParserRuleReturnScope art =null;
		ParserRuleReturnScope caf =null;
		ParserRuleReturnScope pe =null;

		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_conditional_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_expression");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_conditional_assertion_function=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_function");
		RewriteRuleSubtreeStream stream_assertion_record_term=new RewriteRuleSubtreeStream(adaptor,"rule assertion_record_term");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3442:3: ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) )
			int alt205=4;
			int LA205_0 = input.LA(1);
			if ( (LA205_0==LPAREN) ) {
				int LA205_1 = input.LA(2);
				if ( (synpred16_BLESStoAST()) ) {
					alt205=1;
				}
				else if ( (synpred17_BLESStoAST()) ) {
					alt205=2;
				}
				else if ( (synpred18_BLESStoAST()) ) {
					alt205=3;
				}
				else if ( (true) ) {
					alt205=4;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 205, 0, input);
				throw nvae;
			}

			switch (alt205) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3443:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression
					{
					pushFollow(FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15752);
					cpe=conditional_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_expression.add(cpe.getTree());
					// AST REWRITE
					// elements: cpe
					// token labels: 
					// rule labels: cpe, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cpe=new RewriteRuleSubtreeStream(adaptor,"rule cpe",cpe!=null?cpe.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3445:5: -> $cpe
					{
						adaptor.addChild(root_0, stream_cpe.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3447:3: ( LPAREN ID ARROW )=>art= assertion_record_term
					{
					pushFollow(FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15782);
					art=assertion_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_record_term.add(art.getTree());
					// AST REWRITE
					// elements: art
					// token labels: 
					// rule labels: art, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_art=new RewriteRuleSubtreeStream(adaptor,"rule art",art!=null?art.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3449:5: -> $art
					{
						adaptor.addChild(root_0, stream_art.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3451:3: ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15816);
					caf=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_function.add(caf.getTree());
					// AST REWRITE
					// elements: caf
					// token labels: 
					// rule labels: caf, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_caf=new RewriteRuleSubtreeStream(adaptor,"rule caf",caf!=null?caf.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3453:5: -> $caf
					{
						adaptor.addChild(root_0, stream_caf.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3455:3: lp= LPAREN pe= assertion_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_assertion_expression15837); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_parenthesized_assertion_expression15841);
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(pe.getTree());
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_assertion_expression15845); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: lp, rp, pe
					// token labels: lp, rp
					// rule labels: pe, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_pe=new RewriteRuleSubtreeStream(adaptor,"rule pe",pe!=null?pe.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3456:5: -> ^( $lp $pe $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3456:8: ^( $lp $pe $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pe.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_assertion_expression"


	public static class conditional_assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3459:1: conditional_assertion_expression : ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) );
	public final BLESStoASTParser.conditional_assertion_expression_return conditional_assertion_expression() throws RecognitionException {
		BLESStoASTParser.conditional_assertion_expression_return retval = new BLESStoASTParser.conditional_assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token then=null;
		Token q=null;
		Token LPAREN385=null;
		Token LITERAL_if386=null;
		Token LITERAL_else387=null;
		Token RPAREN388=null;
		Token LPAREN389=null;
		Token COLON390=null;
		Token RPAREN391=null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope f =null;

		BAST then_tree=null;
		BAST q_tree=null;
		BAST LPAREN385_tree=null;
		BAST LITERAL_if386_tree=null;
		BAST LITERAL_else387_tree=null;
		BAST RPAREN388_tree=null;
		BAST LPAREN389_tree=null;
		BAST COLON390_tree=null;
		BAST RPAREN391_tree=null;
		RewriteRuleTokenStream stream_QQ=new RewriteRuleTokenStream(adaptor,"token QQ");
		RewriteRuleTokenStream stream_LITERAL_else=new RewriteRuleTokenStream(adaptor,"token LITERAL_else");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_then=new RewriteRuleTokenStream(adaptor,"token LITERAL_then");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3460:3: ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) )
			int alt206=2;
			int LA206_0 = input.LA(1);
			if ( (LA206_0==LPAREN) ) {
				int LA206_1 = input.LA(2);
				if ( (LA206_1==LITERAL_if) ) {
					alt206=1;
				}
				else if ( (LA206_1==AADL_STRING_LITERAL||LA206_1==ID||LA206_1==INTEGER_LIT||LA206_1==LBRACKET||LA206_1==LITERAL_abs||LA206_1==LITERAL_all||LA206_1==LITERAL_complex||LA206_1==LITERAL_def||LA206_1==LITERAL_exists||LA206_1==LITERAL_false||LA206_1==LITERAL_in||LA206_1==LITERAL_integer||LA206_1==LITERAL_natural||(LA206_1 >= LITERAL_not && LA206_1 <= LITERAL_now)||LA206_1==LITERAL_null||(LA206_1 >= LITERAL_rational && LA206_1 <= LITERAL_real)||LA206_1==LITERAL_self||LA206_1==LITERAL_stop||(LA206_1 >= LITERAL_time && LA206_1 <= LITERAL_timeout)||LA206_1==LITERAL_tops||LA206_1==LITERAL_true||LA206_1==LPAREN||LA206_1==MINUS||LA206_1==OCTOTHORPE||LA206_1==REAL_LIT) ) {
					alt206=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 206, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 206, 0, input);
				throw nvae;
			}

			switch (alt206) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3461:3: LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN
					{
					LPAREN385=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15877); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN385);

					LITERAL_if386=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_assertion_expression15879); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if386);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15883);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_assertion_expression15887); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15892);
					t=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(t.getTree());
					LITERAL_else387=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_assertion_expression15894); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else387);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15899);
					f=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(f.getTree());
					RPAREN388=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression15901); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN388);

					// AST REWRITE
					// elements: p, t, f
					// token labels: 
					// rule labels: p, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3462:5: -> ^( CONDITIONAL[$then] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3462:8: ^( CONDITIONAL[$then] $p $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, then), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3464:3: LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN
					{
					LPAREN389=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15929); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN389);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15933);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_assertion_expression15937); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15942);
					t=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(t.getTree());
					COLON390=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_assertion_expression15944); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON390);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15949);
					f=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(f.getTree());
					RPAREN391=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression15951); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN391);

					// AST REWRITE
					// elements: p, t, f
					// token labels: 
					// rule labels: p, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3465:5: -> ^( CONDITIONAL[$q] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3465:8: ^( CONDITIONAL[$q] $p $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, q), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_expression"


	public static class assertion_record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3468:1: assertion_record_term : LPAREN ^ ( assertion_record_value )+ RPAREN ;
	public final BLESStoASTParser.assertion_record_term_return assertion_record_term() throws RecognitionException {
		BLESStoASTParser.assertion_record_term_return retval = new BLESStoASTParser.assertion_record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN392=null;
		Token RPAREN394=null;
		ParserRuleReturnScope assertion_record_value393 =null;

		BAST LPAREN392_tree=null;
		BAST RPAREN394_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3469:3: ( LPAREN ^ ( assertion_record_value )+ RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3470:5: LPAREN ^ ( assertion_record_value )+ RPAREN
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN392=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_record_term15989); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LPAREN392_tree = (BAST)adaptor.create(LPAREN392);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN392_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3470:13: ( assertion_record_value )+
			int cnt207=0;
			loop207:
			while (true) {
				int alt207=2;
				int LA207_0 = input.LA(1);
				if ( (LA207_0==ID) ) {
					alt207=1;
				}

				switch (alt207) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3470:13: assertion_record_value
					{
					pushFollow(FOLLOW_assertion_record_value_in_assertion_record_term15992);
					assertion_record_value393=assertion_record_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_record_value393.getTree());

					}
					break;

				default :
					if ( cnt207 >= 1 ) break loop207;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(207, input);
					throw eee;
				}
				cnt207++;
			}

			RPAREN394=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_record_term15995); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RPAREN394_tree = (BAST)adaptor.create(RPAREN394);
			adaptor.addChild(root_0, RPAREN394_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_term"


	public static class assertion_record_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3473:1: assertion_record_value : ID ARROW ^ value SEMICOLON !;
	public final BLESStoASTParser.assertion_record_value_return assertion_record_value() throws RecognitionException {
		BLESStoASTParser.assertion_record_value_return retval = new BLESStoASTParser.assertion_record_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID395=null;
		Token ARROW396=null;
		Token SEMICOLON398=null;
		ParserRuleReturnScope value397 =null;

		BAST ID395_tree=null;
		BAST ARROW396_tree=null;
		BAST SEMICOLON398_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3474:3: ( ID ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3475:3: ID ARROW ^ value SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


			ID395=(Token)match(input,ID,FOLLOW_ID_in_assertion_record_value16010); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID395_tree = (BAST)adaptor.create(ID395);
			adaptor.addChild(root_0, ID395_tree);
			}

			ARROW396=(Token)match(input,ARROW,FOLLOW_ARROW_in_assertion_record_value16012); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ARROW396_tree = (BAST)adaptor.create(ARROW396);
			root_0 = (BAST)adaptor.becomeRoot(ARROW396_tree, root_0);
			}

			pushFollow(FOLLOW_value_in_assertion_record_value16015);
			value397=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value397.getTree());

			SEMICOLON398=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_assertion_record_value16017); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_value"


	public static class assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3478:1: assertion_parameter : ID ;
	public final BLESStoASTParser.assertion_parameter_return assertion_parameter() throws RecognitionException {
		BLESStoASTParser.assertion_parameter_return retval = new BLESStoASTParser.assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID399=null;

		BAST ID399_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3479:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3480:3: ID
			{
			root_0 = (BAST)adaptor.nil();


			ID399=(Token)match(input,ID,FOLLOW_ID_in_assertion_parameter16033); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID399_tree = (BAST)adaptor.create(ID399);
			adaptor.addChild(root_0, ID399_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_parameter"


	public static class assertion_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3483:1: assertion_type : ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference );
	public final BLESStoASTParser.assertion_type_return assertion_type() throws RecognitionException {
		BLESStoASTParser.assertion_type_return retval = new BLESStoASTParser.assertion_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_boolean400=null;
		Token LITERAL_natural401=null;
		Token LITERAL_integer402=null;
		Token LITERAL_rational403=null;
		Token LITERAL_real404=null;
		Token LITERAL_complex405=null;
		Token LITERAL_time406=null;
		ParserRuleReturnScope unique_component_classifier_reference407 =null;

		BAST LITERAL_boolean400_tree=null;
		BAST LITERAL_natural401_tree=null;
		BAST LITERAL_integer402_tree=null;
		BAST LITERAL_rational403_tree=null;
		BAST LITERAL_real404_tree=null;
		BAST LITERAL_complex405_tree=null;
		BAST LITERAL_time406_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3484:3: ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference )
			int alt208=8;
			switch ( input.LA(1) ) {
			case LITERAL_boolean:
				{
				alt208=1;
				}
				break;
			case LITERAL_natural:
				{
				alt208=2;
				}
				break;
			case LITERAL_integer:
				{
				alt208=3;
				}
				break;
			case LITERAL_rational:
				{
				alt208=4;
				}
				break;
			case LITERAL_real:
				{
				alt208=5;
				}
				break;
			case LITERAL_complex:
				{
				alt208=6;
				}
				break;
			case LITERAL_time:
				{
				alt208=7;
				}
				break;
			case ID:
				{
				alt208=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 208, 0, input);
				throw nvae;
			}
			switch (alt208) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:3: LITERAL_boolean
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_boolean400=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_assertion_type16051); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_boolean400_tree = (BAST)adaptor.create(LITERAL_boolean400);
					adaptor.addChild(root_0, LITERAL_boolean400_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:21: LITERAL_natural
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_natural401=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type16055); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_natural401_tree = (BAST)adaptor.create(LITERAL_natural401);
					adaptor.addChild(root_0, LITERAL_natural401_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:39: LITERAL_integer
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_integer402=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type16059); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_integer402_tree = (BAST)adaptor.create(LITERAL_integer402);
					adaptor.addChild(root_0, LITERAL_integer402_tree);
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:57: LITERAL_rational
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_rational403=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type16063); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_rational403_tree = (BAST)adaptor.create(LITERAL_rational403);
					adaptor.addChild(root_0, LITERAL_rational403_tree);
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:76: LITERAL_real
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_real404=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type16067); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_real404_tree = (BAST)adaptor.create(LITERAL_real404);
					adaptor.addChild(root_0, LITERAL_real404_tree);
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:91: LITERAL_complex
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_complex405=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type16071); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_complex405_tree = (BAST)adaptor.create(LITERAL_complex405);
					adaptor.addChild(root_0, LITERAL_complex405_tree);
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3486:4: LITERAL_time
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_time406=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type16076); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_time406_tree = (BAST)adaptor.create(LITERAL_time406);
					adaptor.addChild(root_0, LITERAL_time406_tree);
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:5: unique_component_classifier_reference
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_unique_component_classifier_reference_in_assertion_type16083);
					unique_component_classifier_reference407=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unique_component_classifier_reference407.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type"


	public static class availability_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3493:1: availability : LITERAL_availability ^ availability_subexpression ;
	public final BLESStoASTParser.availability_return availability() throws RecognitionException {
		BLESStoASTParser.availability_return retval = new BLESStoASTParser.availability_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_availability408=null;
		ParserRuleReturnScope availability_subexpression409 =null;

		BAST LITERAL_availability408_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3494:3: ( LITERAL_availability ^ availability_subexpression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:3: LITERAL_availability ^ availability_subexpression
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_availability408=(Token)match(input,LITERAL_availability,FOLLOW_LITERAL_availability_in_availability16109); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_availability408_tree = (BAST)adaptor.create(LITERAL_availability408);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_availability408_tree, root_0);
			}

			pushFollow(FOLLOW_availability_subexpression_in_availability16113);
			availability_subexpression409=availability_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, availability_subexpression409.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability"


	public static class availability_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3498:1: availability_expression :ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae;
	public final BLESStoASTParser.availability_expression_return availability_expression() throws RecognitionException {
		BLESStoASTParser.availability_expression_return retval = new BLESStoASTParser.availability_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dna=null;
		Token ro=null;
		Token rox=null;
		List<Object> list_ae=null;
		RuleReturnScope ae = null;
		BAST dna_tree=null;
		BAST ro_tree=null;
		BAST rox_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleSubtreeStream stream_availability_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule availability_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3499:3: (ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3500:3: ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
			{
			pushFollow(FOLLOW_availability_subexpression_in_availability_expression16134);
			ae=availability_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
			if (list_ae==null) list_ae=new ArrayList<Object>();
			list_ae.add(ae.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3501:3: ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
			int alt212=4;
			switch ( input.LA(1) ) {
				case LITERAL_and:
					{
					alt212=1;
					}
					break;
				case LITERAL_or:
					{
					alt212=2;
					}
					break;
				case LITERAL_xor:
					{
					alt212=3;
					}
					break;
			}
			switch (alt212) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3502:5: (dna= LITERAL_and ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3502:5: (dna= LITERAL_and ae+= availability_subexpression )+
					int cnt209=0;
					loop209:
					while (true) {
						int alt209=2;
						int LA209_0 = input.LA(1);
						if ( (LA209_0==LITERAL_and) ) {
							alt209=1;
						}

						switch (alt209) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3502:7: dna= LITERAL_and ae+= availability_subexpression
							{
							dna=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_availability_expression16148); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(dna);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16152);
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt209 >= 1 ) break loop209;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(209, input);
							throw eee;
						}
						cnt209++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3504:5: (ro= LITERAL_or ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3504:5: (ro= LITERAL_or ae+= availability_subexpression )+
					int cnt210=0;
					loop210:
					while (true) {
						int alt210=2;
						int LA210_0 = input.LA(1);
						if ( (LA210_0==LITERAL_or) ) {
							alt210=1;
						}

						switch (alt210) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3504:7: ro= LITERAL_or ae+= availability_subexpression
							{
							ro=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_availability_expression16171); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(ro);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16175);
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt210 >= 1 ) break loop210;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(210, input);
							throw eee;
						}
						cnt210++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3506:5: (rox= LITERAL_xor ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3506:5: (rox= LITERAL_xor ae+= availability_subexpression )+
					int cnt211=0;
					loop211:
					while (true) {
						int alt211=2;
						int LA211_0 = input.LA(1);
						if ( (LA211_0==LITERAL_xor) ) {
							alt211=1;
						}

						switch (alt211) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3506:7: rox= LITERAL_xor ae+= availability_subexpression
							{
							rox=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_availability_expression16194); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(rox);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16198);
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt211 >= 1 ) break loop211;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(211, input);
							throw eee;
						}
						cnt211++;
					}

					}
					break;

			}

			// AST REWRITE
			// elements: ae, ae, ae, rox, ro, ae, dna
			// token labels: dna, rox, ro
			// rule labels: retval
			// token list labels: 
			// rule list labels: ae
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dna=new RewriteRuleTokenStream(adaptor,"token dna",dna);
			RewriteRuleTokenStream stream_rox=new RewriteRuleTokenStream(adaptor,"token rox",rox);
			RewriteRuleTokenStream stream_ro=new RewriteRuleTokenStream(adaptor,"token ro",ro);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"token ae",list_ae);
			root_0 = (BAST)adaptor.nil();
			// 3508:5: -> {dna!=null}? ^( $dna ( $ae)+ )
			if (dna!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3508:21: ^( $dna ( $ae)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dna.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3509:5: -> {ro!=null}? ^( $ro ( $ae)+ )
			if (ro!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:20: ^( $ro ( $ae)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_ro.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3510:5: -> {rox!=null}? ^( $rox ( $ae)+ )
			if (rox!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3510:21: ^( $rox ( $ae)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_rox.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3511:5: -> $ae
			{
				adaptor.addChild(root_0, stream_ae.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_expression"


	public static class availability_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3514:1: availability_subexpression : (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id;
	public final BLESStoASTParser.availability_subexpression_return availability_subexpression() throws RecognitionException {
		BLESStoASTParser.availability_subexpression_return retval = new BLESStoASTParser.availability_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token l=null;
		Token RPAREN410=null;
		ParserRuleReturnScope id =null;
		ParserRuleReturnScope ae =null;

		BAST n_tree=null;
		BAST l_tree=null;
		BAST RPAREN410_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_availability_expression=new RewriteRuleSubtreeStream(adaptor,"rule availability_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3515:3: ( (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3516:3: (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3516:3: (n= LITERAL_not )?
			int alt213=2;
			int LA213_0 = input.LA(1);
			if ( (LA213_0==LITERAL_not) ) {
				alt213=1;
			}
			switch (alt213) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3516:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_availability_subexpression16290); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3517:3: (id= identifier |l= LPAREN ae= availability_expression RPAREN )
			int alt214=2;
			int LA214_0 = input.LA(1);
			if ( (LA214_0==ID) ) {
				alt214=1;
			}
			else if ( (LA214_0==LPAREN) ) {
				alt214=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 214, 0, input);
				throw nvae;
			}

			switch (alt214) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3518:3: id= identifier
					{
					pushFollow(FOLLOW_identifier_in_availability_subexpression16305);
					id=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3520:3: l= LPAREN ae= availability_expression RPAREN
					{
					l=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_availability_subexpression16315); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(l);

					pushFollow(FOLLOW_availability_expression_in_availability_subexpression16319);
					ae=availability_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_availability_expression.add(ae.getTree());
					RPAREN410=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_availability_subexpression16321); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN410);

					}
					break;

			}

			// AST REWRITE
			// elements: n, l, n, ae, ae, id, id, l
			// token labels: l, n
			// rule labels: ae, id, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_l=new RewriteRuleTokenStream(adaptor,"token l",l);
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 3522:5: -> {n!=null&&id!=null}? ^( $n $id)
			if (n!=null&&id!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3522:29: ^( $n $id)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_id.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3523:5: -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) )
			if (n!=null&&ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3523:29: ^( $n ^( $l $ae) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3523:34: ^( $l $ae)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_l.nextNode(), root_2);
				adaptor.addChild(root_2, stream_ae.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3524:5: -> {ae!=null}? ^( $l $ae)
			if (ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3524:20: ^( $l $ae)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_l.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ae.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3525:5: -> $id
			{
				adaptor.addChild(root_0, stream_id.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_subexpression"


	public static class dispatch_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3531:1: dispatch_condition : 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? ;
	public final BLESStoASTParser.dispatch_condition_return dispatch_condition() throws RecognitionException {
		BLESStoASTParser.dispatch_condition_return retval = new BLESStoASTParser.dispatch_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token string_literal411=null;
		Token LITERAL_dispatch412=null;
		ParserRuleReturnScope dispatch_expression413 =null;

		BAST string_literal411_tree=null;
		BAST LITERAL_dispatch412_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3532:3: ( 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3533:3: 'on' ! LITERAL_dispatch ^ ( dispatch_expression )?
			{
			root_0 = (BAST)adaptor.nil();


			string_literal411=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_dispatch_condition16409); if (state.failed) return retval;
			LITERAL_dispatch412=(Token)match(input,LITERAL_dispatch,FOLLOW_LITERAL_dispatch_in_dispatch_condition16412); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_dispatch412_tree = (BAST)adaptor.create(LITERAL_dispatch412);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_dispatch412_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3533:28: ( dispatch_expression )?
			int alt215=2;
			int LA215_0 = input.LA(1);
			if ( (LA215_0==ID||LA215_0==LITERAL_stop||LA215_0==LITERAL_timeout) ) {
				alt215=1;
			}
			switch (alt215) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3533:28: dispatch_expression
					{
					pushFollow(FOLLOW_dispatch_expression_in_dispatch_condition16416);
					dispatch_expression413=dispatch_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dispatch_expression413.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("RecognitionException caught by BLESStoAST.dispatch_condition");
			    tellBNF(GrammarStrings.dispatchCondition,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_condition"


	public static class dispatch_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3541:1: dispatch_expression : dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc;
	public final BLESStoASTParser.dispatch_expression_return dispatch_expression() throws RecognitionException {
		BLESStoASTParser.dispatch_expression_return retval = new BLESStoASTParser.dispatch_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_dc2=null;
		ParserRuleReturnScope dc =null;
		RuleReturnScope dc2 = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleSubtreeStream stream_dispatch_conjunction=new RewriteRuleSubtreeStream(adaptor,"rule dispatch_conjunction");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3542:3: (dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3543:3: dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )*
			{
			pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16444);
			dc=dispatch_conjunction();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dispatch_conjunction.add(dc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3543:27: (o= LITERAL_or dc2+= dispatch_conjunction )*
			loop216:
			while (true) {
				int alt216=2;
				int LA216_0 = input.LA(1);
				if ( (LA216_0==LITERAL_or) ) {
					alt216=1;
				}

				switch (alt216) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3543:29: o= LITERAL_or dc2+= dispatch_conjunction
					{
					o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_dispatch_expression16450); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

					pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16454);
					dc2=dispatch_conjunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dispatch_conjunction.add(dc2.getTree());
					if (list_dc2==null) list_dc2=new ArrayList<Object>();
					list_dc2.add(dc2.getTree());
					}
					break;

				default :
					break loop216;
				}
			}

			// AST REWRITE
			// elements: dc, o, dc2, dc
			// token labels: o
			// rule labels: retval, dc
			// token list labels: 
			// rule list labels: dc2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_dc=new RewriteRuleSubtreeStream(adaptor,"rule dc",dc!=null?dc.getTree():null);
			RewriteRuleSubtreeStream stream_dc2=new RewriteRuleSubtreeStream(adaptor,"token dc2",list_dc2);
			root_0 = (BAST)adaptor.nil();
			// 3544:5: -> {o!=null}? ^( $o $dc ( $dc2)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3544:19: ^( $o $dc ( $dc2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dc.nextTree());
				if ( !(stream_dc2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_dc2.hasNext() ) {
					adaptor.addChild(root_1, stream_dc2.nextTree());
				}
				stream_dc2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3545:5: -> $dc
			{
				adaptor.addChild(root_0, stream_dc.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_expression"


	public static class dispatch_conjunction_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_conjunction"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3548:1: dispatch_conjunction : dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt;
	public final BLESStoASTParser.dispatch_conjunction_return dispatch_conjunction() throws RecognitionException {
		BLESStoASTParser.dispatch_conjunction_return retval = new BLESStoASTParser.dispatch_conjunction_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		List<Object> list_dt2=null;
		ParserRuleReturnScope dt =null;
		RuleReturnScope dt2 = null;
		BAST a_tree=null;
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleSubtreeStream stream_dispatch_trigger=new RewriteRuleSubtreeStream(adaptor,"rule dispatch_trigger");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3549:3: (dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3550:3: dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )*
			{
			pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16503);
			dt=dispatch_trigger();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dispatch_trigger.add(dt.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3550:23: (a= LITERAL_and dt2+= dispatch_trigger )*
			loop217:
			while (true) {
				int alt217=2;
				int LA217_0 = input.LA(1);
				if ( (LA217_0==LITERAL_and) ) {
					alt217=1;
				}

				switch (alt217) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3550:25: a= LITERAL_and dt2+= dispatch_trigger
					{
					a=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_dispatch_conjunction16509); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_and.add(a);

					pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16513);
					dt2=dispatch_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dispatch_trigger.add(dt2.getTree());
					if (list_dt2==null) list_dt2=new ArrayList<Object>();
					list_dt2.add(dt2.getTree());
					}
					break;

				default :
					break loop217;
				}
			}

			// AST REWRITE
			// elements: dt2, dt, dt, a
			// token labels: a
			// rule labels: dt, retval
			// token list labels: 
			// rule list labels: dt2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_dt=new RewriteRuleSubtreeStream(adaptor,"rule dt",dt!=null?dt.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_dt2=new RewriteRuleSubtreeStream(adaptor,"token dt2",list_dt2);
			root_0 = (BAST)adaptor.nil();
			// 3551:5: -> {a!=null}? ^( $a $dt $dt2)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3551:19: ^( $a $dt $dt2)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dt.nextTree());
				adaptor.addChild(root_1, stream_dt2.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3552:5: -> $dt
			{
				adaptor.addChild(root_0, stream_dt.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_conjunction"


	public static class dispatch_trigger_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3562:1: dispatch_trigger : ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop);
	public final BLESStoASTParser.dispatch_trigger_return dispatch_trigger() throws RecognitionException {
		BLESStoASTParser.dispatch_trigger_return retval = new BLESStoASTParser.dispatch_trigger_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token stop=null;
		Token LITERAL_timeout414=null;
		Token LPAREN415=null;
		Token RPAREN417=null;
		Token LITERAL_timeout419=null;
		ParserRuleReturnScope identifier416 =null;
		ParserRuleReturnScope behavior_time418 =null;
		ParserRuleReturnScope identifier420 =null;

		BAST stop_tree=null;
		BAST LITERAL_timeout414_tree=null;
		BAST LPAREN415_tree=null;
		BAST RPAREN417_tree=null;
		BAST LITERAL_timeout419_tree=null;
		RewriteRuleTokenStream stream_LITERAL_stop=new RewriteRuleTokenStream(adaptor,"token LITERAL_stop");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3563:3: ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop)
			int alt219=4;
			switch ( input.LA(1) ) {
			case LITERAL_timeout:
				{
				int LA219_1 = input.LA(2);
				if ( (LA219_1==LPAREN) ) {
					alt219=1;
				}
				else if ( (LA219_1==LITERAL_and||LA219_1==LITERAL_or||LA219_1==RCON) ) {
					alt219=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 219, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				alt219=3;
				}
				break;
			case LITERAL_stop:
				{
				alt219=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 219, 0, input);
				throw nvae;
			}
			switch (alt219) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3565:3: LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_timeout414=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16570); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_timeout414_tree = (BAST)adaptor.create(LITERAL_timeout414);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout414_tree, root_0);
					}

					LPAREN415=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_dispatch_trigger16573); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LPAREN415_tree = (BAST)adaptor.create(LPAREN415);
					adaptor.addChild(root_0, LPAREN415_tree);
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3565:67: ( identifier )+
					int cnt218=0;
					loop218:
					while (true) {
						int alt218=2;
						int LA218_0 = input.LA(1);
						if ( (LA218_0==ID) ) {
							alt218=1;
						}

						switch (alt218) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3565:67: identifier
							{
							pushFollow(FOLLOW_identifier_in_dispatch_trigger16576);
							identifier416=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier416.getTree());

							}
							break;

						default :
							if ( cnt218 >= 1 ) break loop218;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(218, input);
							throw eee;
						}
						cnt218++;
					}

					RPAREN417=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_dispatch_trigger16579); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RPAREN417_tree = (BAST)adaptor.create(RPAREN417);
					adaptor.addChild(root_0, RPAREN417_tree);
					}

					pushFollow(FOLLOW_behavior_time_in_dispatch_trigger16582);
					behavior_time418=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time418.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3567:3: LITERAL_timeout ^
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_timeout419=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16591); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_timeout419_tree = (BAST)adaptor.create(LITERAL_timeout419);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout419_tree, root_0);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3569:43: identifier
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_dispatch_trigger16602);
					identifier420=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier420.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3571:3: stop= LITERAL_stop
					{
					stop=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_dispatch_trigger16612); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_stop.add(stop);

					// AST REWRITE
					// elements: stop
					// token labels: stop
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_stop=new RewriteRuleTokenStream(adaptor,"token stop",stop);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3572:5: -> $stop
					{
						adaptor.addChild(root_0, stream_stop.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_trigger"


	public static class in_modes_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "in_modes"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3660:1: in_modes : LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
	public final BLESStoASTParser.in_modes_return in_modes() throws RecognitionException {
		BLESStoASTParser.in_modes_return retval = new BLESStoASTParser.in_modes_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_in421=null;
		Token LITERAL_modes422=null;
		Token LPAREN423=null;
		Token COMMA425=null;
		Token RPAREN427=null;
		ParserRuleReturnScope identifier424 =null;
		ParserRuleReturnScope identifier426 =null;

		BAST LITERAL_in421_tree=null;
		BAST LITERAL_modes422_tree=null;
		BAST LPAREN423_tree=null;
		BAST COMMA425_tree=null;
		BAST RPAREN427_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3661:3: ( LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3662:3: LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_in421=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_in_modes16663); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_in421_tree = (BAST)adaptor.create(LITERAL_in421);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_in421_tree, root_0);
			}

			LITERAL_modes422=(Token)match(input,LITERAL_modes,FOLLOW_LITERAL_modes_in_in_modes16666); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_modes422_tree = (BAST)adaptor.create(LITERAL_modes422);
			adaptor.addChild(root_0, LITERAL_modes422_tree);
			}

			LPAREN423=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_in_modes16670); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_in_modes16676);
			identifier424=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier424.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3664:23: ( COMMA ! identifier )*
			loop220:
			while (true) {
				int alt220=2;
				int LA220_0 = input.LA(1);
				if ( (LA220_0==COMMA) ) {
					alt220=1;
				}

				switch (alt220) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3664:25: COMMA ! identifier
					{
					COMMA425=(Token)match(input,COMMA,FOLLOW_COMMA_in_in_modes16680); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_in_modes16684);
					identifier426=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier426.getTree());

					}
					break;

				default :
					break loop220;
				}
			}

			RPAREN427=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_in_modes16691); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "in_modes"

	// $ANTLR start synpred1_BLESStoAST
	public final void synpred1_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )
		int alt221=2;
		int LA221_0 = input.LA(1);
		if ( (LA221_0==LPAREN) ) {
			int LA221_1 = input.LA(2);
			if ( (LA221_1==LITERAL_if) ) {
				alt221=1;
			}
			else if ( (LA221_1==AADL_STRING_LITERAL||LA221_1==ID||LA221_1==INTEGER_LIT||LA221_1==LBRACKET||LA221_1==LITERAL_complex||LA221_1==LITERAL_false||LA221_1==LITERAL_in||LA221_1==LITERAL_integer||LA221_1==LITERAL_natural||(LA221_1 >= LITERAL_not && LA221_1 <= LITERAL_now)||LA221_1==LITERAL_null||(LA221_1 >= LITERAL_rational && LA221_1 <= LITERAL_real)||LA221_1==LITERAL_self||(LA221_1 >= LITERAL_time && LA221_1 <= LITERAL_timeout)||LA221_1==LITERAL_tops||LA221_1==LITERAL_true||LA221_1==LPAREN||LA221_1==MINUS||LA221_1==OCTOTHORPE||LA221_1==REAL_LIT) ) {
				alt221=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 221, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 221, 0, input);
			throw nvae;
		}

		switch (alt221) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred1_BLESStoAST9464); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred1_BLESStoAST9466); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:24: LPAREN boolean_expression_or_relation QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred1_BLESStoAST9470); if (state.failed) return;

				pushFollow(FOLLOW_boolean_expression_or_relation_in_synpred1_BLESStoAST9472);
				boolean_expression_or_relation();
				state._fsp--;
				if (state.failed) return;

				match(input,QQ,FOLLOW_QQ_in_synpred1_BLESStoAST9474); if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred1_BLESStoAST

	// $ANTLR start synpred2_BLESStoAST
	public final void synpred2_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:3: ( LPAREN case_choice )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:4: LPAREN case_choice
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred2_BLESStoAST9502); if (state.failed) return;

		pushFollow(FOLLOW_case_choice_in_synpred2_BLESStoAST9504);
		case_choice();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_BLESStoAST

	// $ANTLR start synpred3_BLESStoAST
	public final void synpred3_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:4: port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		{
		pushFollow(FOLLOW_port_name_in_synpred3_BLESStoAST9809);
		port_name();
		state._fsp--;
		if (state.failed) return;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:14: ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		int alt222=4;
		int LA222_0 = input.LA(1);
		if ( (LA222_0==QUESTION) ) {
			alt222=1;
		}
		else if ( (LA222_0==TICK) ) {
			switch ( input.LA(2) ) {
			case LITERAL_fresh:
				{
				alt222=2;
				}
				break;
			case LITERAL_count:
				{
				alt222=3;
				}
				break;
			case LITERAL_updated:
				{
				alt222=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 222, 2, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 222, 0, input);
			throw nvae;
		}

		switch (alt222) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:16: QUESTION
				{
				match(input,QUESTION,FOLLOW_QUESTION_in_synpred3_BLESStoAST9813); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:27: TICK LITERAL_fresh
				{
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9817); if (state.failed) return;

				match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_synpred3_BLESStoAST9819); if (state.failed) return;

				}
				break;
			case 3 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:48: TICK LITERAL_count
				{
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9823); if (state.failed) return;

				match(input,LITERAL_count,FOLLOW_LITERAL_count_in_synpred3_BLESStoAST9825); if (state.failed) return;

				}
				break;
			case 4 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:68: TICK LITERAL_updated
				{
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9828); if (state.failed) return;

				match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_synpred3_BLESStoAST9830); if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred3_BLESStoAST

	// $ANTLR start synpred4_BLESStoAST
	public final void synpred4_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2615:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2615:4: LPAREN ID ARROW
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred4_BLESStoAST10540); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred4_BLESStoAST10542); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred4_BLESStoAST10544); if (state.failed) return;

		}

	}
	// $ANTLR end synpred4_BLESStoAST

	// $ANTLR start synpred5_BLESStoAST
	public final void synpred5_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2619:3: ( subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2619:4: subexpression relation_symbol
		{
		pushFollow(FOLLOW_subexpression_in_synpred5_BLESStoAST10572);
		subexpression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_relation_symbol_in_synpred5_BLESStoAST10574);
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_BLESStoAST

	// $ANTLR start synpred6_BLESStoAST
	public final void synpred6_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2634:3: ( subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2634:4: subexpression relation_symbol
		{
		pushFollow(FOLLOW_subexpression_in_synpred6_BLESStoAST10662);
		subexpression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_relation_symbol_in_synpred6_BLESStoAST10664);
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred6_BLESStoAST

	// $ANTLR start synpred7_BLESStoAST
	public final void synpred7_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2993:3: ( parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2993:4: parenthesized_predicate IMP
		{
		pushFollow(FOLLOW_parenthesized_predicate_in_synpred7_BLESStoAST12657);
		parenthesized_predicate();
		state._fsp--;
		if (state.failed) return;

		match(input,IMP,FOLLOW_IMP_in_synpred7_BLESStoAST12659); if (state.failed) return;

		}

	}
	// $ANTLR end synpred7_BLESStoAST

	// $ANTLR start synpred8_BLESStoAST
	public final void synpred8_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3062:5: ( assertion_expression range_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3062:7: assertion_expression range_symbol
		{
		pushFollow(FOLLOW_assertion_expression_in_synpred8_BLESStoAST13048);
		assertion_expression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_range_symbol_in_synpred8_BLESStoAST13050);
		range_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred8_BLESStoAST

	// $ANTLR start synpred9_BLESStoAST
	public final void synpred9_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:3: ( assertion_subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:4: assertion_subexpression relation_symbol
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred9_BLESStoAST13398);
		assertion_subexpression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_relation_symbol_in_synpred9_BLESStoAST13400);
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred9_BLESStoAST

	// $ANTLR start synpred10_BLESStoAST
	public final void synpred10_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:3: ( assertion_subexpression LITERAL_in )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:4: assertion_subexpression LITERAL_in
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13479);
		assertion_subexpression();
		state._fsp--;
		if (state.failed) return;

		match(input,LITERAL_in,FOLLOW_LITERAL_in_in_synpred10_BLESStoAST13481); if (state.failed) return;

		}

	}
	// $ANTLR end synpred10_BLESStoAST

	// $ANTLR start synpred11_BLESStoAST
	public final void synpred11_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3120:3: ( name PLUS_EQUALS )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3120:4: name PLUS_EQUALS
		{
		pushFollow(FOLLOW_name_in_synpred11_BLESStoAST13560);
		name();
		state._fsp--;
		if (state.failed) return;

		match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_synpred11_BLESStoAST13562); if (state.failed) return;

		}

	}
	// $ANTLR end synpred11_BLESStoAST

	// $ANTLR start synpred12_BLESStoAST
	public final void synpred12_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3134:5: ( ID LPAREN )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3134:6: ID LPAREN
		{
		match(input,ID,FOLLOW_ID_in_synpred12_BLESStoAST13732); if (state.failed) return;

		match(input,LPAREN,FOLLOW_LPAREN_in_synpred12_BLESStoAST13734); if (state.failed) return;

		}

	}
	// $ANTLR end synpred12_BLESStoAST

	// $ANTLR start synpred16_BLESStoAST
	public final void synpred16_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3443:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )
		int alt226=2;
		int LA226_0 = input.LA(1);
		if ( (LA226_0==LPAREN) ) {
			int LA226_1 = input.LA(2);
			if ( (LA226_1==LITERAL_if) ) {
				alt226=1;
			}
			else if ( (LA226_1==AADL_STRING_LITERAL||LA226_1==ID||LA226_1==INTEGER_LIT||LA226_1==LBRACKET||LA226_1==LITERAL_abs||LA226_1==LITERAL_all||LA226_1==LITERAL_complex||LA226_1==LITERAL_def||LA226_1==LITERAL_exists||LA226_1==LITERAL_false||LA226_1==LITERAL_in||LA226_1==LITERAL_integer||LA226_1==LITERAL_natural||(LA226_1 >= LITERAL_not && LA226_1 <= LITERAL_now)||LA226_1==LITERAL_null||(LA226_1 >= LITERAL_rational && LA226_1 <= LITERAL_real)||LA226_1==LITERAL_self||LA226_1==LITERAL_stop||(LA226_1 >= LITERAL_time && LA226_1 <= LITERAL_timeout)||LA226_1==LITERAL_tops||LA226_1==LITERAL_true||LA226_1==LPAREN||LA226_1==MINUS||LA226_1==OCTOTHORPE||LA226_1==REAL_LIT) ) {
				alt226=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 226, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 226, 0, input);
			throw nvae;
		}

		switch (alt226) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3443:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred16_BLESStoAST15734); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred16_BLESStoAST15736); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3443:24: LPAREN predicate QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred16_BLESStoAST15740); if (state.failed) return;

				pushFollow(FOLLOW_predicate_in_synpred16_BLESStoAST15742);
				predicate();
				state._fsp--;
				if (state.failed) return;

				match(input,QQ,FOLLOW_QQ_in_synpred16_BLESStoAST15744); if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred16_BLESStoAST

	// $ANTLR start synpred17_BLESStoAST
	public final void synpred17_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3447:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3447:4: LPAREN ID ARROW
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred17_BLESStoAST15770); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred17_BLESStoAST15772); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred17_BLESStoAST15774); if (state.failed) return;

		}

	}
	// $ANTLR end synpred17_BLESStoAST

	// $ANTLR start synpred18_BLESStoAST
	public final void synpred18_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3451:3: ( LPAREN parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3451:4: LPAREN parenthesized_predicate IMP
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred18_BLESStoAST15804); if (state.failed) return;

		pushFollow(FOLLOW_parenthesized_predicate_in_synpred18_BLESStoAST15806);
		parenthesized_predicate();
		state._fsp--;
		if (state.failed) return;

		match(input,IMP,FOLLOW_IMP_in_synpred18_BLESStoAST15808); if (state.failed) return;

		}

	}
	// $ANTLR end synpred18_BLESStoAST

	// Delegated rules

	public final boolean synpred3_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred16_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred16_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred11_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred11_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred8_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred8_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred6_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred6_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred17_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred17_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred9_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred9_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred7_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred7_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred12_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred12_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred10_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred10_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred18_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred18_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred5_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA55 dfa55 = new DFA55(this);
	protected DFA63 dfa63 = new DFA63(this);
	protected DFA99 dfa99 = new DFA99(this);
	protected DFA118 dfa118 = new DFA118(this);
	protected DFA162 dfa162 = new DFA162(this);
	static final String DFA55_eotS =
		"\22\uffff";
	static final String DFA55_eofS =
		"\22\uffff";
	static final String DFA55_minS =
		"\1\76\1\uffff\1\21\7\uffff\1\4\1\76\1\uffff\1\36\2\21\1\76\1\21";
	static final String DFA55_maxS =
		"\1\u00f5\1\uffff\1\u0123\7\uffff\1\u0115\1\76\1\uffff\1\u0125\2\u0123"+
		"\1\76\1\u0123";
	static final String DFA55_acceptS =
		"\1\uffff\1\1\1\uffff\1\3\1\4\1\5\1\6\1\7\1\10\1\11\2\uffff\1\2\5\uffff";
	static final String DFA55_specialS =
		"\22\uffff}>";
	static final String[] DFA55_transitionS = {
			"\1\2\60\uffff\1\4\20\uffff\1\11\5\uffff\4\7\53\uffff\1\3\32\uffff\1\5"+
			"\1\uffff\1\1\10\uffff\1\7\25\uffff\1\6\3\uffff\1\10",
			"",
			"\1\14\42\uffff\1\3\27\uffff\1\12\u00a8\uffff\1\3\14\uffff\1\13\14\uffff"+
			"\1\3\23\uffff\1\14",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\14\71\uffff\1\14\3\uffff\1\15\11\uffff\1\14\40\uffff\1\14\25\uffff"+
			"\1\14\24\uffff\1\14\2\uffff\1\14\13\uffff\1\14\2\uffff\2\14\1\uffff\1"+
			"\14\27\uffff\2\14\6\uffff\1\14\23\uffff\2\14\1\uffff\1\14\2\uffff\1\14"+
			"\15\uffff\1\14\3\uffff\1\14\3\uffff\1\14\27\uffff\1\14",
			"\1\16",
			"",
			"\2\14\11\uffff\1\14\1\uffff\2\14\10\uffff\1\14\46\uffff\1\14\14\uffff"+
			"\1\14\11\uffff\1\14\57\uffff\1\14\15\uffff\1\14\27\uffff\1\14\52\uffff"+
			"\1\14\4\uffff\1\14\11\uffff\1\14\16\uffff\1\17\22\uffff\1\14",
			"\1\14\42\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\14\42\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\14\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\21",
			"\1\14\42\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
			"\1\14"
	};

	static final short[] DFA55_eot = DFA.unpackEncodedString(DFA55_eotS);
	static final short[] DFA55_eof = DFA.unpackEncodedString(DFA55_eofS);
	static final char[] DFA55_min = DFA.unpackEncodedStringToUnsignedChars(DFA55_minS);
	static final char[] DFA55_max = DFA.unpackEncodedStringToUnsignedChars(DFA55_maxS);
	static final short[] DFA55_accept = DFA.unpackEncodedString(DFA55_acceptS);
	static final short[] DFA55_special = DFA.unpackEncodedString(DFA55_specialS);
	static final short[][] DFA55_transition;

	static {
		int numStates = DFA55_transitionS.length;
		DFA55_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA55_transition[i] = DFA.unpackEncodedString(DFA55_transitionS[i]);
		}
	}

	protected class DFA55 extends DFA {

		public DFA55(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 55;
			this.eot = DFA55_eot;
			this.eof = DFA55_eof;
			this.min = DFA55_min;
			this.max = DFA55_max;
			this.accept = DFA55_accept;
			this.special = DFA55_special;
			this.transition = DFA55_transition;
		}
		@Override
		public String getDescription() {
			return "2017:1: basic_action : ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception );";
		}
	}

	static final String DFA63_eotS =
		"\15\uffff";
	static final String DFA63_eofS =
		"\15\uffff";
	static final String DFA63_minS =
		"\1\76\1\64\2\uffff\1\76\1\uffff\1\102\1\uffff\1\64\1\u0112\1\76\2\64";
	static final String DFA63_maxS =
		"\1\u00b5\1\u010f\2\uffff\1\76\1\uffff\1\102\1\uffff\1\u010f\1\u0112\1"+
		"\76\2\u010f";
	static final String DFA63_acceptS =
		"\2\uffff\1\4\1\1\1\uffff\1\2\1\uffff\1\3\5\uffff";
	static final String DFA63_specialS =
		"\15\uffff}>";
	static final String[] DFA63_transitionS = {
			"\1\1\166\uffff\1\2",
			"\1\5\27\uffff\1\6\u00a8\uffff\1\3\14\uffff\1\4\14\uffff\1\7",
			"",
			"",
			"\1\10",
			"",
			"\1\11",
			"",
			"\1\5\u00cd\uffff\1\12\14\uffff\1\7",
			"\1\13",
			"\1\14",
			"\1\5\u00da\uffff\1\7",
			"\1\5\u00cd\uffff\1\12\14\uffff\1\7"
	};

	static final short[] DFA63_eot = DFA.unpackEncodedString(DFA63_eotS);
	static final short[] DFA63_eof = DFA.unpackEncodedString(DFA63_eofS);
	static final char[] DFA63_min = DFA.unpackEncodedStringToUnsignedChars(DFA63_minS);
	static final char[] DFA63_max = DFA.unpackEncodedStringToUnsignedChars(DFA63_maxS);
	static final short[] DFA63_accept = DFA.unpackEncodedString(DFA63_acceptS);
	static final short[] DFA63_special = DFA.unpackEncodedString(DFA63_specialS);
	static final short[][] DFA63_transition;

	static {
		int numStates = DFA63_transitionS.length;
		DFA63_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA63_transition[i] = DFA.unpackEncodedString(DFA63_transitionS[i]);
		}
	}

	protected class DFA63 extends DFA {

		public DFA63(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 63;
			this.eot = DFA63_eot;
			this.eof = DFA63_eof;
			this.min = DFA63_min;
			this.max = DFA63_max;
			this.accept = DFA63_accept;
			this.special = DFA63_special;
			this.transition = DFA63_transition;
		}
		@Override
		public String getDescription() {
			return "2123:1: communication_action : (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause);";
		}
	}

	static final String DFA99_eotS =
		"\13\uffff";
	static final String DFA99_eofS =
		"\2\uffff\1\1\2\uffff\1\1\5\uffff";
	static final String DFA99_minS =
		"\1\4\1\uffff\1\7\1\uffff\1\76\1\7\2\76\1\34\1\uffff\1\55";
	static final String DFA99_maxS =
		"\1\u0115\1\uffff\1\u0125\1\uffff\1\76\1\u0125\1\u0117\1\76\1\u0123\1\uffff"+
		"\1\u0102";
	static final String DFA99_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\5\uffff\1\3\1\uffff";
	static final String DFA99_specialS =
		"\13\uffff}>";
	static final String[] DFA99_transitionS = {
			"\1\1\71\uffff\1\2\3\uffff\1\1\11\uffff\1\1\40\uffff\1\3\25\uffff\1\1"+
			"\24\uffff\1\1\2\uffff\1\3\13\uffff\1\3\2\uffff\2\1\1\uffff\1\1\27\uffff"+
			"\2\3\6\uffff\1\1\23\uffff\1\3\1\1\1\uffff\1\1\2\uffff\1\1\15\uffff\1"+
			"\1\3\uffff\1\1\3\uffff\1\1\27\uffff\1\1",
			"",
			"\3\1\17\uffff\1\1\2\uffff\4\1\11\uffff\1\1\1\uffff\2\1\1\4\5\uffff\1"+
			"\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\2\1\1\uffff\1\1\15\uffff"+
			"\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4\uffff\2\1\3\uffff"+
			"\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1\1\5\uffff\2\1\2\uffff"+
			"\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff\1\1\6\uffff\1\1\2\uffff"+
			"\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff\1\1\13\uffff\1\1\2"+
			"\uffff\1\1\3\uffff\2\1\1\uffff\3\1\2\uffff\1\1\1\uffff\1\1\1\uffff\1"+
			"\1\4\uffff\2\1\12\uffff\2\1\2\uffff\3\1\2\uffff\1\1\1\uffff\1\1\11\uffff"+
			"\1\1\1\uffff\1\1",
			"",
			"\1\5",
			"\3\1\17\uffff\1\1\2\uffff\4\1\11\uffff\1\1\1\uffff\2\1\1\7\5\uffff\1"+
			"\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\1\1\2\uffff\1\1\15\uffff"+
			"\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4\uffff\2\1\3\uffff"+
			"\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1\1\5\uffff\2\1\2\uffff"+
			"\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff\1\1\6\uffff\1\1\2\uffff"+
			"\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff\1\1\13\uffff\1\1\2"+
			"\uffff\1\1\3\uffff\2\1\1\uffff\1\1\1\6\1\1\2\uffff\1\1\1\uffff\1\1\1"+
			"\uffff\1\1\4\uffff\2\1\12\uffff\1\1\3\uffff\3\1\2\uffff\1\1\1\uffff\1"+
			"\1\13\uffff\1\1",
			"\1\10\u00d8\uffff\1\11",
			"\1\12",
			"\1\11\1\1\56\uffff\1\1\u00b5\uffff\1\1\40\uffff\1\1",
			"",
			"\1\7\u00c7\uffff\1\11\7\uffff\1\1\4\uffff\1\1"
	};

	static final short[] DFA99_eot = DFA.unpackEncodedString(DFA99_eotS);
	static final short[] DFA99_eof = DFA.unpackEncodedString(DFA99_eofS);
	static final char[] DFA99_min = DFA.unpackEncodedStringToUnsignedChars(DFA99_minS);
	static final char[] DFA99_max = DFA.unpackEncodedStringToUnsignedChars(DFA99_maxS);
	static final short[] DFA99_accept = DFA.unpackEncodedString(DFA99_acceptS);
	static final short[] DFA99_special = DFA.unpackEncodedString(DFA99_specialS);
	static final short[][] DFA99_transition;

	static {
		int numStates = DFA99_transitionS.length;
		DFA99_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA99_transition[i] = DFA.unpackEncodedString(DFA99_transitionS[i]);
		}
	}

	protected class DFA99 extends DFA {

		public DFA99(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 99;
			this.eot = DFA99_eot;
			this.eof = DFA99_eof;
			this.min = DFA99_min;
			this.max = DFA99_max;
			this.accept = DFA99_accept;
			this.special = DFA99_special;
			this.transition = DFA99_transition;
		}
		@Override
		public String getDescription() {
			return "2351:1: subexpression : ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc);";
		}
	}

	static final String DFA118_eotS =
		"\26\uffff";
	static final String DFA118_eofS =
		"\2\uffff\1\14\6\uffff\1\14\3\uffff\1\14\5\uffff\3\14";
	static final String DFA118_minS =
		"\1\4\1\uffff\1\7\5\uffff\1\76\1\7\1\uffff\1\4\1\uffff\1\7\3\uffff\1\36"+
		"\1\76\3\7";
	static final String DFA118_maxS =
		"\1\u0115\1\uffff\1\u0125\5\uffff\1\76\1\u0125\1\uffff\1\u0115\1\uffff"+
		"\1\u0125\3\uffff\1\u0125\1\76\3\u0125";
	static final String DFA118_acceptS =
		"\1\uffff\1\1\1\uffff\1\4\1\5\1\6\1\7\1\10\2\uffff\1\2\1\uffff\1\3\1\uffff"+
		"\3\2\5\uffff";
	static final String DFA118_specialS =
		"\2\uffff\1\1\6\uffff\1\2\3\uffff\1\0\5\uffff\1\5\1\4\1\3}>";
	static final String[] DFA118_transitionS = {
			"\1\1\71\uffff\1\2\3\uffff\1\1\11\uffff\1\1\66\uffff\1\1\24\uffff\1\3"+
			"\22\uffff\1\6\1\uffff\1\5\37\uffff\1\1\24\uffff\1\4\1\uffff\1\7\2\uffff"+
			"\1\1\25\uffff\1\1\27\uffff\1\1",
			"",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\1\1\5\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff"+
			"\1\14\1\13\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff"+
			"\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14"+
			"\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff"+
			"\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1"+
			"\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14"+
			"\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2"+
			"\uffff\1\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\10\1\14\12\uffff\1\14"+
			"\1\12\1\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\11\1\uffff"+
			"\1\14",
			"",
			"",
			"",
			"",
			"",
			"\1\15",
			"\2\14\1\uffff\1\14\21\uffff\4\14\11\uffff\1\14\1\uffff\2\14\6\uffff"+
			"\1\14\1\uffff\1\14\5\uffff\1\14\2\uffff\1\1\1\14\34\uffff\1\14\3\uffff"+
			"\1\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1\14\1\uffff\2"+
			"\14\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1\14\23\uffff\2"+
			"\14\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1\14\1\uffff\1\14"+
			"\7\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14\15\uffff\1\14",
			"",
			"\1\14\71\uffff\1\14\3\uffff\1\21\11\uffff\1\14\40\uffff\1\14\25\uffff"+
			"\1\14\24\uffff\1\14\2\uffff\1\14\13\uffff\1\14\2\uffff\2\14\1\uffff\1"+
			"\14\27\uffff\2\14\6\uffff\1\14\23\uffff\2\14\1\uffff\1\14\2\uffff\1\14"+
			"\15\uffff\1\14\3\uffff\1\14\3\uffff\1\14\27\uffff\1\14",
			"",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff\2\14"+
			"\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff\1\14\3"+
			"\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14\3\uffff"+
			"\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff\1\14"+
			"\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1\14\6"+
			"\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14\1\uffff"+
			"\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2\uffff\1"+
			"\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\22\1\14\12\uffff\1\14\1\12\1\14"+
			"\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14",
			"",
			"",
			"",
			"\2\14\11\uffff\1\14\1\uffff\2\14\10\uffff\1\14\46\uffff\1\14\14\uffff"+
			"\1\14\11\uffff\1\14\57\uffff\1\14\15\uffff\1\14\27\uffff\1\14\52\uffff"+
			"\1\14\4\uffff\1\14\11\uffff\1\14\16\uffff\1\24\22\uffff\1\14",
			"\1\25",
			"\2\14\1\uffff\1\14\21\uffff\4\14\11\uffff\1\14\1\uffff\2\14\6\uffff"+
			"\1\14\1\uffff\1\14\5\uffff\1\14\3\uffff\1\14\34\uffff\1\14\3\uffff\1"+
			"\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1\14\1\uffff\2\14"+
			"\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1\14\23\uffff\2\14"+
			"\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1\14\1\uffff\1\14\7"+
			"\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14\15\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff\2\14"+
			"\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff\1\14\3"+
			"\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14\3\uffff"+
			"\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff\1\14"+
			"\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1\14\6"+
			"\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14\1\uffff"+
			"\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2\uffff\1"+
			"\14\1\uffff\1\14\6\uffff\2\14\12\uffff\1\14\1\12\1\14\1\uffff\3\14\2"+
			"\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff\2\14"+
			"\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff\1\14\3"+
			"\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14\3\uffff"+
			"\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff\1\14"+
			"\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1\14\6"+
			"\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14\1\uffff"+
			"\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2\uffff\1"+
			"\14\1\uffff\1\14\6\uffff\1\22\1\14\12\uffff\1\14\1\12\1\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14"
	};

	static final short[] DFA118_eot = DFA.unpackEncodedString(DFA118_eotS);
	static final short[] DFA118_eof = DFA.unpackEncodedString(DFA118_eofS);
	static final char[] DFA118_min = DFA.unpackEncodedStringToUnsignedChars(DFA118_minS);
	static final char[] DFA118_max = DFA.unpackEncodedStringToUnsignedChars(DFA118_maxS);
	static final short[] DFA118_accept = DFA.unpackEncodedString(DFA118_acceptS);
	static final short[] DFA118_special = DFA.unpackEncodedString(DFA118_specialS);
	static final short[][] DFA118_transition;

	static {
		int numStates = DFA118_transitionS.length;
		DFA118_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA118_transition[i] = DFA.unpackEncodedString(DFA118_transitionS[i]);
		}
	}

	protected class DFA118 extends DFA {

		public DFA118(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 118;
			this.eot = DFA118_eot;
			this.eof = DFA118_eof;
			this.min = DFA118_min;
			this.max = DFA118_max;
			this.accept = DFA118_accept;
			this.special = DFA118_special;
			this.transition = DFA118_transition;
		}
		@Override
		public String getDescription() {
			return "2514:1: value : (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops);";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA118_13 = input.LA(1);
						 
						int index118_13 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_13==OCTOTHORPE) ) {s = 1;}
						else if ( (LA118_13==PERIOD) ) {s = 18;}
						else if ( (LA118_13==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_13==TICK) ) {s = 19;}
						else if ( (LA118_13==EOF||(LA118_13 >= AL && LA118_13 <= ANNEX_END)||LA118_13==AT_SIGN||(LA118_13 >= BOX && LA118_13 <= CARET)||(LA118_13 >= COLON && LA118_13 <= COMMADOT)||LA118_13==DIVIDE||(LA118_13 >= DOTCOMMA && LA118_13 <= DOTDOT)||LA118_13==EQ||LA118_13==EXP||(LA118_13 >= GT && LA118_13 <= GUARD)||(LA118_13 >= ID && LA118_13 <= IMP)||(LA118_13 >= LASS && LA118_13 <= LBRACKET)||LA118_13==LCURLY||LA118_13==LITERAL_and||LA118_13==LITERAL_are||LA118_13==LITERAL_cand||LA118_13==LITERAL_computation||LA118_13==LITERAL_cor||LA118_13==LITERAL_declare||(LA118_13 >= LITERAL_do && LA118_13 <= LITERAL_else)||LA118_13==LITERAL_exception||(LA118_13 >= LITERAL_fetchadd && LA118_13 <= LITERAL_fi)||(LA118_13 >= LITERAL_for && LA118_13 <= LITERAL_forall)||(LA118_13 >= LITERAL_hr && LA118_13 <= LITERAL_iff)||(LA118_13 >= LITERAL_implies && LA118_13 <= LITERAL_in)||LA118_13==LITERAL_invariant||(LA118_13 >= LITERAL_min && LA118_13 <= LITERAL_mod)||LA118_13==LITERAL_ms||LA118_13==LITERAL_ns||LA118_13==LITERAL_of||LA118_13==LITERAL_or||LA118_13==LITERAL_pause||LA118_13==LITERAL_ps||LA118_13==LITERAL_rem||LA118_13==LITERAL_sec||LA118_13==LITERAL_setmode||LA118_13==LITERAL_skip||LA118_13==LITERAL_swap||(LA118_13 >= LITERAL_that && LA118_13 <= LITERAL_then)||LA118_13==LITERAL_until||LA118_13==LITERAL_us||(LA118_13 >= LITERAL_when && LA118_13 <= LITERAL_while)||(LA118_13 >= LITERAL_xor && LA118_13 <= LT)||LA118_13==MINUS||LA118_13==NEQ||LA118_13==PLUS||LA118_13==QQ||LA118_13==RASS||(LA118_13 >= RBRACKET && LA118_13 <= RCURLY)||LA118_13==RPAREN||LA118_13==SEMICOLON||LA118_13==TIMES) ) {s = 12;}
						 
						input.seek(index118_13);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA118_2 = input.LA(1);
						 
						int index118_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_2==DOUBLE_COLON||LA118_2==OCTOTHORPE) ) {s = 1;}
						else if ( (LA118_2==PERIOD) ) {s = 8;}
						else if ( (LA118_2==TICK) ) {s = 9;}
						else if ( (LA118_2==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_2==LBRACKET) ) {s = 11;}
						else if ( (LA118_2==EOF||(LA118_2 >= AL && LA118_2 <= ANNEX_END)||LA118_2==AT_SIGN||(LA118_2 >= BOX && LA118_2 <= CARET)||(LA118_2 >= COLON && LA118_2 <= COMMADOT)||LA118_2==DIVIDE||(LA118_2 >= DOTCOMMA && LA118_2 <= DOTDOT)||LA118_2==EQ||LA118_2==EXP||(LA118_2 >= GT && LA118_2 <= GUARD)||(LA118_2 >= ID && LA118_2 <= IMP)||LA118_2==LASS||LA118_2==LCURLY||LA118_2==LITERAL_and||LA118_2==LITERAL_are||LA118_2==LITERAL_cand||LA118_2==LITERAL_computation||LA118_2==LITERAL_cor||LA118_2==LITERAL_declare||(LA118_2 >= LITERAL_do && LA118_2 <= LITERAL_else)||LA118_2==LITERAL_exception||(LA118_2 >= LITERAL_fetchadd && LA118_2 <= LITERAL_fi)||(LA118_2 >= LITERAL_for && LA118_2 <= LITERAL_forall)||(LA118_2 >= LITERAL_hr && LA118_2 <= LITERAL_iff)||(LA118_2 >= LITERAL_implies && LA118_2 <= LITERAL_in)||LA118_2==LITERAL_invariant||(LA118_2 >= LITERAL_min && LA118_2 <= LITERAL_mod)||LA118_2==LITERAL_ms||LA118_2==LITERAL_ns||LA118_2==LITERAL_of||LA118_2==LITERAL_or||LA118_2==LITERAL_pause||LA118_2==LITERAL_ps||LA118_2==LITERAL_rem||LA118_2==LITERAL_sec||LA118_2==LITERAL_setmode||LA118_2==LITERAL_skip||LA118_2==LITERAL_swap||(LA118_2 >= LITERAL_that && LA118_2 <= LITERAL_then)||LA118_2==LITERAL_until||LA118_2==LITERAL_us||(LA118_2 >= LITERAL_when && LA118_2 <= LITERAL_while)||(LA118_2 >= LITERAL_xor && LA118_2 <= LT)||LA118_2==MINUS||LA118_2==NEQ||LA118_2==PLUS||LA118_2==QQ||LA118_2==RASS||(LA118_2 >= RBRACKET && LA118_2 <= RCURLY)||LA118_2==RPAREN||LA118_2==SEMICOLON||LA118_2==TIMES) ) {s = 12;}
						 
						input.seek(index118_2);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA118_9 = input.LA(1);
						 
						int index118_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_9==LITERAL_fresh) && (synpred3_BLESStoAST())) {s = 14;}
						else if ( (LA118_9==LITERAL_count) && (synpred3_BLESStoAST())) {s = 15;}
						else if ( (LA118_9==LITERAL_updated) && (synpred3_BLESStoAST())) {s = 16;}
						else if ( (LA118_9==ID) ) {s = 1;}
						else if ( (LA118_9==EOF||(LA118_9 >= AL && LA118_9 <= AM)||LA118_9==ANNEX_END||(LA118_9 >= COLON && LA118_9 <= COMMADOT)||LA118_9==DIVIDE||(LA118_9 >= DOTCOMMA && LA118_9 <= DOTDOT)||LA118_9==EQ||LA118_9==EXP||LA118_9==GT||LA118_9==IMP||LA118_9==LITERAL_and||LA118_9==LITERAL_are||LA118_9==LITERAL_else||LA118_9==LITERAL_iff||(LA118_9 >= LITERAL_implies && LA118_9 <= LITERAL_in)||LA118_9==LITERAL_mod||LA118_9==LITERAL_of||LA118_9==LITERAL_or||LA118_9==LITERAL_rem||(LA118_9 >= LITERAL_that && LA118_9 <= LITERAL_then)||LA118_9==LITERAL_xor||LA118_9==LT||LA118_9==MINUS||LA118_9==NEQ||LA118_9==PLUS||LA118_9==QQ||LA118_9==RASS||LA118_9==RPAREN||LA118_9==TIMES) ) {s = 12;}
						 
						input.seek(index118_9);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA118_21 = input.LA(1);
						 
						int index118_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_21==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_21==TICK) ) {s = 19;}
						else if ( (LA118_21==PERIOD) ) {s = 18;}
						else if ( (LA118_21==EOF||(LA118_21 >= AL && LA118_21 <= ANNEX_END)||LA118_21==AT_SIGN||(LA118_21 >= BOX && LA118_21 <= CARET)||(LA118_21 >= COLON && LA118_21 <= COMMADOT)||LA118_21==DIVIDE||(LA118_21 >= DOTCOMMA && LA118_21 <= DOTDOT)||LA118_21==EQ||LA118_21==EXP||(LA118_21 >= GT && LA118_21 <= GUARD)||(LA118_21 >= ID && LA118_21 <= IMP)||(LA118_21 >= LASS && LA118_21 <= LBRACKET)||LA118_21==LCURLY||LA118_21==LITERAL_and||LA118_21==LITERAL_are||LA118_21==LITERAL_cand||LA118_21==LITERAL_computation||LA118_21==LITERAL_cor||LA118_21==LITERAL_declare||(LA118_21 >= LITERAL_do && LA118_21 <= LITERAL_else)||LA118_21==LITERAL_exception||(LA118_21 >= LITERAL_fetchadd && LA118_21 <= LITERAL_fi)||(LA118_21 >= LITERAL_for && LA118_21 <= LITERAL_forall)||(LA118_21 >= LITERAL_hr && LA118_21 <= LITERAL_iff)||(LA118_21 >= LITERAL_implies && LA118_21 <= LITERAL_in)||LA118_21==LITERAL_invariant||(LA118_21 >= LITERAL_min && LA118_21 <= LITERAL_mod)||LA118_21==LITERAL_ms||LA118_21==LITERAL_ns||LA118_21==LITERAL_of||LA118_21==LITERAL_or||LA118_21==LITERAL_pause||LA118_21==LITERAL_ps||LA118_21==LITERAL_rem||LA118_21==LITERAL_sec||LA118_21==LITERAL_setmode||LA118_21==LITERAL_skip||LA118_21==LITERAL_swap||(LA118_21 >= LITERAL_that && LA118_21 <= LITERAL_then)||LA118_21==LITERAL_until||LA118_21==LITERAL_us||(LA118_21 >= LITERAL_when && LA118_21 <= LITERAL_while)||(LA118_21 >= LITERAL_xor && LA118_21 <= LT)||LA118_21==MINUS||LA118_21==NEQ||LA118_21==PLUS||LA118_21==QQ||LA118_21==RASS||(LA118_21 >= RBRACKET && LA118_21 <= RCURLY)||LA118_21==RPAREN||LA118_21==SEMICOLON||LA118_21==TIMES) ) {s = 12;}
						 
						input.seek(index118_21);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA118_20 = input.LA(1);
						 
						int index118_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_20==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_20==TICK) ) {s = 19;}
						else if ( (LA118_20==EOF||(LA118_20 >= AL && LA118_20 <= ANNEX_END)||LA118_20==AT_SIGN||(LA118_20 >= BOX && LA118_20 <= CARET)||(LA118_20 >= COLON && LA118_20 <= COMMADOT)||LA118_20==DIVIDE||(LA118_20 >= DOTCOMMA && LA118_20 <= DOTDOT)||LA118_20==EQ||LA118_20==EXP||(LA118_20 >= GT && LA118_20 <= GUARD)||(LA118_20 >= ID && LA118_20 <= IMP)||(LA118_20 >= LASS && LA118_20 <= LBRACKET)||LA118_20==LCURLY||LA118_20==LITERAL_and||LA118_20==LITERAL_are||LA118_20==LITERAL_cand||LA118_20==LITERAL_computation||LA118_20==LITERAL_cor||LA118_20==LITERAL_declare||(LA118_20 >= LITERAL_do && LA118_20 <= LITERAL_else)||LA118_20==LITERAL_exception||(LA118_20 >= LITERAL_fetchadd && LA118_20 <= LITERAL_fi)||(LA118_20 >= LITERAL_for && LA118_20 <= LITERAL_forall)||(LA118_20 >= LITERAL_hr && LA118_20 <= LITERAL_iff)||(LA118_20 >= LITERAL_implies && LA118_20 <= LITERAL_in)||LA118_20==LITERAL_invariant||(LA118_20 >= LITERAL_min && LA118_20 <= LITERAL_mod)||LA118_20==LITERAL_ms||LA118_20==LITERAL_ns||LA118_20==LITERAL_of||LA118_20==LITERAL_or||LA118_20==LITERAL_pause||LA118_20==LITERAL_ps||LA118_20==LITERAL_rem||LA118_20==LITERAL_sec||LA118_20==LITERAL_setmode||LA118_20==LITERAL_skip||LA118_20==LITERAL_swap||(LA118_20 >= LITERAL_that && LA118_20 <= LITERAL_then)||LA118_20==LITERAL_until||LA118_20==LITERAL_us||(LA118_20 >= LITERAL_when && LA118_20 <= LITERAL_while)||(LA118_20 >= LITERAL_xor && LA118_20 <= LT)||LA118_20==MINUS||LA118_20==NEQ||(LA118_20 >= PERIOD && LA118_20 <= PLUS)||LA118_20==QQ||LA118_20==RASS||(LA118_20 >= RBRACKET && LA118_20 <= RCURLY)||LA118_20==RPAREN||LA118_20==SEMICOLON||LA118_20==TIMES) ) {s = 12;}
						 
						input.seek(index118_20);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA118_19 = input.LA(1);
						 
						int index118_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_19==LITERAL_fresh) && (synpred3_BLESStoAST())) {s = 14;}
						else if ( (LA118_19==LITERAL_count) && (synpred3_BLESStoAST())) {s = 15;}
						else if ( (LA118_19==LITERAL_updated) && (synpred3_BLESStoAST())) {s = 16;}
						else if ( (LA118_19==EOF||(LA118_19 >= AL && LA118_19 <= AM)||LA118_19==ANNEX_END||(LA118_19 >= COLON && LA118_19 <= COMMADOT)||LA118_19==DIVIDE||(LA118_19 >= DOTCOMMA && LA118_19 <= DOTDOT)||LA118_19==EQ||LA118_19==EXP||LA118_19==GT||LA118_19==IMP||LA118_19==LITERAL_and||LA118_19==LITERAL_are||LA118_19==LITERAL_else||LA118_19==LITERAL_iff||(LA118_19 >= LITERAL_implies && LA118_19 <= LITERAL_in)||LA118_19==LITERAL_mod||LA118_19==LITERAL_of||LA118_19==LITERAL_or||LA118_19==LITERAL_rem||(LA118_19 >= LITERAL_that && LA118_19 <= LITERAL_then)||LA118_19==LITERAL_xor||LA118_19==LT||LA118_19==MINUS||LA118_19==NEQ||LA118_19==PLUS||LA118_19==QQ||LA118_19==RASS||LA118_19==RPAREN||LA118_19==TIMES) ) {s = 12;}
						 
						input.seek(index118_19);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 118, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA162_eotS =
		"\32\uffff";
	static final String DFA162_eofS =
		"\32\uffff";
	static final String DFA162_minS =
		"\1\4\1\7\3\uffff\1\21\1\u0104\2\uffff\1\76\1\uffff\1\21\2\76\1\21\1\u0124"+
		"\1\76\1\21\2\76\1\21\1\u0124\1\76\1\21\1\76\1\21";
	static final String DFA162_maxS =
		"\1\u0115\1\u0123\3\uffff\1\76\1\u0124\2\uffff\1\76\1\uffff\1\55\2\76\1"+
		"\35\1\u0124\1\76\1\55\2\76\1\35\1\u0124\1\76\1\55\1\76\1\35";
	static final String DFA162_acceptS =
		"\2\uffff\1\2\1\5\1\6\2\uffff\1\3\1\4\1\uffff\1\1\17\uffff";
	static final String DFA162_specialS =
		"\32\uffff}>";
	static final String[] DFA162_transitionS = {
			"\1\4\14\uffff\1\3\54\uffff\1\1\3\uffff\1\4\11\uffff\1\4\13\uffff\1\4"+
			"\2\uffff\1\4\21\uffff\1\4\11\uffff\1\4\11\uffff\1\4\1\uffff\1\4\24\uffff"+
			"\1\4\2\uffff\1\4\13\uffff\1\4\2\uffff\2\4\1\uffff\1\4\27\uffff\2\4\6"+
			"\uffff\1\4\10\uffff\1\4\12\uffff\2\4\1\uffff\1\4\2\uffff\1\4\15\uffff"+
			"\1\4\3\uffff\1\4\3\uffff\1\4\6\uffff\1\2\20\uffff\1\4",
			"\2\4\11\uffff\1\4\7\uffff\1\4\1\uffff\1\5\20\uffff\1\4\5\uffff\1\4\7"+
			"\uffff\1\4\3\uffff\1\4\14\uffff\1\4\17\uffff\1\4\70\uffff\1\4\1\uffff"+
			"\2\4\30\uffff\1\4\102\uffff\3\4\4\uffff\1\4\1\uffff\1\4\4\uffff\1\4\2"+
			"\uffff\1\4\11\uffff\2\4\22\uffff\1\4",
			"",
			"",
			"",
			"\1\10\12\uffff\1\7\41\uffff\1\6",
			"\1\12\37\uffff\1\11",
			"",
			"",
			"\1\13",
			"",
			"\1\10\12\uffff\1\7\1\15\17\uffff\1\14",
			"\1\16",
			"\1\17",
			"\1\10\12\uffff\1\7\1\15",
			"\1\20",
			"\1\21",
			"\1\10\12\uffff\1\7\1\23\17\uffff\1\22",
			"\1\24",
			"\1\25",
			"\1\10\12\uffff\1\7\1\23",
			"\1\26",
			"\1\27",
			"\1\10\12\uffff\1\7\1\23\17\uffff\1\30",
			"\1\31",
			"\1\10\12\uffff\1\7\1\23"
	};

	static final short[] DFA162_eot = DFA.unpackEncodedString(DFA162_eotS);
	static final short[] DFA162_eof = DFA.unpackEncodedString(DFA162_eofS);
	static final char[] DFA162_min = DFA.unpackEncodedStringToUnsignedChars(DFA162_minS);
	static final char[] DFA162_max = DFA.unpackEncodedStringToUnsignedChars(DFA162_maxS);
	static final short[] DFA162_accept = DFA.unpackEncodedString(DFA162_acceptS);
	static final short[] DFA162_special = DFA.unpackEncodedString(DFA162_specialS);
	static final short[][] DFA162_transition;

	static {
		int numStates = DFA162_transitionS.length;
		DFA162_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA162_transition[i] = DFA.unpackEncodedString(DFA162_transitionS[i]);
		}
	}

	protected class DFA162 extends DFA {

		public DFA162(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 162;
			this.eot = DFA162_eot;
			this.eof = DFA162_eof;
			this.min = DFA162_min;
			this.max = DFA162_max;
			this.accept = DFA162_accept;
			this.special = DFA162_special;
			this.transition = DFA162_transition;
		}
		@Override
		public String getDescription() {
			return "2929:1: assertion_body : ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) );";
		}
	}

	public static final BitSet FOLLOW_LBRACKET_in_rational_literal2624 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L,0x0000000000000000L,0x0200000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2628 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2633 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_303_in_rational_literal2635 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L,0x0000000000000000L,0x0200000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2639 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2644 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_rational_literal2646 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_complex_literal2743 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0200000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2747 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2752 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_complex_literal2754 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0200000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2758 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2763 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_complex_literal2765 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_identifier2919 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_annex_library_assertions3294 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_annex_library_assertions3304 = new BitSet(new long[]{0x0000000000000402L,0x0000000000000800L});
	public static final BitSet FOLLOW_ANNEX_END_in_annex_library_assertions3324 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_thread_behavior3999 = new BitSet(new long[]{0x0000800000000000L,0x0000000C00000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_thread_behavior4006 = new BitSet(new long[]{0x0000000000000000L,0x0000000C00000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_availability_in_thread_behavior4013 = new BitSet(new long[]{0x0000000000000000L,0x0000000400000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_assert_clause_in_thread_behavior4020 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_invariant_clause_in_thread_behavior4027 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_variables_in_thread_behavior4034 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_states_in_thread_behavior4041 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_state_in_thread_behavior4047 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_transitions_in_thread_behavior4056 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_thread_behavior4060 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_assert_in_assert_clause4149 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_assert_clause4153 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000800L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_invariant_clause4197 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_invariant_clause4201 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variables_in_variables4244 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_variables4250 = new BitSet(new long[]{0x4000000000000002L});
	public static final BitSet FOLLOW_LITERAL_declare_in_quantified_variables4302 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_quantified_variables4308 = new BitSet(new long[]{0x4000000000000002L});
	public static final BitSet FOLLOW_declarators_in_behavior_variable4368 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_variable4372 = new BitSet(new long[]{0x4000000000000000L,0x4004201200000000L,0x0000028008000800L,0x00008002008A00E0L});
	public static final BitSet FOLLOW_LITERAL_nonvolatile_in_behavior_variable4381 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_shared_in_behavior_variable4387 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_constant_in_behavior_variable4393 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_spread_in_behavior_variable4399 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_variable4407 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_type_in_behavior_variable4417 = new BitSet(new long[]{0x0000000000020000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_ASSIGN_in_behavior_variable4423 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_behavior_variable4427 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_variable4437 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_variable4446 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_declarators4583 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_declarators4588 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_declarators4593 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_state4677 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_state4682 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L,0x0000000004000800L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_initial_in_behavior_state4687 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_complete_in_behavior_state4693 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_state4699 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_state_in_behavior_state4705 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_state4709 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_state4712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_transitions_in_transitions4772 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_transition_in_transitions4776 = new BitSet(new long[]{0x4000000000000002L});
	public static final BitSet FOLLOW_behavior_transition_label_in_behavior_transition4823 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_transition4825 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4835 = new BitSet(new long[]{0x0000000020000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_COMMA_in_behavior_transition4839 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4844 = new BitSet(new long[]{0x0000000020000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_LCON_in_behavior_transition4853 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00012C8009000008L,0x2220009600002060L,0x0000000000280000L});
	public static final BitSet FOLLOW_behavior_condition_in_behavior_transition4857 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RCON_in_behavior_transition4860 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4867 = new BitSet(new long[]{0x0002000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCURLY_in_behavior_transition4874 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_behavior_transition4878 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCURLY_in_behavior_transition4880 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_EMPTY_CURLY_in_behavior_transition4884 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_transition4892 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_transition4897 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition_label5061 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_behavior_transition_label5065 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_behavior_transition_label5069 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_behavior_transition_label5071 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_condition_in_behavior_condition5109 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_execute_condition_in_behavior_condition5113 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_mode_condition_in_behavior_condition5117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_or_relation_in_execute_condition5135 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_mode_condition5151 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_mode_condition5154 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5172 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5178 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5182 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5192 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5196 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5267 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5269 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5276 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5278 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5288 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_event_trigger5294 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_event_trigger5297 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_event_trigger5299 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_subprogram_behavior5361 = new BitSet(new long[]{0x0000800000000000L,0x0040000400004000L,0x0180000000000000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5368 = new BitSet(new long[]{0x0000000000000000L,0x0040000400004000L,0x0180000000000000L});
	public static final BitSet FOLLOW_assert_clause_in_subprogram_behavior5376 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L,0x0180000000000000L});
	public static final BitSet FOLLOW_LITERAL_pre_in_subprogram_behavior5385 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5389 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L,0x0080000000000000L});
	public static final BitSet FOLLOW_LITERAL_post_in_subprogram_behavior5400 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5404 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_subprogram_behavior5413 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_subprogram_behavior5417 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5577 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004000L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_action_in_asserted_action5586 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5592 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_basic_action_in_action5713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_alternative_in_action5719 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_while_loop_in_action5725 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_loop_in_action5731 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_do_until_loop_in_action5737 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_action5743 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_lattice_quantification_in_action5749 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_if_in_alternative5776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5784 = new BitSet(new long[]{0x0000000002000000L});
	public static final BitSet FOLLOW_BOX_in_alternative5790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5794 = new BitSet(new long[]{0x0000000002000000L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_LITERAL_fi_in_alternative5802 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_guarded_action5845 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_guarded_action5849 = new BitSet(new long[]{0x1000000000000000L});
	public static final BitSet FOLLOW_GUARD_in_guarded_action5851 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_guarded_action5854 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_forall_in_universal_lattice_quantification5881 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_lattice_variables_in_universal_lattice_quantification5890 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_universal_lattice_quantification5894 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_range_in_universal_lattice_quantification5898 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5907 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5958 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5963 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5967 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5970 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5974 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_LITERAL_while_in_while_loop6036 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_while_loop6042 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_while_loop6047 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_while_loop6049 = new BitSet(new long[]{0x0000000000000000L,0x0040002000004000L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_while_loop6056 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_while_loop6060 = new BitSet(new long[]{0x0000000000000000L,0x0040002000004000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_while_loop6069 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_while_loop6074 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_while_loop6085 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_for_in_for_loop6150 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_for_loop6158 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_for_loop6163 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_for_loop6168 = new BitSet(new long[]{0x0000100000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_for_loop6170 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_for_loop6175 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_for_loop6184 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_for_loop6188 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCURLY_in_for_loop6195 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_for_loop6200 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCURLY_in_for_loop6202 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_do_in_do_until_loop6272 = new BitSet(new long[]{0x4000000000000000L,0x0840802000004800L,0x002000001010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_do_until_loop6280 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_do_until_loop6284 = new BitSet(new long[]{0x4000000000000000L,0x0840802000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_do_until_loop6293 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_do_until_loop6298 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_do_until_loop6309 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_until_in_do_until_loop6315 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_do_until_loop6317 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_do_until_loop6322 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_do_until_loop6324 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_skip_in_basic_action6394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_basic_action6400 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_communication_action_in_basic_action6407 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_computation_action_in_basic_action6414 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_setmode_in_basic_action6420 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_basic_action6423 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_throw_in_basic_action6429 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_combinable_operation_in_basic_action6435 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simultaneous_assignment_in_basic_action6441 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_issue_exception_in_basic_action6447 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_tick_in_assignment6474 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assignment6478 = new BitSet(new long[]{0x4000000000000010L,0x0000200040001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_assignment6482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_name_tick6526 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_name_tick6530 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_record_term6554 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_record_term6560 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_any_in_expression_or_record_term6566 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_record_term6581 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_record_value_in_record_term6586 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_record_term6589 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_value6607 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_record_value6609 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2000009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_record_value6612 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_value6614 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_simultaneous_assignment6640 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6644 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6650 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6654 = new BitSet(new long[]{0x0000000020020000L});
	public static final BitSet FOLLOW_ASSIGN_in_simultaneous_assignment6664 = new BitSet(new long[]{0x4000000000000010L,0x0000200040001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6668 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6674 = new BitSet(new long[]{0x4000000000000010L,0x0000200040001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6678 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_simultaneous_assignment6683 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exception_in_issue_exception6745 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_issue_exception6748 = new BitSet(new long[]{0x4000000000000010L});
	public static final BitSet FOLLOW_identifier_in_issue_exception6758 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_issue_exception6760 = new BitSet(new long[]{0x0000000000000010L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_issue_exception6768 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_issue_exception6770 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_computation_in_computation_action6799 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_computation_action6806 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6809 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_computation_action6813 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_computation_action6824 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_behavior_time6855 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000104400080000L,0x0000200000001004L});
	public static final BitSet FOLLOW_time_unit_in_behavior_time6860 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_procedure_call_in_communication_action6950 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_output_in_communication_action6968 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_input_in_communication_action6986 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_pause_in_communication_action7004 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_procedure_call7041 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_procedure_call7045 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000000000000008L,0x2020008000002000L,0x0000000000A00000L});
	public static final BitSet FOLLOW_formal_actual_list_in_procedure_call7049 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_procedure_call7052 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_output7109 = new BitSet(new long[]{0x0010000000000000L});
	public static final BitSet FOLLOW_EXCLAMATION_in_port_output7111 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_output7115 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_port_output7119 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_port_output7121 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_input7179 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QUESTION_in_port_input7181 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_input7183 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_name_in_port_input7188 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_port_input7190 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_port_name7233 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7236 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7239 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7242 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7245 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_identifier_in_port_name7259 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_port_name7261 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_port_name7265 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_port_name7267 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7286 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_actual_list7292 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000000000000008L,0x2020008000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7296 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_identifier_in_formal_actual7351 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_actual7353 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000000000000008L,0x2020008000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_actual_parameter_in_formal_actual7359 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_actual_parameter7378 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_actual_parameter7386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_actual_parameter7394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_quantified_variables_in_existential_lattice_quantification7420 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCURLY_in_existential_lattice_quantification7425 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_existential_lattice_quantification7429 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCURLY_in_existential_lattice_quantification7431 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0000000000000000L,0x0000000400000000L});
	public static final BitSet FOLLOW_timeout_clause_in_existential_lattice_quantification7437 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
	public static final BitSet FOLLOW_catch_clause_in_existential_lattice_quantification7442 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_catch_in_catch_clause7466 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_catch_clause_term_in_catch_clause7469 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_timeout_clause7485 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_timeout_clause7488 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_catch_clause_term7509 = new BitSet(new long[]{0x4000000000000000L,0x0000000008000000L});
	public static final BitSet FOLLOW_identifier_in_catch_clause_term7516 = new BitSet(new long[]{0x4000000010000000L});
	public static final BitSet FOLLOW_LITERAL_all_in_catch_clause_term7523 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_catch_clause_term7529 = new BitSet(new long[]{0x4000000000000000L,0x0000800000000000L,0x00200000000003C1L,0x0022000008050000L});
	public static final BitSet FOLLOW_basic_action_in_catch_clause_term7533 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_catch_clause_term7535 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_when_in_when_throw7591 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_when_throw7594 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_when_throw7598 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_when_throw7600 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000100000000L});
	public static final BitSet FOLLOW_LITERAL_throw_in_when_throw7603 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_when_throw7606 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchadd_in_combinable_operation7621 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7624 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7628 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7630 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7641 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7645 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7649 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7654 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchor_in_combinable_operation7663 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7666 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7670 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7672 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7683 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7687 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7691 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7696 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchand_in_combinable_operation7705 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7708 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7712 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7714 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7725 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7729 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7733 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7738 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchxor_in_combinable_operation7747 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7750 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7754 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7756 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7767 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7771 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7775 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7780 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_swap_in_combinable_operation7789 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7793 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7797 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7799 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7810 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7814 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7818 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7823 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7846 = new BitSet(new long[]{0x0000000000000202L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7862 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7866 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7870 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7874 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7895 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7899 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7903 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7907 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_partial_name_in_name8002 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_name8008 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_partial_name_in_name8012 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_identifier_in_partial_name8079 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_partial_name8088 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_range_in_partial_name8092 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_partial_name8094 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8143 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_parameter_list8152 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8156 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8218 = new BitSet(new long[]{0x00001800C0000002L});
	public static final BitSet FOLLOW_range_symbol_in_expression_or_range8222 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8225 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_variable_name8252 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression8278 = new BitSet(new long[]{0x0020020000000002L,0x0008020010000000L,0x0002000800000000L,0x0210000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_expression8294 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8298 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_expression8314 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8318 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_expression8332 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8336 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_expression8347 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8351 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_expression8362 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8366 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_expression8377 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8381 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_expression8392 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8396 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_expression8409 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8413 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_expression8429 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8433 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_expression8449 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8453 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_expression8467 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_expression8482 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8486 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_subexpression8558 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_not_in_subexpression8564 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_subexpression8576 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression8582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_conversion_in_subexpression8682 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_function_call_in_subexpression8702 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_type_conversion8732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_type_conversion8741 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_type_conversion8750 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_type_conversion8759 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_type_conversion8768 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_type_conversion8776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion8785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type_conversion8816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type_conversion8825 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type_conversion8834 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type_conversion8843 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type_conversion8852 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type_conversion8860 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8869 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8904 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_boolean_expression8920 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8924 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_boolean_expression8940 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8944 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_boolean_expression8960 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8964 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_boolean_expression8978 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8982 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_boolean_expression8993 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8997 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_boolean_subexpression9069 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_boolean_subexpression9081 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_boolean_subexpression9087 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9172 = new BitSet(new long[]{0x0020020000000002L,0x0000000000000000L,0x0000000800000000L,0x0200000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_numeric_expression9188 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9192 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_numeric_expression9208 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9212 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_numeric_expression9226 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9230 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_numeric_expression9241 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9245 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_numeric_expression9256 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9260 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_numeric_expression9271 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_numeric_expression9286 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9290 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_numeric_subexpression9362 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_numeric_subexpression9374 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_numeric_subexpression9380 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_expression_in_parenthesized_subexpression9482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_expression_in_parenthesized_subexpression9512 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_subexpression9531 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_parenthesized_subexpression9535 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_subexpression9539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_expression9576 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9580 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9586 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9590 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9598 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_case_expression9605 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_choice9642 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_case_choice9647 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_case_choice9649 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_case_choice9652 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_case_choice9657 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9672 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_expression9674 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9678 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_expression9682 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9687 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_expression9689 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9694 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9696 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9726 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9730 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_conditional_expression9734 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9739 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_expression9741 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9746 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_value9788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_value9840 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800008000L});
	public static final BitSet FOLLOW_QUESTION_in_value9846 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9852 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_value9856 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9862 = new BitSet(new long[]{0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_value9866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9873 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000080000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_value9877 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_value9972 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_value9987 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_LITERAL_mode_in_value9989 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_value9991 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_value9996 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_value9999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_value10025 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_null_in_value10040 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_now_in_value10055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_tops_in_value10070 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_value_constant10098 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_value_constant10102 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_constant_in_value_constant10108 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_value_constant10114 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_value_in_value_constant10120 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10151 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_enumeration_value10155 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10159 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_constant_in_property10195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_reference_in_property10199 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_constant10217 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_constant10221 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_constant10227 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10244 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10248 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_property_field_in_property_reference10263 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_self_in_property_reference10293 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10297 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10301 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_property_field_in_property_reference10307 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_property_reference10341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10345 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10349 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_property_field_in_property_reference10359 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_LBRACKET_in_property_field10399 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_set_in_property_field10402 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_property_field10410 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_property_field10418 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000100000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_set_in_property_field10421 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_name10447 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_name10451 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_name10456 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_numeric_constant10494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_LIT_in_numeric_constant10501 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rational_literal_in_numeric_constant10510 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_complex_literal_in_numeric_constant10514 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_numeric_constant10520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_relation10552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10582 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_expression_or_relation10591 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10595 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_relation10623 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10672 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_boolean_expression_or_relation10682 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10686 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_expression_in_boolean_expression_or_relation10713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_function_call10762 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_function_call10764 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_function_call10774 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_function_call10778 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_function_parameters_in_function_call10782 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_function_call10785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10844 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10848 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10854 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10864 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10869 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_ID_in_formal_expression_pair10891 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_expression_pair10893 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_formal_expression_pair10898 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_name_in_type10923 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_type_in_type10942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_type_in_type10961 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_type_in_type10980 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_type_in_type10999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_variant_type_in_type11018 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_type11040 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_string_in_type11055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_enumeration_in_enumeration_type11084 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_enumeration_type11087 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11092 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_enumeration_type11098 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11101 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_enumeration_type11105 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_number_type11160 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_number_type11169 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_number_type11178 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_number_type11187 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_number_type11196 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_number_type11204 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_number_range_in_number_type11212 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_units_in_number_type11219 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000104400080000L,0x0000200000001004L});
	public static final BitSet FOLLOW_units_designator_in_number_type11223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_number_range11288 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2200000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_constant_number_range_in_number_range11291 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_number_range11293 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11311 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2000000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11316 = new BitSet(new long[]{0x0000100000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range11320 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2200000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11324 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2000000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11329 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_units_designator11443 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_unit_in_units_designator11449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11489 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11493 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11498 = new BitSet(new long[]{0x0000200000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11510 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11515 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11573 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11581 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11586 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_type_name11662 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_type_name11667 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_type_name11672 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_array_in_array_type11699 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_array_type11702 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_array_range_list_in_array_type11705 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_array_type11707 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_array_type11710 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_type_in_array_type11712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_record_in_record_type11739 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_record_type11742 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_record_field_in_record_type11745 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_record_type11748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_field11777 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_record_field11779 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_type_in_record_field11782 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_field11784 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11814 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11818 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11821 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11825 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11828 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11865 = new BitSet(new long[]{0x0000100000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11871 = new BitSet(new long[]{0x0000100000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11877 = new BitSet(new long[]{0x0000100000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_natural_range11887 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11894 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11900 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11906 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variant_in_variant_type11943 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_variant_type11951 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_record_field_in_variant_type11954 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_variant_type11957 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_subclause11986 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001804L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_subclause11997 = new BitSet(new long[]{0x0000000000000402L,0x0000000000000800L});
	public static final BitSet FOLLOW_predicate_in_assertion_annex_subclause12020 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_subclause12041 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_library12069 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_library12080 = new BitSet(new long[]{0x0000000000000402L,0x0000000000000800L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_library12103 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LASS_in_assertion12133 = new BitSet(new long[]{0x4000000000020010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200010L});
	public static final BitSet FOLLOW_assertion_body_in_assertion12138 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RASS_in_assertion12140 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12195 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12199 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12203 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12207 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12263 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12290 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12294 = new BitSet(new long[]{0x4000000010000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12298 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12301 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12305 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12397 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12401 = new BitSet(new long[]{0x4000000000020000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12405 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12408 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12412 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12503 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12543 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_formal_assertion_parameter12594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TILDE_in_formal_assertion_parameter12596 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_type_name_in_formal_assertion_parameter12599 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12615 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12619 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12622 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12631 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12633 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_assertion_function_value12667 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_value12686 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_function12712 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12719 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12725 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12729 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12736 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12740 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_function12750 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_condition_value_pair12791 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_condition_value_pair12793 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_condition_value_pair12796 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12814 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12817 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_assertion_enumeration12820 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12823 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12838 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_assertion_enumeration12841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_enumeration_pair12860 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_enumeration_pair12863 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_enumeration_pair12866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_all_in_universal_quantification12885 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_universal_quantification12888 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_universal_quantification12890 = new BitSet(new long[]{0x0000000000000000L,0x0000000100000000L});
	public static final BitSet FOLLOW_LITERAL_are_in_universal_quantification12894 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_universal_quantification12897 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exists_in_existential_quantification12923 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_existential_quantification12926 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_existential_quantification12928 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_existential_quantification12932 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_existential_quantification12935 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_logic_variables12963 = new BitSet(new long[]{0x0000000030000000L});
	public static final BitSet FOLLOW_COMMA_in_logic_variables12966 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_logic_variables12970 = new BitSet(new long[]{0x0000000030000000L});
	public static final BitSet FOLLOW_COLON_in_logic_variables12976 = new BitSet(new long[]{0x4000000000000000L,0x0000201000000000L,0x0000008008000000L,0x0000000200000060L});
	public static final BitSet FOLLOW_assertion_type_in_logic_variables12980 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_logic_variable_domain13032 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x20006C800900000AL,0x2220009604402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13061 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_logic_variable_domain13065 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13069 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_logic_variable_domain13104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_quantification_in_predicate13164 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_quantification_in_predicate13172 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13181 = new BitSet(new long[]{0x8000000000000002L,0x0000000010000000L,0x0002000000A00000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13199 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13202 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13206 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13209 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13229 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13232 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13236 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13239 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13262 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13265 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13269 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13272 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_implies_in_predicate13294 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13297 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_iff_in_predicate13316 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13319 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IMP_in_predicate13337 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13340 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_subpredicate13382 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x0000288009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13412 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_subpredicate13416 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13420 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13495 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_subpredicate13499 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_range_in_subpredicate13503 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_subpredicate13571 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_subpredicate13575 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13581 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_subpredicate13623 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_subpredicate13661 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_subpredicate13697 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_invocation_in_subpredicate13742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_predicate_in_subpredicate13776 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_def_in_subpredicate13813 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_assertion_parameter_in_subpredicate13817 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_timed_predicate13866 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate13870 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate13874 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_timed_predicate13880 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_predicate13888 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_predicate13891 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_predicate13900 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_timed_predicate13903 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_predicate13941 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_parenthesized_predicate13944 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_predicate13946 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_floatingAtom13966 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_period_shift13994 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14012 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14016 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift14042 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14046 = new BitSet(new long[]{0x0000020000000000L,0x0000000000000000L,0x0000000000000000L,0x0200000000000000L,0x0000002000800008L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14057 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14061 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14065 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_period_shift14079 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14083 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14087 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14101 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14105 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800008L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14108 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14112 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800008L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14118 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14134 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14138 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000800000L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14141 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14145 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000800000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14151 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14335 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14339 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14341 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14376 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14380 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_invocation14384 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14429 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14433 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14437 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_predicate_invocation14441 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14445 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14451 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter14508 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_actual_assertion_parameter14512 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_actual_assertion_parameter14516 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_expression_in_range14562 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_range14564 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_expression_in_range14567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14593 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_assertion_range14595 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14598 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_sum_in_assertion_expression14633 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14635 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14639 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14644 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14646 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_product_in_assertion_expression14678 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14680 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14684 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14689 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14691 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_numberof_in_assertion_expression14721 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14723 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14727 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_assertion_expression14732 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_assertion_expression14734 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14768 = new BitSet(new long[]{0x0020020000000002L,0x0000000000000000L,0x0000000800000000L,0x0200000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_assertion_expression14782 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14784 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_assertion_expression14817 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14819 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_assertion_expression14853 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14855 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_assertion_expression14886 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14888 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_assertion_expression14920 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14922 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_assertion_expression14954 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14956 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_assertion_expression14981 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14983 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_assertion_subexpression15043 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_abs_in_assertion_subexpression15049 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression15069 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_type_conversion_in_assertion_subexpression15129 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_vpa_in_timed_expression15162 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_timed_expression15167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_expression15175 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_expression15178 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_expression15187 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_timed_expression15190 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_vpa15218 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_vpa15228 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_vpa15238 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15255 = new BitSet(new long[]{0x0020020000000002L,0x0000000000000000L,0x0000000800000000L,0x0200000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15266 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15271 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15275 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15279 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15294 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15299 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15303 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15307 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_time_expression15322 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15327 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_time_expression15340 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15345 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_time_expression15358 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15363 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_time_expression15376 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15381 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_time_expression15394 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15399 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_time_subexpression15426 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_time_subexpression15436 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_time_subexpression15444 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_time_subexpression15453 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_expression_in_time_subexpression15457 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_time_subexpression15461 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15581 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15585 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000A00000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_invocation15589 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15592 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15639 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15643 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15652 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_assertion_function_invocation15656 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15660 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15665 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15752 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15782 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15816 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_assertion_expression15837 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_parenthesized_assertion_expression15841 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_assertion_expression15845 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15877 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_assertion_expression15879 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15883 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_assertion_expression15887 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15892 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_assertion_expression15894 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15899 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression15901 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15929 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15933 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_conditional_assertion_expression15937 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15942 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_assertion_expression15944 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15949 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression15951 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_record_term15989 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_assertion_record_value_in_assertion_record_term15992 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_record_term15995 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_record_value16010 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_assertion_record_value16012 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2000009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_assertion_record_value16015 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_assertion_record_value16017 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_parameter16033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_assertion_type16051 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type16055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type16059 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type16063 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type16067 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type16071 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type16076 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_assertion_type16083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_availability_in_availability16109 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability16113 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16134 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_availability_expression16148 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16152 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_availability_expression16171 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16175 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_availability_expression16194 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16198 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_not_in_availability_subexpression16290 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_identifier_in_availability_subexpression16305 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_availability_subexpression16315 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_expression_in_availability_subexpression16319 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_availability_subexpression16321 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_dispatch_condition16409 = new BitSet(new long[]{0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_LITERAL_dispatch_in_dispatch_condition16412 = new BitSet(new long[]{0x4000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000400400000L});
	public static final BitSet FOLLOW_dispatch_expression_in_dispatch_condition16416 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16444 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_dispatch_expression16450 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000400400000L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16454 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16503 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_dispatch_conjunction16509 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000400400000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16513 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16570 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_dispatch_trigger16573 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16576 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_dispatch_trigger16579 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_dispatch_trigger16582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16591 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16602 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_dispatch_trigger16612 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_in_modes16663 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_LITERAL_modes_in_in_modes16666 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_in_modes16670 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16676 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_in_modes16680 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16684 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_in_modes16691 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred1_BLESStoAST9464 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred1_BLESStoAST9466 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred1_BLESStoAST9470 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_synpred1_BLESStoAST9472 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_synpred1_BLESStoAST9474 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred2_BLESStoAST9502 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_synpred2_BLESStoAST9504 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_synpred3_BLESStoAST9809 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800008000L});
	public static final BitSet FOLLOW_QUESTION_in_synpred3_BLESStoAST9813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9817 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_synpred3_BLESStoAST9819 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9823 = new BitSet(new long[]{0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_synpred3_BLESStoAST9825 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9828 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000080000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_synpred3_BLESStoAST9830 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred4_BLESStoAST10540 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred4_BLESStoAST10542 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred4_BLESStoAST10544 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred5_BLESStoAST10572 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred5_BLESStoAST10574 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred6_BLESStoAST10662 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred6_BLESStoAST10664 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred7_BLESStoAST12657 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_synpred7_BLESStoAST12659 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_synpred8_BLESStoAST13048 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_synpred8_BLESStoAST13050 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred9_BLESStoAST13398 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred9_BLESStoAST13400 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13479 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_synpred10_BLESStoAST13481 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_synpred11_BLESStoAST13560 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_synpred11_BLESStoAST13562 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_synpred12_BLESStoAST13732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_synpred12_BLESStoAST13734 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred16_BLESStoAST15734 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred16_BLESStoAST15736 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred16_BLESStoAST15740 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_synpred16_BLESStoAST15742 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_synpred16_BLESStoAST15744 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred17_BLESStoAST15770 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred17_BLESStoAST15772 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred17_BLESStoAST15774 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred18_BLESStoAST15804 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred18_BLESStoAST15806 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_synpred18_BLESStoAST15808 = new BitSet(new long[]{0x0000000000000002L});
}
