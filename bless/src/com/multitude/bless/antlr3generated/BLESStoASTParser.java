<<<<<<< HEAD
// $ANTLR 3.5.2 /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g 2023-02-08 13:04:13
=======
// $ANTLR 3.5.2 /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g 2023-02-21 12:41:11
>>>>>>> origin/continuum

//copyright 2020 Multitude Corporation
package com.multitude.bless.antlr3generated;
import java.util.HashMap;
import java.util.Vector;
//import com.multitude.bless.BAST;
import org.antlr.runtime.Parser;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.UnwantedTokenException;
import com.multitude.bless.exceptions.*;
import com.multitude.bless.tree.BAST;
import com.multitude.bless.ui.preferences.ConfigurationPreferencePage;
import com.multitude.bless.app.Global;
import com.multitude.bless.record.ParseRecord;
import com.multitude.bless.record.PackageRecord;
import com.multitude.bless.record.ThreadRecord;
import com.multitude.bless.record.DataRecord;
import com.multitude.bless.record.SubprogramRecord;
import com.multitude.bless.record.PropertySetRecord;
//import com.multitude.bless.symbol.Model;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings("all")
public class BLESStoASTParser extends Parser {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AADL_STRING_LITERAL", "AADL_STRING_PART", 
		"ACTION", "AL", "AM", "AMPERSAND", "ANNEX_END", "ANNEX_START", "ARROW", 
		"ASSERTION", "ASSERTION_ANNEX", "ASSERTION_ENUMERATION", "ASSERTION_FUNCTION", 
		"ASSIGN", "AT_SIGN", "BASE", "BASED_INTEGER", "BEHAVIOR_GUARD", "BEHAVIOR_TIME", 
<<<<<<< HEAD
		"BI", "BOUND", "BOX", "CARET", "CASE_EXPRESSION", "COLON", "COMMA", "COMMACOMMA", 
		"COMMADOT", "COMPLEX", "COMPONENT", "CONDITION", "CONDITIONAL", "CONDITIONAL_FUNCTION", 
		"CONNECTION", "COUNTING_TRIGGER", "DESTINATION", "DIGIT", "DIVIDE", "DOLLAR", 
		"DOTCOMMA", "DOTDOT", "DOUBLE_COLON", "DOUBLE_QUOTE", "DO_NOT_PROVE", 
		"DUMMY", "EMPTY_CURLY", "END_ASSERTION_PROPERTY", "EQ", "EXCLAMATION", 
		"EXP", "EXPONENT", "EXTENDED_DIGIT", "FLOATING", "FUNCTION", "FUNCTION_CALL", 
		"GT", "GUARD", "HEX_DIGIT", "ID", "IMP", "INMODE", "INOUT", "INTEGER_LIT", 
		"INT_EXPONENT", "INVARIANT", "INVOKE", "INVOKE_FUNCTION", "IP_NAME", "IP_PE", 
		"IP_PRED", "LABEL", "LASS", "LBRACKET", "LCON", "LCURLY", "LITERAL_Assertion", 
		"LITERAL_Invariant", "LITERAL_Postcondition", "LITERAL_Precondition", 
		"LITERAL_Typed", "LITERAL_aadlboolean", "LITERAL_aadlinteger", "LITERAL_aadlreal", 
		"LITERAL_aadlstring", "LITERAL_abs", "LITERAL_abstract", "LITERAL_access", 
		"LITERAL_all", "LITERAL_and", "LITERAL_annex", "LITERAL_any", "LITERAL_applies", 
		"LITERAL_are", "LITERAL_array", "LITERAL_assert", "LITERAL_availability", 
=======
		"BI", "BOUND", "BOX", "CARET", "CASE_EXPRESSION", "COLON", "COLON_TILDE", 
		"COMMA", "COMMACOMMA", "COMMADOT", "COMPLEX", "COMPONENT", "CONDITION", 
		"CONDITIONAL", "CONDITIONAL_FUNCTION", "CONNECTION", "COUNTING_TRIGGER", 
		"DESTINATION", "DIGIT", "DIVIDE", "DOLLAR", "DOTCOMMA", "DOTDOT", "DOUBLE_COLON", 
		"DOUBLE_QUOTE", "DO_NOT_PROVE", "DUMMY", "EMPTY_CURLY", "END_ASSERTION_PROPERTY", 
		"EQ", "EXCLAMATION", "EXP", "EXPONENT", "EXTENDED_DIGIT", "FLOATING", 
		"FUNCTION", "FUNCTION_CALL", "GT", "GUARD", "HEX_DIGIT", "ID", "IMP", 
		"INMODE", "INOUT", "INTEGER_LIT", "INT_EXPONENT", "INVARIANT", "INVOKE", 
		"INVOKE_FUNCTION", "IP_NAME", "IP_PE", "IP_PRED", "LABEL", "LASS", "LBRACKET", 
		"LCON", "LCURLY", "LITERAL_Assertion", "LITERAL_Invariant", "LITERAL_Postcondition", 
		"LITERAL_Precondition", "LITERAL_Typed", "LITERAL_aadlboolean", "LITERAL_aadlinteger", 
		"LITERAL_aadlreal", "LITERAL_aadlstring", "LITERAL_abs", "LITERAL_abstract", 
		"LITERAL_access", "LITERAL_all", "LITERAL_and", "LITERAL_annex", "LITERAL_any", 
		"LITERAL_applies", "LITERAL_are", "LITERAL_array", "LITERAL_assert", "LITERAL_availability", 
>>>>>>> origin/continuum
		"LITERAL_boolean", "LITERAL_bound", "LITERAL_bus", "LITERAL_call", "LITERAL_calls", 
		"LITERAL_cand", "LITERAL_catch", "LITERAL_classifier", "LITERAL_complete", 
		"LITERAL_complex", "LITERAL_component", "LITERAL_computation", "LITERAL_connection", 
		"LITERAL_connections", "LITERAL_constant", "LITERAL_cor", "LITERAL_count", 
		"LITERAL_data", "LITERAL_declare", "LITERAL_def", "LITERAL_delay", "LITERAL_device", 
		"LITERAL_dispatch", "LITERAL_do", "LITERAL_else", "LITERAL_end", "LITERAL_enumeration", 
		"LITERAL_event", "LITERAL_exception", "LITERAL_exists", "LITERAL_extends", 
		"LITERAL_false", "LITERAL_feature", "LITERAL_features", "LITERAL_fetchadd", 
		"LITERAL_fetchand", "LITERAL_fetchor", "LITERAL_fetchxor", "LITERAL_fi", 
		"LITERAL_final", "LITERAL_flow", "LITERAL_flows", "LITERAL_for", "LITERAL_forall", 
		"LITERAL_fresh", "LITERAL_function", "LITERAL_group", "LITERAL_hr", "LITERAL_if", 
		"LITERAL_iff", "LITERAL_implementation", "LITERAL_implies", "LITERAL_in", 
		"LITERAL_inherit", "LITERAL_initial", "LITERAL_integer", "LITERAL_invariant", 
		"LITERAL_inverse", "LITERAL_is", "LITERAL_list", "LITERAL_lower_bound", 
		"LITERAL_memory", "LITERAL_min", "LITERAL_mod", "LITERAL_mode", "LITERAL_modes", 
		"LITERAL_ms", "LITERAL_natural", "LITERAL_none", "LITERAL_nonvolatile", 
		"LITERAL_not", "LITERAL_now", "LITERAL_ns", "LITERAL_null", "LITERAL_numberof", 
		"LITERAL_of", "LITERAL_on", "LITERAL_or", "LITERAL_out", "LITERAL_package", 
		"LITERAL_parameter", "LITERAL_pause", "LITERAL_port", "LITERAL_post", 
		"LITERAL_pre", "LITERAL_private", "LITERAL_procedure", "LITERAL_process", 
		"LITERAL_processor", "LITERAL_product", "LITERAL_properties", "LITERAL_property", 
		"LITERAL_prototypes", "LITERAL_provides", "LITERAL_ps", "LITERAL_public", 
		"LITERAL_range", "LITERAL_rational", "LITERAL_real", "LITERAL_record", 
		"LITERAL_reference", "LITERAL_rem", "LITERAL_renames", "LITERAL_requires", 
		"LITERAL_sec", "LITERAL_self", "LITERAL_sequence", "LITERAL_set", "LITERAL_setmode", 
		"LITERAL_shared", "LITERAL_skip", "LITERAL_spread", "LITERAL_state", "LITERAL_states", 
		"LITERAL_stop", "LITERAL_string", "LITERAL_subcomponents", "LITERAL_subprogram", 
		"LITERAL_sum", "LITERAL_swap", "LITERAL_system", "LITERAL_that", "LITERAL_then", 
		"LITERAL_thread", "LITERAL_throw", "LITERAL_time", "LITERAL_timeout", 
		"LITERAL_to", "LITERAL_tops", "LITERAL_transition", "LITERAL_transitions", 
		"LITERAL_true", "LITERAL_type", "LITERAL_units", "LITERAL_until", "LITERAL_updated", 
		"LITERAL_upper_bound", "LITERAL_us", "LITERAL_variables", "LITERAL_variant", 
		"LITERAL_virtual", "LITERAL_when", "LITERAL_while", "LITERAL_with", "LITERAL_xor", 
		"LPAREN", "LT", "LTE_STRING", "LT_STRING", "MINUS", "MT_STRING", "NEQ", 
		"OBLIGATION", "OCTOTHORPE", "ON", "P", "PARAMETER", "PARAMETERS", "PERIOD", 
		"PLUS", "PLUS_ARROW", "PLUS_EQUALS", "PORT", "PORT_INPUT", "PORT_OUTPUT", 
		"PREDICATE_RELATION", "PROCEDURE", "PROCEDURE_CALL", "PROPERTY_LIST", 
		"Q", "QQ", "QUESTION", "RASS", "RATIONAL", "RBRACKET", "RCON", "RCURLY", 
		"REAL_LIT", "RECORD_VALUE", "RPAREN", "S", "SEMICOLON", "SLCOMMENT", "SOURCE", 
		"START", "START_ASSERTION_PROPERTY", "STOP", "SUBCOMPONENT", "SUBPROGRAM_ANNEX", 
		"THREAD_ANNEX", "THREAD_GROUP", "TICK", "TILDE", "TIMES", "TOP", "TRANSITION", 
		"TYPE", "TYPE_OPERATOR", "TYPE_OPERATOR_INVOCATION", "UNARY_MINUS", "VALUE", 
		"WP", "WS", "'|'"
	};
	public static final int EOF=-1;
<<<<<<< HEAD
	public static final int T__303=303;
=======
	public static final int T__304=304;
>>>>>>> origin/continuum
	public static final int AADL_STRING_LITERAL=4;
	public static final int AADL_STRING_PART=5;
	public static final int ACTION=6;
	public static final int AL=7;
	public static final int AM=8;
	public static final int AMPERSAND=9;
	public static final int ANNEX_END=10;
	public static final int ANNEX_START=11;
	public static final int ARROW=12;
	public static final int ASSERTION=13;
	public static final int ASSERTION_ANNEX=14;
	public static final int ASSERTION_ENUMERATION=15;
	public static final int ASSERTION_FUNCTION=16;
	public static final int ASSIGN=17;
	public static final int AT_SIGN=18;
	public static final int BASE=19;
	public static final int BASED_INTEGER=20;
	public static final int BEHAVIOR_GUARD=21;
	public static final int BEHAVIOR_TIME=22;
	public static final int BI=23;
	public static final int BOUND=24;
	public static final int BOX=25;
	public static final int CARET=26;
	public static final int CASE_EXPRESSION=27;
	public static final int COLON=28;
<<<<<<< HEAD
	public static final int COMMA=29;
	public static final int COMMACOMMA=30;
	public static final int COMMADOT=31;
	public static final int COMPLEX=32;
	public static final int COMPONENT=33;
	public static final int CONDITION=34;
	public static final int CONDITIONAL=35;
	public static final int CONDITIONAL_FUNCTION=36;
	public static final int CONNECTION=37;
	public static final int COUNTING_TRIGGER=38;
	public static final int DESTINATION=39;
	public static final int DIGIT=40;
	public static final int DIVIDE=41;
	public static final int DOLLAR=42;
	public static final int DOTCOMMA=43;
	public static final int DOTDOT=44;
	public static final int DOUBLE_COLON=45;
	public static final int DOUBLE_QUOTE=46;
	public static final int DO_NOT_PROVE=47;
	public static final int DUMMY=48;
	public static final int EMPTY_CURLY=49;
	public static final int END_ASSERTION_PROPERTY=50;
	public static final int EQ=51;
	public static final int EXCLAMATION=52;
	public static final int EXP=53;
	public static final int EXPONENT=54;
	public static final int EXTENDED_DIGIT=55;
	public static final int FLOATING=56;
	public static final int FUNCTION=57;
	public static final int FUNCTION_CALL=58;
	public static final int GT=59;
	public static final int GUARD=60;
	public static final int HEX_DIGIT=61;
	public static final int ID=62;
	public static final int IMP=63;
	public static final int INMODE=64;
	public static final int INOUT=65;
	public static final int INTEGER_LIT=66;
	public static final int INT_EXPONENT=67;
	public static final int INVARIANT=68;
	public static final int INVOKE=69;
	public static final int INVOKE_FUNCTION=70;
	public static final int IP_NAME=71;
	public static final int IP_PE=72;
	public static final int IP_PRED=73;
	public static final int LABEL=74;
	public static final int LASS=75;
	public static final int LBRACKET=76;
	public static final int LCON=77;
	public static final int LCURLY=78;
	public static final int LITERAL_Assertion=79;
	public static final int LITERAL_Invariant=80;
	public static final int LITERAL_Postcondition=81;
	public static final int LITERAL_Precondition=82;
	public static final int LITERAL_Typed=83;
	public static final int LITERAL_aadlboolean=84;
	public static final int LITERAL_aadlinteger=85;
	public static final int LITERAL_aadlreal=86;
	public static final int LITERAL_aadlstring=87;
	public static final int LITERAL_abs=88;
	public static final int LITERAL_abstract=89;
	public static final int LITERAL_access=90;
	public static final int LITERAL_all=91;
	public static final int LITERAL_and=92;
	public static final int LITERAL_annex=93;
	public static final int LITERAL_any=94;
	public static final int LITERAL_applies=95;
	public static final int LITERAL_are=96;
	public static final int LITERAL_array=97;
	public static final int LITERAL_assert=98;
	public static final int LITERAL_availability=99;
	public static final int LITERAL_boolean=100;
	public static final int LITERAL_bound=101;
	public static final int LITERAL_bus=102;
	public static final int LITERAL_call=103;
	public static final int LITERAL_calls=104;
	public static final int LITERAL_cand=105;
	public static final int LITERAL_catch=106;
	public static final int LITERAL_classifier=107;
	public static final int LITERAL_complete=108;
	public static final int LITERAL_complex=109;
	public static final int LITERAL_component=110;
	public static final int LITERAL_computation=111;
	public static final int LITERAL_connection=112;
	public static final int LITERAL_connections=113;
	public static final int LITERAL_constant=114;
	public static final int LITERAL_cor=115;
	public static final int LITERAL_count=116;
	public static final int LITERAL_data=117;
	public static final int LITERAL_declare=118;
	public static final int LITERAL_def=119;
	public static final int LITERAL_delay=120;
	public static final int LITERAL_device=121;
	public static final int LITERAL_dispatch=122;
	public static final int LITERAL_do=123;
	public static final int LITERAL_else=124;
	public static final int LITERAL_end=125;
	public static final int LITERAL_enumeration=126;
	public static final int LITERAL_event=127;
	public static final int LITERAL_exception=128;
	public static final int LITERAL_exists=129;
	public static final int LITERAL_extends=130;
	public static final int LITERAL_false=131;
	public static final int LITERAL_feature=132;
	public static final int LITERAL_features=133;
	public static final int LITERAL_fetchadd=134;
	public static final int LITERAL_fetchand=135;
	public static final int LITERAL_fetchor=136;
	public static final int LITERAL_fetchxor=137;
	public static final int LITERAL_fi=138;
	public static final int LITERAL_final=139;
	public static final int LITERAL_flow=140;
	public static final int LITERAL_flows=141;
	public static final int LITERAL_for=142;
	public static final int LITERAL_forall=143;
	public static final int LITERAL_fresh=144;
	public static final int LITERAL_function=145;
	public static final int LITERAL_group=146;
	public static final int LITERAL_hr=147;
	public static final int LITERAL_if=148;
	public static final int LITERAL_iff=149;
	public static final int LITERAL_implementation=150;
	public static final int LITERAL_implies=151;
	public static final int LITERAL_in=152;
	public static final int LITERAL_inherit=153;
	public static final int LITERAL_initial=154;
	public static final int LITERAL_integer=155;
	public static final int LITERAL_invariant=156;
	public static final int LITERAL_inverse=157;
	public static final int LITERAL_is=158;
	public static final int LITERAL_list=159;
	public static final int LITERAL_lower_bound=160;
	public static final int LITERAL_memory=161;
	public static final int LITERAL_min=162;
	public static final int LITERAL_mod=163;
	public static final int LITERAL_mode=164;
	public static final int LITERAL_modes=165;
	public static final int LITERAL_ms=166;
	public static final int LITERAL_natural=167;
	public static final int LITERAL_none=168;
	public static final int LITERAL_nonvolatile=169;
	public static final int LITERAL_not=170;
	public static final int LITERAL_now=171;
	public static final int LITERAL_ns=172;
	public static final int LITERAL_null=173;
	public static final int LITERAL_numberof=174;
	public static final int LITERAL_of=175;
	public static final int LITERAL_on=176;
	public static final int LITERAL_or=177;
	public static final int LITERAL_out=178;
	public static final int LITERAL_package=179;
	public static final int LITERAL_parameter=180;
	public static final int LITERAL_pause=181;
	public static final int LITERAL_port=182;
	public static final int LITERAL_post=183;
	public static final int LITERAL_pre=184;
	public static final int LITERAL_private=185;
	public static final int LITERAL_procedure=186;
	public static final int LITERAL_process=187;
	public static final int LITERAL_processor=188;
	public static final int LITERAL_product=189;
	public static final int LITERAL_properties=190;
	public static final int LITERAL_property=191;
	public static final int LITERAL_prototypes=192;
	public static final int LITERAL_provides=193;
	public static final int LITERAL_ps=194;
	public static final int LITERAL_public=195;
	public static final int LITERAL_range=196;
	public static final int LITERAL_rational=197;
	public static final int LITERAL_real=198;
	public static final int LITERAL_record=199;
	public static final int LITERAL_reference=200;
	public static final int LITERAL_rem=201;
	public static final int LITERAL_renames=202;
	public static final int LITERAL_requires=203;
	public static final int LITERAL_sec=204;
	public static final int LITERAL_self=205;
	public static final int LITERAL_sequence=206;
	public static final int LITERAL_set=207;
	public static final int LITERAL_setmode=208;
	public static final int LITERAL_shared=209;
	public static final int LITERAL_skip=210;
	public static final int LITERAL_spread=211;
	public static final int LITERAL_state=212;
	public static final int LITERAL_states=213;
	public static final int LITERAL_stop=214;
	public static final int LITERAL_string=215;
	public static final int LITERAL_subcomponents=216;
	public static final int LITERAL_subprogram=217;
	public static final int LITERAL_sum=218;
	public static final int LITERAL_swap=219;
	public static final int LITERAL_system=220;
	public static final int LITERAL_that=221;
	public static final int LITERAL_then=222;
	public static final int LITERAL_thread=223;
	public static final int LITERAL_throw=224;
	public static final int LITERAL_time=225;
	public static final int LITERAL_timeout=226;
	public static final int LITERAL_to=227;
	public static final int LITERAL_tops=228;
	public static final int LITERAL_transition=229;
	public static final int LITERAL_transitions=230;
	public static final int LITERAL_true=231;
	public static final int LITERAL_type=232;
	public static final int LITERAL_units=233;
	public static final int LITERAL_until=234;
	public static final int LITERAL_updated=235;
	public static final int LITERAL_upper_bound=236;
	public static final int LITERAL_us=237;
	public static final int LITERAL_variables=238;
	public static final int LITERAL_variant=239;
	public static final int LITERAL_virtual=240;
	public static final int LITERAL_when=241;
	public static final int LITERAL_while=242;
	public static final int LITERAL_with=243;
	public static final int LITERAL_xor=244;
	public static final int LPAREN=245;
	public static final int LT=246;
	public static final int LTE_STRING=247;
	public static final int LT_STRING=248;
	public static final int MINUS=249;
	public static final int MT_STRING=250;
	public static final int NEQ=251;
	public static final int OBLIGATION=252;
	public static final int OCTOTHORPE=253;
	public static final int ON=254;
	public static final int P=255;
	public static final int PARAMETER=256;
	public static final int PARAMETERS=257;
	public static final int PERIOD=258;
	public static final int PLUS=259;
	public static final int PLUS_ARROW=260;
	public static final int PLUS_EQUALS=261;
	public static final int PORT=262;
	public static final int PORT_INPUT=263;
	public static final int PORT_OUTPUT=264;
	public static final int PREDICATE_RELATION=265;
	public static final int PROCEDURE=266;
	public static final int PROCEDURE_CALL=267;
	public static final int PROPERTY_LIST=268;
	public static final int Q=269;
	public static final int QQ=270;
	public static final int QUESTION=271;
	public static final int RASS=272;
	public static final int RATIONAL=273;
	public static final int RBRACKET=274;
	public static final int RCON=275;
	public static final int RCURLY=276;
	public static final int REAL_LIT=277;
	public static final int RECORD_VALUE=278;
	public static final int RPAREN=279;
	public static final int S=280;
	public static final int SEMICOLON=281;
	public static final int SLCOMMENT=282;
	public static final int SOURCE=283;
	public static final int START=284;
	public static final int START_ASSERTION_PROPERTY=285;
	public static final int STOP=286;
	public static final int SUBCOMPONENT=287;
	public static final int SUBPROGRAM_ANNEX=288;
	public static final int THREAD_ANNEX=289;
	public static final int THREAD_GROUP=290;
	public static final int TICK=291;
	public static final int TILDE=292;
	public static final int TIMES=293;
	public static final int TOP=294;
	public static final int TRANSITION=295;
	public static final int TYPE=296;
	public static final int TYPE_OPERATOR=297;
	public static final int TYPE_OPERATOR_INVOCATION=298;
	public static final int UNARY_MINUS=299;
	public static final int VALUE=300;
	public static final int WP=301;
	public static final int WS=302;
=======
	public static final int COLON_TILDE=29;
	public static final int COMMA=30;
	public static final int COMMACOMMA=31;
	public static final int COMMADOT=32;
	public static final int COMPLEX=33;
	public static final int COMPONENT=34;
	public static final int CONDITION=35;
	public static final int CONDITIONAL=36;
	public static final int CONDITIONAL_FUNCTION=37;
	public static final int CONNECTION=38;
	public static final int COUNTING_TRIGGER=39;
	public static final int DESTINATION=40;
	public static final int DIGIT=41;
	public static final int DIVIDE=42;
	public static final int DOLLAR=43;
	public static final int DOTCOMMA=44;
	public static final int DOTDOT=45;
	public static final int DOUBLE_COLON=46;
	public static final int DOUBLE_QUOTE=47;
	public static final int DO_NOT_PROVE=48;
	public static final int DUMMY=49;
	public static final int EMPTY_CURLY=50;
	public static final int END_ASSERTION_PROPERTY=51;
	public static final int EQ=52;
	public static final int EXCLAMATION=53;
	public static final int EXP=54;
	public static final int EXPONENT=55;
	public static final int EXTENDED_DIGIT=56;
	public static final int FLOATING=57;
	public static final int FUNCTION=58;
	public static final int FUNCTION_CALL=59;
	public static final int GT=60;
	public static final int GUARD=61;
	public static final int HEX_DIGIT=62;
	public static final int ID=63;
	public static final int IMP=64;
	public static final int INMODE=65;
	public static final int INOUT=66;
	public static final int INTEGER_LIT=67;
	public static final int INT_EXPONENT=68;
	public static final int INVARIANT=69;
	public static final int INVOKE=70;
	public static final int INVOKE_FUNCTION=71;
	public static final int IP_NAME=72;
	public static final int IP_PE=73;
	public static final int IP_PRED=74;
	public static final int LABEL=75;
	public static final int LASS=76;
	public static final int LBRACKET=77;
	public static final int LCON=78;
	public static final int LCURLY=79;
	public static final int LITERAL_Assertion=80;
	public static final int LITERAL_Invariant=81;
	public static final int LITERAL_Postcondition=82;
	public static final int LITERAL_Precondition=83;
	public static final int LITERAL_Typed=84;
	public static final int LITERAL_aadlboolean=85;
	public static final int LITERAL_aadlinteger=86;
	public static final int LITERAL_aadlreal=87;
	public static final int LITERAL_aadlstring=88;
	public static final int LITERAL_abs=89;
	public static final int LITERAL_abstract=90;
	public static final int LITERAL_access=91;
	public static final int LITERAL_all=92;
	public static final int LITERAL_and=93;
	public static final int LITERAL_annex=94;
	public static final int LITERAL_any=95;
	public static final int LITERAL_applies=96;
	public static final int LITERAL_are=97;
	public static final int LITERAL_array=98;
	public static final int LITERAL_assert=99;
	public static final int LITERAL_availability=100;
	public static final int LITERAL_boolean=101;
	public static final int LITERAL_bound=102;
	public static final int LITERAL_bus=103;
	public static final int LITERAL_call=104;
	public static final int LITERAL_calls=105;
	public static final int LITERAL_cand=106;
	public static final int LITERAL_catch=107;
	public static final int LITERAL_classifier=108;
	public static final int LITERAL_complete=109;
	public static final int LITERAL_complex=110;
	public static final int LITERAL_component=111;
	public static final int LITERAL_computation=112;
	public static final int LITERAL_connection=113;
	public static final int LITERAL_connections=114;
	public static final int LITERAL_constant=115;
	public static final int LITERAL_cor=116;
	public static final int LITERAL_count=117;
	public static final int LITERAL_data=118;
	public static final int LITERAL_declare=119;
	public static final int LITERAL_def=120;
	public static final int LITERAL_delay=121;
	public static final int LITERAL_device=122;
	public static final int LITERAL_dispatch=123;
	public static final int LITERAL_do=124;
	public static final int LITERAL_else=125;
	public static final int LITERAL_end=126;
	public static final int LITERAL_enumeration=127;
	public static final int LITERAL_event=128;
	public static final int LITERAL_exception=129;
	public static final int LITERAL_exists=130;
	public static final int LITERAL_extends=131;
	public static final int LITERAL_false=132;
	public static final int LITERAL_feature=133;
	public static final int LITERAL_features=134;
	public static final int LITERAL_fetchadd=135;
	public static final int LITERAL_fetchand=136;
	public static final int LITERAL_fetchor=137;
	public static final int LITERAL_fetchxor=138;
	public static final int LITERAL_fi=139;
	public static final int LITERAL_final=140;
	public static final int LITERAL_flow=141;
	public static final int LITERAL_flows=142;
	public static final int LITERAL_for=143;
	public static final int LITERAL_forall=144;
	public static final int LITERAL_fresh=145;
	public static final int LITERAL_function=146;
	public static final int LITERAL_group=147;
	public static final int LITERAL_hr=148;
	public static final int LITERAL_if=149;
	public static final int LITERAL_iff=150;
	public static final int LITERAL_implementation=151;
	public static final int LITERAL_implies=152;
	public static final int LITERAL_in=153;
	public static final int LITERAL_inherit=154;
	public static final int LITERAL_initial=155;
	public static final int LITERAL_integer=156;
	public static final int LITERAL_invariant=157;
	public static final int LITERAL_inverse=158;
	public static final int LITERAL_is=159;
	public static final int LITERAL_list=160;
	public static final int LITERAL_lower_bound=161;
	public static final int LITERAL_memory=162;
	public static final int LITERAL_min=163;
	public static final int LITERAL_mod=164;
	public static final int LITERAL_mode=165;
	public static final int LITERAL_modes=166;
	public static final int LITERAL_ms=167;
	public static final int LITERAL_natural=168;
	public static final int LITERAL_none=169;
	public static final int LITERAL_nonvolatile=170;
	public static final int LITERAL_not=171;
	public static final int LITERAL_now=172;
	public static final int LITERAL_ns=173;
	public static final int LITERAL_null=174;
	public static final int LITERAL_numberof=175;
	public static final int LITERAL_of=176;
	public static final int LITERAL_on=177;
	public static final int LITERAL_or=178;
	public static final int LITERAL_out=179;
	public static final int LITERAL_package=180;
	public static final int LITERAL_parameter=181;
	public static final int LITERAL_pause=182;
	public static final int LITERAL_port=183;
	public static final int LITERAL_post=184;
	public static final int LITERAL_pre=185;
	public static final int LITERAL_private=186;
	public static final int LITERAL_procedure=187;
	public static final int LITERAL_process=188;
	public static final int LITERAL_processor=189;
	public static final int LITERAL_product=190;
	public static final int LITERAL_properties=191;
	public static final int LITERAL_property=192;
	public static final int LITERAL_prototypes=193;
	public static final int LITERAL_provides=194;
	public static final int LITERAL_ps=195;
	public static final int LITERAL_public=196;
	public static final int LITERAL_range=197;
	public static final int LITERAL_rational=198;
	public static final int LITERAL_real=199;
	public static final int LITERAL_record=200;
	public static final int LITERAL_reference=201;
	public static final int LITERAL_rem=202;
	public static final int LITERAL_renames=203;
	public static final int LITERAL_requires=204;
	public static final int LITERAL_sec=205;
	public static final int LITERAL_self=206;
	public static final int LITERAL_sequence=207;
	public static final int LITERAL_set=208;
	public static final int LITERAL_setmode=209;
	public static final int LITERAL_shared=210;
	public static final int LITERAL_skip=211;
	public static final int LITERAL_spread=212;
	public static final int LITERAL_state=213;
	public static final int LITERAL_states=214;
	public static final int LITERAL_stop=215;
	public static final int LITERAL_string=216;
	public static final int LITERAL_subcomponents=217;
	public static final int LITERAL_subprogram=218;
	public static final int LITERAL_sum=219;
	public static final int LITERAL_swap=220;
	public static final int LITERAL_system=221;
	public static final int LITERAL_that=222;
	public static final int LITERAL_then=223;
	public static final int LITERAL_thread=224;
	public static final int LITERAL_throw=225;
	public static final int LITERAL_time=226;
	public static final int LITERAL_timeout=227;
	public static final int LITERAL_to=228;
	public static final int LITERAL_tops=229;
	public static final int LITERAL_transition=230;
	public static final int LITERAL_transitions=231;
	public static final int LITERAL_true=232;
	public static final int LITERAL_type=233;
	public static final int LITERAL_units=234;
	public static final int LITERAL_until=235;
	public static final int LITERAL_updated=236;
	public static final int LITERAL_upper_bound=237;
	public static final int LITERAL_us=238;
	public static final int LITERAL_variables=239;
	public static final int LITERAL_variant=240;
	public static final int LITERAL_virtual=241;
	public static final int LITERAL_when=242;
	public static final int LITERAL_while=243;
	public static final int LITERAL_with=244;
	public static final int LITERAL_xor=245;
	public static final int LPAREN=246;
	public static final int LT=247;
	public static final int LTE_STRING=248;
	public static final int LT_STRING=249;
	public static final int MINUS=250;
	public static final int MT_STRING=251;
	public static final int NEQ=252;
	public static final int OBLIGATION=253;
	public static final int OCTOTHORPE=254;
	public static final int ON=255;
	public static final int P=256;
	public static final int PARAMETER=257;
	public static final int PARAMETERS=258;
	public static final int PERIOD=259;
	public static final int PLUS=260;
	public static final int PLUS_ARROW=261;
	public static final int PLUS_EQUALS=262;
	public static final int PORT=263;
	public static final int PORT_INPUT=264;
	public static final int PORT_OUTPUT=265;
	public static final int PREDICATE_RELATION=266;
	public static final int PROCEDURE=267;
	public static final int PROCEDURE_CALL=268;
	public static final int PROPERTY_LIST=269;
	public static final int Q=270;
	public static final int QQ=271;
	public static final int QUESTION=272;
	public static final int RASS=273;
	public static final int RATIONAL=274;
	public static final int RBRACKET=275;
	public static final int RCON=276;
	public static final int RCURLY=277;
	public static final int REAL_LIT=278;
	public static final int RECORD_VALUE=279;
	public static final int RPAREN=280;
	public static final int S=281;
	public static final int SEMICOLON=282;
	public static final int SLCOMMENT=283;
	public static final int SOURCE=284;
	public static final int START=285;
	public static final int START_ASSERTION_PROPERTY=286;
	public static final int STOP=287;
	public static final int SUBCOMPONENT=288;
	public static final int SUBPROGRAM_ANNEX=289;
	public static final int THREAD_ANNEX=290;
	public static final int THREAD_GROUP=291;
	public static final int TICK=292;
	public static final int TILDE=293;
	public static final int TIMES=294;
	public static final int TOP=295;
	public static final int TRANSITION=296;
	public static final int TYPE=297;
	public static final int TYPE_OPERATOR=298;
	public static final int TYPE_OPERATOR_INVOCATION=299;
	public static final int UNARY_MINUS=300;
	public static final int VALUE=301;
	public static final int WP=302;
	public static final int WS=303;
>>>>>>> origin/continuum

	// delegates
	public Parser[] getDelegates() {
		return new Parser[] {};
	}

	// delegators


	public BLESStoASTParser(TokenStream input) {
		this(input, new RecognizerSharedState());
	}
	public BLESStoASTParser(TokenStream input, RecognizerSharedState state) {
		super(input, state);
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return BLESStoASTParser.tokenNames; }
	@Override public String getGrammarFileName() { return "/Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g"; }


	/** Map variable name to Integer object holding value */
	HashMap memory = new HashMap();
	Token tok = null;
	public boolean recognitionErrorOccurred = false;    //did a parse error occur?
	public static int countRecognitionErrors = 1; //accumulates count of recognition errors
	public static Vector<String> error_messages = new Vector<String>();

	//MUST SET currentPackageRecord BEFORE USE
	public PackageRecord currentPackageRecord = null;  //created by package_spec
	public PropertySetRecord currentPropertySetRecord = null;  //created by property_set
	public ParseRecord currentParseRecord = null;  //either currentPackageRecord or currentPropertySetRecord
	//public boolean putAssertionsIntoMap = true;  //put Assertions with labels into Proof.label_assertion_map?
	boolean saidTypeError = false;  //has a type exception already happened
	public String fileName = null;

	int startingLine = 0; //starting line of sublanguage in AADL file
	static int staticLine=0;  //used by BAST constructor

	  public void 
	setStartingLine(int line) //sets starting line
	  {
	  startingLine = line;
	  staticLine = line;
	  }

	  public int
	getStartingLine()
	  {
	  return startingLine;
	  }

	  public static int
	getStaticStartingLine()
	  {
	  return staticLine;
	  }
	  
	 
	public void reportError(RecognitionException ex, BAST start)
	  {
	  if (start!=null)
	    if (start.getParent()!=null)
	      ((BAST)start.getParent()).showParseTree("parent of "+start.getText());
	    else
	      start.showParseTree(start.getText());
	  reportError(ex);     
	  }  //end of reportError(RecognitionException ex, BAST start)

	public void reportError(RecognitionException ex)
	  {
	  if ((currentPackageRecord != null) && (currentPackageRecord.packageID != null))
	    Dump.it("In Package "+currentPackageRecord.packageID);
	  if ((currentPackageRecord != null) && (currentPackageRecord.file != null))
	    Dump.it("In File "+currentPackageRecord.file.getName());
	  else if (fileName != null)
	    Dump.it("In File "+fileName);
	  Dump.it("\nBLESS Syntax Error #"+
	    Integer.toString(countRecognitionErrors)+"\n");
	  error_messages.add(getErrorHeader(ex));  
	  Dump.it("\nSome "+Global.dope+", made another "+
	     (Global.kindMessages?"unfortunate":"stupid")+" grammatical mistake. \n"+
	      "We know this because the token we\'re trying to parse has token-type \""+
	      ((ex.getUnexpectedType()>0)&&(ex.getUnexpectedType()<tokenNames.length)?tokenNames[ex.getUnexpectedType()]:Integer.toString(ex.getUnexpectedType()))+
	      "\" "+
	      (ex.token!=null?"having text \""+ex.token.getText()+"\"":"")+"\n"+
	      "  which is not among the permitted token types here on line "+
	      (ex.token!=null?ex.token.getLine():"null ex.token"));
	//  Dump.it("This "+Global.dope+" may not be you, but you must fix it.");
	  if ((ex.node!=null)&&(ex.node instanceof BAST))
	    ((BAST)ex.node).showParseTree(((BAST)ex.node).getText());
	  int x=5;
	  if (ex instanceof UnwantedTokenException)
	    {
	    UnwantedTokenException ute = (UnwantedTokenException)ex;
	    Dump.it("Expecting:  "+tokenNames[ute.expecting]);
	    Dump.it("\nHint: Don\'t include units for numeric literals in BLESS::Assertion property strings.\n");
	    }
	  if (countRecognitionErrors<Global.YouIdiotReportLimit)
	    {
	    recognitionErrorOccurred = true;
	    ex.line = ex.line+startingLine;
	    Dump.it("offending text = \""+input.toString()+"\"");
	    Dump.it(getErrorHeader(ex));
	//    super.reportError(ex);
	  ex.printStackTrace();
	//    StackTraceElement[] ste = ex.getStackTrace(); 
	//    for (int k=0;k<ste.length;k++)
	//      Dump.it("   "+ste[k].toString());     
	//    HelpfulHints.giveHint();
	    }
	  else
	    {
	    Dump.it(countRecognitionErrors+" recognition errors occurred; divide by zero to stop runaway parser");
	    x=(x+x)/(x-5);
	    }
	  countRecognitionErrors++;
	//  // Global.stopProof = true; 
	  } //end of reportError

	public int errorCount = 0;
	public final int errorLimit=3;

	//REPLACE THIS WITH LOOK-UP OF OSATE RENAMES CLAUSE
	public String timeAlias = "T";

	//public void emitErrorMessage(String msg) 
	//  {
	//  System.err.println(msg);
	//  Dump.it(msg);
	//  }

	public void recover(IntStream input, RecognitionException re) {}
	 

	//tell user of BNF when they make a mistake 
	public boolean toldBNF=false;         
	public void tellBNF(String s, RecognitionException re)
	  {
	  if (!toldBNF)
	    {
	    Dump.it("BNF reminder:\n"+s);
	    toldBNF=true;
	    }
	  } //end of tellBNF(String s, RecognitionException re)
	  
	public void tellBNF(String s, RecognitionException re, BAST errorTree)
	  {
	  if (errorTree!=null)
	    {
	    errorTree.showParseTree(errorTree.getText()!=null?errorTree.getText():"error");
	    Dump.it("error on line "+Integer.toString(errorTree.getLine()+startingLine)+": "+
	      (errorTree.getText()!=null?errorTree.getText():""));
	    }
	  else Dump.it("error tree is null");
	  tellBNF(s,re);
	  }  //end of tellBNF(String s, RecognitionException re, BAST errorTree)
	  
	  


	public static class rational_literal_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "rational_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:1: rational_literal : LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) ) -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor) -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) ) -> ^( RATIONAL $dividend $divisor) ;
	public final BLESStoASTParser.rational_literal_return rational_literal() throws RecognitionException {
		BLESStoASTParser.rational_literal_return retval = new BLESStoASTParser.rational_literal_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token up=null;
		Token dividend=null;
		Token down=null;
		Token divisor=null;
		Token LBRACKET1=null;
		Token char_literal2=null;
		Token RBRACKET3=null;

		BAST up_tree=null;
		BAST dividend_tree=null;
		BAST down_tree=null;
		BAST divisor_tree=null;
		BAST LBRACKET1_tree=null;
		BAST char_literal2_tree=null;
		BAST RBRACKET3_tree=null;
		RewriteRuleTokenStream stream_INTEGER_LIT=new RewriteRuleTokenStream(adaptor,"token INTEGER_LIT");
<<<<<<< HEAD
		RewriteRuleTokenStream stream_303=new RewriteRuleTokenStream(adaptor,"token 303");
=======
		RewriteRuleTokenStream stream_304=new RewriteRuleTokenStream(adaptor,"token 304");
>>>>>>> origin/continuum
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:723:3: ( LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) ) -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor) -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) ) -> ^( RATIONAL $dividend $divisor) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:3: LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET
			{
<<<<<<< HEAD
			LBRACKET1=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_rational_literal2624); if (state.failed) return retval; 
=======
			LBRACKET1=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_rational_literal2632); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET1);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:14: (up= MINUS )?
			int alt1=2;
			int LA1_0 = input.LA(1);
			if ( (LA1_0==MINUS) ) {
				alt1=1;
			}
			switch (alt1) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:14: up= MINUS
					{
<<<<<<< HEAD
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2628); if (state.failed) return retval; 
=======
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2636); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(up);

					}
					break;

			}

<<<<<<< HEAD
			dividend=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2633); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(dividend);

			char_literal2=(Token)match(input,303,FOLLOW_303_in_rational_literal2635); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_303.add(char_literal2);
=======
			dividend=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2641); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(dividend);

			char_literal2=(Token)match(input,304,FOLLOW_304_in_rational_literal2643); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_304.add(char_literal2);
>>>>>>> origin/continuum

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:51: (down= MINUS )?
			int alt2=2;
			int LA2_0 = input.LA(1);
			if ( (LA2_0==MINUS) ) {
				alt2=1;
			}
			switch (alt2) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:51: down= MINUS
					{
<<<<<<< HEAD
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2639); if (state.failed) return retval; 
=======
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2647); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(down);

					}
					break;

			}

<<<<<<< HEAD
			divisor=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2644); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(divisor);

			RBRACKET3=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_rational_literal2646); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET3);

			// AST REWRITE
			// elements: divisor, divisor, up, dividend, divisor, dividend, divisor, down, down, dividend, up, dividend
=======
			divisor=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2652); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(divisor);

			RBRACKET3=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_rational_literal2654); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET3);

			// AST REWRITE
			// elements: up, dividend, dividend, dividend, divisor, up, dividend, down, divisor, divisor, down, divisor
>>>>>>> origin/continuum
			// token labels: divisor, dividend, up, down
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_divisor=new RewriteRuleTokenStream(adaptor,"token divisor",divisor);
			RewriteRuleTokenStream stream_dividend=new RewriteRuleTokenStream(adaptor,"token dividend",dividend);
			RewriteRuleTokenStream stream_up=new RewriteRuleTokenStream(adaptor,"token up",up);
			RewriteRuleTokenStream stream_down=new RewriteRuleTokenStream(adaptor,"token down",down);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 725:3: -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) )
			if ((up!=null)&&(down!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:34: ^( RATIONAL ^( $up $dividend) ^( $down $divisor) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:45: ^( $up $dividend)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_dividend.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:62: ^( $down $divisor)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_divisor.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 726:3: -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor)
			if (up!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:726:18: ^( RATIONAL ^( $up $dividend) $divisor)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:726:29: ^( $up $dividend)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_dividend.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_divisor.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 727:3: -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) )
			if (down!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:727:20: ^( RATIONAL $dividend ^( $down $divisor) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				adaptor.addChild(root_1, stream_dividend.nextNode());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:727:41: ^( $down $divisor)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_divisor.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 728:3: -> ^( RATIONAL $dividend $divisor)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:728:6: ^( RATIONAL $dividend $divisor)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				adaptor.addChild(root_1, stream_dividend.nextNode());
				adaptor.addChild(root_1, stream_divisor.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rational_literal"


	public static class complex_literal_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "complex_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:1: complex_literal : LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) ) -> {up!=null}? ^( COMPLEX ^( $up $real) $im) -> {down!=null}? ^( COMPLEX $real ^( $down $im) ) -> ^( COMPLEX $real $im) ;
	public final BLESStoASTParser.complex_literal_return complex_literal() throws RecognitionException {
		BLESStoASTParser.complex_literal_return retval = new BLESStoASTParser.complex_literal_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token up=null;
		Token real=null;
		Token down=null;
		Token im=null;
		Token LBRACKET4=null;
		Token COLON5=null;
		Token RBRACKET6=null;

		BAST up_tree=null;
		BAST real_tree=null;
		BAST down_tree=null;
		BAST im_tree=null;
		BAST LBRACKET4_tree=null;
		BAST COLON5_tree=null;
		BAST RBRACKET6_tree=null;
		RewriteRuleTokenStream stream_REAL_LIT=new RewriteRuleTokenStream(adaptor,"token REAL_LIT");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:732:3: ( LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) ) -> {up!=null}? ^( COMPLEX ^( $up $real) $im) -> {down!=null}? ^( COMPLEX $real ^( $down $im) ) -> ^( COMPLEX $real $im) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:3: LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET
			{
<<<<<<< HEAD
			LBRACKET4=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_complex_literal2743); if (state.failed) return retval; 
=======
			LBRACKET4=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_complex_literal2751); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET4);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:14: (up= MINUS )?
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==MINUS) ) {
				alt3=1;
			}
			switch (alt3) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:14: up= MINUS
					{
<<<<<<< HEAD
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2747); if (state.failed) return retval; 
=======
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2755); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(up);

					}
					break;

			}

<<<<<<< HEAD
			real=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2752); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(real);

			COLON5=(Token)match(input,COLON,FOLLOW_COLON_in_complex_literal2754); if (state.failed) return retval; 
=======
			real=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2760); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(real);

			COLON5=(Token)match(input,COLON,FOLLOW_COLON_in_complex_literal2762); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_COLON.add(COLON5);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:46: (down= MINUS )?
			int alt4=2;
			int LA4_0 = input.LA(1);
			if ( (LA4_0==MINUS) ) {
				alt4=1;
			}
			switch (alt4) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:46: down= MINUS
					{
<<<<<<< HEAD
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2758); if (state.failed) return retval; 
=======
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2766); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(down);

					}
					break;

			}

<<<<<<< HEAD
			im=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2763); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(im);

			RBRACKET6=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_complex_literal2765); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET6);

			// AST REWRITE
			// elements: up, real, im, im, real, im, im, down, real, real, down, up
=======
			im=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2771); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(im);

			RBRACKET6=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_complex_literal2773); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET6);

			// AST REWRITE
			// elements: im, up, im, im, up, down, real, real, im, real, real, down
>>>>>>> origin/continuum
			// token labels: im, up, real, down
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_im=new RewriteRuleTokenStream(adaptor,"token im",im);
			RewriteRuleTokenStream stream_up=new RewriteRuleTokenStream(adaptor,"token up",up);
			RewriteRuleTokenStream stream_real=new RewriteRuleTokenStream(adaptor,"token real",real);
			RewriteRuleTokenStream stream_down=new RewriteRuleTokenStream(adaptor,"token down",down);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 734:3: -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) )
			if ((up!=null)&&(down!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:34: ^( COMPLEX ^( $up $real) ^( $down $im) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:44: ^( $up $real)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_real.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:57: ^( $down $im)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_im.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 735:3: -> {up!=null}? ^( COMPLEX ^( $up $real) $im)
			if (up!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:735:18: ^( COMPLEX ^( $up $real) $im)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:735:28: ^( $up $real)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_real.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_im.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 736:3: -> {down!=null}? ^( COMPLEX $real ^( $down $im) )
			if (down!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:736:20: ^( COMPLEX $real ^( $down $im) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				adaptor.addChild(root_1, stream_real.nextNode());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:736:36: ^( $down $im)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_im.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 737:3: -> ^( COMPLEX $real $im)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:737:6: ^( COMPLEX $real $im)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				adaptor.addChild(root_1, stream_real.nextNode());
				adaptor.addChild(root_1, stream_im.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "complex_literal"


	public static class relation_symbol_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "relation_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:740:1: relation_symbol : ( EQ | NEQ | LT | AM | AL | GT );
	public final BLESStoASTParser.relation_symbol_return relation_symbol() throws RecognitionException {
		BLESStoASTParser.relation_symbol_return retval = new BLESStoASTParser.relation_symbol_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set7=null;

		BAST set7_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:741:3: ( EQ | NEQ | LT | AM | AL | GT )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set7=input.LT(1);
			if ( (input.LA(1) >= AL && input.LA(1) <= AM)||input.LA(1)==EQ||input.LA(1)==GT||input.LA(1)==LT||input.LA(1)==NEQ ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set7));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relation_symbol"


	public static class range_symbol_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "range_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:746:1: range_symbol : ( DOTDOT | COMMADOT | DOTCOMMA | COMMACOMMA );
	public final BLESStoASTParser.range_symbol_return range_symbol() throws RecognitionException {
		BLESStoASTParser.range_symbol_return retval = new BLESStoASTParser.range_symbol_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set8=null;

		BAST set8_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:746:14: ( DOTDOT | COMMADOT | DOTCOMMA | COMMACOMMA )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set8=input.LT(1);
			if ( (input.LA(1) >= COMMACOMMA && input.LA(1) <= COMMADOT)||(input.LA(1) >= DOTCOMMA && input.LA(1) <= DOTDOT) ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set8));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range_symbol"


	public static class identifier_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "identifier"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:748:1: identifier : ID ;
	public final BLESStoASTParser.identifier_return identifier() throws RecognitionException {
		BLESStoASTParser.identifier_return retval = new BLESStoASTParser.identifier_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID9=null;

		BAST ID9_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:749:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:749:5: ID
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			ID9=(Token)match(input,ID,FOLLOW_ID_in_identifier2919); if (state.failed) return retval;
=======
			ID9=(Token)match(input,ID,FOLLOW_ID_in_identifier2927); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ID9_tree = (BAST)adaptor.create(ID9);
			adaptor.addChild(root_0, ID9_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re,(BAST)retval.getTree()); Dump.it("\nYou may be using a reserved word inappropriately.\n");throw(re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "identifier"


	public static class annex_library_assertions_return extends ParserRuleReturnScope {
		public BAST newRoot;
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "annex_library_assertions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1083:1: annex_library_assertions[HashMap<String,BAST> assertions_in_library] returns [BAST newRoot] : ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )? ;
	public final BLESStoASTParser.annex_library_assertions_return annex_library_assertions(HashMap<String,BAST> assertions_in_library) throws RecognitionException {
		BLESStoASTParser.annex_library_assertions_return retval = new BLESStoASTParser.annex_library_assertions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START10=null;
		Token ANNEX_END11=null;
		ParserRuleReturnScope ala =null;

		BAST ANNEX_START10_tree=null;
		BAST ANNEX_END11_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1085:3: ( ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1086:3: ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )?
			{
			root_0 = (BAST)adaptor.nil();


			if ( state.backtracking==0 ) {retval.newRoot = new BAST("ASSERTION_ANNEX",BLESStoASTLexer.ASSERTION_ANNEX,getStartingLine());}
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1087:3: ( ANNEX_START )?
			int alt5=2;
			int LA5_0 = input.LA(1);
			if ( (LA5_0==ANNEX_START) ) {
				alt5=1;
			}
			switch (alt5) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1087:3: ANNEX_START
					{
<<<<<<< HEAD
					ANNEX_START10=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_annex_library_assertions3294); if (state.failed) return retval;
=======
					ANNEX_START10=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_annex_library_assertions3302); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					ANNEX_START10_tree = (BAST)adaptor.create(ANNEX_START10);
					adaptor.addChild(root_0, ANNEX_START10_tree);
					}

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1088:5: (ala= assertion )+
			int cnt6=0;
			loop6:
			while (true) {
				int alt6=2;
				int LA6_0 = input.LA(1);
				if ( (LA6_0==LASS) ) {
					alt6=1;
				}

				switch (alt6) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1088:6: ala= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_annex_library_assertions3304);
=======
					pushFollow(FOLLOW_assertion_in_annex_library_assertions3312);
>>>>>>> origin/continuum
					ala=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, ala.getTree());

					if ( state.backtracking==0 ) {if ((assertions_in_library!=null)&&
					      ((ala!=null?((BAST)ala.getTree()):null)!=null)&&((ala!=null?((BAST)ala.getTree()):null).getChild(0)!=null)&&
					      ((ala!=null?((BAST)ala.getTree()):null).getChild(0).getChild(0)!=null)&&
					      ((BAST)(ala!=null?((BAST)ala.getTree()):null).getChild(0)).hasType(BLESStoASTLexer.LABEL)) 
					      assertions_in_library.put(((BAST)(ala!=null?((BAST)ala.getTree()):null).getChild(0).getChild(0)).getText(),(ala!=null?((BAST)ala.getTree()):null));
					      retval.newRoot.addChild((BAST)(ala!=null?((BAST)ala.getTree()):null));}
					}
					break;

				default :
					if ( cnt6 >= 1 ) break loop6;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(6, input);
					throw eee;
				}
				cnt6++;
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1096:3: ( ANNEX_END )?
			int alt7=2;
			int LA7_0 = input.LA(1);
			if ( (LA7_0==ANNEX_END) ) {
				alt7=1;
			}
			switch (alt7) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1096:3: ANNEX_END
					{
<<<<<<< HEAD
					ANNEX_END11=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_annex_library_assertions3324); if (state.failed) return retval;
=======
					ANNEX_END11=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_annex_library_assertions3332); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					ANNEX_END11_tree = (BAST)adaptor.create(ANNEX_END11);
					adaptor.addChild(root_0, ANNEX_END11_tree);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "annex_library_assertions"


	public static class thread_behavior_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "thread_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1676:1: thread_behavior : ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )? -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP ) ;
	public final BLESStoASTParser.thread_behavior_return thread_behavior() throws RecognitionException {
		BLESStoASTParser.thread_behavior_return retval = new BLESStoASTParser.thread_behavior_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token no_proof=null;
		Token s=null;
		Token ANNEX_START12=null;
		Token ANNEX_END13=null;
		List<Object> list_bs=null;
		ParserRuleReturnScope av =null;
		ParserRuleReturnScope ac =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope sv =null;
		ParserRuleReturnScope tran =null;
		RuleReturnScope bs = null;
		BAST no_proof_tree=null;
		BAST s_tree=null;
		BAST ANNEX_START12_tree=null;
		BAST ANNEX_END13_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_LITERAL_states=new RewriteRuleTokenStream(adaptor,"token LITERAL_states");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleTokenStream stream_DO_NOT_PROVE=new RewriteRuleTokenStream(adaptor,"token DO_NOT_PROVE");
		RewriteRuleSubtreeStream stream_assert_clause=new RewriteRuleSubtreeStream(adaptor,"rule assert_clause");
		RewriteRuleSubtreeStream stream_variables=new RewriteRuleSubtreeStream(adaptor,"rule variables");
		RewriteRuleSubtreeStream stream_behavior_state=new RewriteRuleSubtreeStream(adaptor,"rule behavior_state");
		RewriteRuleSubtreeStream stream_invariant_clause=new RewriteRuleSubtreeStream(adaptor,"rule invariant_clause");
		RewriteRuleSubtreeStream stream_availability=new RewriteRuleSubtreeStream(adaptor,"rule availability");
		RewriteRuleSubtreeStream stream_transitions=new RewriteRuleSubtreeStream(adaptor,"rule transitions");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1677:3: ( ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )? -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:3: ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:3: ( ANNEX_START )?
			int alt8=2;
			int LA8_0 = input.LA(1);
			if ( (LA8_0==ANNEX_START) ) {
				alt8=1;
			}
			switch (alt8) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:3: ANNEX_START
					{
<<<<<<< HEAD
					ANNEX_START12=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_thread_behavior3999); if (state.failed) return retval; 
=======
					ANNEX_START12=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_thread_behavior4007); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START12);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1679:11: (no_proof= DO_NOT_PROVE )?
			int alt9=2;
			int LA9_0 = input.LA(1);
			if ( (LA9_0==DO_NOT_PROVE) ) {
				alt9=1;
			}
			switch (alt9) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1679:11: no_proof= DO_NOT_PROVE
					{
<<<<<<< HEAD
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_thread_behavior4006); if (state.failed) return retval; 
=======
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_thread_behavior4014); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_DO_NOT_PROVE.add(no_proof);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1680:5: (av= availability )?
			int alt10=2;
			int LA10_0 = input.LA(1);
			if ( (LA10_0==LITERAL_availability) ) {
				alt10=1;
			}
			switch (alt10) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1680:5: av= availability
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_availability_in_thread_behavior4013);
=======
					pushFollow(FOLLOW_availability_in_thread_behavior4021);
>>>>>>> origin/continuum
					av=availability();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_availability.add(av.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1681:5: (ac= assert_clause )?
			int alt11=2;
			int LA11_0 = input.LA(1);
			if ( (LA11_0==LITERAL_assert) ) {
				alt11=1;
			}
			switch (alt11) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1681:5: ac= assert_clause
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assert_clause_in_thread_behavior4020);
=======
					pushFollow(FOLLOW_assert_clause_in_thread_behavior4028);
>>>>>>> origin/continuum
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assert_clause.add(ac.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1682:6: (inv= invariant_clause )?
			int alt12=2;
			int LA12_0 = input.LA(1);
			if ( (LA12_0==LITERAL_invariant) ) {
				alt12=1;
			}
			switch (alt12) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1682:6: inv= invariant_clause
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_invariant_clause_in_thread_behavior4027);
=======
					pushFollow(FOLLOW_invariant_clause_in_thread_behavior4035);
>>>>>>> origin/continuum
					inv=invariant_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_invariant_clause.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1683:5: (sv= variables )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==LITERAL_variables) ) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1683:5: sv= variables
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_variables_in_thread_behavior4034);
=======
					pushFollow(FOLLOW_variables_in_thread_behavior4042);
>>>>>>> origin/continuum
					sv=variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_variables.add(sv.getTree());
					}
					break;

			}

<<<<<<< HEAD
			s=(Token)match(input,LITERAL_states,FOLLOW_LITERAL_states_in_thread_behavior4041); if (state.failed) return retval; 
=======
			s=(Token)match(input,LITERAL_states,FOLLOW_LITERAL_states_in_thread_behavior4049); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_states.add(s);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1684:20: (bs+= behavior_state )+
			int cnt14=0;
			loop14:
			while (true) {
				int alt14=2;
				int LA14_0 = input.LA(1);
				if ( (LA14_0==ID) ) {
					alt14=1;
				}

				switch (alt14) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1684:22: bs+= behavior_state
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_state_in_thread_behavior4047);
=======
					pushFollow(FOLLOW_behavior_state_in_thread_behavior4055);
>>>>>>> origin/continuum
					bs=behavior_state();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_state.add(bs.getTree());
					if (list_bs==null) list_bs=new ArrayList<Object>();
					list_bs.add(bs.getTree());
					}
					break;

				default :
					if ( cnt14 >= 1 ) break loop14;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(14, input);
					throw eee;
				}
				cnt14++;
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_transitions_in_thread_behavior4056);
=======
			pushFollow(FOLLOW_transitions_in_thread_behavior4064);
>>>>>>> origin/continuum
			tran=transitions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_transitions.add(tran.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1686:3: ( ANNEX_END )?
			int alt15=2;
			int LA15_0 = input.LA(1);
			if ( (LA15_0==ANNEX_END) ) {
				alt15=1;
			}
			switch (alt15) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1686:3: ANNEX_END
					{
<<<<<<< HEAD
					ANNEX_END13=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_thread_behavior4060); if (state.failed) return retval; 
=======
					ANNEX_END13=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_thread_behavior4068); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END13);

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: inv, sv, no_proof, bs, LITERAL_states, ac, tran
=======
			// elements: LITERAL_states, inv, bs, ac, no_proof, tran, sv
>>>>>>> origin/continuum
			// token labels: no_proof
			// rule labels: inv, ac, sv, tran, retval
			// token list labels: 
			// rule list labels: bs
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_no_proof=new RewriteRuleTokenStream(adaptor,"token no_proof",no_proof);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"rule ac",ac!=null?ac.getTree():null);
			RewriteRuleSubtreeStream stream_sv=new RewriteRuleSubtreeStream(adaptor,"rule sv",sv!=null?sv.getTree():null);
			RewriteRuleSubtreeStream stream_tran=new RewriteRuleSubtreeStream(adaptor,"rule tran",tran!=null?tran.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bs=new RewriteRuleSubtreeStream(adaptor,"token bs",list_bs);
			root_0 = (BAST)adaptor.nil();
			// 1687:5: -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1687:8: ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(THREAD_ANNEX, s, "THREAD_ANNEX"+(startingLine>0?"["+startingLine+"]":"")), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1688:9: ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_states, s, "states["+Integer.toString(s.getLine()+startingLine)+"]"), root_2);
				if ( !(stream_bs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bs.hasNext() ) {
					adaptor.addChild(root_2, stream_bs.nextTree());
				}
				stream_bs.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:10: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:15: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_1, stream_inv.nextTree());
				}
				stream_inv.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:21: ( $sv)?
				if ( stream_sv.hasNext() ) {
					adaptor.addChild(root_1, stream_sv.nextTree());
				}
				stream_sv.reset();

				adaptor.addChild(root_1, stream_tran.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:32: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_1, (BAST)adaptor.create(STOP, "STOP"));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
			    Dump.it("RecognitionException in BLESStoAST.thread_behavior");
			     if (re instanceof MismatchedTokenException)
			       Dump.it("\nHey "+HelpfulHints.getIdiot()+"!\n\nDid you put the semicolon *after* "+
			        "the Assertion?\n"+
			        "You must have \"states\" and at least one behvior state:  PowerOn: initial state;\n");
			     tellBNF(GrammarStrings.threadBehavior,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "thread_behavior"


	public static class assert_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assert_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1700:1: assert_clause : la= LITERAL_assert (ass+= assertion )+ -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ ) ;
	public final BLESStoASTParser.assert_clause_return assert_clause() throws RecognitionException {
		BLESStoASTParser.assert_clause_return retval = new BLESStoASTParser.assert_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token la=null;
		List<Object> list_ass=null;
		RuleReturnScope ass = null;
		BAST la_tree=null;
		RewriteRuleTokenStream stream_LITERAL_assert=new RewriteRuleTokenStream(adaptor,"token LITERAL_assert");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1701:3: (la= LITERAL_assert (ass+= assertion )+ -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1702:3: la= LITERAL_assert (ass+= assertion )+
			{
<<<<<<< HEAD
			la=(Token)match(input,LITERAL_assert,FOLLOW_LITERAL_assert_in_assert_clause4149); if (state.failed) return retval; 
=======
			la=(Token)match(input,LITERAL_assert,FOLLOW_LITERAL_assert_in_assert_clause4157); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_assert.add(la);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1702:24: (ass+= assertion )+
			int cnt16=0;
			loop16:
			while (true) {
				int alt16=2;
				int LA16_0 = input.LA(1);
				if ( (LA16_0==LASS) ) {
					alt16=1;
				}

				switch (alt16) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1702:24: ass+= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_assert_clause4153);
=======
					pushFollow(FOLLOW_assertion_in_assert_clause4161);
>>>>>>> origin/continuum
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(ass.getTree());
					if (list_ass==null) list_ass=new ArrayList<Object>();
					list_ass.add(ass.getTree());
					}
					break;

				default :
					if ( cnt16 >= 1 ) break loop16;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(16, input);
					throw eee;
				}
				cnt16++;
			}

			// AST REWRITE
			// elements: LITERAL_assert, ass
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: ass
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ass=new RewriteRuleSubtreeStream(adaptor,"token ass",list_ass);
			root_0 = (BAST)adaptor.nil();
			// 1703:5: -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1703:8: ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_assert, la, "assert["+Integer.toString(la.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_ass.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.assertClause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assert_clause"


	public static class invariant_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "invariant_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1708:1: invariant_clause : li= LITERAL_invariant inv= assertion -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv) ;
	public final BLESStoASTParser.invariant_clause_return invariant_clause() throws RecognitionException {
		BLESStoASTParser.invariant_clause_return retval = new BLESStoASTParser.invariant_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token li=null;
		ParserRuleReturnScope inv =null;

		BAST li_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1709:3: (li= LITERAL_invariant inv= assertion -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1710:3: li= LITERAL_invariant inv= assertion
			{
<<<<<<< HEAD
			li=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_invariant_clause4197); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_invariant.add(li);

			pushFollow(FOLLOW_assertion_in_invariant_clause4201);
=======
			li=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_invariant_clause4205); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_invariant.add(li);

			pushFollow(FOLLOW_assertion_in_invariant_clause4209);
>>>>>>> origin/continuum
			inv=assertion();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
			// AST REWRITE
			// elements: inv, LITERAL_invariant
			// token labels: 
			// rule labels: inv, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1711:5: -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1711:8: ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_invariant, li, "invariant["+Integer.toString(li.getLine()+startingLine)+"]"), root_1);
				adaptor.addChild(root_1, stream_inv.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.invariantClause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "invariant_clause"


	public static class variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1716:1: variables : v= LITERAL_variables (bv+= behavior_variable )+ -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* ) ;
	public final BLESStoASTParser.variables_return variables() throws RecognitionException {
		BLESStoASTParser.variables_return retval = new BLESStoASTParser.variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		BAST v_tree=null;
		RewriteRuleTokenStream stream_LITERAL_variables=new RewriteRuleTokenStream(adaptor,"token LITERAL_variables");
		RewriteRuleSubtreeStream stream_behavior_variable=new RewriteRuleSubtreeStream(adaptor,"rule behavior_variable");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1717:3: (v= LITERAL_variables (bv+= behavior_variable )+ -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1718:3: v= LITERAL_variables (bv+= behavior_variable )+
			{
<<<<<<< HEAD
			v=(Token)match(input,LITERAL_variables,FOLLOW_LITERAL_variables_in_variables4244); if (state.failed) return retval; 
=======
			v=(Token)match(input,LITERAL_variables,FOLLOW_LITERAL_variables_in_variables4252); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_variables.add(v);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1718:23: (bv+= behavior_variable )+
			int cnt17=0;
			loop17:
			while (true) {
				int alt17=2;
				int LA17_0 = input.LA(1);
				if ( (LA17_0==ID) ) {
					alt17=1;
				}

				switch (alt17) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1718:25: bv+= behavior_variable
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_variable_in_variables4250);
=======
					pushFollow(FOLLOW_behavior_variable_in_variables4258);
>>>>>>> origin/continuum
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_variable.add(bv.getTree());
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTree());
					}
					break;

				default :
					if ( cnt17 >= 1 ) break loop17;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(17, input);
					throw eee;
				}
				cnt17++;
			}

			// AST REWRITE
			// elements: LITERAL_variables, bv
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bv=new RewriteRuleSubtreeStream(adaptor,"token bv",list_bv);
			root_0 = (BAST)adaptor.nil();
			// 1719:5: -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1719:8: ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_variables, v, "variables["+Integer.toString(v.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1719:95: ( $bv)*
				while ( stream_bv.hasNext() ) {
					adaptor.addChild(root_1, stream_bv.nextTree());
				}
				stream_bv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.variables,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variables"


	public static class quantified_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "quantified_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1726:1: quantified_variables : v= LITERAL_declare (bv+= behavior_variable )+ -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ ) ;
	public final BLESStoASTParser.quantified_variables_return quantified_variables() throws RecognitionException {
		BLESStoASTParser.quantified_variables_return retval = new BLESStoASTParser.quantified_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		BAST v_tree=null;
		RewriteRuleTokenStream stream_LITERAL_declare=new RewriteRuleTokenStream(adaptor,"token LITERAL_declare");
		RewriteRuleSubtreeStream stream_behavior_variable=new RewriteRuleSubtreeStream(adaptor,"rule behavior_variable");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1727:3: (v= LITERAL_declare (bv+= behavior_variable )+ -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1728:3: v= LITERAL_declare (bv+= behavior_variable )+
			{
<<<<<<< HEAD
			v=(Token)match(input,LITERAL_declare,FOLLOW_LITERAL_declare_in_quantified_variables4302); if (state.failed) return retval; 
=======
			v=(Token)match(input,LITERAL_declare,FOLLOW_LITERAL_declare_in_quantified_variables4310); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_declare.add(v);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1728:21: (bv+= behavior_variable )+
			int cnt18=0;
			loop18:
			while (true) {
				int alt18=2;
				int LA18_0 = input.LA(1);
				if ( (LA18_0==ID) ) {
					alt18=1;
				}

				switch (alt18) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1728:23: bv+= behavior_variable
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_variable_in_quantified_variables4308);
=======
					pushFollow(FOLLOW_behavior_variable_in_quantified_variables4316);
>>>>>>> origin/continuum
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_variable.add(bv.getTree());
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTree());
					}
					break;

				default :
					if ( cnt18 >= 1 ) break loop18;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(18, input);
					throw eee;
				}
				cnt18++;
			}

			// AST REWRITE
			// elements: LITERAL_declare, bv
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bv=new RewriteRuleSubtreeStream(adaptor,"token bv",list_bv);
			root_0 = (BAST)adaptor.nil();
			// 1729:5: -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1729:8: ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_declare, v, "declare["+Integer.toString(v.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_bv.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bv.hasNext() ) {
					adaptor.addChild(root_1, stream_bv.nextTree());
				}
				stream_bv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.quantifiedVariables,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "quantified_variables"


	public static class behavior_variable_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_variable"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1744:1: behavior_variable : dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) ;
	public final BLESStoASTParser.behavior_variable_return behavior_variable() throws RecognitionException {
		BLESStoASTParser.behavior_variable_return retval = new BLESStoASTParser.behavior_variable_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token p=null;
		Token s=null;
		Token con=null;
		Token sp=null;
		Token finl=null;
		Token agn=null;
		Token semi=null;
		ParserRuleReturnScope dec =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope ass =null;

		BAST c_tree=null;
		BAST p_tree=null;
		BAST s_tree=null;
		BAST con_tree=null;
		BAST sp_tree=null;
		BAST finl_tree=null;
		BAST agn_tree=null;
		BAST semi_tree=null;
		RewriteRuleTokenStream stream_LITERAL_shared=new RewriteRuleTokenStream(adaptor,"token LITERAL_shared");
		RewriteRuleTokenStream stream_LITERAL_final=new RewriteRuleTokenStream(adaptor,"token LITERAL_final");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_LITERAL_nonvolatile=new RewriteRuleTokenStream(adaptor,"token LITERAL_nonvolatile");
		RewriteRuleTokenStream stream_LITERAL_spread=new RewriteRuleTokenStream(adaptor,"token LITERAL_spread");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleTokenStream stream_LITERAL_constant=new RewriteRuleTokenStream(adaptor,"token LITERAL_constant");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_declarators=new RewriteRuleSubtreeStream(adaptor,"rule declarators");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:3: (dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1746:3: dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_declarators_in_behavior_variable4368);
=======
			pushFollow(FOLLOW_declarators_in_behavior_variable4376);
>>>>>>> origin/continuum
			dec=declarators();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_declarators.add(dec.getTree());
<<<<<<< HEAD
			c=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_variable4372); if (state.failed) return retval; 
=======
			c=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_variable4380); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_COLON.add(c);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:3: (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )?
			int alt19=6;
			switch ( input.LA(1) ) {
				case LITERAL_nonvolatile:
					{
					alt19=1;
					}
					break;
				case LITERAL_shared:
					{
					alt19=2;
					}
					break;
				case LITERAL_constant:
					{
					alt19=3;
					}
					break;
				case LITERAL_spread:
					{
					alt19=4;
					}
					break;
				case LITERAL_final:
					{
					alt19=5;
					}
					break;
			}
			switch (alt19) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:5: p= LITERAL_nonvolatile
					{
<<<<<<< HEAD
					p=(Token)match(input,LITERAL_nonvolatile,FOLLOW_LITERAL_nonvolatile_in_behavior_variable4381); if (state.failed) return retval; 
=======
					p=(Token)match(input,LITERAL_nonvolatile,FOLLOW_LITERAL_nonvolatile_in_behavior_variable4389); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_nonvolatile.add(p);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:29: s= LITERAL_shared
					{
<<<<<<< HEAD
					s=(Token)match(input,LITERAL_shared,FOLLOW_LITERAL_shared_in_behavior_variable4387); if (state.failed) return retval; 
=======
					s=(Token)match(input,LITERAL_shared,FOLLOW_LITERAL_shared_in_behavior_variable4395); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_shared.add(s);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:48: con= LITERAL_constant
					{
<<<<<<< HEAD
					con=(Token)match(input,LITERAL_constant,FOLLOW_LITERAL_constant_in_behavior_variable4393); if (state.failed) return retval; 
=======
					con=(Token)match(input,LITERAL_constant,FOLLOW_LITERAL_constant_in_behavior_variable4401); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_constant.add(con);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:71: sp= LITERAL_spread
					{
<<<<<<< HEAD
					sp=(Token)match(input,LITERAL_spread,FOLLOW_LITERAL_spread_in_behavior_variable4399); if (state.failed) return retval; 
=======
					sp=(Token)match(input,LITERAL_spread,FOLLOW_LITERAL_spread_in_behavior_variable4407); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_spread.add(sp);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1748:5: finl= LITERAL_final
					{
<<<<<<< HEAD
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_variable4407); if (state.failed) return retval; 
=======
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_variable4415); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_final.add(finl);

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_type_in_behavior_variable4417);
=======
			pushFollow(FOLLOW_type_in_behavior_variable4425);
>>>>>>> origin/continuum
			t=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_type.add(t.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1749:10: (agn= ASSIGN e= expression )?
			int alt20=2;
			int LA20_0 = input.LA(1);
			if ( (LA20_0==ASSIGN) ) {
				alt20=1;
			}
			switch (alt20) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1749:12: agn= ASSIGN e= expression
					{
<<<<<<< HEAD
					agn=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_behavior_variable4423); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(agn);

					pushFollow(FOLLOW_expression_in_behavior_variable4427);
=======
					agn=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_behavior_variable4431); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(agn);

					pushFollow(FOLLOW_expression_in_behavior_variable4435);
>>>>>>> origin/continuum
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:6: (ass= assertion )?
			int alt21=2;
			int LA21_0 = input.LA(1);
			if ( (LA21_0==LASS) ) {
				alt21=1;
			}
			switch (alt21) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:6: ass= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_behavior_variable4437);
=======
					pushFollow(FOLLOW_assertion_in_behavior_variable4445);
>>>>>>> origin/continuum
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(ass.getTree());
					}
					break;

			}

<<<<<<< HEAD
			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_variable4446); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: finl, con, con, semi, finl, semi, s, t, agn, t, dec, ass, sp, c, p, c, e, dec, ass, sp, s, p
			// token labels: p, con, s, c, agn, semi, sp, finl
=======
			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_variable4454); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: e, t, c, ass, t, ass, semi, con, agn, sp, p, p, c, con, s, finl, semi, s, sp, dec, dec, finl
			// token labels: p, c, con, s, agn, semi, sp, finl
>>>>>>> origin/continuum
			// rule labels: ass, dec, t, e, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_p=new RewriteRuleTokenStream(adaptor,"token p",p);
<<<<<<< HEAD
			RewriteRuleTokenStream stream_con=new RewriteRuleTokenStream(adaptor,"token con",con);
			RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
=======
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_con=new RewriteRuleTokenStream(adaptor,"token con",con);
			RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
>>>>>>> origin/continuum
			RewriteRuleTokenStream stream_agn=new RewriteRuleTokenStream(adaptor,"token agn",agn);
			RewriteRuleTokenStream stream_semi=new RewriteRuleTokenStream(adaptor,"token semi",semi);
			RewriteRuleTokenStream stream_sp=new RewriteRuleTokenStream(adaptor,"token sp",sp);
			RewriteRuleTokenStream stream_finl=new RewriteRuleTokenStream(adaptor,"token finl",finl);
			RewriteRuleSubtreeStream stream_ass=new RewriteRuleSubtreeStream(adaptor,"rule ass",ass!=null?ass.getTree():null);
			RewriteRuleSubtreeStream stream_dec=new RewriteRuleSubtreeStream(adaptor,"rule dec",dec!=null?dec.getTree():null);
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1752:5: -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
			if (e!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:19: ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dec.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:29: ^( TYPE[\"TYPE\"] $t)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TYPE, "TYPE"), root_2);
				adaptor.addChild(root_2, stream_t.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:48: ^( $agn $e)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_agn.nextNode(), root_2);
				adaptor.addChild(root_2, stream_e.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:62: ( $ass)?
				if ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:68: ( $p)?
				if ( stream_p.hasNext() ) {
					adaptor.addChild(root_1, stream_p.nextNode());
				}
				stream_p.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:72: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_1, stream_s.nextNode());
				}
				stream_s.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:76: ( $con)?
				if ( stream_con.hasNext() ) {
					adaptor.addChild(root_1, stream_con.nextNode());
				}
				stream_con.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:82: ( $sp)?
				if ( stream_sp.hasNext() ) {
					adaptor.addChild(root_1, stream_sp.nextNode());
				}
				stream_sp.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:87: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_semi.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1753:5: -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:8: ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dec.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:18: ^( TYPE[\"TYPE\"] $t)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TYPE, "TYPE"), root_2);
				adaptor.addChild(root_2, stream_t.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:38: ( $ass)?
				if ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:44: ( $p)?
				if ( stream_p.hasNext() ) {
					adaptor.addChild(root_1, stream_p.nextNode());
				}
				stream_p.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:48: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_1, stream_s.nextNode());
				}
				stream_s.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:52: ( $con)?
				if ( stream_con.hasNext() ) {
					adaptor.addChild(root_1, stream_con.nextNode());
				}
				stream_con.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:58: ( $sp)?
				if ( stream_sp.hasNext() ) {
					adaptor.addChild(root_1, stream_sp.nextNode());
				}
				stream_sp.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:63: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_semi.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.behaviorVariable,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_variable"


	public static class declarators_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "declarators"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1758:1: declarators : d= ID (c= COMMA ds+= ID )* -> {ds!=null}? ^( $c $d ( $ds)+ ) -> $d;
	public final BLESStoASTParser.declarators_return declarators() throws RecognitionException {
		BLESStoASTParser.declarators_return retval = new BLESStoASTParser.declarators_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token d=null;
		Token c=null;
		Token ds=null;
		List<Object> list_ds=null;

		BAST d_tree=null;
		BAST c_tree=null;
		BAST ds_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1759:3: (d= ID (c= COMMA ds+= ID )* -> {ds!=null}? ^( $c $d ( $ds)+ ) -> $d)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1760:24: d= ID (c= COMMA ds+= ID )*
			{
<<<<<<< HEAD
			d=(Token)match(input,ID,FOLLOW_ID_in_declarators4583); if (state.failed) return retval; 
=======
			d=(Token)match(input,ID,FOLLOW_ID_in_declarators4591); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_ID.add(d);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1760:29: (c= COMMA ds+= ID )*
			loop22:
			while (true) {
				int alt22=2;
				int LA22_0 = input.LA(1);
				if ( (LA22_0==COMMA) ) {
					alt22=1;
				}

				switch (alt22) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1760:30: c= COMMA ds+= ID
					{
<<<<<<< HEAD
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_declarators4588); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					ds=(Token)match(input,ID,FOLLOW_ID_in_declarators4593); if (state.failed) return retval; 
=======
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_declarators4596); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					ds=(Token)match(input,ID,FOLLOW_ID_in_declarators4601); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ID.add(ds);

					if (list_ds==null) list_ds=new ArrayList<Object>();
					list_ds.add(ds);
					}
					break;

				default :
					break loop22;
				}
			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: c, d, d, ds
=======
			// elements: ds, d, c, d
>>>>>>> origin/continuum
			// token labels: c, d
			// rule labels: retval
			// token list labels: ds
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
			RewriteRuleTokenStream stream_ds=new RewriteRuleTokenStream(adaptor,"token ds", list_ds);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1761:5: -> {ds!=null}? ^( $c $d ( $ds)+ )
			if (ds!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1761:20: ^( $c $d ( $ds)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_d.nextNode());
				if ( !(stream_ds.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ds.hasNext() ) {
					adaptor.addChild(root_1, stream_ds.nextNode());
				}
				stream_ds.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1762:5: -> $d
			{
				adaptor.addChild(root_0, stream_d.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "declarators"


	public static class behavior_state_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_state"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1792:1: behavior_state : i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? ) ;
	public final BLESStoASTParser.behavior_state_return behavior_state() throws RecognitionException {
		BLESStoASTParser.behavior_state_return retval = new BLESStoASTParser.behavior_state_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token init=null;
		Token com=null;
		Token finl=null;
		Token st=null;
		Token COLON14=null;
		Token SEMICOLON15=null;
		ParserRuleReturnScope i =null;
		ParserRuleReturnScope a =null;

		BAST init_tree=null;
		BAST com_tree=null;
		BAST finl_tree=null;
		BAST st_tree=null;
		BAST COLON14_tree=null;
		BAST SEMICOLON15_tree=null;
		RewriteRuleTokenStream stream_LITERAL_final=new RewriteRuleTokenStream(adaptor,"token LITERAL_final");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_LITERAL_state=new RewriteRuleTokenStream(adaptor,"token LITERAL_state");
		RewriteRuleTokenStream stream_LITERAL_initial=new RewriteRuleTokenStream(adaptor,"token LITERAL_initial");
		RewriteRuleTokenStream stream_LITERAL_complete=new RewriteRuleTokenStream(adaptor,"token LITERAL_complete");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:3: (i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:3: i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_behavior_state4677);
=======
			pushFollow(FOLLOW_identifier_in_behavior_state4685);
>>>>>>> origin/continuum
			i=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
<<<<<<< HEAD
			COLON14=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_state4682); if (state.failed) return retval; 
=======
			COLON14=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_state4690); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_COLON.add(COLON14);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:9: (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )?
			int alt23=4;
			switch ( input.LA(1) ) {
				case LITERAL_initial:
					{
					alt23=1;
					}
					break;
				case LITERAL_complete:
					{
					alt23=2;
					}
					break;
				case LITERAL_final:
					{
					alt23=3;
					}
					break;
			}
			switch (alt23) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:10: init= LITERAL_initial
					{
<<<<<<< HEAD
					init=(Token)match(input,LITERAL_initial,FOLLOW_LITERAL_initial_in_behavior_state4687); if (state.failed) return retval; 
=======
					init=(Token)match(input,LITERAL_initial,FOLLOW_LITERAL_initial_in_behavior_state4695); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_initial.add(init);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:33: com= LITERAL_complete
					{
<<<<<<< HEAD
					com=(Token)match(input,LITERAL_complete,FOLLOW_LITERAL_complete_in_behavior_state4693); if (state.failed) return retval; 
=======
					com=(Token)match(input,LITERAL_complete,FOLLOW_LITERAL_complete_in_behavior_state4701); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_complete.add(com);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:56: finl= LITERAL_final
					{
<<<<<<< HEAD
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_state4699); if (state.failed) return retval; 
=======
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_state4707); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_final.add(finl);

					}
					break;

			}

<<<<<<< HEAD
			st=(Token)match(input,LITERAL_state,FOLLOW_LITERAL_state_in_behavior_state4705); if (state.failed) return retval; 
=======
			st=(Token)match(input,LITERAL_state,FOLLOW_LITERAL_state_in_behavior_state4713); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_state.add(st);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:95: (a= assertion )?
			int alt24=2;
			int LA24_0 = input.LA(1);
			if ( (LA24_0==LASS) ) {
				alt24=1;
			}
			switch (alt24) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:95: a= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_behavior_state4709);
=======
					pushFollow(FOLLOW_assertion_in_behavior_state4717);
>>>>>>> origin/continuum
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
					}
					break;

			}

<<<<<<< HEAD
			SEMICOLON15=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_state4712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON15);

			// AST REWRITE
			// elements: com, i, a, LITERAL_state, finl, init
=======
			SEMICOLON15=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_state4720); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON15);

			// AST REWRITE
			// elements: a, LITERAL_state, i, finl, init, com
>>>>>>> origin/continuum
			// token labels: com, init, finl
			// rule labels: a, i, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_com=new RewriteRuleTokenStream(adaptor,"token com",com);
			RewriteRuleTokenStream stream_init=new RewriteRuleTokenStream(adaptor,"token init",init);
			RewriteRuleTokenStream stream_finl=new RewriteRuleTokenStream(adaptor,"token finl",finl);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1796:5: -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:8: ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_state, st, "state["+Integer.toString(st.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:89: ( $init)?
				if ( stream_init.hasNext() ) {
					adaptor.addChild(root_1, stream_init.nextNode());
				}
				stream_init.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:96: ( $com)?
				if ( stream_com.hasNext() ) {
					adaptor.addChild(root_1, stream_com.nextNode());
				}
				stream_com.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:102: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_i.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:112: ( $a)?
				if ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.behaviorState,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_state"


	public static class transitions_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "transitions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1801:1: transitions : t= LITERAL_transitions (bt+= behavior_transition )+ -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ ) ;
	public final BLESStoASTParser.transitions_return transitions() throws RecognitionException {
		BLESStoASTParser.transitions_return retval = new BLESStoASTParser.transitions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token t=null;
		List<Object> list_bt=null;
		RuleReturnScope bt = null;
		BAST t_tree=null;
		RewriteRuleTokenStream stream_LITERAL_transitions=new RewriteRuleTokenStream(adaptor,"token LITERAL_transitions");
		RewriteRuleSubtreeStream stream_behavior_transition=new RewriteRuleSubtreeStream(adaptor,"rule behavior_transition");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1802:3: (t= LITERAL_transitions (bt+= behavior_transition )+ -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1803:3: t= LITERAL_transitions (bt+= behavior_transition )+
			{
<<<<<<< HEAD
			t=(Token)match(input,LITERAL_transitions,FOLLOW_LITERAL_transitions_in_transitions4772); if (state.failed) return retval; 
=======
			t=(Token)match(input,LITERAL_transitions,FOLLOW_LITERAL_transitions_in_transitions4780); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_transitions.add(t);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1803:27: (bt+= behavior_transition )+
			int cnt25=0;
			loop25:
			while (true) {
				int alt25=2;
				int LA25_0 = input.LA(1);
				if ( (LA25_0==ID) ) {
					alt25=1;
				}

				switch (alt25) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1803:27: bt+= behavior_transition
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_transition_in_transitions4776);
=======
					pushFollow(FOLLOW_behavior_transition_in_transitions4784);
>>>>>>> origin/continuum
					bt=behavior_transition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_transition.add(bt.getTree());
					if (list_bt==null) list_bt=new ArrayList<Object>();
					list_bt.add(bt.getTree());
					}
					break;

				default :
					if ( cnt25 >= 1 ) break loop25;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(25, input);
					throw eee;
				}
				cnt25++;
			}

			// AST REWRITE
			// elements: LITERAL_transitions, bt
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bt
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bt=new RewriteRuleSubtreeStream(adaptor,"token bt",list_bt);
			root_0 = (BAST)adaptor.nil();
			// 1804:5: -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1804:8: ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_transitions, t, "transitions["+Integer.toString(t.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_bt.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bt.hasNext() ) {
					adaptor.addChild(root_1, stream_bt.nextTree());
				}
				stream_bt.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("If you get \"mismatched input"+
			      " '<<' expecting 'transitions'\" then you might have put a semicolon "+
			      "between an action and a Assertion, instead of afterwards.");
			    tellBNF(GrammarStrings.transitions,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "transitions"


	public static class behavior_transition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_transition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1812:1: behavior_transition : (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) ) ;
	public final BLESStoASTParser.behavior_transition_return behavior_transition() throws RecognitionException {
		BLESStoASTParser.behavior_transition_return retval = new BLESStoASTParser.behavior_transition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token x=null;
		Token semi=null;
		Token COLON16=null;
		Token COMMA17=null;
		Token RCON18=null;
		Token LCURLY19=null;
		Token RCURLY20=null;
		Token EMPTY_CURLY21=null;
		List<Object> list_ssi=null;
		ParserRuleReturnScope btl =null;
		ParserRuleReturnScope bc =null;
		ParserRuleReturnScope dsi =null;
		ParserRuleReturnScope s =null;
		ParserRuleReturnScope q =null;
		RuleReturnScope ssi = null;
		BAST x_tree=null;
		BAST semi_tree=null;
		BAST COLON16_tree=null;
		BAST COMMA17_tree=null;
		BAST RCON18_tree=null;
		BAST LCURLY19_tree=null;
		BAST RCURLY20_tree=null;
		BAST EMPTY_CURLY21_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EMPTY_CURLY=new RewriteRuleTokenStream(adaptor,"token EMPTY_CURLY");
		RewriteRuleTokenStream stream_LCON=new RewriteRuleTokenStream(adaptor,"token LCON");
		RewriteRuleTokenStream stream_RCON=new RewriteRuleTokenStream(adaptor,"token RCON");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_behavior_transition_label=new RewriteRuleSubtreeStream(adaptor,"rule behavior_transition_label");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_behavior_condition=new RewriteRuleSubtreeStream(adaptor,"rule behavior_condition");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1813:3: ( (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:3: (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:3: (btl= behavior_transition_label COLON )?
			int alt26=2;
			int LA26_0 = input.LA(1);
			if ( (LA26_0==ID) ) {
				int LA26_1 = input.LA(2);
				if ( (LA26_1==COLON||LA26_1==LBRACKET) ) {
					alt26=1;
				}
			}
			switch (alt26) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:5: btl= behavior_transition_label COLON
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_transition_label_in_behavior_transition4823);
=======
					pushFollow(FOLLOW_behavior_transition_label_in_behavior_transition4831);
>>>>>>> origin/continuum
					btl=behavior_transition_label();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_transition_label.add(btl.getTree());
<<<<<<< HEAD
					COLON16=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_transition4825); if (state.failed) return retval; 
=======
					COLON16=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_transition4833); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_COLON.add(COLON16);

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_behavior_transition4835);
=======
			pushFollow(FOLLOW_identifier_in_behavior_transition4843);
>>>>>>> origin/continuum
			ssi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(ssi.getTree());
			if (list_ssi==null) list_ssi=new ArrayList<Object>();
			list_ssi.add(ssi.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1815:36: ( COMMA ssi+= identifier )*
			loop27:
			while (true) {
				int alt27=2;
				int LA27_0 = input.LA(1);
				if ( (LA27_0==COMMA) ) {
					alt27=1;
				}

				switch (alt27) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1815:38: COMMA ssi+= identifier
					{
<<<<<<< HEAD
					COMMA17=(Token)match(input,COMMA,FOLLOW_COMMA_in_behavior_transition4839); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA17);

					pushFollow(FOLLOW_identifier_in_behavior_transition4844);
=======
					COMMA17=(Token)match(input,COMMA,FOLLOW_COMMA_in_behavior_transition4847); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA17);

					pushFollow(FOLLOW_identifier_in_behavior_transition4852);
>>>>>>> origin/continuum
					ssi=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(ssi.getTree());
					if (list_ssi==null) list_ssi=new ArrayList<Object>();
					list_ssi.add(ssi.getTree());
					}
					break;

				default :
					break loop27;
				}
			}

<<<<<<< HEAD
			x=(Token)match(input,LCON,FOLLOW_LCON_in_behavior_transition4853); if (state.failed) return retval; 
=======
			x=(Token)match(input,LCON,FOLLOW_LCON_in_behavior_transition4861); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LCON.add(x);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:12: (bc= behavior_condition )?
			int alt28=2;
			int LA28_0 = input.LA(1);
			if ( (LA28_0==AADL_STRING_LITERAL||LA28_0==ID||LA28_0==INTEGER_LIT||LA28_0==LBRACKET||LA28_0==LITERAL_complex||LA28_0==LITERAL_false||LA28_0==LITERAL_in||LA28_0==LITERAL_integer||LA28_0==LITERAL_natural||(LA28_0 >= LITERAL_not && LA28_0 <= LITERAL_now)||LA28_0==LITERAL_null||LA28_0==LITERAL_on||(LA28_0 >= LITERAL_rational && LA28_0 <= LITERAL_real)||LA28_0==LITERAL_self||(LA28_0 >= LITERAL_time && LA28_0 <= LITERAL_timeout)||LA28_0==LITERAL_tops||LA28_0==LITERAL_true||LA28_0==LPAREN||LA28_0==MINUS||LA28_0==OCTOTHORPE||LA28_0==REAL_LIT) ) {
				alt28=1;
			}
			switch (alt28) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:12: bc= behavior_condition
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_condition_in_behavior_transition4857);
=======
					pushFollow(FOLLOW_behavior_condition_in_behavior_transition4865);
>>>>>>> origin/continuum
					bc=behavior_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_condition.add(bc.getTree());
					}
					break;

			}

<<<<<<< HEAD
			RCON18=(Token)match(input,RCON,FOLLOW_RCON_in_behavior_transition4860); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCON.add(RCON18);

			pushFollow(FOLLOW_identifier_in_behavior_transition4867);
=======
			RCON18=(Token)match(input,RCON,FOLLOW_RCON_in_behavior_transition4868); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCON.add(RCON18);

			pushFollow(FOLLOW_identifier_in_behavior_transition4875);
>>>>>>> origin/continuum
			dsi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(dsi.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1818:3: ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY )
			int alt29=2;
			int LA29_0 = input.LA(1);
			if ( (LA29_0==LCURLY) ) {
				alt29=1;
			}
			else if ( (LA29_0==EMPTY_CURLY) ) {
				alt29=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 29, 0, input);
				throw nvae;
			}

			switch (alt29) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1818:5: LCURLY s= behavior_actions RCURLY
					{
<<<<<<< HEAD
					LCURLY19=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_behavior_transition4874); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY19);

					pushFollow(FOLLOW_behavior_actions_in_behavior_transition4878);
=======
					LCURLY19=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_behavior_transition4882); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY19);

					pushFollow(FOLLOW_behavior_actions_in_behavior_transition4886);
>>>>>>> origin/continuum
					s=behavior_actions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_actions.add(s.getTree());
<<<<<<< HEAD
					RCURLY20=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_behavior_transition4880); if (state.failed) return retval; 
=======
					RCURLY20=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_behavior_transition4888); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY20);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1818:40: EMPTY_CURLY
					{
<<<<<<< HEAD
					EMPTY_CURLY21=(Token)match(input,EMPTY_CURLY,FOLLOW_EMPTY_CURLY_in_behavior_transition4884); if (state.failed) return retval; 
=======
					EMPTY_CURLY21=(Token)match(input,EMPTY_CURLY,FOLLOW_EMPTY_CURLY_in_behavior_transition4892); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_EMPTY_CURLY.add(EMPTY_CURLY21);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1819:4: (q= assertion )?
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==LASS) ) {
				alt30=1;
			}
			switch (alt30) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1819:4: q= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_behavior_transition4892);
=======
					pushFollow(FOLLOW_assertion_in_behavior_transition4900);
>>>>>>> origin/continuum
					q=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(q.getTree());
					}
					break;

			}

<<<<<<< HEAD
			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_transition4897); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: dsi, btl, s, bc, ssi, q
=======
			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_transition4905); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: bc, s, q, dsi, ssi, btl
>>>>>>> origin/continuum
			// token labels: 
			// rule labels: bc, q, s, dsi, btl, retval
			// token list labels: 
			// rule list labels: ssi
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_bc=new RewriteRuleSubtreeStream(adaptor,"rule bc",bc!=null?bc.getTree():null);
			RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.getTree():null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.getTree():null);
			RewriteRuleSubtreeStream stream_dsi=new RewriteRuleSubtreeStream(adaptor,"rule dsi",dsi!=null?dsi.getTree():null);
			RewriteRuleSubtreeStream stream_btl=new RewriteRuleSubtreeStream(adaptor,"rule btl",btl!=null?btl.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ssi=new RewriteRuleSubtreeStream(adaptor,"token ssi",list_ssi);
			root_0 = (BAST)adaptor.nil();
			// 1820:5: -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1821:7: ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TRANSITION, x, "TRANSITION["+Integer.toString(x.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1822:7: ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, x, "LABEL["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1822:78: ( $btl)?
				if ( stream_btl.hasNext() ) {
					adaptor.addChild(root_2, stream_btl.nextTree());
				}
				stream_btl.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1823:7: ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SOURCE, x, "SOURCE["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				if ( !(stream_ssi.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ssi.hasNext() ) {
					adaptor.addChild(root_2, stream_ssi.nextTree());
				}
				stream_ssi.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1824:7: ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITION, x, "CONDITION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1824:86: ( $bc)?
				if ( stream_bc.hasNext() ) {
					adaptor.addChild(root_2, stream_bc.nextTree());
				}
				stream_bc.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1825:7: ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(DESTINATION, x, "DESTINATION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				adaptor.addChild(root_2, stream_dsi.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1826:7: ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ACTION, x, "ACTION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1826:80: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_2, stream_s.nextTree());
				}
				stream_s.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1827:7: ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(Q, semi, "Q["+Integer.toString(semi.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1827:76: ( $q)?
				if ( stream_q.hasNext() ) {
					adaptor.addChild(root_2, stream_q.nextTree());
				}
				stream_q.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nDo you have either behavior actions or empty curly brackets?");
			    Dump.it("Is there a space between your empty curly brackets?\nYou stink!  Take a bath.\n");
			    Dump.it("Is your execute condition grammatically-correct? ");
			    tellBNF(GrammarStrings.behaviorTransition,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition"


	public static class behavior_transition_label_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_transition_label"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1839:1: behavior_transition_label : id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )? -> ^( $id ( $lit)? ) ;
	public final BLESStoASTParser.behavior_transition_label_return behavior_transition_label() throws RecognitionException {
		BLESStoASTParser.behavior_transition_label_return retval = new BLESStoASTParser.behavior_transition_label_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lit=null;
		Token LBRACKET22=null;
		Token RBRACKET23=null;
		ParserRuleReturnScope id =null;

		BAST lit_tree=null;
		BAST LBRACKET22_tree=null;
		BAST RBRACKET23_tree=null;
		RewriteRuleTokenStream stream_INTEGER_LIT=new RewriteRuleTokenStream(adaptor,"token INTEGER_LIT");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1840:3: (id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )? -> ^( $id ( $lit)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1841:3: id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )?
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_behavior_transition_label5061);
=======
			pushFollow(FOLLOW_identifier_in_behavior_transition_label5069);
>>>>>>> origin/continuum
			id=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1841:17: ( LBRACKET lit= INTEGER_LIT RBRACKET )?
			int alt31=2;
			int LA31_0 = input.LA(1);
			if ( (LA31_0==LBRACKET) ) {
				alt31=1;
			}
			switch (alt31) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1841:19: LBRACKET lit= INTEGER_LIT RBRACKET
					{
<<<<<<< HEAD
					LBRACKET22=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_behavior_transition_label5065); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET22);

					lit=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_behavior_transition_label5069); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_INTEGER_LIT.add(lit);

					RBRACKET23=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_behavior_transition_label5071); if (state.failed) return retval; 
=======
					LBRACKET22=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_behavior_transition_label5073); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET22);

					lit=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_behavior_transition_label5077); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_INTEGER_LIT.add(lit);

					RBRACKET23=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_behavior_transition_label5079); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET23);

					}
					break;

			}

			// AST REWRITE
			// elements: id, lit
			// token labels: lit
			// rule labels: id, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lit=new RewriteRuleTokenStream(adaptor,"token lit",lit);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1842:5: -> ^( $id ( $lit)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1842:8: ^( $id ( $lit)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_id.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1842:16: ( $lit)?
				if ( stream_lit.hasNext() ) {
					adaptor.addChild(root_1, stream_lit.nextNode());
				}
				stream_lit.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition_label"


	public static class behavior_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1845:1: behavior_condition : ( dispatch_condition | execute_condition | mode_condition );
	public final BLESStoASTParser.behavior_condition_return behavior_condition() throws RecognitionException {
		BLESStoASTParser.behavior_condition_return retval = new BLESStoASTParser.behavior_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope dispatch_condition24 =null;
		ParserRuleReturnScope execute_condition25 =null;
		ParserRuleReturnScope mode_condition26 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1846:3: ( dispatch_condition | execute_condition | mode_condition )
			int alt32=3;
			int LA32_0 = input.LA(1);
			if ( (LA32_0==LITERAL_on) ) {
				int LA32_1 = input.LA(2);
				if ( (LA32_1==LITERAL_dispatch) ) {
					alt32=1;
				}
				else if ( (LA32_1==ID||LA32_1==LPAREN) ) {
					alt32=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 32, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA32_0==AADL_STRING_LITERAL||LA32_0==ID||LA32_0==INTEGER_LIT||LA32_0==LBRACKET||LA32_0==LITERAL_complex||LA32_0==LITERAL_false||LA32_0==LITERAL_in||LA32_0==LITERAL_integer||LA32_0==LITERAL_natural||(LA32_0 >= LITERAL_not && LA32_0 <= LITERAL_now)||LA32_0==LITERAL_null||(LA32_0 >= LITERAL_rational && LA32_0 <= LITERAL_real)||LA32_0==LITERAL_self||(LA32_0 >= LITERAL_time && LA32_0 <= LITERAL_timeout)||LA32_0==LITERAL_tops||LA32_0==LITERAL_true||LA32_0==LPAREN||LA32_0==MINUS||LA32_0==OCTOTHORPE||LA32_0==REAL_LIT) ) {
				alt32=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 32, 0, input);
				throw nvae;
			}

			switch (alt32) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1847:3: dispatch_condition
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_dispatch_condition_in_behavior_condition5109);
=======
					pushFollow(FOLLOW_dispatch_condition_in_behavior_condition5117);
>>>>>>> origin/continuum
					dispatch_condition24=dispatch_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dispatch_condition24.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1847:24: execute_condition
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_execute_condition_in_behavior_condition5113);
=======
					pushFollow(FOLLOW_execute_condition_in_behavior_condition5121);
>>>>>>> origin/continuum
					execute_condition25=execute_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, execute_condition25.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1847:44: mode_condition
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_mode_condition_in_behavior_condition5117);
=======
					pushFollow(FOLLOW_mode_condition_in_behavior_condition5125);
>>>>>>> origin/continuum
					mode_condition26=mode_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, mode_condition26.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_condition"


	public static class execute_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "execute_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1850:1: execute_condition : expression_or_relation ;
	public final BLESStoASTParser.execute_condition_return execute_condition() throws RecognitionException {
		BLESStoASTParser.execute_condition_return retval = new BLESStoASTParser.execute_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope expression_or_relation27 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1851:3: ( expression_or_relation )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1852:15: expression_or_relation
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_expression_or_relation_in_execute_condition5135);
=======
			pushFollow(FOLLOW_expression_or_relation_in_execute_condition5143);
>>>>>>> origin/continuum
			expression_or_relation27=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_relation27.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "execute_condition"


	public static class mode_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "mode_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1855:1: mode_condition : LITERAL_on ^ trigger_logical_expression ;
	public final BLESStoASTParser.mode_condition_return mode_condition() throws RecognitionException {
		BLESStoASTParser.mode_condition_return retval = new BLESStoASTParser.mode_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_on28=null;
		ParserRuleReturnScope trigger_logical_expression29 =null;

		BAST LITERAL_on28_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1856:3: ( LITERAL_on ^ trigger_logical_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1857:3: LITERAL_on ^ trigger_logical_expression
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_on28=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_mode_condition5151); if (state.failed) return retval;
=======
			LITERAL_on28=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_mode_condition5159); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_on28_tree = (BAST)adaptor.create(LITERAL_on28);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_on28_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_trigger_logical_expression_in_mode_condition5154);
=======
			pushFollow(FOLLOW_trigger_logical_expression_in_mode_condition5162);
>>>>>>> origin/continuum
			trigger_logical_expression29=trigger_logical_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, trigger_logical_expression29.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mode_condition"


	public static class trigger_logical_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "trigger_logical_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1861:1: trigger_logical_expression : first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )? -> {op1!=null}? ^( $op1 $first ( $et)+ ) -> $first;
	public final BLESStoASTParser.trigger_logical_expression_return trigger_logical_expression() throws RecognitionException {
		BLESStoASTParser.trigger_logical_expression_return retval = new BLESStoASTParser.trigger_logical_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		List<Object> list_et=null;
		ParserRuleReturnScope first =null;
		ParserRuleReturnScope op1 =null;
		ParserRuleReturnScope op2 =null;
		RuleReturnScope et = null;
		RewriteRuleSubtreeStream stream_event_trigger=new RewriteRuleSubtreeStream(adaptor,"rule event_trigger");
		RewriteRuleSubtreeStream stream_logical_operator=new RewriteRuleSubtreeStream(adaptor,"rule logical_operator");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1862:3: (first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )? -> {op1!=null}? ^( $op1 $first ( $et)+ ) -> $first)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:3: first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )?
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5172);
=======
			pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5180);
>>>>>>> origin/continuum
			first=event_trigger();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_event_trigger.add(first.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:23: (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )?
			int alt34=2;
			int LA34_0 = input.LA(1);
			if ( (LA34_0==LITERAL_and||LA34_0==LITERAL_cand||LA34_0==LITERAL_cor||LA34_0==LITERAL_or||LA34_0==LITERAL_xor) ) {
				alt34=1;
			}
			switch (alt34) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:25: op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)*
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5178);
=======
					pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5186);
>>>>>>> origin/continuum
					op1=logical_operator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logical_operator.add(op1.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5182);
=======
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5190);
>>>>>>> origin/continuum
					et=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_event_trigger.add(et.getTree());
					if (list_et==null) list_et=new ArrayList<Object>();
					list_et.add(et.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1864:5: (op2= logical_operator et+= event_trigger {...}?)*
					loop33:
					while (true) {
						int alt33=2;
						int LA33_0 = input.LA(1);
						if ( (LA33_0==LITERAL_and||LA33_0==LITERAL_cand||LA33_0==LITERAL_cor||LA33_0==LITERAL_or||LA33_0==LITERAL_xor) ) {
							alt33=1;
						}

						switch (alt33) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1864:6: op2= logical_operator et+= event_trigger {...}?
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5192);
=======
							pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5200);
>>>>>>> origin/continuum
							op2=logical_operator();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logical_operator.add(op2.getTree());
<<<<<<< HEAD
							pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5196);
=======
							pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5204);
>>>>>>> origin/continuum
							et=event_trigger();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_event_trigger.add(et.getTree());
							if (list_et==null) list_et=new ArrayList<Object>();
							list_et.add(et.getTree());
							if ( !((op1==op2)) ) {
								if (state.backtracking>0) {state.failed=true; return retval;}
								throw new FailedPredicateException(input, "trigger_logical_expression", "op1==op2");
							}
							}
							break;

						default :
							break loop33;
						}
					}

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: op1, first, et, first
=======
			// elements: op1, first, first, et
>>>>>>> origin/continuum
			// token labels: 
			// rule labels: op1, first, retval
			// token list labels: 
			// rule list labels: et
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_op1=new RewriteRuleSubtreeStream(adaptor,"rule op1",op1!=null?op1.getTree():null);
			RewriteRuleSubtreeStream stream_first=new RewriteRuleSubtreeStream(adaptor,"rule first",first!=null?first.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_et=new RewriteRuleSubtreeStream(adaptor,"token et",list_et);
			root_0 = (BAST)adaptor.nil();
			// 1865:5: -> {op1!=null}? ^( $op1 $first ( $et)+ )
			if (op1!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1865:21: ^( $op1 $first ( $et)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_op1.nextNode(), root_1);
				adaptor.addChild(root_1, stream_first.nextTree());
				if ( !(stream_et.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_et.hasNext() ) {
					adaptor.addChild(root_1, stream_et.nextTree());
				}
				stream_et.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1866:5: -> $first
			{
				adaptor.addChild(root_0, stream_first.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nAll operators in trigger_logical_expression must be the same.");
			    reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trigger_logical_expression"


	public static class event_trigger_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "event_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:1: event_trigger : ( (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID | LPAREN ^ trigger_logical_expression RPAREN );
	public final BLESStoASTParser.event_trigger_return event_trigger() throws RecognitionException {
		BLESStoASTParser.event_trigger_return retval = new BLESStoASTParser.event_trigger_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token port=null;
		Token PERIOD30=null;
		Token PERIOD31=null;
		Token LPAREN32=null;
		Token RPAREN34=null;
		Token sub=null;
		List<Object> list_sub=null;
		ParserRuleReturnScope trigger_logical_expression33 =null;

		BAST port_tree=null;
		BAST PERIOD30_tree=null;
		BAST PERIOD31_tree=null;
		BAST LPAREN32_tree=null;
		BAST RPAREN34_tree=null;
		BAST sub_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1874:3: ( (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID | LPAREN ^ trigger_logical_expression RPAREN )
			int alt37=2;
			int LA37_0 = input.LA(1);
			if ( (LA37_0==ID) ) {
				alt37=1;
			}
			else if ( (LA37_0==LPAREN) ) {
				alt37=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 37, 0, input);
				throw nvae;
			}

			switch (alt37) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:3: (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:3: (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )?
					int alt36=2;
					int LA36_0 = input.LA(1);
					if ( (LA36_0==ID) ) {
						int LA36_1 = input.LA(2);
						if ( (LA36_1==PERIOD) ) {
							alt36=1;
						}
					}
					switch (alt36) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:5: sub+= ID PERIOD ^ (sub+= ID PERIOD )*
							{
<<<<<<< HEAD
							sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5267); if (state.failed) return retval;
=======
							sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5275); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							sub_tree = (BAST)adaptor.create(sub);
							adaptor.addChild(root_0, sub_tree);
							}

							if (list_sub==null) list_sub=new ArrayList<Object>();
							list_sub.add(sub);
<<<<<<< HEAD
							PERIOD30=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5269); if (state.failed) return retval;
=======
							PERIOD30=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5277); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							PERIOD30_tree = (BAST)adaptor.create(PERIOD30);
							root_0 = (BAST)adaptor.becomeRoot(PERIOD30_tree, root_0);
							}

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:21: (sub+= ID PERIOD )*
							loop35:
							while (true) {
								int alt35=2;
								int LA35_0 = input.LA(1);
								if ( (LA35_0==ID) ) {
									int LA35_1 = input.LA(2);
									if ( (LA35_1==PERIOD) ) {
										alt35=1;
									}

								}

								switch (alt35) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:23: sub+= ID PERIOD
									{
<<<<<<< HEAD
									sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5276); if (state.failed) return retval;
=======
									sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5284); if (state.failed) return retval;
>>>>>>> origin/continuum
									if ( state.backtracking==0 ) {
									sub_tree = (BAST)adaptor.create(sub);
									adaptor.addChild(root_0, sub_tree);
									}

									if (list_sub==null) list_sub=new ArrayList<Object>();
									list_sub.add(sub);
<<<<<<< HEAD
									PERIOD31=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5278); if (state.failed) return retval;
=======
									PERIOD31=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5286); if (state.failed) return retval;
>>>>>>> origin/continuum
									if ( state.backtracking==0 ) {
									PERIOD31_tree = (BAST)adaptor.create(PERIOD31);
									adaptor.addChild(root_0, PERIOD31_tree);
									}

									}
									break;

								default :
									break loop35;
								}
							}

							}
							break;

					}

<<<<<<< HEAD
					port=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5288); if (state.failed) return retval;
=======
					port=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5296); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					port_tree = (BAST)adaptor.create(port);
					adaptor.addChild(root_0, port_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1876:5: LPAREN ^ trigger_logical_expression RPAREN
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LPAREN32=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_trigger5294); if (state.failed) return retval;
=======
					LPAREN32=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_trigger5302); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LPAREN32_tree = (BAST)adaptor.create(LPAREN32);
					root_0 = (BAST)adaptor.becomeRoot(LPAREN32_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_trigger_logical_expression_in_event_trigger5297);
=======
					pushFollow(FOLLOW_trigger_logical_expression_in_event_trigger5305);
>>>>>>> origin/continuum
					trigger_logical_expression33=trigger_logical_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, trigger_logical_expression33.getTree());

<<<<<<< HEAD
					RPAREN34=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_trigger5299); if (state.failed) return retval;
=======
					RPAREN34=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_trigger5307); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					RPAREN34_tree = (BAST)adaptor.create(RPAREN34);
					adaptor.addChild(root_0, RPAREN34_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "event_trigger"


	public static class logical_operator_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logical_operator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1879:1: logical_operator : ( LITERAL_and | LITERAL_or | LITERAL_xor | LITERAL_cand | LITERAL_cor );
	public final BLESStoASTParser.logical_operator_return logical_operator() throws RecognitionException {
		BLESStoASTParser.logical_operator_return retval = new BLESStoASTParser.logical_operator_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set35=null;

		BAST set35_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1880:3: ( LITERAL_and | LITERAL_or | LITERAL_xor | LITERAL_cand | LITERAL_cor )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set35=input.LT(1);
			if ( input.LA(1)==LITERAL_and||input.LA(1)==LITERAL_cand||input.LA(1)==LITERAL_cor||input.LA(1)==LITERAL_or||input.LA(1)==LITERAL_xor ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set35));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logical_operator"


	public static class subprogram_behavior_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subprogram_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1890:1: subprogram_behavior : ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )? -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? ) -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? ) -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? ) -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? ) ;
	public final BLESStoASTParser.subprogram_behavior_return subprogram_behavior() throws RecognitionException {
		BLESStoASTParser.subprogram_behavior_return retval = new BLESStoASTParser.subprogram_behavior_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token no_proof=null;
		Token pr=null;
		Token po=null;
		Token ANNEX_START36=null;
		Token ANNEX_END37=null;
		ParserRuleReturnScope ac =null;
		ParserRuleReturnScope p1 =null;
		ParserRuleReturnScope p2 =null;
		ParserRuleReturnScope elq =null;

		BAST no_proof_tree=null;
		BAST pr_tree=null;
		BAST po_tree=null;
		BAST ANNEX_START36_tree=null;
		BAST ANNEX_END37_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_LITERAL_pre=new RewriteRuleTokenStream(adaptor,"token LITERAL_pre");
		RewriteRuleTokenStream stream_LITERAL_post=new RewriteRuleTokenStream(adaptor,"token LITERAL_post");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleTokenStream stream_DO_NOT_PROVE=new RewriteRuleTokenStream(adaptor,"token DO_NOT_PROVE");
		RewriteRuleSubtreeStream stream_assert_clause=new RewriteRuleSubtreeStream(adaptor,"rule assert_clause");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1891:3: ( ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )? -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? ) -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? ) -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? ) -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1892:3: ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1892:3: ( ANNEX_START )?
			int alt38=2;
			int LA38_0 = input.LA(1);
			if ( (LA38_0==ANNEX_START) ) {
				alt38=1;
			}
			switch (alt38) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1892:3: ANNEX_START
					{
<<<<<<< HEAD
					ANNEX_START36=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_subprogram_behavior5361); if (state.failed) return retval; 
=======
					ANNEX_START36=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_subprogram_behavior5369); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START36);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1893:11: (no_proof= DO_NOT_PROVE )?
			int alt39=2;
			int LA39_0 = input.LA(1);
			if ( (LA39_0==DO_NOT_PROVE) ) {
				alt39=1;
			}
			switch (alt39) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1893:11: no_proof= DO_NOT_PROVE
					{
<<<<<<< HEAD
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5368); if (state.failed) return retval; 
=======
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5376); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_DO_NOT_PROVE.add(no_proof);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1895:5: (ac= assert_clause )?
			int alt40=2;
			int LA40_0 = input.LA(1);
			if ( (LA40_0==LITERAL_assert) ) {
				alt40=1;
			}
			switch (alt40) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1895:5: ac= assert_clause
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assert_clause_in_subprogram_behavior5376);
=======
					pushFollow(FOLLOW_assert_clause_in_subprogram_behavior5384);
>>>>>>> origin/continuum
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assert_clause.add(ac.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1896:3: (pr= LITERAL_pre p1= assertion )?
			int alt41=2;
			int LA41_0 = input.LA(1);
			if ( (LA41_0==LITERAL_pre) ) {
				alt41=1;
			}
			switch (alt41) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1896:5: pr= LITERAL_pre p1= assertion
					{
<<<<<<< HEAD
					pr=(Token)match(input,LITERAL_pre,FOLLOW_LITERAL_pre_in_subprogram_behavior5385); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_pre.add(pr);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5389);
=======
					pr=(Token)match(input,LITERAL_pre,FOLLOW_LITERAL_pre_in_subprogram_behavior5393); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_pre.add(pr);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5397);
>>>>>>> origin/continuum
					p1=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(p1.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1897:3: (po= LITERAL_post p2= assertion )?
			int alt42=2;
			int LA42_0 = input.LA(1);
			if ( (LA42_0==LITERAL_post) ) {
				alt42=1;
			}
			switch (alt42) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1897:5: po= LITERAL_post p2= assertion
					{
<<<<<<< HEAD
					po=(Token)match(input,LITERAL_post,FOLLOW_LITERAL_post_in_subprogram_behavior5400); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_post.add(po);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5404);
=======
					po=(Token)match(input,LITERAL_post,FOLLOW_LITERAL_post_in_subprogram_behavior5408); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_post.add(po);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5412);
>>>>>>> origin/continuum
					p2=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(p2.getTree());
					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_existential_lattice_quantification_in_subprogram_behavior5413);
=======
			pushFollow(FOLLOW_existential_lattice_quantification_in_subprogram_behavior5421);
>>>>>>> origin/continuum
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:3: ( ANNEX_END )?
			int alt43=2;
			int LA43_0 = input.LA(1);
			if ( (LA43_0==ANNEX_END) ) {
				alt43=1;
			}
			switch (alt43) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:3: ANNEX_END
					{
<<<<<<< HEAD
					ANNEX_END37=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_subprogram_behavior5417); if (state.failed) return retval; 
=======
					ANNEX_END37=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_subprogram_behavior5425); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END37);

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: elq, ac, p2, no_proof, no_proof, pr, p1, p1, elq, ac, pr, ac, po, no_proof, p2, ac, po, no_proof, elq, elq
=======
			// elements: ac, p1, pr, elq, ac, po, no_proof, pr, ac, elq, elq, no_proof, p2, elq, p2, ac, no_proof, po, no_proof, p1
>>>>>>> origin/continuum
			// token labels: pr, no_proof, po
			// rule labels: p1, ac, p2, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_pr=new RewriteRuleTokenStream(adaptor,"token pr",pr);
			RewriteRuleTokenStream stream_no_proof=new RewriteRuleTokenStream(adaptor,"token no_proof",no_proof);
			RewriteRuleTokenStream stream_po=new RewriteRuleTokenStream(adaptor,"token po",po);
			RewriteRuleSubtreeStream stream_p1=new RewriteRuleSubtreeStream(adaptor,"rule p1",p1!=null?p1.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"rule ac",ac!=null?ac.getTree():null);
			RewriteRuleSubtreeStream stream_p2=new RewriteRuleSubtreeStream(adaptor,"rule p2",p2!=null?p2.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1901:5: -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? )
			if (pr==null & po==null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:31: ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:61: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1902:5: -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? )
			if (pr!=null & po==null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:31: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:55: ^( $pr $p1)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_pr.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:73: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1903:5: -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? )
			if (pr==null & po!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:31: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:55: ^( $po $p2)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_po.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p2.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:72: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1904:5: -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:8: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:28: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:32: ^( $pr $p1)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_pr.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:43: ^( $po $p2)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_po.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p2.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:60: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subprogramBehavior,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subprogram_behavior"


	public static class asserted_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "asserted_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1909:1: asserted_action : (pre= assertion )? s= action (post= assertion )? -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) ) ;
	public final BLESStoASTParser.asserted_action_return asserted_action() throws RecognitionException {
		BLESStoASTParser.asserted_action_return retval = new BLESStoASTParser.asserted_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope pre =null;
		ParserRuleReturnScope s =null;
		ParserRuleReturnScope post =null;

		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1911:3: ( (pre= assertion )? s= action (post= assertion )? -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:3: (pre= assertion )? s= action (post= assertion )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:6: (pre= assertion )?
			int alt44=2;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==LASS) ) {
				alt44=1;
			}
			switch (alt44) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:6: pre= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_asserted_action5577);
=======
					pushFollow(FOLLOW_assertion_in_asserted_action5585);
>>>>>>> origin/continuum
					pre=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(pre.getTree());
					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_action_in_asserted_action5586);
=======
			pushFollow(FOLLOW_action_in_asserted_action5594);
>>>>>>> origin/continuum
			s=action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_action.add(s.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1914:7: (post= assertion )?
			int alt45=2;
			int LA45_0 = input.LA(1);
			if ( (LA45_0==LASS) ) {
				alt45=1;
			}
			switch (alt45) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1914:7: post= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_asserted_action5592);
=======
					pushFollow(FOLLOW_assertion_in_asserted_action5600);
>>>>>>> origin/continuum
					post=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(post.getTree());
					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: pre, s, post
=======
			// elements: pre, post, s
>>>>>>> origin/continuum
			// token labels: 
			// rule labels: pre, s, post, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_pre=new RewriteRuleSubtreeStream(adaptor,"rule pre",pre!=null?pre.getTree():null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.getTree():null);
			RewriteRuleSubtreeStream stream_post=new RewriteRuleSubtreeStream(adaptor,"rule post",post!=null?post.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1915:5: -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1916:5: ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ACTION, (s!=null?((BAST)s.getTree()):null).getToken(), "ACTION["+Integer.toString((s!=null?((BAST)s.getTree()):null).getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1917:9: ^( P[\"P\"] ( $pre)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(P, "P"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1917:20: ( $pre)?
				if ( stream_pre.hasNext() ) {
					adaptor.addChild(root_2, stream_pre.nextTree());
				}
				stream_pre.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1918:9: ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(S, (s!=null?((BAST)s.getTree()):null).getToken(), "S["+Integer.toString((s!=null?((BAST)s.getTree()):null).getLine()+startingLine)+"]"), root_2);
				adaptor.addChild(root_2, stream_s.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1919:9: ^( Q[\"Q\"] ( $post)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(Q, "Q"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1919:20: ( $post)?
				if ( stream_post.hasNext() ) {
					adaptor.addChild(root_2, stream_post.nextTree());
				}
				stream_post.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(s!=null?((BAST)s.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertedAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "asserted_action"


	public static class action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1925:1: action : ( basic_action | alternative | while_loop | for_loop | do_until_loop | existential_lattice_quantification | universal_lattice_quantification );
	public final BLESStoASTParser.action_return action() throws RecognitionException {
		BLESStoASTParser.action_return retval = new BLESStoASTParser.action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope basic_action38 =null;
		ParserRuleReturnScope alternative39 =null;
		ParserRuleReturnScope while_loop40 =null;
		ParserRuleReturnScope for_loop41 =null;
		ParserRuleReturnScope do_until_loop42 =null;
		ParserRuleReturnScope existential_lattice_quantification43 =null;
		ParserRuleReturnScope universal_lattice_quantification44 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1926:3: ( basic_action | alternative | while_loop | for_loop | do_until_loop | existential_lattice_quantification | universal_lattice_quantification )
			int alt46=7;
			switch ( input.LA(1) ) {
			case ID:
			case LITERAL_computation:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_pause:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_when:
			case LPAREN:
				{
				alt46=1;
				}
				break;
			case LITERAL_if:
				{
				alt46=2;
				}
				break;
			case LITERAL_while:
				{
				alt46=3;
				}
				break;
			case LITERAL_for:
				{
				alt46=4;
				}
				break;
			case LITERAL_do:
				{
				alt46=5;
				}
				break;
			case LCURLY:
			case LITERAL_declare:
				{
				alt46=6;
				}
				break;
			case LITERAL_forall:
				{
				alt46=7;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 46, 0, input);
				throw nvae;
			}
			switch (alt46) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1927:3: basic_action
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_basic_action_in_action5713);
=======
					pushFollow(FOLLOW_basic_action_in_action5721);
>>>>>>> origin/continuum
					basic_action38=basic_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, basic_action38.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1928:5: alternative
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_alternative_in_action5719);
=======
					pushFollow(FOLLOW_alternative_in_action5727);
>>>>>>> origin/continuum
					alternative39=alternative();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, alternative39.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1929:5: while_loop
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_while_loop_in_action5725);
=======
					pushFollow(FOLLOW_while_loop_in_action5733);
>>>>>>> origin/continuum
					while_loop40=while_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, while_loop40.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1930:5: for_loop
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_for_loop_in_action5731);
=======
					pushFollow(FOLLOW_for_loop_in_action5739);
>>>>>>> origin/continuum
					for_loop41=for_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, for_loop41.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1931:5: do_until_loop
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_do_until_loop_in_action5737);
=======
					pushFollow(FOLLOW_do_until_loop_in_action5745);
>>>>>>> origin/continuum
					do_until_loop42=do_until_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, do_until_loop42.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1932:5: existential_lattice_quantification
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_existential_lattice_quantification_in_action5743);
=======
					pushFollow(FOLLOW_existential_lattice_quantification_in_action5751);
>>>>>>> origin/continuum
					existential_lattice_quantification43=existential_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, existential_lattice_quantification43.getTree());

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1933:5: universal_lattice_quantification
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_universal_lattice_quantification_in_action5749);
=======
					pushFollow(FOLLOW_universal_lattice_quantification_in_action5757);
>>>>>>> origin/continuum
					universal_lattice_quantification44=universal_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, universal_lattice_quantification44.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.action,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "action"


	public static class alternative_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "alternative"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1938:1: alternative : lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi -> ^( $lif ( $alt)+ ) ;
	public final BLESStoASTParser.alternative_return alternative() throws RecognitionException {
		BLESStoASTParser.alternative_return retval = new BLESStoASTParser.alternative_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lif=null;
		Token string_literal45=null;
		Token LITERAL_fi46=null;
		List<Object> list_alt=null;
		RuleReturnScope alt = null;
		BAST lif_tree=null;
		BAST string_literal45_tree=null;
		BAST LITERAL_fi46_tree=null;
		RewriteRuleTokenStream stream_LITERAL_fi=new RewriteRuleTokenStream(adaptor,"token LITERAL_fi");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_BOX=new RewriteRuleTokenStream(adaptor,"token BOX");
		RewriteRuleSubtreeStream stream_guarded_action=new RewriteRuleSubtreeStream(adaptor,"rule guarded_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1939:3: (lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi -> ^( $lif ( $alt)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1940:3: lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi
			{
<<<<<<< HEAD
			lif=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_alternative5776); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_if.add(lif);

			pushFollow(FOLLOW_guarded_action_in_alternative5784);
=======
			lif=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_alternative5784); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_if.add(lif);

			pushFollow(FOLLOW_guarded_action_in_alternative5792);
>>>>>>> origin/continuum
			alt=guarded_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_guarded_action.add(alt.getTree());
			if (list_alt==null) list_alt=new ArrayList<Object>();
			list_alt.add(alt.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1943:3: ( '[]' alt+= guarded_action )+
			int cnt47=0;
			loop47:
			while (true) {
				int alt47=2;
				int LA47_0 = input.LA(1);
				if ( (LA47_0==BOX) ) {
					alt47=1;
				}

				switch (alt47) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1943:5: '[]' alt+= guarded_action
					{
<<<<<<< HEAD
					string_literal45=(Token)match(input,BOX,FOLLOW_BOX_in_alternative5790); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_BOX.add(string_literal45);

					pushFollow(FOLLOW_guarded_action_in_alternative5794);
=======
					string_literal45=(Token)match(input,BOX,FOLLOW_BOX_in_alternative5798); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_BOX.add(string_literal45);

					pushFollow(FOLLOW_guarded_action_in_alternative5802);
>>>>>>> origin/continuum
					alt=guarded_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_guarded_action.add(alt.getTree());
					if (list_alt==null) list_alt=new ArrayList<Object>();
					list_alt.add(alt.getTree());
					}
					break;

				default :
					if ( cnt47 >= 1 ) break loop47;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(47, input);
					throw eee;
				}
				cnt47++;
			}

<<<<<<< HEAD
			LITERAL_fi46=(Token)match(input,LITERAL_fi,FOLLOW_LITERAL_fi_in_alternative5802); if (state.failed) return retval; 
=======
			LITERAL_fi46=(Token)match(input,LITERAL_fi,FOLLOW_LITERAL_fi_in_alternative5810); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_fi.add(LITERAL_fi46);

			// AST REWRITE
			// elements: alt, lif
			// token labels: lif
			// rule labels: retval
			// token list labels: 
			// rule list labels: alt
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lif=new RewriteRuleTokenStream(adaptor,"token lif",lif);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_alt=new RewriteRuleSubtreeStream(adaptor,"token alt",list_alt);
			root_0 = (BAST)adaptor.nil();
			// 1945:5: -> ^( $lif ( $alt)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1945:8: ^( $lif ( $alt)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lif.nextNode(), root_1);
				if ( !(stream_alt.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_alt.hasNext() ) {
					adaptor.addChild(root_1, stream_alt.nextTree());
				}
				stream_alt.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.alternative,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "alternative"


	public static class guarded_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "guarded_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1951:1: guarded_action : LPAREN ! expression_or_relation GUARD ^ asserted_action ;
	public final BLESStoASTParser.guarded_action_return guarded_action() throws RecognitionException {
		BLESStoASTParser.guarded_action_return retval = new BLESStoASTParser.guarded_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN47=null;
		Token GUARD49=null;
		ParserRuleReturnScope expression_or_relation48 =null;
		ParserRuleReturnScope asserted_action50 =null;

		BAST LPAREN47_tree=null;
		BAST GUARD49_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1952:3: ( LPAREN ! expression_or_relation GUARD ^ asserted_action )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1953:3: LPAREN ! expression_or_relation GUARD ^ asserted_action
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LPAREN47=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_guarded_action5845); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_guarded_action5849);
=======
			LPAREN47=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_guarded_action5853); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_guarded_action5857);
>>>>>>> origin/continuum
			expression_or_relation48=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_relation48.getTree());

<<<<<<< HEAD
			GUARD49=(Token)match(input,GUARD,FOLLOW_GUARD_in_guarded_action5851); if (state.failed) return retval;
=======
			GUARD49=(Token)match(input,GUARD,FOLLOW_GUARD_in_guarded_action5859); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			GUARD49_tree = (BAST)adaptor.create(GUARD49);
			root_0 = (BAST)adaptor.becomeRoot(GUARD49_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_asserted_action_in_guarded_action5854);
=======
			pushFollow(FOLLOW_asserted_action_in_guarded_action5862);
>>>>>>> origin/continuum
			asserted_action50=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, asserted_action50.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.guardedAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "guarded_action"


	public static class universal_lattice_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "universal_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1958:1: universal_lattice_quantification : lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification -> ^( $lf $lv ^( $li $r) $elq) ;
	public final BLESStoASTParser.universal_lattice_quantification_return universal_lattice_quantification() throws RecognitionException {
		BLESStoASTParser.universal_lattice_quantification_return retval = new BLESStoASTParser.universal_lattice_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lf=null;
		Token li=null;
		ParserRuleReturnScope lv =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope elq =null;

		BAST lf_tree=null;
		BAST li_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_forall=new RewriteRuleTokenStream(adaptor,"token LITERAL_forall");
		RewriteRuleSubtreeStream stream_lattice_variables=new RewriteRuleSubtreeStream(adaptor,"rule lattice_variables");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_range=new RewriteRuleSubtreeStream(adaptor,"rule range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1959:3: (lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification -> ^( $lf $lv ^( $li $r) $elq) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1960:3: lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification
			{
<<<<<<< HEAD
			lf=(Token)match(input,LITERAL_forall,FOLLOW_LITERAL_forall_in_universal_lattice_quantification5881); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_forall.add(lf);

			pushFollow(FOLLOW_lattice_variables_in_universal_lattice_quantification5890);
=======
			lf=(Token)match(input,LITERAL_forall,FOLLOW_LITERAL_forall_in_universal_lattice_quantification5889); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_forall.add(lf);

			pushFollow(FOLLOW_lattice_variables_in_universal_lattice_quantification5898);
>>>>>>> origin/continuum
			lv=lattice_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_lattice_variables.add(lv.getTree());
<<<<<<< HEAD
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_universal_lattice_quantification5894); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_range_in_universal_lattice_quantification5898);
=======
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_universal_lattice_quantification5902); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_range_in_universal_lattice_quantification5906);
>>>>>>> origin/continuum
			r=range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_range.add(r.getTree());
<<<<<<< HEAD
			pushFollow(FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5907);
=======
			pushFollow(FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5915);
>>>>>>> origin/continuum
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// AST REWRITE
<<<<<<< HEAD
			// elements: li, elq, lf, lv, r
=======
			// elements: lv, r, lf, li, elq
>>>>>>> origin/continuum
			// token labels: lf, li
			// rule labels: r, lv, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lf=new RewriteRuleTokenStream(adaptor,"token lf",lf);
			RewriteRuleTokenStream stream_li=new RewriteRuleTokenStream(adaptor,"token li",li);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
			RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1964:5: -> ^( $lf $lv ^( $li $r) $elq)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1964:8: ^( $lf $lv ^( $li $r) $elq)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lf.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lv.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1964:18: ^( $li $r)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_li.nextNode(), root_2);
				adaptor.addChild(root_2, stream_r.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.ulq,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_lattice_quantification"


	public static class lattice_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "lattice_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:1: lattice_variables : i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )? -> {com!=null}? ^( $com $i1 ( $i)+ ) -> $i1;
	public final BLESStoASTParser.lattice_variables_return lattice_variables() throws RecognitionException {
		BLESStoASTParser.lattice_variables_return retval = new BLESStoASTParser.lattice_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token com=null;
		Token COMMA51=null;
		List<Object> list_i=null;
		ParserRuleReturnScope i1 =null;
		RuleReturnScope i = null;
		BAST com_tree=null;
		BAST COMMA51_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1970:3: (i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )? -> {com!=null}? ^( $com $i1 ( $i)+ ) -> $i1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:3: i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )?
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_lattice_variables5958);
=======
			pushFollow(FOLLOW_identifier_in_lattice_variables5966);
>>>>>>> origin/continuum
			i1=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:17: (com= COMMA i+= identifier ( COMMA i+= identifier )* )?
			int alt49=2;
			int LA49_0 = input.LA(1);
			if ( (LA49_0==COMMA) ) {
				alt49=1;
			}
			switch (alt49) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:18: com= COMMA i+= identifier ( COMMA i+= identifier )*
					{
<<<<<<< HEAD
					com=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5963); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(com);

					pushFollow(FOLLOW_identifier_in_lattice_variables5967);
=======
					com=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5971); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(com);

					pushFollow(FOLLOW_identifier_in_lattice_variables5975);
>>>>>>> origin/continuum
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:42: ( COMMA i+= identifier )*
					loop48:
					while (true) {
						int alt48=2;
						int LA48_0 = input.LA(1);
						if ( (LA48_0==COMMA) ) {
							alt48=1;
						}

						switch (alt48) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:43: COMMA i+= identifier
							{
<<<<<<< HEAD
							COMMA51=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5970); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA51);

							pushFollow(FOLLOW_identifier_in_lattice_variables5974);
=======
							COMMA51=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5978); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA51);

							pushFollow(FOLLOW_identifier_in_lattice_variables5982);
>>>>>>> origin/continuum
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							break loop48;
						}
					}

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: i1, com, i, i1
=======
			// elements: i1, i, i1, com
>>>>>>> origin/continuum
			// token labels: com
			// rule labels: i1, retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_com=new RewriteRuleTokenStream(adaptor,"token com",com);
			RewriteRuleSubtreeStream stream_i1=new RewriteRuleSubtreeStream(adaptor,"rule i1",i1!=null?i1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (BAST)adaptor.nil();
			// 1972:5: -> {com!=null}? ^( $com $i1 ( $i)+ )
			if (com!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1972:20: ^( $com $i1 ( $i)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_com.nextNode(), root_1);
				adaptor.addChild(root_1, stream_i1.nextTree());
				if ( !(stream_i.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_i.hasNext() ) {
					adaptor.addChild(root_1, stream_i.nextTree());
				}
				stream_i.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1973:5: -> $i1
			{
				adaptor.addChild(root_0, stream_i1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lattice_variables"


	public static class while_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "while_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1978:1: while_loop : lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq) ;
	public final BLESStoASTParser.while_loop_return while_loop() throws RecognitionException {
		BLESStoASTParser.while_loop_return retval = new BLESStoASTParser.while_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lw=null;
		Token LPAREN52=null;
		Token RPAREN53=null;
		Token LITERAL_invariant54=null;
		Token LITERAL_bound55=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope bd =null;
		ParserRuleReturnScope elq =null;

		BAST lw_tree=null;
		BAST LPAREN52_tree=null;
		BAST RPAREN53_tree=null;
		BAST LITERAL_invariant54_tree=null;
		BAST LITERAL_bound55_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_bound=new RewriteRuleTokenStream(adaptor,"token LITERAL_bound");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_LITERAL_while=new RewriteRuleTokenStream(adaptor,"token LITERAL_while");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1979:3: (lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1980:3: lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification
			{
<<<<<<< HEAD
			lw=(Token)match(input,LITERAL_while,FOLLOW_LITERAL_while_in_while_loop6036); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_while.add(lw);

			LPAREN52=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_while_loop6042); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN52);

			pushFollow(FOLLOW_expression_or_relation_in_while_loop6047);
=======
			lw=(Token)match(input,LITERAL_while,FOLLOW_LITERAL_while_in_while_loop6044); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_while.add(lw);

			LPAREN52=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_while_loop6050); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN52);

			pushFollow(FOLLOW_expression_or_relation_in_while_loop6055);
>>>>>>> origin/continuum
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
<<<<<<< HEAD
			RPAREN53=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_while_loop6049); if (state.failed) return retval; 
=======
			RPAREN53=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_while_loop6057); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN53);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1983:3: ( LITERAL_invariant inv= assertion )?
			int alt50=2;
			int LA50_0 = input.LA(1);
			if ( (LA50_0==LITERAL_invariant) ) {
				alt50=1;
			}
			switch (alt50) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1983:5: LITERAL_invariant inv= assertion
					{
<<<<<<< HEAD
					LITERAL_invariant54=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_while_loop6056); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant54);

					pushFollow(FOLLOW_assertion_in_while_loop6060);
=======
					LITERAL_invariant54=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_while_loop6064); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant54);

					pushFollow(FOLLOW_assertion_in_while_loop6068);
>>>>>>> origin/continuum
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:3: ( LITERAL_bound bd= expression )?
			int alt51=2;
			int LA51_0 = input.LA(1);
			if ( (LA51_0==LITERAL_bound) ) {
				alt51=1;
			}
			switch (alt51) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:5: LITERAL_bound bd= expression
					{
<<<<<<< HEAD
					LITERAL_bound55=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_while_loop6069); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound55);

					pushFollow(FOLLOW_expression_in_while_loop6074);
=======
					LITERAL_bound55=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_while_loop6077); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound55);

					pushFollow(FOLLOW_expression_in_while_loop6082);
>>>>>>> origin/continuum
					bd=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(bd.getTree());
					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_existential_lattice_quantification_in_while_loop6085);
=======
			pushFollow(FOLLOW_existential_lattice_quantification_in_while_loop6093);
>>>>>>> origin/continuum
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// AST REWRITE
<<<<<<< HEAD
			// elements: lw, be, bd, elq, inv
=======
			// elements: inv, bd, elq, be, lw
>>>>>>> origin/continuum
			// token labels: lw
			// rule labels: inv, bd, be, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lw=new RewriteRuleTokenStream(adaptor,"token lw",lw);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_bd=new RewriteRuleSubtreeStream(adaptor,"rule bd",bd!=null?bd.getTree():null);
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1986:5: -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:8: ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lw.nextNode(), root_1);
				adaptor.addChild(root_1, stream_be.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:18: ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, lw, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:48: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:54: ^( BOUND[$lw,\"BOUND\"] ( $bd)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BOUND, lw, "BOUND"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:76: ( $bd)?
				if ( stream_bd.hasNext() ) {
					adaptor.addChild(root_2, stream_bd.nextTree());
				}
				stream_bd.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.whileLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "while_loop"


	public static class for_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "for_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1991:1: for_loop : lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act) ;
	public final BLESStoASTParser.for_loop_return for_loop() throws RecognitionException {
		BLESStoASTParser.for_loop_return retval = new BLESStoASTParser.for_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lf=null;
		Token li=null;
		Token DOTDOT56=null;
		Token LITERAL_invariant57=null;
		Token LCURLY58=null;
		Token RCURLY59=null;
		ParserRuleReturnScope a =null;
		ParserRuleReturnScope lb =null;
		ParserRuleReturnScope ub =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope act =null;

		BAST lf_tree=null;
		BAST li_tree=null;
		BAST DOTDOT56_tree=null;
		BAST LITERAL_invariant57_tree=null;
		BAST LCURLY58_tree=null;
		BAST RCURLY59_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_for=new RewriteRuleTokenStream(adaptor,"token LITERAL_for");
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1992:3: (lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1993:3: lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY
			{
<<<<<<< HEAD
			lf=(Token)match(input,LITERAL_for,FOLLOW_LITERAL_for_in_for_loop6150); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_for.add(lf);

			pushFollow(FOLLOW_identifier_in_for_loop6158);
=======
			lf=(Token)match(input,LITERAL_for,FOLLOW_LITERAL_for_in_for_loop6158); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_for.add(lf);

			pushFollow(FOLLOW_identifier_in_for_loop6166);
>>>>>>> origin/continuum
			a=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
<<<<<<< HEAD
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_for_loop6163); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_expression_in_for_loop6168);
=======
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_for_loop6171); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_expression_in_for_loop6176);
>>>>>>> origin/continuum
			lb=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(lb.getTree());
<<<<<<< HEAD
			DOTDOT56=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_for_loop6170); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT56);

			pushFollow(FOLLOW_expression_in_for_loop6175);
=======
			DOTDOT56=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_for_loop6178); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT56);

			pushFollow(FOLLOW_expression_in_for_loop6183);
>>>>>>> origin/continuum
			ub=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(ub.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1998:3: ( LITERAL_invariant inv= assertion )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==LITERAL_invariant) ) {
				alt52=1;
			}
			switch (alt52) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1998:5: LITERAL_invariant inv= assertion
					{
<<<<<<< HEAD
					LITERAL_invariant57=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_for_loop6184); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant57);

					pushFollow(FOLLOW_assertion_in_for_loop6188);
=======
					LITERAL_invariant57=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_for_loop6192); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant57);

					pushFollow(FOLLOW_assertion_in_for_loop6196);
>>>>>>> origin/continuum
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

<<<<<<< HEAD
			LCURLY58=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_for_loop6195); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY58);

			pushFollow(FOLLOW_behavior_actions_in_for_loop6200);
=======
			LCURLY58=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_for_loop6203); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY58);

			pushFollow(FOLLOW_behavior_actions_in_for_loop6208);
>>>>>>> origin/continuum
			act=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_behavior_actions.add(act.getTree());
<<<<<<< HEAD
			RCURLY59=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_for_loop6202); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY59);

			// AST REWRITE
			// elements: inv, lb, ub, a, lf, act, li
=======
			RCURLY59=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_for_loop6210); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY59);

			// AST REWRITE
			// elements: a, act, ub, lb, lf, li, inv
>>>>>>> origin/continuum
			// token labels: lf, li
			// rule labels: inv, a, act, lb, ub, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lf=new RewriteRuleTokenStream(adaptor,"token lf",lf);
			RewriteRuleTokenStream stream_li=new RewriteRuleTokenStream(adaptor,"token li",li);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
			RewriteRuleSubtreeStream stream_act=new RewriteRuleSubtreeStream(adaptor,"rule act",act!=null?act.getTree():null);
			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,"rule lb",lb!=null?lb.getTree():null);
			RewriteRuleSubtreeStream stream_ub=new RewriteRuleSubtreeStream(adaptor,"rule ub",ub!=null?ub.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2001:5: -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:7: ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lf.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:16: ^( $li $lb $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_li.nextNode(), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:31: ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, lf, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:61: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_act.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.forLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_loop"


	public static class do_until_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "do_until_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2006:1: do_until_loop : ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba) ;
	public final BLESStoASTParser.do_until_loop_return do_until_loop() throws RecognitionException {
		BLESStoASTParser.do_until_loop_return retval = new BLESStoASTParser.do_until_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ld=null;
		Token lu=null;
		Token LITERAL_invariant60=null;
		Token LITERAL_bound61=null;
		Token LPAREN62=null;
		Token RPAREN63=null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope bd =null;
		ParserRuleReturnScope ba =null;
		ParserRuleReturnScope be =null;

		BAST ld_tree=null;
		BAST lu_tree=null;
		BAST LITERAL_invariant60_tree=null;
		BAST LITERAL_bound61_tree=null;
		BAST LPAREN62_tree=null;
		BAST RPAREN63_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_bound=new RewriteRuleTokenStream(adaptor,"token LITERAL_bound");
		RewriteRuleTokenStream stream_LITERAL_until=new RewriteRuleTokenStream(adaptor,"token LITERAL_until");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_LITERAL_do=new RewriteRuleTokenStream(adaptor,"token LITERAL_do");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2007:3: (ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2008:3: ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN
			{
<<<<<<< HEAD
			ld=(Token)match(input,LITERAL_do,FOLLOW_LITERAL_do_in_do_until_loop6272); if (state.failed) return retval; 
=======
			ld=(Token)match(input,LITERAL_do,FOLLOW_LITERAL_do_in_do_until_loop6280); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LITERAL_do.add(ld);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2010:3: ( LITERAL_invariant inv= assertion )?
			int alt53=2;
			int LA53_0 = input.LA(1);
			if ( (LA53_0==LITERAL_invariant) ) {
				alt53=1;
			}
			switch (alt53) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2010:5: LITERAL_invariant inv= assertion
					{
<<<<<<< HEAD
					LITERAL_invariant60=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_do_until_loop6280); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant60);

					pushFollow(FOLLOW_assertion_in_do_until_loop6284);
=======
					LITERAL_invariant60=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_do_until_loop6288); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant60);

					pushFollow(FOLLOW_assertion_in_do_until_loop6292);
>>>>>>> origin/continuum
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2011:3: ( LITERAL_bound bd= expression )?
			int alt54=2;
			int LA54_0 = input.LA(1);
			if ( (LA54_0==LITERAL_bound) ) {
				alt54=1;
			}
			switch (alt54) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2011:5: LITERAL_bound bd= expression
					{
<<<<<<< HEAD
					LITERAL_bound61=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_do_until_loop6293); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound61);

					pushFollow(FOLLOW_expression_in_do_until_loop6298);
=======
					LITERAL_bound61=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_do_until_loop6301); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound61);

					pushFollow(FOLLOW_expression_in_do_until_loop6306);
>>>>>>> origin/continuum
					bd=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(bd.getTree());
					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_behavior_actions_in_do_until_loop6309);
=======
			pushFollow(FOLLOW_behavior_actions_in_do_until_loop6317);
>>>>>>> origin/continuum
			ba=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_behavior_actions.add(ba.getTree());
<<<<<<< HEAD
			lu=(Token)match(input,LITERAL_until,FOLLOW_LITERAL_until_in_do_until_loop6315); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_until.add(lu);

			LPAREN62=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_do_until_loop6317); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN62);

			pushFollow(FOLLOW_expression_or_relation_in_do_until_loop6322);
=======
			lu=(Token)match(input,LITERAL_until,FOLLOW_LITERAL_until_in_do_until_loop6323); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_until.add(lu);

			LPAREN62=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_do_until_loop6325); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN62);

			pushFollow(FOLLOW_expression_or_relation_in_do_until_loop6330);
>>>>>>> origin/continuum
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
<<<<<<< HEAD
			RPAREN63=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_do_until_loop6324); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN63);

			// AST REWRITE
			// elements: be, inv, ba, ld, bd, lu
=======
			RPAREN63=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_do_until_loop6332); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN63);

			// AST REWRITE
			// elements: be, bd, lu, ld, inv, ba
>>>>>>> origin/continuum
			// token labels: ld, lu
			// rule labels: inv, bd, be, retval, ba
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_ld=new RewriteRuleTokenStream(adaptor,"token ld",ld);
			RewriteRuleTokenStream stream_lu=new RewriteRuleTokenStream(adaptor,"token lu",lu);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_bd=new RewriteRuleSubtreeStream(adaptor,"rule bd",bd!=null?bd.getTree():null);
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ba=new RewriteRuleSubtreeStream(adaptor,"rule ba",ba!=null?ba.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2014:5: -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:7: ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_ld.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:13: ^( $lu $be)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_lu.nextNode(), root_2);
				adaptor.addChild(root_2, stream_be.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:24: ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, ld, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:54: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:60: ^( BOUND[$ld,\"BOUND\"] ( $bd)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BOUND, ld, "BOUND"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:82: ( $bd)?
				if ( stream_bd.hasNext() ) {
					adaptor.addChild(root_2, stream_bd.nextTree());
				}
				stream_bd.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.doUntilLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "do_until_loop"


	public static class basic_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "basic_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2019:1: basic_action : ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception );
	public final BLESStoASTParser.basic_action_return basic_action() throws RecognitionException {
		BLESStoASTParser.basic_action_return retval = new BLESStoASTParser.basic_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_skip64=null;
		Token LITERAL_setmode68=null;
		ParserRuleReturnScope assignment65 =null;
		ParserRuleReturnScope communication_action66 =null;
		ParserRuleReturnScope computation_action67 =null;
		ParserRuleReturnScope identifier69 =null;
		ParserRuleReturnScope when_throw70 =null;
		ParserRuleReturnScope combinable_operation71 =null;
		ParserRuleReturnScope simultaneous_assignment72 =null;
		ParserRuleReturnScope issue_exception73 =null;

		BAST LITERAL_skip64_tree=null;
		BAST LITERAL_setmode68_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2020:3: ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception )
			int alt55=9;
			alt55 = dfa55.predict(input);
			switch (alt55) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2021:3: LITERAL_skip
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_skip64=(Token)match(input,LITERAL_skip,FOLLOW_LITERAL_skip_in_basic_action6394); if (state.failed) return retval;
=======
					LITERAL_skip64=(Token)match(input,LITERAL_skip,FOLLOW_LITERAL_skip_in_basic_action6402); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_skip64_tree = (BAST)adaptor.create(LITERAL_skip64);
					adaptor.addChild(root_0, LITERAL_skip64_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2022:5: assignment
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_assignment_in_basic_action6400);
=======
					pushFollow(FOLLOW_assignment_in_basic_action6408);
>>>>>>> origin/continuum
					assignment65=assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assignment65.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2024:5: communication_action
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_communication_action_in_basic_action6407);
=======
					pushFollow(FOLLOW_communication_action_in_basic_action6415);
>>>>>>> origin/continuum
					communication_action66=communication_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, communication_action66.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2025:5: computation_action
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_computation_action_in_basic_action6414);
=======
					pushFollow(FOLLOW_computation_action_in_basic_action6422);
>>>>>>> origin/continuum
					computation_action67=computation_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, computation_action67.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2026:5: LITERAL_setmode identifier
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_setmode68=(Token)match(input,LITERAL_setmode,FOLLOW_LITERAL_setmode_in_basic_action6420); if (state.failed) return retval;
=======
					LITERAL_setmode68=(Token)match(input,LITERAL_setmode,FOLLOW_LITERAL_setmode_in_basic_action6428); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_setmode68_tree = (BAST)adaptor.create(LITERAL_setmode68);
					adaptor.addChild(root_0, LITERAL_setmode68_tree);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_basic_action6423);
=======
					pushFollow(FOLLOW_identifier_in_basic_action6431);
>>>>>>> origin/continuum
					identifier69=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier69.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2027:5: when_throw
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_when_throw_in_basic_action6429);
=======
					pushFollow(FOLLOW_when_throw_in_basic_action6437);
>>>>>>> origin/continuum
					when_throw70=when_throw();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, when_throw70.getTree());

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2028:5: combinable_operation
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_combinable_operation_in_basic_action6435);
=======
					pushFollow(FOLLOW_combinable_operation_in_basic_action6443);
>>>>>>> origin/continuum
					combinable_operation71=combinable_operation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, combinable_operation71.getTree());

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2029:5: simultaneous_assignment
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_simultaneous_assignment_in_basic_action6441);
=======
					pushFollow(FOLLOW_simultaneous_assignment_in_basic_action6449);
>>>>>>> origin/continuum
					simultaneous_assignment72=simultaneous_assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, simultaneous_assignment72.getTree());

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2030:5: issue_exception
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_issue_exception_in_basic_action6447);
=======
					pushFollow(FOLLOW_issue_exception_in_basic_action6455);
>>>>>>> origin/continuum
					issue_exception73=issue_exception();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, issue_exception73.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.basicAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "basic_action"


	public static class assignment_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2035:1: assignment : nt= name_tick a= ASSIGN eort= expression_or_record_term -> ^( $a $nt $eort) ;
	public final BLESStoASTParser.assignment_return assignment() throws RecognitionException {
		BLESStoASTParser.assignment_return retval = new BLESStoASTParser.assignment_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		ParserRuleReturnScope nt =null;
		ParserRuleReturnScope eort =null;

		BAST a_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression_or_record_term=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_record_term");
		RewriteRuleSubtreeStream stream_name_tick=new RewriteRuleSubtreeStream(adaptor,"rule name_tick");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2036:3: (nt= name_tick a= ASSIGN eort= expression_or_record_term -> ^( $a $nt $eort) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2037:2: nt= name_tick a= ASSIGN eort= expression_or_record_term
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_name_tick_in_assignment6474);
=======
			pushFollow(FOLLOW_name_tick_in_assignment6482);
>>>>>>> origin/continuum
			nt=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name_tick.add(nt.getTree());
<<<<<<< HEAD
			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignment6478); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_assignment6482);
=======
			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignment6486); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_assignment6490);
>>>>>>> origin/continuum
			eort=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_record_term.add(eort.getTree());
			// AST REWRITE
<<<<<<< HEAD
			// elements: eort, nt, a
=======
			// elements: nt, eort, a
>>>>>>> origin/continuum
			// token labels: a
			// rule labels: eort, nt, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_eort=new RewriteRuleSubtreeStream(adaptor,"rule eort",eort!=null?eort.getTree():null);
			RewriteRuleSubtreeStream stream_nt=new RewriteRuleSubtreeStream(adaptor,"rule nt",nt!=null?nt.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2038:5: -> ^( $a $nt $eort)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2038:8: ^( $a $nt $eort)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				adaptor.addChild(root_1, stream_nt.nextTree());
				adaptor.addChild(root_1, stream_eort.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignment"


	public static class name_tick_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "name_tick"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2046:1: name_tick : name ( TICK ^)? ;
	public final BLESStoASTParser.name_tick_return name_tick() throws RecognitionException {
		BLESStoASTParser.name_tick_return retval = new BLESStoASTParser.name_tick_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK75=null;
		ParserRuleReturnScope name74 =null;

		BAST TICK75_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2047:3: ( name ( TICK ^)? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2048:17: name ( TICK ^)?
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_name_in_name_tick6526);
=======
			pushFollow(FOLLOW_name_in_name_tick6534);
>>>>>>> origin/continuum
			name74=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, name74.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2048:22: ( TICK ^)?
			int alt56=2;
			int LA56_0 = input.LA(1);
			if ( (LA56_0==TICK) ) {
				alt56=1;
			}
			switch (alt56) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2048:24: TICK ^
					{
<<<<<<< HEAD
					TICK75=(Token)match(input,TICK,FOLLOW_TICK_in_name_tick6530); if (state.failed) return retval;
=======
					TICK75=(Token)match(input,TICK,FOLLOW_TICK_in_name_tick6538); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					TICK75_tree = (BAST)adaptor.create(TICK75);
					root_0 = (BAST)adaptor.becomeRoot(TICK75_tree, root_0);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name_tick"


	public static class expression_or_record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2051:1: expression_or_record_term : (e= expression |rt= record_term |any= LITERAL_any );
	public final BLESStoASTParser.expression_or_record_term_return expression_or_record_term() throws RecognitionException {
		BLESStoASTParser.expression_or_record_term_return retval = new BLESStoASTParser.expression_or_record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token any=null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope rt =null;

		BAST any_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2052:3: (e= expression |rt= record_term |any= LITERAL_any )
			int alt57=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt57=1;
				}
				break;
			case LPAREN:
				{
				int LA57_2 = input.LA(2);
				if ( (LA57_2==AADL_STRING_LITERAL||LA57_2==INTEGER_LIT||LA57_2==LBRACKET||LA57_2==LITERAL_complex||LA57_2==LITERAL_false||LA57_2==LITERAL_if||LA57_2==LITERAL_in||LA57_2==LITERAL_integer||LA57_2==LITERAL_natural||(LA57_2 >= LITERAL_not && LA57_2 <= LITERAL_now)||LA57_2==LITERAL_null||(LA57_2 >= LITERAL_rational && LA57_2 <= LITERAL_real)||LA57_2==LITERAL_self||(LA57_2 >= LITERAL_time && LA57_2 <= LITERAL_timeout)||LA57_2==LITERAL_tops||LA57_2==LITERAL_true||LA57_2==LPAREN||LA57_2==MINUS||LA57_2==OCTOTHORPE||LA57_2==REAL_LIT) ) {
					alt57=1;
				}
				else if ( (LA57_2==ID) ) {
					int LA57_4 = input.LA(3);
					if ( ((LA57_4 >= AL && LA57_4 <= AM)||LA57_4==DIVIDE||LA57_4==DOUBLE_COLON||LA57_4==EQ||LA57_4==EXP||LA57_4==GT||LA57_4==LBRACKET||LA57_4==LITERAL_and||LA57_4==LITERAL_cand||LA57_4==LITERAL_cor||LA57_4==LITERAL_mod||LA57_4==LITERAL_or||LA57_4==LITERAL_rem||LA57_4==LITERAL_xor||LA57_4==LT||LA57_4==MINUS||LA57_4==NEQ||LA57_4==OCTOTHORPE||(LA57_4 >= PERIOD && LA57_4 <= PLUS)||(LA57_4 >= QQ && LA57_4 <= QUESTION)||LA57_4==RPAREN||LA57_4==TICK||LA57_4==TIMES) ) {
						alt57=1;
					}
					else if ( (LA57_4==ARROW) ) {
						alt57=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 57, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 57, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_any:
				{
				alt57=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 57, 0, input);
				throw nvae;
			}
			switch (alt57) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2053:3: e= expression
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_expression_in_expression_or_record_term6554);
=======
					pushFollow(FOLLOW_expression_in_expression_or_record_term6562);
>>>>>>> origin/continuum
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, e.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2053:18: rt= record_term
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_record_term_in_expression_or_record_term6560);
=======
					pushFollow(FOLLOW_record_term_in_expression_or_record_term6568);
>>>>>>> origin/continuum
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rt.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2053:35: any= LITERAL_any
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					any=(Token)match(input,LITERAL_any,FOLLOW_LITERAL_any_in_expression_or_record_term6566); if (state.failed) return retval;
=======
					any=(Token)match(input,LITERAL_any,FOLLOW_LITERAL_any_in_expression_or_record_term6574); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					any_tree = (BAST)adaptor.create(any);
					adaptor.addChild(root_0, any_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_record_term"


	public static class record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2056:1: record_term : LPAREN ^ (prv+= record_value )+ RPAREN ;
	public final BLESStoASTParser.record_term_return record_term() throws RecognitionException {
		BLESStoASTParser.record_term_return retval = new BLESStoASTParser.record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN76=null;
		Token RPAREN77=null;
		List<Object> list_prv=null;
		RuleReturnScope prv = null;
		BAST LPAREN76_tree=null;
		BAST RPAREN77_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2057:3: ( LPAREN ^ (prv+= record_value )+ RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2058:3: LPAREN ^ (prv+= record_value )+ RPAREN
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LPAREN76=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_term6581); if (state.failed) return retval;
=======
			LPAREN76=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_term6589); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LPAREN76_tree = (BAST)adaptor.create(LPAREN76);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN76_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2058:14: (prv+= record_value )+
			int cnt58=0;
			loop58:
			while (true) {
				int alt58=2;
				int LA58_0 = input.LA(1);
				if ( (LA58_0==ID) ) {
					alt58=1;
				}

				switch (alt58) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2058:14: prv+= record_value
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_record_value_in_record_term6586);
=======
					pushFollow(FOLLOW_record_value_in_record_term6594);
>>>>>>> origin/continuum
					prv=record_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, prv.getTree());

					if (list_prv==null) list_prv=new ArrayList<Object>();
					list_prv.add(prv.getTree());
					}
					break;

				default :
					if ( cnt58 >= 1 ) break loop58;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(58, input);
					throw eee;
				}
				cnt58++;
			}

<<<<<<< HEAD
			RPAREN77=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_term6589); if (state.failed) return retval;
=======
			RPAREN77=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_term6597); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			RPAREN77_tree = (BAST)adaptor.create(RPAREN77);
			adaptor.addChild(root_0, RPAREN77_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_term"


	public static class record_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2061:1: record_value : identifier ARROW ^ value SEMICOLON !;
	public final BLESStoASTParser.record_value_return record_value() throws RecognitionException {
		BLESStoASTParser.record_value_return retval = new BLESStoASTParser.record_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ARROW79=null;
		Token SEMICOLON81=null;
		ParserRuleReturnScope identifier78 =null;
		ParserRuleReturnScope value80 =null;

		BAST ARROW79_tree=null;
		BAST SEMICOLON81_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2062:3: ( identifier ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2063:20: identifier ARROW ^ value SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_record_value6607);
=======
			pushFollow(FOLLOW_identifier_in_record_value6615);
>>>>>>> origin/continuum
			identifier78=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier78.getTree());

<<<<<<< HEAD
			ARROW79=(Token)match(input,ARROW,FOLLOW_ARROW_in_record_value6609); if (state.failed) return retval;
=======
			ARROW79=(Token)match(input,ARROW,FOLLOW_ARROW_in_record_value6617); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ARROW79_tree = (BAST)adaptor.create(ARROW79);
			root_0 = (BAST)adaptor.becomeRoot(ARROW79_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_value_in_record_value6612);
=======
			pushFollow(FOLLOW_value_in_record_value6620);
>>>>>>> origin/continuum
			value80=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value80.getTree());

<<<<<<< HEAD
			SEMICOLON81=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_value6614); if (state.failed) return retval;
=======
			SEMICOLON81=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_value6622); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_value"


	public static class simultaneous_assignment_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "simultaneous_assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2066:1: simultaneous_assignment : LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) ) ;
	public final BLESStoASTParser.simultaneous_assignment_return simultaneous_assignment() throws RecognitionException {
		BLESStoASTParser.simultaneous_assignment_return retval = new BLESStoASTParser.simultaneous_assignment_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token left_comma=null;
		Token a=null;
		Token right_comma=null;
		Token LPAREN82=null;
		Token RPAREN83=null;
		List<Object> list_lhs=null;
		List<Object> list_rhs=null;
		RuleReturnScope lhs = null;
		RuleReturnScope rhs = null;
		BAST left_comma_tree=null;
		BAST a_tree=null;
		BAST right_comma_tree=null;
		BAST LPAREN82_tree=null;
		BAST RPAREN83_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression_or_record_term=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_record_term");
		RewriteRuleSubtreeStream stream_name_tick=new RewriteRuleSubtreeStream(adaptor,"rule name_tick");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2085:3: ( LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2086:3: LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN
			{
<<<<<<< HEAD
			LPAREN82=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_simultaneous_assignment6640); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN82);

			pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6644);
=======
			LPAREN82=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_simultaneous_assignment6648); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN82);

			pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6652);
>>>>>>> origin/continuum
			lhs=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name_tick.add(lhs.getTree());
			if (list_lhs==null) list_lhs=new ArrayList<Object>();
			list_lhs.add(lhs.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2086:25: (left_comma= COMMA lhs+= name_tick )+
			int cnt59=0;
			loop59:
			while (true) {
				int alt59=2;
				int LA59_0 = input.LA(1);
				if ( (LA59_0==COMMA) ) {
					alt59=1;
				}

				switch (alt59) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2086:27: left_comma= COMMA lhs+= name_tick
					{
<<<<<<< HEAD
					left_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6650); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(left_comma);

					pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6654);
=======
					left_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6658); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(left_comma);

					pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6662);
>>>>>>> origin/continuum
					lhs=name_tick();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name_tick.add(lhs.getTree());
					if (list_lhs==null) list_lhs=new ArrayList<Object>();
					list_lhs.add(lhs.getTree());
					}
					break;

				default :
					if ( cnt59 >= 1 ) break loop59;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(59, input);
					throw eee;
				}
				cnt59++;
			}

<<<<<<< HEAD
			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_simultaneous_assignment6664); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6668);
=======
			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_simultaneous_assignment6672); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6676);
>>>>>>> origin/continuum
			rhs=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_record_term.add(rhs.getTree());
			if (list_rhs==null) list_rhs=new ArrayList<Object>();
			list_rhs.add(rhs.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2087:43: (right_comma= COMMA rhs+= expression_or_record_term )+
			int cnt60=0;
			loop60:
			while (true) {
				int alt60=2;
				int LA60_0 = input.LA(1);
				if ( (LA60_0==COMMA) ) {
					alt60=1;
				}

				switch (alt60) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2087:45: right_comma= COMMA rhs+= expression_or_record_term
					{
<<<<<<< HEAD
					right_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6674); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(right_comma);

					pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6678);
=======
					right_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6682); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(right_comma);

					pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6686);
>>>>>>> origin/continuum
					rhs=expression_or_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_record_term.add(rhs.getTree());
					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}
					break;

				default :
					if ( cnt60 >= 1 ) break loop60;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(60, input);
					throw eee;
				}
				cnt60++;
			}

<<<<<<< HEAD
			RPAREN83=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_simultaneous_assignment6683); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN83);

			// AST REWRITE
			// elements: right_comma, rhs, left_comma, a, lhs
=======
			RPAREN83=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_simultaneous_assignment6691); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN83);

			// AST REWRITE
			// elements: left_comma, a, right_comma, lhs, rhs
>>>>>>> origin/continuum
			// token labels: a, right_comma, left_comma
			// rule labels: retval
			// token list labels: 
			// rule list labels: lhs, rhs
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleTokenStream stream_right_comma=new RewriteRuleTokenStream(adaptor,"token right_comma",right_comma);
			RewriteRuleTokenStream stream_left_comma=new RewriteRuleTokenStream(adaptor,"token left_comma",left_comma);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"token lhs",list_lhs);
			RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"token rhs",list_rhs);
			root_0 = (BAST)adaptor.nil();
			// 2088:5: -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2088:8: ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2088:13: ^( $left_comma ( $lhs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_left_comma.nextNode(), root_2);
				if ( !(stream_lhs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_lhs.hasNext() ) {
					adaptor.addChild(root_2, stream_lhs.nextTree());
				}
				stream_lhs.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2088:36: ^( $right_comma ( $rhs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_right_comma.nextNode(), root_2);
				if ( !(stream_rhs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_rhs.hasNext() ) {
					adaptor.addChild(root_2, stream_rhs.nextTree());
				}
				stream_rhs.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {
			    if (retval.tree==null) throw new YouIdiot("No retval.tree in simultaneous_assignment");
			    if (!retval.tree.hasType(BLESStoASTLexer.ASSIGN)) throw new YouIdiot(
			      "retval.tree must be := for simulatneous assignmen",retval.tree);
			    if (retval.tree.getChildCount()!=2) throw new YouIdiot(" := must have two children",retval.tree);
			    BAST lhc=(BAST)retval.tree.getChild(0); 
			    BAST rhc=(BAST)retval.tree.getChild(1); 
			    if (!lhc.hasType(BLESStoASTLexer.COMMA) || !rhc.hasType(BLESStoASTLexer.COMMA))
			      throw new YouIdiot(" children of := must be ,",retval.tree);
			    if (lhc.getChildCount()!=rhc.getChildCount())
			      {
			      Dump.it("\n\nBoth sides of simulatneous assignment must have equal number of terms:  "+
			          lhc.getChildCount()+" is not "+rhc.getChildCount());
			      throw new YouIdiot("simultaneous assignment "+
			      (lhc.getChildCount()>rhc.getChildCount()?"more variables than expressions":"more expressions than variables")
			      ,retval.tree);
			      }
			  }
		}
		catch (YouIdiot yi) {
			yi.handleException();
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simultaneous_assignment"


	public static class issue_exception_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "issue_exception"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2092:1: issue_exception : LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !;
	public final BLESStoASTParser.issue_exception_return issue_exception() throws RecognitionException {
		BLESStoASTParser.issue_exception_return retval = new BLESStoASTParser.issue_exception_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token message=null;
		Token LITERAL_exception84=null;
		Token LPAREN85=null;
		Token COMMA86=null;
		Token RPAREN87=null;
		ParserRuleReturnScope exception_state =null;

		BAST message_tree=null;
		BAST LITERAL_exception84_tree=null;
		BAST LPAREN85_tree=null;
		BAST COMMA86_tree=null;
		BAST RPAREN87_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2093:3: ( LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2094:3: LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_exception84=(Token)match(input,LITERAL_exception,FOLLOW_LITERAL_exception_in_issue_exception6745); if (state.failed) return retval;
=======
			LITERAL_exception84=(Token)match(input,LITERAL_exception,FOLLOW_LITERAL_exception_in_issue_exception6753); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_exception84_tree = (BAST)adaptor.create(LITERAL_exception84);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_exception84_tree, root_0);
			}

<<<<<<< HEAD
			LPAREN85=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_issue_exception6748); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2093:3: (exception_state= identifier COMMA !)?
=======
			LPAREN85=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_issue_exception6756); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2095:3: (exception_state= identifier COMMA !)?
>>>>>>> origin/continuum
			int alt61=2;
			int LA61_0 = input.LA(1);
			if ( (LA61_0==ID) ) {
				alt61=1;
			}
			switch (alt61) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2095:5: exception_state= identifier COMMA !
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_issue_exception6758);
=======
					pushFollow(FOLLOW_identifier_in_issue_exception6766);
>>>>>>> origin/continuum
					exception_state=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exception_state.getTree());

<<<<<<< HEAD
					COMMA86=(Token)match(input,COMMA,FOLLOW_COMMA_in_issue_exception6760); if (state.failed) return retval;
=======
					COMMA86=(Token)match(input,COMMA,FOLLOW_COMMA_in_issue_exception6768); if (state.failed) return retval;
>>>>>>> origin/continuum
					}
					break;

			}

<<<<<<< HEAD
			message=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_issue_exception6768); if (state.failed) return retval;
=======
			message=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_issue_exception6776); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			message_tree = (BAST)adaptor.create(message);
			adaptor.addChild(root_0, message_tree);
			}

<<<<<<< HEAD
			RPAREN87=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_issue_exception6770); if (state.failed) return retval;
=======
			RPAREN87=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_issue_exception6778); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "issue_exception"


	public static class computation_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "computation_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2099:1: computation_action : LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !;
	public final BLESStoASTParser.computation_action_return computation_action() throws RecognitionException {
		BLESStoASTParser.computation_action_return retval = new BLESStoASTParser.computation_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_computation88=null;
		Token LPAREN89=null;
		Token COMMA91=null;
		Token RPAREN93=null;
		ParserRuleReturnScope behavior_time90 =null;
		ParserRuleReturnScope behavior_time92 =null;

		BAST LITERAL_computation88_tree=null;
		BAST LPAREN89_tree=null;
		BAST COMMA91_tree=null;
		BAST RPAREN93_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2100:3: ( LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2101:3: LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_computation88=(Token)match(input,LITERAL_computation,FOLLOW_LITERAL_computation_in_computation_action6799); if (state.failed) return retval;
=======
			LITERAL_computation88=(Token)match(input,LITERAL_computation,FOLLOW_LITERAL_computation_in_computation_action6807); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_computation88_tree = (BAST)adaptor.create(LITERAL_computation88);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_computation88_tree, root_0);
			}

<<<<<<< HEAD
			LPAREN89=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_computation_action6806); if (state.failed) return retval;
			pushFollow(FOLLOW_behavior_time_in_computation_action6809);
=======
			LPAREN89=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_computation_action6814); if (state.failed) return retval;
			pushFollow(FOLLOW_behavior_time_in_computation_action6817);
>>>>>>> origin/continuum
			behavior_time90=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time90.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2103:25: ( COMMA ! behavior_time )?
			int alt62=2;
			int LA62_0 = input.LA(1);
			if ( (LA62_0==COMMA) ) {
				alt62=1;
			}
			switch (alt62) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2103:27: COMMA ! behavior_time
					{
<<<<<<< HEAD
					COMMA91=(Token)match(input,COMMA,FOLLOW_COMMA_in_computation_action6813); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_time_in_computation_action6816);
=======
					COMMA91=(Token)match(input,COMMA,FOLLOW_COMMA_in_computation_action6821); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_time_in_computation_action6824);
>>>>>>> origin/continuum
					behavior_time92=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time92.getTree());

					}
					break;

			}

<<<<<<< HEAD
			RPAREN93=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_computation_action6824); if (state.failed) return retval;
=======
			RPAREN93=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_computation_action6832); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "computation_action"


	public static class behavior_time_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_time"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2111:1: behavior_time : duration= expression u= time_unit -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u) ;
	public final BLESStoASTParser.behavior_time_return behavior_time() throws RecognitionException {
		BLESStoASTParser.behavior_time_return retval = new BLESStoASTParser.behavior_time_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope duration =null;
		ParserRuleReturnScope u =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_time_unit=new RewriteRuleSubtreeStream(adaptor,"rule time_unit");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2113:3: (duration= expression u= time_unit -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2114:3: duration= expression u= time_unit
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_expression_in_behavior_time6855);
=======
			pushFollow(FOLLOW_expression_in_behavior_time6863);
>>>>>>> origin/continuum
			duration=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(duration.getTree());
<<<<<<< HEAD
			pushFollow(FOLLOW_time_unit_in_behavior_time6860);
=======
			pushFollow(FOLLOW_time_unit_in_behavior_time6868);
>>>>>>> origin/continuum
			u=time_unit();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_time_unit.add(u.getTree());
			// AST REWRITE
			// elements: duration, u
			// token labels: 
			// rule labels: duration, u, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_duration=new RewriteRuleSubtreeStream(adaptor,"rule duration",duration!=null?duration.getTree():null);
			RewriteRuleSubtreeStream stream_u=new RewriteRuleSubtreeStream(adaptor,"rule u",u!=null?u.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2115:5: -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2115:8: ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BEHAVIOR_TIME, "BEHAVIOR_TIME"), root_1);
				adaptor.addChild(root_1, stream_duration.nextTree());
				adaptor.addChild(root_1, stream_u.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(duration!=null?((BAST)duration.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_time"


	public static class time_unit_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_unit"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2120:1: time_unit : ( LITERAL_ps | LITERAL_ns | LITERAL_us | LITERAL_ms | LITERAL_sec | LITERAL_min | LITERAL_hr );
	public final BLESStoASTParser.time_unit_return time_unit() throws RecognitionException {
		BLESStoASTParser.time_unit_return retval = new BLESStoASTParser.time_unit_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set94=null;

		BAST set94_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2121:3: ( LITERAL_ps | LITERAL_ns | LITERAL_us | LITERAL_ms | LITERAL_sec | LITERAL_min | LITERAL_hr )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set94=input.LT(1);
			if ( input.LA(1)==LITERAL_hr||input.LA(1)==LITERAL_min||input.LA(1)==LITERAL_ms||input.LA(1)==LITERAL_ns||input.LA(1)==LITERAL_ps||input.LA(1)==LITERAL_sec||input.LA(1)==LITERAL_us ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set94));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_unit"


	public static class communication_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "communication_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2125:1: communication_action : (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause);
	public final BLESStoASTParser.communication_action_return communication_action() throws RecognitionException {
		BLESStoASTParser.communication_action_return retval = new BLESStoASTParser.communication_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token pause=null;
		ParserRuleReturnScope pc =null;
		ParserRuleReturnScope po =null;
		ParserRuleReturnScope pi =null;

		BAST pause_tree=null;
		RewriteRuleTokenStream stream_LITERAL_pause=new RewriteRuleTokenStream(adaptor,"token LITERAL_pause");
		RewriteRuleSubtreeStream stream_port_input=new RewriteRuleSubtreeStream(adaptor,"rule port_input");
		RewriteRuleSubtreeStream stream_port_output=new RewriteRuleSubtreeStream(adaptor,"rule port_output");
		RewriteRuleSubtreeStream stream_procedure_call=new RewriteRuleSubtreeStream(adaptor,"rule procedure_call");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2126:3: (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause)
			int alt63=4;
			alt63 = dfa63.predict(input);
			switch (alt63) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2127:3: pc= procedure_call
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_procedure_call_in_communication_action6950);
=======
					pushFollow(FOLLOW_procedure_call_in_communication_action6958);
>>>>>>> origin/continuum
					pc=procedure_call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_procedure_call.add(pc.getTree());
					// AST REWRITE
					// elements: pc
					// token labels: 
					// rule labels: pc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_pc=new RewriteRuleSubtreeStream(adaptor,"rule pc",pc!=null?pc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2128:5: -> $pc
					{
						adaptor.addChild(root_0, stream_pc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2130:3: po= port_output
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_port_output_in_communication_action6968);
=======
					pushFollow(FOLLOW_port_output_in_communication_action6976);
>>>>>>> origin/continuum
					po=port_output();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_output.add(po.getTree());
					// AST REWRITE
					// elements: po
					// token labels: 
					// rule labels: retval, po
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_po=new RewriteRuleSubtreeStream(adaptor,"rule po",po!=null?po.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2131:5: -> $po
					{
						adaptor.addChild(root_0, stream_po.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2133:3: pi= port_input
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_port_input_in_communication_action6986);
=======
					pushFollow(FOLLOW_port_input_in_communication_action6994);
>>>>>>> origin/continuum
					pi=port_input();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_input.add(pi.getTree());
					// AST REWRITE
					// elements: pi
					// token labels: 
					// rule labels: pi, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_pi=new RewriteRuleSubtreeStream(adaptor,"rule pi",pi!=null?pi.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2134:5: -> $pi
					{
						adaptor.addChild(root_0, stream_pi.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2136:3: pause= LITERAL_pause
					{
<<<<<<< HEAD
					pause=(Token)match(input,LITERAL_pause,FOLLOW_LITERAL_pause_in_communication_action7004); if (state.failed) return retval; 
=======
					pause=(Token)match(input,LITERAL_pause,FOLLOW_LITERAL_pause_in_communication_action7012); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_pause.add(pause);

					// AST REWRITE
					// elements: pause
					// token labels: pause
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_pause=new RewriteRuleTokenStream(adaptor,"token pause",pause);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2137:5: -> $pause
					{
						adaptor.addChild(root_0, stream_pause.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "communication_action"


	public static class procedure_call_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "procedure_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2140:1: procedure_call : p= identifier LPAREN (spb= formal_actual_list )? RPAREN -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? ) ;
	public final BLESStoASTParser.procedure_call_return procedure_call() throws RecognitionException {
		BLESStoASTParser.procedure_call_return retval = new BLESStoASTParser.procedure_call_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN95=null;
		Token RPAREN96=null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope spb =null;

		BAST LPAREN95_tree=null;
		BAST RPAREN96_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_formal_actual_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_actual_list");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2142:3: (p= identifier LPAREN (spb= formal_actual_list )? RPAREN -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2143:27: p= identifier LPAREN (spb= formal_actual_list )? RPAREN
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_procedure_call7041);
=======
			pushFollow(FOLLOW_identifier_in_procedure_call7049);
>>>>>>> origin/continuum
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
<<<<<<< HEAD
			LPAREN95=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_procedure_call7045); if (state.failed) return retval; 
=======
			LPAREN95=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_procedure_call7053); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN95);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2143:61: (spb= formal_actual_list )?
			int alt64=2;
			int LA64_0 = input.LA(1);
			if ( (LA64_0==AADL_STRING_LITERAL||LA64_0==ID||LA64_0==INTEGER_LIT||LA64_0==LBRACKET||LA64_0==LITERAL_false||LA64_0==LITERAL_self||LA64_0==LITERAL_true||LA64_0==LPAREN||LA64_0==OCTOTHORPE||LA64_0==REAL_LIT) ) {
				alt64=1;
			}
			switch (alt64) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2143:61: spb= formal_actual_list
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_formal_actual_list_in_procedure_call7049);
=======
					pushFollow(FOLLOW_formal_actual_list_in_procedure_call7057);
>>>>>>> origin/continuum
					spb=formal_actual_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_formal_actual_list.add(spb.getTree());
					}
					break;

			}

<<<<<<< HEAD
			RPAREN96=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_procedure_call7052); if (state.failed) return retval; 
=======
			RPAREN96=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_procedure_call7060); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN96);

			// AST REWRITE
			// elements: spb, p
			// token labels: 
			// rule labels: p, spb, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
			RewriteRuleSubtreeStream stream_spb=new RewriteRuleSubtreeStream(adaptor,"rule spb",spb!=null?spb.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2144:5: -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2144:8: ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PROCEDURE_CALL, (p!=null?((BAST)p.getTree()):null).getToken(), "PROCEDURE_CALL["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_p.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2146:18: ( $spb)?
				if ( stream_spb.hasNext() ) {
					adaptor.addChild(root_1, stream_spb.nextTree());
				}
				stream_spb.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(p!=null?((BAST)p.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  Dump.it("RecognitionException caught by BLESStoAST.procedure_call");
			  Dump.it("Did you forget \"formal:actual\" in your subprogram invocation, "+HelpfulHints.getIdiot()+"?");
			//    tellBNF(GrammarStrings.procedureCall,re,retval.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "procedure_call"


	public static class port_output_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_output"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2155:1: port_output : pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )? -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? ) ;
	public final BLESStoASTParser.port_output_return port_output() throws RecognitionException {
		BLESStoASTParser.port_output_return retval = new BLESStoASTParser.port_output_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token EXCLAMATION97=null;
		Token LPAREN98=null;
		Token RPAREN99=null;
		ParserRuleReturnScope pn =null;
		ParserRuleReturnScope be =null;

		BAST EXCLAMATION97_tree=null;
		BAST LPAREN98_tree=null;
		BAST RPAREN99_tree=null;
		RewriteRuleTokenStream stream_EXCLAMATION=new RewriteRuleTokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2157:3: (pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )? -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2158:5: pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )?
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_port_name_in_port_output7109);
=======
			pushFollow(FOLLOW_port_name_in_port_output7117);
>>>>>>> origin/continuum
			pn=port_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_port_name.add(pn.getTree());
<<<<<<< HEAD
			EXCLAMATION97=(Token)match(input,EXCLAMATION,FOLLOW_EXCLAMATION_in_port_output7111); if (state.failed) return retval; 
=======
			EXCLAMATION97=(Token)match(input,EXCLAMATION,FOLLOW_EXCLAMATION_in_port_output7119); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_EXCLAMATION.add(EXCLAMATION97);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2158:30: ( LPAREN be= expression_or_relation RPAREN )?
			int alt65=2;
			int LA65_0 = input.LA(1);
			if ( (LA65_0==LPAREN) ) {
				alt65=1;
			}
			switch (alt65) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2158:32: LPAREN be= expression_or_relation RPAREN
					{
<<<<<<< HEAD
					LPAREN98=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_output7115); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN98);

					pushFollow(FOLLOW_expression_or_relation_in_port_output7119);
=======
					LPAREN98=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_output7123); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN98);

					pushFollow(FOLLOW_expression_or_relation_in_port_output7127);
>>>>>>> origin/continuum
					be=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
<<<<<<< HEAD
					RPAREN99=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_output7121); if (state.failed) return retval; 
=======
					RPAREN99=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_output7129); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN99);

					}
					break;

			}

			// AST REWRITE
			// elements: be, pn
			// token labels: 
			// rule labels: be, pn, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_pn=new RewriteRuleSubtreeStream(adaptor,"rule pn",pn!=null?pn.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2159:5: -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2159:8: ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PORT_OUTPUT, (pn!=null?((BAST)pn.getTree()):null).getToken(), "PORT_OUTPUT["+Integer.toString((pn!=null?((BAST)pn.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_pn.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2161:19: ( $be)?
				if ( stream_be.hasNext() ) {
					adaptor.addChild(root_1, stream_be.nextTree());
				}
				stream_be.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(pn!=null?((BAST)pn.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_output"


	public static class port_input_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_input"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2165:1: port_input : pn2= port_name QUESTION LPAREN n= name RPAREN -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n) ;
	public final BLESStoASTParser.port_input_return port_input() throws RecognitionException {
		BLESStoASTParser.port_input_return retval = new BLESStoASTParser.port_input_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token QUESTION100=null;
		Token LPAREN101=null;
		Token RPAREN102=null;
		ParserRuleReturnScope pn2 =null;
		ParserRuleReturnScope n =null;

		BAST QUESTION100_tree=null;
		BAST LPAREN101_tree=null;
		BAST RPAREN102_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2167:3: (pn2= port_name QUESTION LPAREN n= name RPAREN -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2168:5: pn2= port_name QUESTION LPAREN n= name RPAREN
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_port_name_in_port_input7179);
=======
			pushFollow(FOLLOW_port_name_in_port_input7187);
>>>>>>> origin/continuum
			pn2=port_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_port_name.add(pn2.getTree());
<<<<<<< HEAD
			QUESTION100=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_port_input7181); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION100);

			LPAREN101=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_input7183); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN101);

			pushFollow(FOLLOW_name_in_port_input7188);
=======
			QUESTION100=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_port_input7189); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION100);

			LPAREN101=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_input7191); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN101);

			pushFollow(FOLLOW_name_in_port_input7196);
>>>>>>> origin/continuum
			n=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(n.getTree());
<<<<<<< HEAD
			RPAREN102=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_input7190); if (state.failed) return retval; 
=======
			RPAREN102=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_input7198); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN102);

			// AST REWRITE
			// elements: pn2, n
			// token labels: 
			// rule labels: pn2, n, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_pn2=new RewriteRuleSubtreeStream(adaptor,"rule pn2",pn2!=null?pn2.getTree():null);
			RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,"rule n",n!=null?n.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2169:6: -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2169:9: ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PORT_INPUT, (pn2!=null?((BAST)pn2.getTree()):null).getToken(), "PORT_INPUT["+Integer.toString((pn2!=null?((BAST)pn2.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_pn2.nextTree());
				adaptor.addChild(root_1, stream_n.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(pn2!=null?((BAST)pn2.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_input"


	public static class port_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2176:1: port_name : ( identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )? | identifier LBRACKET ^ INTEGER_LIT RBRACKET );
	public final BLESStoASTParser.port_name_return port_name() throws RecognitionException {
		BLESStoASTParser.port_name_return retval = new BLESStoASTParser.port_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token PERIOD104=null;
		Token PERIOD106=null;
		Token LBRACKET109=null;
		Token INTEGER_LIT110=null;
		Token RBRACKET111=null;
		ParserRuleReturnScope identifier103 =null;
		ParserRuleReturnScope identifier105 =null;
		ParserRuleReturnScope identifier107 =null;
		ParserRuleReturnScope identifier108 =null;

		BAST PERIOD104_tree=null;
		BAST PERIOD106_tree=null;
		BAST LBRACKET109_tree=null;
		BAST INTEGER_LIT110_tree=null;
		BAST RBRACKET111_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2177:3: ( identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )? | identifier LBRACKET ^ INTEGER_LIT RBRACKET )
			int alt68=2;
			int LA68_0 = input.LA(1);
			if ( (LA68_0==ID) ) {
				int LA68_1 = input.LA(2);
				if ( (LA68_1==EXCLAMATION||LA68_1==PERIOD||LA68_1==QUESTION||LA68_1==TICK) ) {
					alt68=1;
				}
				else if ( (LA68_1==LBRACKET) ) {
					alt68=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 68, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 68, 0, input);
				throw nvae;
			}

			switch (alt68) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:12: identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )?
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_port_name7233);
=======
					pushFollow(FOLLOW_identifier_in_port_name7241);
>>>>>>> origin/continuum
					identifier103=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier103.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:23: ( PERIOD ^ identifier ( PERIOD ! identifier )* )?
					int alt67=2;
					int LA67_0 = input.LA(1);
					if ( (LA67_0==PERIOD) ) {
						alt67=1;
					}
					switch (alt67) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:24: PERIOD ^ identifier ( PERIOD ! identifier )*
							{
<<<<<<< HEAD
							PERIOD104=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7236); if (state.failed) return retval;
=======
							PERIOD104=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7244); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							PERIOD104_tree = (BAST)adaptor.create(PERIOD104);
							root_0 = (BAST)adaptor.becomeRoot(PERIOD104_tree, root_0);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_identifier_in_port_name7239);
=======
							pushFollow(FOLLOW_identifier_in_port_name7247);
>>>>>>> origin/continuum
							identifier105=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier105.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:43: ( PERIOD ! identifier )*
							loop66:
							while (true) {
								int alt66=2;
								int LA66_0 = input.LA(1);
								if ( (LA66_0==PERIOD) ) {
									alt66=1;
								}

								switch (alt66) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:44: PERIOD ! identifier
									{
<<<<<<< HEAD
									PERIOD106=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7242); if (state.failed) return retval;
									pushFollow(FOLLOW_identifier_in_port_name7245);
=======
									PERIOD106=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7250); if (state.failed) return retval;
									pushFollow(FOLLOW_identifier_in_port_name7253);
>>>>>>> origin/continuum
									identifier107=identifier();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier107.getTree());

									}
									break;

								default :
									break loop66;
								}
							}

							}
							break;

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2180:12: identifier LBRACKET ^ INTEGER_LIT RBRACKET
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_port_name7259);
=======
					pushFollow(FOLLOW_identifier_in_port_name7267);
>>>>>>> origin/continuum
					identifier108=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier108.getTree());

<<<<<<< HEAD
					LBRACKET109=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_port_name7261); if (state.failed) return retval;
=======
					LBRACKET109=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_port_name7269); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LBRACKET109_tree = (BAST)adaptor.create(LBRACKET109);
					root_0 = (BAST)adaptor.becomeRoot(LBRACKET109_tree, root_0);
					}

<<<<<<< HEAD
					INTEGER_LIT110=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_port_name7265); if (state.failed) return retval;
=======
					INTEGER_LIT110=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_port_name7273); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					INTEGER_LIT110_tree = (BAST)adaptor.create(INTEGER_LIT110);
					adaptor.addChild(root_0, INTEGER_LIT110_tree);
					}

<<<<<<< HEAD
					RBRACKET111=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_port_name7267); if (state.failed) return retval;
=======
					RBRACKET111=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_port_name7275); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					RBRACKET111_tree = (BAST)adaptor.create(RBRACKET111);
					adaptor.addChild(root_0, RBRACKET111_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_name"


	public static class formal_actual_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_actual_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2183:1: formal_actual_list : fa= formal_actual (c= COMMA fa2+= formal_actual )* -> {c!=null}? ^( $c $fa ( $fa2)+ ) -> $fa;
	public final BLESStoASTParser.formal_actual_list_return formal_actual_list() throws RecognitionException {
		BLESStoASTParser.formal_actual_list_return retval = new BLESStoASTParser.formal_actual_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		List<Object> list_fa2=null;
		ParserRuleReturnScope fa =null;
		RuleReturnScope fa2 = null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal_actual=new RewriteRuleSubtreeStream(adaptor,"rule formal_actual");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2184:3: (fa= formal_actual (c= COMMA fa2+= formal_actual )* -> {c!=null}? ^( $c $fa ( $fa2)+ ) -> $fa)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2185:3: fa= formal_actual (c= COMMA fa2+= formal_actual )*
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_formal_actual_in_formal_actual_list7286);
=======
			pushFollow(FOLLOW_formal_actual_in_formal_actual_list7294);
>>>>>>> origin/continuum
			fa=formal_actual();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_formal_actual.add(fa.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2185:20: (c= COMMA fa2+= formal_actual )*
			loop69:
			while (true) {
				int alt69=2;
				int LA69_0 = input.LA(1);
				if ( (LA69_0==COMMA) ) {
					alt69=1;
				}

				switch (alt69) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2185:22: c= COMMA fa2+= formal_actual
					{
<<<<<<< HEAD
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_actual_list7292); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_formal_actual_in_formal_actual_list7296);
=======
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_actual_list7300); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_formal_actual_in_formal_actual_list7304);
>>>>>>> origin/continuum
					fa2=formal_actual();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_formal_actual.add(fa2.getTree());
					if (list_fa2==null) list_fa2=new ArrayList<Object>();
					list_fa2.add(fa2.getTree());
					}
					break;

				default :
					break loop69;
				}
			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: c, fa2, fa, fa
=======
			// elements: fa, fa2, fa, c
>>>>>>> origin/continuum
			// token labels: c
			// rule labels: fa, retval
			// token list labels: 
			// rule list labels: fa2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_fa=new RewriteRuleSubtreeStream(adaptor,"rule fa",fa!=null?fa.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_fa2=new RewriteRuleSubtreeStream(adaptor,"token fa2",list_fa2);
			root_0 = (BAST)adaptor.nil();
			// 2186:5: -> {c!=null}? ^( $c $fa ( $fa2)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2186:19: ^( $c $fa ( $fa2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_fa.nextTree());
				if ( !(stream_fa2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_fa2.hasNext() ) {
					adaptor.addChild(root_1, stream_fa2.nextTree());
				}
				stream_fa2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2187:5: -> $fa
			{
				adaptor.addChild(root_0, stream_fa.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual_list"


	public static class formal_actual_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_actual"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2190:1: formal_actual : ( identifier COLON ^)? actual_parameter ;
	public final BLESStoASTParser.formal_actual_return formal_actual() throws RecognitionException {
		BLESStoASTParser.formal_actual_return retval = new BLESStoASTParser.formal_actual_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COLON113=null;
		ParserRuleReturnScope identifier112 =null;
		ParserRuleReturnScope actual_parameter114 =null;

		BAST COLON113_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2191:3: ( ( identifier COLON ^)? actual_parameter )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2192:3: ( identifier COLON ^)? actual_parameter
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2192:3: ( identifier COLON ^)?
			int alt70=2;
			int LA70_0 = input.LA(1);
			if ( (LA70_0==ID) ) {
				int LA70_1 = input.LA(2);
				if ( (LA70_1==COLON) ) {
					alt70=1;
				}
			}
			switch (alt70) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2192:26: identifier COLON ^
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_formal_actual7351);
=======
					pushFollow(FOLLOW_identifier_in_formal_actual7359);
>>>>>>> origin/continuum
					identifier112=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier112.getTree());

<<<<<<< HEAD
					COLON113=(Token)match(input,COLON,FOLLOW_COLON_in_formal_actual7353); if (state.failed) return retval;
=======
					COLON113=(Token)match(input,COLON,FOLLOW_COLON_in_formal_actual7361); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					COLON113_tree = (BAST)adaptor.create(COLON113);
					root_0 = (BAST)adaptor.becomeRoot(COLON113_tree, root_0);
					}

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_actual_parameter_in_formal_actual7359);
=======
			pushFollow(FOLLOW_actual_parameter_in_formal_actual7367);
>>>>>>> origin/continuum
			actual_parameter114=actual_parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, actual_parameter114.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual"


	public static class actual_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "actual_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2195:1: actual_parameter : ( name | value_constant | parenthesized_subexpression );
	public final BLESStoASTParser.actual_parameter_return actual_parameter() throws RecognitionException {
		BLESStoASTParser.actual_parameter_return retval = new BLESStoASTParser.actual_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope name115 =null;
		ParserRuleReturnScope value_constant116 =null;
		ParserRuleReturnScope parenthesized_subexpression117 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2196:3: ( name | value_constant | parenthesized_subexpression )
			int alt71=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				switch ( input.LA(2) ) {
				case COMMA:
				case LBRACKET:
				case RPAREN:
					{
					alt71=1;
					}
					break;
				case PERIOD:
					{
					int LA71_5 = input.LA(3);
					if ( (LA71_5==ID) ) {
						int LA71_6 = input.LA(4);
						if ( (LA71_6==COMMA||LA71_6==LBRACKET||LA71_6==PERIOD||LA71_6==RPAREN) ) {
							alt71=1;
						}
						else if ( (LA71_6==OCTOTHORPE) ) {
							alt71=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 71, 6, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 71, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

					}
					break;
				case DOUBLE_COLON:
				case OCTOTHORPE:
				case TICK:
					{
					alt71=2;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 71, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
				}
				break;
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_self:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt71=2;
				}
				break;
			case LPAREN:
				{
				alt71=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 71, 0, input);
				throw nvae;
			}
			switch (alt71) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2197:17: name
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_name_in_actual_parameter7378);
=======
					pushFollow(FOLLOW_name_in_actual_parameter7386);
>>>>>>> origin/continuum
					name115=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, name115.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2198:6: value_constant
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_value_constant_in_actual_parameter7386);
=======
					pushFollow(FOLLOW_value_constant_in_actual_parameter7394);
>>>>>>> origin/continuum
					value_constant116=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, value_constant116.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2199:6: parenthesized_subexpression
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_parenthesized_subexpression_in_actual_parameter7394);
=======
					pushFollow(FOLLOW_parenthesized_subexpression_in_actual_parameter7402);
>>>>>>> origin/continuum
					parenthesized_subexpression117=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_subexpression117.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_parameter"


	public static class existential_lattice_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "existential_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2202:1: existential_lattice_quantification : ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )? ;
	public final BLESStoASTParser.existential_lattice_quantification_return existential_lattice_quantification() throws RecognitionException {
		BLESStoASTParser.existential_lattice_quantification_return retval = new BLESStoASTParser.existential_lattice_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LCURLY119=null;
		Token RCURLY121=null;
		ParserRuleReturnScope quantified_variables118 =null;
		ParserRuleReturnScope behavior_actions120 =null;
		ParserRuleReturnScope timeout_clause122 =null;
		ParserRuleReturnScope catch_clause123 =null;

		BAST LCURLY119_tree=null;
		BAST RCURLY121_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2203:3: ( ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2204:3: ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2204:3: ( quantified_variables )?
			int alt72=2;
			int LA72_0 = input.LA(1);
			if ( (LA72_0==LITERAL_declare) ) {
				alt72=1;
			}
			switch (alt72) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2204:3: quantified_variables
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_quantified_variables_in_existential_lattice_quantification7420);
=======
					pushFollow(FOLLOW_quantified_variables_in_existential_lattice_quantification7428);
>>>>>>> origin/continuum
					quantified_variables118=quantified_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, quantified_variables118.getTree());

					}
					break;

			}

<<<<<<< HEAD
			LCURLY119=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_existential_lattice_quantification7425); if (state.failed) return retval;
=======
			LCURLY119=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_existential_lattice_quantification7433); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LCURLY119_tree = (BAST)adaptor.create(LCURLY119);
			root_0 = (BAST)adaptor.becomeRoot(LCURLY119_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_behavior_actions_in_existential_lattice_quantification7429);
=======
			pushFollow(FOLLOW_behavior_actions_in_existential_lattice_quantification7437);
>>>>>>> origin/continuum
			behavior_actions120=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_actions120.getTree());

<<<<<<< HEAD
			RCURLY121=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_existential_lattice_quantification7431); if (state.failed) return retval;
=======
			RCURLY121=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_existential_lattice_quantification7439); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			RCURLY121_tree = (BAST)adaptor.create(RCURLY121);
			adaptor.addChild(root_0, RCURLY121_tree);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2206:3: ( timeout_clause )?
			int alt73=2;
			int LA73_0 = input.LA(1);
			if ( (LA73_0==LITERAL_timeout) ) {
				alt73=1;
			}
			switch (alt73) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2206:3: timeout_clause
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_timeout_clause_in_existential_lattice_quantification7437);
=======
					pushFollow(FOLLOW_timeout_clause_in_existential_lattice_quantification7445);
>>>>>>> origin/continuum
					timeout_clause122=timeout_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, timeout_clause122.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2207:3: ( catch_clause )?
			int alt74=2;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==LITERAL_catch) ) {
				alt74=1;
			}
			switch (alt74) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2207:3: catch_clause
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_catch_clause_in_existential_lattice_quantification7442);
=======
					pushFollow(FOLLOW_catch_clause_in_existential_lattice_quantification7450);
>>>>>>> origin/continuum
					catch_clause123=catch_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clause123.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.elq,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_lattice_quantification"


	public static class catch_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "catch_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2212:1: catch_clause : LITERAL_catch ^ ( catch_clause_term )+ ;
	public final BLESStoASTParser.catch_clause_return catch_clause() throws RecognitionException {
		BLESStoASTParser.catch_clause_return retval = new BLESStoASTParser.catch_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_catch124=null;
		ParserRuleReturnScope catch_clause_term125 =null;

		BAST LITERAL_catch124_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2213:3: ( LITERAL_catch ^ ( catch_clause_term )+ )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2214:3: LITERAL_catch ^ ( catch_clause_term )+
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_catch124=(Token)match(input,LITERAL_catch,FOLLOW_LITERAL_catch_in_catch_clause7466); if (state.failed) return retval;
=======
			LITERAL_catch124=(Token)match(input,LITERAL_catch,FOLLOW_LITERAL_catch_in_catch_clause7474); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_catch124_tree = (BAST)adaptor.create(LITERAL_catch124);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_catch124_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2214:18: ( catch_clause_term )+
			int cnt75=0;
			loop75:
			while (true) {
				int alt75=2;
				int LA75_0 = input.LA(1);
				if ( (LA75_0==LPAREN) ) {
					alt75=1;
				}

				switch (alt75) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2214:18: catch_clause_term
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_catch_clause_term_in_catch_clause7469);
=======
					pushFollow(FOLLOW_catch_clause_term_in_catch_clause7477);
>>>>>>> origin/continuum
					catch_clause_term125=catch_clause_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clause_term125.getTree());

					}
					break;

				default :
					if ( cnt75 >= 1 ) break loop75;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(75, input);
					throw eee;
				}
				cnt75++;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause"


	public static class timeout_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timeout_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2217:1: timeout_clause : LITERAL_timeout ^ behavior_time ;
	public final BLESStoASTParser.timeout_clause_return timeout_clause() throws RecognitionException {
		BLESStoASTParser.timeout_clause_return retval = new BLESStoASTParser.timeout_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_timeout126=null;
		ParserRuleReturnScope behavior_time127 =null;

		BAST LITERAL_timeout126_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2218:3: ( LITERAL_timeout ^ behavior_time )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2219:3: LITERAL_timeout ^ behavior_time
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_timeout126=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_timeout_clause7485); if (state.failed) return retval;
=======
			LITERAL_timeout126=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_timeout_clause7493); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_timeout126_tree = (BAST)adaptor.create(LITERAL_timeout126);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout126_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_behavior_time_in_timeout_clause7488);
=======
			pushFollow(FOLLOW_behavior_time_in_timeout_clause7496);
>>>>>>> origin/continuum
			behavior_time127=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time127.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timeout_clause"


	public static class catch_clause_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "catch_clause_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2222:1: catch_clause_term : LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN -> {a!=null}? ^( $c $a $ba) -> ^( $c ( $ei)+ $ba) ;
	public final BLESStoASTParser.catch_clause_term_return catch_clause_term() throws RecognitionException {
		BLESStoASTParser.catch_clause_term_return retval = new BLESStoASTParser.catch_clause_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		Token c=null;
		Token LPAREN128=null;
		Token RPAREN129=null;
		List<Object> list_ei=null;
		ParserRuleReturnScope ba =null;
		RuleReturnScope ei = null;
		BAST a_tree=null;
		BAST c_tree=null;
		BAST LPAREN128_tree=null;
		BAST RPAREN129_tree=null;
		RewriteRuleTokenStream stream_LITERAL_all=new RewriteRuleTokenStream(adaptor,"token LITERAL_all");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_basic_action=new RewriteRuleSubtreeStream(adaptor,"rule basic_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2223:3: ( LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN -> {a!=null}? ^( $c $a $ba) -> ^( $c ( $ei)+ $ba) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:3: LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN
			{
<<<<<<< HEAD
			LPAREN128=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_catch_clause_term7509); if (state.failed) return retval; 
=======
			LPAREN128=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_catch_clause_term7517); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN128);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:10: ( (ei+= identifier )+ |a= LITERAL_all )
			int alt77=2;
			int LA77_0 = input.LA(1);
			if ( (LA77_0==ID) ) {
				alt77=1;
			}
			else if ( (LA77_0==LITERAL_all) ) {
				alt77=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 77, 0, input);
				throw nvae;
			}

			switch (alt77) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:12: (ei+= identifier )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:14: (ei+= identifier )+
					int cnt76=0;
					loop76:
					while (true) {
						int alt76=2;
						int LA76_0 = input.LA(1);
						if ( (LA76_0==ID) ) {
							alt76=1;
						}

						switch (alt76) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:14: ei+= identifier
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_identifier_in_catch_clause_term7516);
=======
							pushFollow(FOLLOW_identifier_in_catch_clause_term7524);
>>>>>>> origin/continuum
							ei=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ei.getTree());
							if (list_ei==null) list_ei=new ArrayList<Object>();
							list_ei.add(ei.getTree());
							}
							break;

						default :
							if ( cnt76 >= 1 ) break loop76;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(76, input);
							throw eee;
						}
						cnt76++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:44: a= LITERAL_all
					{
<<<<<<< HEAD
					a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_catch_clause_term7523); if (state.failed) return retval; 
=======
					a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_catch_clause_term7531); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_all.add(a);

					}
					break;

			}

<<<<<<< HEAD
			c=(Token)match(input,COLON,FOLLOW_COLON_in_catch_clause_term7529); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			pushFollow(FOLLOW_basic_action_in_catch_clause_term7533);
=======
			c=(Token)match(input,COLON,FOLLOW_COLON_in_catch_clause_term7537); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			pushFollow(FOLLOW_basic_action_in_catch_clause_term7541);
>>>>>>> origin/continuum
			ba=basic_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_basic_action.add(ba.getTree());
<<<<<<< HEAD
			RPAREN129=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_catch_clause_term7535); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN129);

			// AST REWRITE
			// elements: ba, a, c, ei, ba, c
=======
			RPAREN129=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_catch_clause_term7543); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN129);

			// AST REWRITE
			// elements: c, ei, ba, a, ba, c
>>>>>>> origin/continuum
			// token labels: a, c
			// rule labels: retval, ba
			// token list labels: 
			// rule list labels: ei
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ba=new RewriteRuleSubtreeStream(adaptor,"rule ba",ba!=null?ba.getTree():null);
			RewriteRuleSubtreeStream stream_ei=new RewriteRuleSubtreeStream(adaptor,"token ei",list_ei);
			root_0 = (BAST)adaptor.nil();
			// 2225:5: -> {a!=null}? ^( $c $a $ba)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2225:19: ^( $c $a $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a.nextNode());
				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2226:5: -> ^( $c ( $ei)+ $ba)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:8: ^( $c ( $ei)+ $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				if ( !(stream_ei.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ei.hasNext() ) {
					adaptor.addChild(root_1, stream_ei.nextTree());
				}
				stream_ei.reset();

				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause_term"


	public static class when_throw_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "when_throw"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2229:1: when_throw : LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier ;
	public final BLESStoASTParser.when_throw_return when_throw() throws RecognitionException {
		BLESStoASTParser.when_throw_return retval = new BLESStoASTParser.when_throw_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_when130=null;
		Token LPAREN131=null;
		Token RPAREN133=null;
		Token LITERAL_throw134=null;
		ParserRuleReturnScope expression132 =null;
		ParserRuleReturnScope identifier135 =null;

		BAST LITERAL_when130_tree=null;
		BAST LPAREN131_tree=null;
		BAST RPAREN133_tree=null;
		BAST LITERAL_throw134_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2230:3: ( LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2231:3: LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_when130=(Token)match(input,LITERAL_when,FOLLOW_LITERAL_when_in_when_throw7591); if (state.failed) return retval;
=======
			LITERAL_when130=(Token)match(input,LITERAL_when,FOLLOW_LITERAL_when_in_when_throw7599); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_when130_tree = (BAST)adaptor.create(LITERAL_when130);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_when130_tree, root_0);
			}

<<<<<<< HEAD
			LPAREN131=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_when_throw7594); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_when_throw7598);
=======
			LPAREN131=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_when_throw7602); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_when_throw7606);
>>>>>>> origin/continuum
			expression132=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression132.getTree());

<<<<<<< HEAD
			RPAREN133=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_when_throw7600); if (state.failed) return retval;
			LITERAL_throw134=(Token)match(input,LITERAL_throw,FOLLOW_LITERAL_throw_in_when_throw7603); if (state.failed) return retval;
=======
			RPAREN133=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_when_throw7608); if (state.failed) return retval;
			LITERAL_throw134=(Token)match(input,LITERAL_throw,FOLLOW_LITERAL_throw_in_when_throw7611); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_throw134_tree = (BAST)adaptor.create(LITERAL_throw134);
			adaptor.addChild(root_0, LITERAL_throw134_tree);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_when_throw7606);
=======
			pushFollow(FOLLOW_identifier_in_when_throw7614);
>>>>>>> origin/continuum
			identifier135=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier135.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "when_throw"


	public static class combinable_operation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "combinable_operation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2234:1: combinable_operation : ( LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !);
	public final BLESStoASTParser.combinable_operation_return combinable_operation() throws RecognitionException {
		BLESStoASTParser.combinable_operation_return retval = new BLESStoASTParser.combinable_operation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_fetchadd136=null;
		Token LPAREN137=null;
		Token COMMA139=null;
		Token COMMA141=null;
		Token RPAREN143=null;
		Token LITERAL_fetchor144=null;
		Token LPAREN145=null;
		Token COMMA147=null;
		Token COMMA149=null;
		Token RPAREN151=null;
		Token LITERAL_fetchand152=null;
		Token LPAREN153=null;
		Token COMMA155=null;
		Token COMMA157=null;
		Token RPAREN159=null;
		Token LITERAL_fetchxor160=null;
		Token LPAREN161=null;
		Token COMMA163=null;
		Token COMMA165=null;
		Token RPAREN167=null;
		Token LITERAL_swap168=null;
		Token LPAREN169=null;
		Token COMMA171=null;
		Token COMMA173=null;
		Token RPAREN175=null;
		ParserRuleReturnScope variable_name138 =null;
		ParserRuleReturnScope expression140 =null;
		ParserRuleReturnScope identifier142 =null;
		ParserRuleReturnScope variable_name146 =null;
		ParserRuleReturnScope expression148 =null;
		ParserRuleReturnScope identifier150 =null;
		ParserRuleReturnScope variable_name154 =null;
		ParserRuleReturnScope expression156 =null;
		ParserRuleReturnScope identifier158 =null;
		ParserRuleReturnScope variable_name162 =null;
		ParserRuleReturnScope expression164 =null;
		ParserRuleReturnScope identifier166 =null;
		ParserRuleReturnScope variable_name170 =null;
		ParserRuleReturnScope variable_name172 =null;
		ParserRuleReturnScope identifier174 =null;

		BAST LITERAL_fetchadd136_tree=null;
		BAST LPAREN137_tree=null;
		BAST COMMA139_tree=null;
		BAST COMMA141_tree=null;
		BAST RPAREN143_tree=null;
		BAST LITERAL_fetchor144_tree=null;
		BAST LPAREN145_tree=null;
		BAST COMMA147_tree=null;
		BAST COMMA149_tree=null;
		BAST RPAREN151_tree=null;
		BAST LITERAL_fetchand152_tree=null;
		BAST LPAREN153_tree=null;
		BAST COMMA155_tree=null;
		BAST COMMA157_tree=null;
		BAST RPAREN159_tree=null;
		BAST LITERAL_fetchxor160_tree=null;
		BAST LPAREN161_tree=null;
		BAST COMMA163_tree=null;
		BAST COMMA165_tree=null;
		BAST RPAREN167_tree=null;
		BAST LITERAL_swap168_tree=null;
		BAST LPAREN169_tree=null;
		BAST COMMA171_tree=null;
		BAST COMMA173_tree=null;
		BAST RPAREN175_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2235:3: ( LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !)
			int alt83=5;
			switch ( input.LA(1) ) {
			case LITERAL_fetchadd:
				{
				alt83=1;
				}
				break;
			case LITERAL_fetchor:
				{
				alt83=2;
				}
				break;
			case LITERAL_fetchand:
				{
				alt83=3;
				}
				break;
			case LITERAL_fetchxor:
				{
				alt83=4;
				}
				break;
			case LITERAL_swap:
				{
				alt83=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 83, 0, input);
				throw nvae;
			}
			switch (alt83) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2236:3: LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_fetchadd136=(Token)match(input,LITERAL_fetchadd,FOLLOW_LITERAL_fetchadd_in_combinable_operation7621); if (state.failed) return retval;
=======
					LITERAL_fetchadd136=(Token)match(input,LITERAL_fetchadd,FOLLOW_LITERAL_fetchadd_in_combinable_operation7629); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_fetchadd136_tree = (BAST)adaptor.create(LITERAL_fetchadd136);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchadd136_tree, root_0);
					}

<<<<<<< HEAD
					LPAREN137=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7624); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7628);
=======
					LPAREN137=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7632); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7636);
>>>>>>> origin/continuum
					variable_name138=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name138.getTree());

<<<<<<< HEAD
					COMMA139=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7630); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7641);
=======
					COMMA139=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7638); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7649);
>>>>>>> origin/continuum
					expression140=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression140.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2237:32: ( COMMA ! identifier )?
					int alt78=2;
					int LA78_0 = input.LA(1);
					if ( (LA78_0==COMMA) ) {
						alt78=1;
					}
					switch (alt78) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2237:34: COMMA ! identifier
							{
<<<<<<< HEAD
							COMMA141=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7645); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7649);
=======
							COMMA141=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7653); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7657);
>>>>>>> origin/continuum
							identifier142=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier142.getTree());

							}
							break;

					}

<<<<<<< HEAD
					RPAREN143=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7654); if (state.failed) return retval;
=======
					RPAREN143=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7662); if (state.failed) return retval;
>>>>>>> origin/continuum
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2239:3: LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_fetchor144=(Token)match(input,LITERAL_fetchor,FOLLOW_LITERAL_fetchor_in_combinable_operation7663); if (state.failed) return retval;
=======
					LITERAL_fetchor144=(Token)match(input,LITERAL_fetchor,FOLLOW_LITERAL_fetchor_in_combinable_operation7671); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_fetchor144_tree = (BAST)adaptor.create(LITERAL_fetchor144);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchor144_tree, root_0);
					}

<<<<<<< HEAD
					LPAREN145=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7666); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7670);
=======
					LPAREN145=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7674); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7678);
>>>>>>> origin/continuum
					variable_name146=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name146.getTree());

<<<<<<< HEAD
					COMMA147=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7672); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7683);
=======
					COMMA147=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7680); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7691);
>>>>>>> origin/continuum
					expression148=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression148.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2240:30: ( COMMA ! identifier )?
					int alt79=2;
					int LA79_0 = input.LA(1);
					if ( (LA79_0==COMMA) ) {
						alt79=1;
					}
					switch (alt79) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2240:32: COMMA ! identifier
							{
<<<<<<< HEAD
							COMMA149=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7687); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7691);
=======
							COMMA149=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7695); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7699);
>>>>>>> origin/continuum
							identifier150=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier150.getTree());

							}
							break;

					}

<<<<<<< HEAD
					RPAREN151=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7696); if (state.failed) return retval;
=======
					RPAREN151=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7704); if (state.failed) return retval;
>>>>>>> origin/continuum
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2242:3: LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_fetchand152=(Token)match(input,LITERAL_fetchand,FOLLOW_LITERAL_fetchand_in_combinable_operation7705); if (state.failed) return retval;
=======
					LITERAL_fetchand152=(Token)match(input,LITERAL_fetchand,FOLLOW_LITERAL_fetchand_in_combinable_operation7713); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_fetchand152_tree = (BAST)adaptor.create(LITERAL_fetchand152);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchand152_tree, root_0);
					}

<<<<<<< HEAD
					LPAREN153=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7708); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7712);
=======
					LPAREN153=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7716); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7720);
>>>>>>> origin/continuum
					variable_name154=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name154.getTree());

<<<<<<< HEAD
					COMMA155=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7714); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7725);
=======
					COMMA155=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7722); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7733);
>>>>>>> origin/continuum
					expression156=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression156.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2243:30: ( COMMA ! identifier )?
					int alt80=2;
					int LA80_0 = input.LA(1);
					if ( (LA80_0==COMMA) ) {
						alt80=1;
					}
					switch (alt80) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2243:32: COMMA ! identifier
							{
<<<<<<< HEAD
							COMMA157=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7729); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7733);
=======
							COMMA157=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7737); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7741);
>>>>>>> origin/continuum
							identifier158=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier158.getTree());

							}
							break;

					}

<<<<<<< HEAD
					RPAREN159=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7738); if (state.failed) return retval;
=======
					RPAREN159=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7746); if (state.failed) return retval;
>>>>>>> origin/continuum
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2245:3: LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_fetchxor160=(Token)match(input,LITERAL_fetchxor,FOLLOW_LITERAL_fetchxor_in_combinable_operation7747); if (state.failed) return retval;
=======
					LITERAL_fetchxor160=(Token)match(input,LITERAL_fetchxor,FOLLOW_LITERAL_fetchxor_in_combinable_operation7755); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_fetchxor160_tree = (BAST)adaptor.create(LITERAL_fetchxor160);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchxor160_tree, root_0);
					}

<<<<<<< HEAD
					LPAREN161=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7750); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7754);
=======
					LPAREN161=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7758); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7762);
>>>>>>> origin/continuum
					variable_name162=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name162.getTree());

<<<<<<< HEAD
					COMMA163=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7756); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7767);
=======
					COMMA163=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7764); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7775);
>>>>>>> origin/continuum
					expression164=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression164.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2246:30: ( COMMA ! identifier )?
					int alt81=2;
					int LA81_0 = input.LA(1);
					if ( (LA81_0==COMMA) ) {
						alt81=1;
					}
					switch (alt81) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2246:32: COMMA ! identifier
							{
<<<<<<< HEAD
							COMMA165=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7771); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7775);
=======
							COMMA165=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7779); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7783);
>>>>>>> origin/continuum
							identifier166=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier166.getTree());

							}
							break;

					}

<<<<<<< HEAD
					RPAREN167=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7780); if (state.failed) return retval;
=======
					RPAREN167=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7788); if (state.failed) return retval;
>>>>>>> origin/continuum
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2248:3: LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_swap168=(Token)match(input,LITERAL_swap,FOLLOW_LITERAL_swap_in_combinable_operation7789); if (state.failed) return retval;
=======
					LITERAL_swap168=(Token)match(input,LITERAL_swap,FOLLOW_LITERAL_swap_in_combinable_operation7797); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_swap168_tree = (BAST)adaptor.create(LITERAL_swap168);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_swap168_tree, root_0);
					}

<<<<<<< HEAD
					LPAREN169=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7793); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7797);
=======
					LPAREN169=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7801); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7805);
>>>>>>> origin/continuum
					variable_name170=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name170.getTree());

<<<<<<< HEAD
					COMMA171=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7799); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7810);
=======
					COMMA171=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7807); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7818);
>>>>>>> origin/continuum
					variable_name172=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name172.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2249:35: ( COMMA ! identifier )?
					int alt82=2;
					int LA82_0 = input.LA(1);
					if ( (LA82_0==COMMA) ) {
						alt82=1;
					}
					switch (alt82) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2249:37: COMMA ! identifier
							{
<<<<<<< HEAD
							COMMA173=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7814); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7818);
=======
							COMMA173=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7822); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7826);
>>>>>>> origin/continuum
							identifier174=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier174.getTree());

							}
							break;

					}

<<<<<<< HEAD
					RPAREN175=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7823); if (state.failed) return retval;
=======
					RPAREN175=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7831); if (state.failed) return retval;
>>>>>>> origin/continuum
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "combinable_operation"


	public static class behavior_actions_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_actions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2252:1: behavior_actions : aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )? -> {c!=null}? ^( $c $aa ( $as)+ ) -> {amp!=null}? ^( $amp $aa ( $ac)+ ) -> $aa;
	public final BLESStoASTParser.behavior_actions_return behavior_actions() throws RecognitionException {
		BLESStoASTParser.behavior_actions_return retval = new BLESStoASTParser.behavior_actions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token amp=null;
		Token SEMICOLON176=null;
		Token AMPERSAND177=null;
		List<Object> list_as=null;
		List<Object> list_ac=null;
		ParserRuleReturnScope aa =null;
		RuleReturnScope as = null;
		RuleReturnScope ac = null;
		BAST c_tree=null;
		BAST amp_tree=null;
		BAST SEMICOLON176_tree=null;
		BAST AMPERSAND177_tree=null;
		RewriteRuleTokenStream stream_AMPERSAND=new RewriteRuleTokenStream(adaptor,"token AMPERSAND");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_asserted_action=new RewriteRuleSubtreeStream(adaptor,"rule asserted_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2253:3: (aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )? -> {c!=null}? ^( $c $aa ( $as)+ ) -> {amp!=null}? ^( $amp $aa ( $ac)+ ) -> $aa)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:3: aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )?
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_asserted_action_in_behavior_actions7846);
=======
			pushFollow(FOLLOW_asserted_action_in_behavior_actions7854);
>>>>>>> origin/continuum
			aa=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_asserted_action.add(aa.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2255:5: ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )?
			int alt86=3;
			int LA86_0 = input.LA(1);
			if ( (LA86_0==SEMICOLON) ) {
				alt86=1;
			}
			else if ( (LA86_0==AMPERSAND) ) {
				alt86=2;
			}
			switch (alt86) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:5: (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:5: (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:7: c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )*
					{
<<<<<<< HEAD
					c=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7862); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SEMICOLON.add(c);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7866);
=======
					c=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7870); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SEMICOLON.add(c);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7874);
>>>>>>> origin/continuum
					as=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asserted_action.add(as.getTree());
					if (list_as==null) list_as=new ArrayList<Object>();
					list_as.add(as.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:39: ( SEMICOLON as+= asserted_action )*
					loop84:
					while (true) {
						int alt84=2;
						int LA84_0 = input.LA(1);
						if ( (LA84_0==SEMICOLON) ) {
							alt84=1;
						}

						switch (alt84) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:41: SEMICOLON as+= asserted_action
							{
<<<<<<< HEAD
							SEMICOLON176=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7870); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON176);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7874);
=======
							SEMICOLON176=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7878); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON176);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7882);
>>>>>>> origin/continuum
							as=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_asserted_action.add(as.getTree());
							if (list_as==null) list_as=new ArrayList<Object>();
							list_as.add(as.getTree());
							}
							break;

						default :
							break loop84;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:5: (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:5: (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:7: amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )*
					{
<<<<<<< HEAD
					amp=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7895); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AMPERSAND.add(amp);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7899);
=======
					amp=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7903); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AMPERSAND.add(amp);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7907);
>>>>>>> origin/continuum
					ac=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asserted_action.add(ac.getTree());
					if (list_ac==null) list_ac=new ArrayList<Object>();
					list_ac.add(ac.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:41: ( AMPERSAND ac+= asserted_action )*
					loop85:
					while (true) {
						int alt85=2;
						int LA85_0 = input.LA(1);
						if ( (LA85_0==AMPERSAND) ) {
							alt85=1;
						}

						switch (alt85) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:43: AMPERSAND ac+= asserted_action
							{
<<<<<<< HEAD
							AMPERSAND177=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7903); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_AMPERSAND.add(AMPERSAND177);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7907);
=======
							AMPERSAND177=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7911); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_AMPERSAND.add(AMPERSAND177);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7915);
>>>>>>> origin/continuum
							ac=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_asserted_action.add(ac.getTree());
							if (list_ac==null) list_ac=new ArrayList<Object>();
							list_ac.add(ac.getTree());
							}
							break;

						default :
							break loop85;
						}
					}

					}

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: aa, as, aa, c, aa, ac, amp
=======
			// elements: ac, aa, aa, c, amp, as, aa
>>>>>>> origin/continuum
			// token labels: c, amp
			// rule labels: aa, retval
			// token list labels: 
			// rule list labels: as, ac
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_amp=new RewriteRuleTokenStream(adaptor,"token amp",amp);
			RewriteRuleSubtreeStream stream_aa=new RewriteRuleSubtreeStream(adaptor,"rule aa",aa!=null?aa.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_as=new RewriteRuleSubtreeStream(adaptor,"token as",list_as);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"token ac",list_ac);
			root_0 = (BAST)adaptor.nil();
			// 2260:5: -> {c!=null}? ^( $c $aa ( $as)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2260:19: ^( $c $aa ( $as)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aa.nextTree());
				if ( !(stream_as.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_as.hasNext() ) {
					adaptor.addChild(root_1, stream_as.nextTree());
				}
				stream_as.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2261:5: -> {amp!=null}? ^( $amp $aa ( $ac)+ )
			if (amp!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2261:21: ^( $amp $aa ( $ac)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_amp.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aa.nextTree());
				if ( !(stream_ac.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2262:5: -> $aa
			{
				adaptor.addChild(root_0, stream_aa.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.behaviorActions,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_actions"


	public static class name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2271:1: name : pn1= partial_name (d= PERIOD pn2+= partial_name )* -> {d!=null}? ^( $d $pn1 ( $pn2)+ ) -> $pn1;
	public final BLESStoASTParser.name_return name() throws RecognitionException {
		BLESStoASTParser.name_return retval = new BLESStoASTParser.name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token d=null;
		List<Object> list_pn2=null;
		ParserRuleReturnScope pn1 =null;
		RuleReturnScope pn2 = null;
		BAST d_tree=null;
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleSubtreeStream stream_partial_name=new RewriteRuleSubtreeStream(adaptor,"rule partial_name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2272:3: (pn1= partial_name (d= PERIOD pn2+= partial_name )* -> {d!=null}? ^( $d $pn1 ( $pn2)+ ) -> $pn1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2272:5: pn1= partial_name (d= PERIOD pn2+= partial_name )*
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_partial_name_in_name8002);
=======
			pushFollow(FOLLOW_partial_name_in_name8010);
>>>>>>> origin/continuum
			pn1=partial_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_partial_name.add(pn1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2272:22: (d= PERIOD pn2+= partial_name )*
			loop87:
			while (true) {
				int alt87=2;
				int LA87_0 = input.LA(1);
				if ( (LA87_0==PERIOD) ) {
					alt87=1;
				}

				switch (alt87) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2272:24: d= PERIOD pn2+= partial_name
					{
<<<<<<< HEAD
					d=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_name8008); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERIOD.add(d);

					pushFollow(FOLLOW_partial_name_in_name8012);
=======
					d=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_name8016); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERIOD.add(d);

					pushFollow(FOLLOW_partial_name_in_name8020);
>>>>>>> origin/continuum
					pn2=partial_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_partial_name.add(pn2.getTree());
					if (list_pn2==null) list_pn2=new ArrayList<Object>();
					list_pn2.add(pn2.getTree());
					}
					break;

				default :
					break loop87;
				}
			}

			// AST REWRITE
			// elements: pn1, pn2, pn1, d
			// token labels: d
			// rule labels: pn1, retval
			// token list labels: 
			// rule list labels: pn2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
			RewriteRuleSubtreeStream stream_pn1=new RewriteRuleSubtreeStream(adaptor,"rule pn1",pn1!=null?pn1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_pn2=new RewriteRuleSubtreeStream(adaptor,"token pn2",list_pn2);
			root_0 = (BAST)adaptor.nil();
			// 2274:5: -> {d!=null}? ^( $d $pn1 ( $pn2)+ )
			if (d!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2274:19: ^( $d $pn1 ( $pn2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_d.nextNode(), root_1);
				adaptor.addChild(root_1, stream_pn1.nextTree());
				if ( !(stream_pn2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_pn2.hasNext() ) {
					adaptor.addChild(root_1, stream_pn2.nextTree());
				}
				stream_pn2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2275:5: -> $pn1
			{
				adaptor.addChild(root_0, stream_pn1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.name,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name"


	public static class partial_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "partial_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2280:1: partial_name : identifier ( LBRACKET index+= expression_or_range RBRACKET )* -> {index!=null}? ^( identifier ( $index)+ ) -> identifier ;
	public final BLESStoASTParser.partial_name_return partial_name() throws RecognitionException {
		BLESStoASTParser.partial_name_return retval = new BLESStoASTParser.partial_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET179=null;
		Token RBRACKET180=null;
		List<Object> list_index=null;
		ParserRuleReturnScope identifier178 =null;
		RuleReturnScope index = null;
		BAST LBRACKET179_tree=null;
		BAST RBRACKET180_tree=null;
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_expression_or_range=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2281:3: ( identifier ( LBRACKET index+= expression_or_range RBRACKET )* -> {index!=null}? ^( identifier ( $index)+ ) -> identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2282:3: identifier ( LBRACKET index+= expression_or_range RBRACKET )*
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_partial_name8079);
=======
			pushFollow(FOLLOW_identifier_in_partial_name8087);
>>>>>>> origin/continuum
			identifier178=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(identifier178.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2283:3: ( LBRACKET index+= expression_or_range RBRACKET )*
			loop88:
			while (true) {
				int alt88=2;
				int LA88_0 = input.LA(1);
				if ( (LA88_0==LBRACKET) ) {
					alt88=1;
				}

				switch (alt88) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2283:5: LBRACKET index+= expression_or_range RBRACKET
					{
<<<<<<< HEAD
					LBRACKET179=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_partial_name8088); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET179);

					pushFollow(FOLLOW_expression_or_range_in_partial_name8092);
=======
					LBRACKET179=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_partial_name8096); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET179);

					pushFollow(FOLLOW_expression_or_range_in_partial_name8100);
>>>>>>> origin/continuum
					index=expression_or_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_range.add(index.getTree());
					if (list_index==null) list_index=new ArrayList<Object>();
					list_index.add(index.getTree());
<<<<<<< HEAD
					RBRACKET180=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_partial_name8094); if (state.failed) return retval; 
=======
					RBRACKET180=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_partial_name8102); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET180);

					}
					break;

				default :
					break loop88;
				}
			}

			// AST REWRITE
			// elements: identifier, index, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: index
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"token index",list_index);
			root_0 = (BAST)adaptor.nil();
			// 2284:3: -> {index!=null}? ^( identifier ( $index)+ )
			if (index!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2284:21: ^( identifier ( $index)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_identifier.nextNode(), root_1);
				if ( !(stream_index.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_index.hasNext() ) {
					adaptor.addChild(root_1, stream_index.nextTree());
				}
				stream_index.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2285:3: -> identifier
			{
				adaptor.addChild(root_0, stream_identifier.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "partial_name"


	public static class parameter_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2288:1: parameter_list : e1= expression_or_range (c= COMMA e2+= expression_or_range )* -> {c!=null}? ^( $c $e1 ( $e2)+ ) -> $e1;
	public final BLESStoASTParser.parameter_list_return parameter_list() throws RecognitionException {
		BLESStoASTParser.parameter_list_return retval = new BLESStoASTParser.parameter_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		List<Object> list_e2=null;
		ParserRuleReturnScope e1 =null;
		RuleReturnScope e2 = null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression_or_range=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2289:3: (e1= expression_or_range (c= COMMA e2+= expression_or_range )* -> {c!=null}? ^( $c $e1 ( $e2)+ ) -> $e1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2290:3: e1= expression_or_range (c= COMMA e2+= expression_or_range )*
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_expression_or_range_in_parameter_list8143);
=======
			pushFollow(FOLLOW_expression_or_range_in_parameter_list8151);
>>>>>>> origin/continuum
			e1=expression_or_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_range.add(e1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2291:3: (c= COMMA e2+= expression_or_range )*
			loop89:
			while (true) {
				int alt89=2;
				int LA89_0 = input.LA(1);
				if ( (LA89_0==COMMA) ) {
					alt89=1;
				}

				switch (alt89) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2291:5: c= COMMA e2+= expression_or_range
					{
<<<<<<< HEAD
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_parameter_list8152); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_expression_or_range_in_parameter_list8156);
=======
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_parameter_list8160); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_expression_or_range_in_parameter_list8164);
>>>>>>> origin/continuum
					e2=expression_or_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_range.add(e2.getTree());
					if (list_e2==null) list_e2=new ArrayList<Object>();
					list_e2.add(e2.getTree());
					}
					break;

				default :
					break loop89;
				}
			}

			// AST REWRITE
			// elements: e2, c, e1, e1
			// token labels: c
			// rule labels: e1, retval
			// token list labels: 
			// rule list labels: e2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"token e2",list_e2);
			root_0 = (BAST)adaptor.nil();
			// 2292:5: -> {c!=null}? ^( $c $e1 ( $e2)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2292:19: ^( $c $e1 ( $e2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_e1.nextTree());
				if ( !(stream_e2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_e2.hasNext() ) {
					adaptor.addChild(root_1, stream_e2.nextTree());
				}
				stream_e2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2293:5: -> $e1
			{
				adaptor.addChild(root_0, stream_e1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.parameterList,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameter_list"


	public static class expression_or_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2298:1: expression_or_range : expression ( range_symbol ^ expression )? ;
	public final BLESStoASTParser.expression_or_range_return expression_or_range() throws RecognitionException {
		BLESStoASTParser.expression_or_range_return retval = new BLESStoASTParser.expression_or_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope expression181 =null;
		ParserRuleReturnScope range_symbol182 =null;
		ParserRuleReturnScope expression183 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2299:3: ( expression ( range_symbol ^ expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2300:3: expression ( range_symbol ^ expression )?
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_expression_in_expression_or_range8218);
=======
			pushFollow(FOLLOW_expression_in_expression_or_range8226);
>>>>>>> origin/continuum
			expression181=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression181.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2300:14: ( range_symbol ^ expression )?
			int alt90=2;
			int LA90_0 = input.LA(1);
			if ( ((LA90_0 >= COMMACOMMA && LA90_0 <= COMMADOT)||(LA90_0 >= DOTCOMMA && LA90_0 <= DOTDOT)) ) {
				alt90=1;
			}
			switch (alt90) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2300:16: range_symbol ^ expression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_range_symbol_in_expression_or_range8222);
=======
					pushFollow(FOLLOW_range_symbol_in_expression_or_range8230);
>>>>>>> origin/continuum
					range_symbol182=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol182.getTree(), root_0);
<<<<<<< HEAD
					pushFollow(FOLLOW_expression_in_expression_or_range8225);
=======
					pushFollow(FOLLOW_expression_in_expression_or_range8233);
>>>>>>> origin/continuum
					expression183=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression183.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expressionOrRange,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_range"


	public static class variable_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variable_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2305:1: variable_name : name ;
	public final BLESStoASTParser.variable_name_return variable_name() throws RecognitionException {
		BLESStoASTParser.variable_name_return retval = new BLESStoASTParser.variable_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope name184 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2306:3: ( name )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2306:5: name
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_name_in_variable_name8252);
=======
			pushFollow(FOLLOW_name_in_variable_name8260);
>>>>>>> origin/continuum
			name184=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, name184.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variable_name"


	public static class expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2314:1: expression : a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.expression_return expression() throws RecognitionException {
		BLESStoASTParser.expression_return retval = new BLESStoASTParser.expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_cor=new RewriteRuleTokenStream(adaptor,"token LITERAL_cor");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleTokenStream stream_LITERAL_cand=new RewriteRuleTokenStream(adaptor,"token LITERAL_cand");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2316:3: (a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2317:3: a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |)
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_subexpression_in_expression8278);
=======
			pushFollow(FOLLOW_subexpression_in_expression8286);
>>>>>>> origin/continuum
			a1=subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2318:3: ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |)
			int alt96=13;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt96=1;
				}
				break;
			case TIMES:
				{
				alt96=2;
				}
				break;
			case MINUS:
				{
				alt96=3;
				}
				break;
			case DIVIDE:
				{
				alt96=4;
				}
				break;
			case LITERAL_mod:
				{
				alt96=5;
				}
				break;
			case LITERAL_rem:
				{
				alt96=6;
				}
				break;
			case EXP:
				{
				alt96=7;
				}
				break;
			case LITERAL_and:
				{
				alt96=8;
				}
				break;
			case LITERAL_or:
				{
				alt96=9;
				}
				break;
			case LITERAL_xor:
				{
				alt96=10;
				}
				break;
			case LITERAL_cand:
				{
				alt96=11;
				}
				break;
			case LITERAL_cor:
				{
				alt96=12;
				}
				break;
			case EOF:
			case AMPERSAND:
			case BOX:
			case COLON:
			case COMMA:
			case COMMACOMMA:
			case COMMADOT:
			case DOTCOMMA:
			case DOTDOT:
			case GUARD:
			case ID:
			case LASS:
			case LCURLY:
			case LITERAL_computation:
			case LITERAL_declare:
			case LITERAL_do:
			case LITERAL_else:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_fi:
			case LITERAL_for:
			case LITERAL_forall:
			case LITERAL_hr:
			case LITERAL_if:
			case LITERAL_invariant:
			case LITERAL_min:
			case LITERAL_ms:
			case LITERAL_ns:
			case LITERAL_pause:
			case LITERAL_ps:
			case LITERAL_sec:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_until:
			case LITERAL_us:
			case LITERAL_when:
			case LITERAL_while:
			case LPAREN:
			case RBRACKET:
			case RCON:
			case RCURLY:
			case RPAREN:
			case SEMICOLON:
				{
				alt96=13;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 96, 0, input);
				throw nvae;
			}
			switch (alt96) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:3: (o= PLUS a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:3: (o= PLUS a+= subexpression )+
					int cnt91=0;
					loop91:
					while (true) {
						int alt91=2;
						int LA91_0 = input.LA(1);
						if ( (LA91_0==PLUS) ) {
							alt91=1;
						}

						switch (alt91) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:5: o= PLUS a+= subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_expression8294); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8298);
=======
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_expression8302); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8306);
>>>>>>> origin/continuum
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt91 >= 1 ) break loop91;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(91, input);
							throw eee;
						}
						cnt91++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:3: (o= TIMES a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:3: (o= TIMES a+= subexpression )+
					int cnt92=0;
					loop92:
					while (true) {
						int alt92=2;
						int LA92_0 = input.LA(1);
						if ( (LA92_0==TIMES) ) {
							alt92=1;
						}

						switch (alt92) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:5: o= TIMES a+= subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_expression8314); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8318);
=======
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_expression8322); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8326);
>>>>>>> origin/continuum
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt92 >= 1 ) break loop92;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(92, input);
							throw eee;
						}
						cnt92++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2324:3: o= MINUS a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_expression8332); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8336);
=======
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_expression8340); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8344);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2326:3: o= DIVIDE a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_expression8347); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8351);
=======
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_expression8355); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8359);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2328:3: o= LITERAL_mod a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_expression8362); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8366);
=======
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_expression8370); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8374);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2330:3: o= LITERAL_rem a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_expression8377); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8381);
=======
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_expression8385); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8389);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2332:3: o= EXP a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,EXP,FOLLOW_EXP_in_expression8392); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8396);
=======
					o=(Token)match(input,EXP,FOLLOW_EXP_in_expression8400); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8404);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:3: (o= LITERAL_and a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:3: (o= LITERAL_and a+= subexpression )+
					int cnt93=0;
					loop93:
					while (true) {
						int alt93=2;
						int LA93_0 = input.LA(1);
						if ( (LA93_0==LITERAL_and) ) {
							alt93=1;
						}

						switch (alt93) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:5: o= LITERAL_and a+= subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_expression8409); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8413);
=======
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_expression8417); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8421);
>>>>>>> origin/continuum
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt93 >= 1 ) break loop93;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(93, input);
							throw eee;
						}
						cnt93++;
					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:3: (o= LITERAL_or a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:3: (o= LITERAL_or a+= subexpression )+
					int cnt94=0;
					loop94:
					while (true) {
						int alt94=2;
						int LA94_0 = input.LA(1);
						if ( (LA94_0==LITERAL_or) ) {
							alt94=1;
						}

						switch (alt94) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:5: o= LITERAL_or a+= subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_expression8429); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8433);
=======
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_expression8437); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8441);
>>>>>>> origin/continuum
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt94 >= 1 ) break loop94;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(94, input);
							throw eee;
						}
						cnt94++;
					}

					}
					break;
				case 10 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:3: (o= LITERAL_xor a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:3: (o= LITERAL_xor a+= subexpression )+
					int cnt95=0;
					loop95:
					while (true) {
						int alt95=2;
						int LA95_0 = input.LA(1);
						if ( (LA95_0==LITERAL_xor) ) {
							alt95=1;
						}

						switch (alt95) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:5: o= LITERAL_xor a+= subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_expression8449); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8453);
=======
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_expression8457); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8461);
>>>>>>> origin/continuum
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt95 >= 1 ) break loop95;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(95, input);
							throw eee;
						}
						cnt95++;
					}

					}
					break;
				case 11 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2340:3: o= LITERAL_cand a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_expression8467); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8471);
=======
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_expression8475); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8479);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 12 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2342:3: o= LITERAL_cor a+= subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_expression8482); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8486);
=======
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_expression8490); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8494);
>>>>>>> origin/continuum
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 13 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2344:3: 
					{
					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: a, a1, o, a1
=======
			// elements: a1, a1, a, o
>>>>>>> origin/continuum
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2346:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2346:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2348:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2353:1: subexpression : ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc);
	public final BLESStoASTParser.subexpression_return subexpression() throws RecognitionException {
		BLESStoASTParser.subexpression_return retval = new BLESStoASTParser.subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		Token n=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope tc =null;
		ParserRuleReturnScope fc =null;

		BAST m_tree=null;
		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_function_call=new RewriteRuleSubtreeStream(adaptor,"rule function_call");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_type_conversion=new RewriteRuleSubtreeStream(adaptor,"rule type_conversion");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2355:3: ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc)
			int alt99=3;
			alt99 = dfa99.predict(input);
			switch (alt99) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2356:3: (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2356:3: (m= MINUS |n= LITERAL_not )?
					int alt97=3;
					int LA97_0 = input.LA(1);
					if ( (LA97_0==MINUS) ) {
						alt97=1;
					}
					else if ( (LA97_0==LITERAL_not) ) {
						alt97=2;
					}
					switch (alt97) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2356:5: m= MINUS
							{
<<<<<<< HEAD
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_subexpression8558); if (state.failed) return retval; 
=======
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_subexpression8566); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_MINUS.add(m);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2356:15: n= LITERAL_not
							{
<<<<<<< HEAD
							n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subexpression8564); if (state.failed) return retval; 
=======
							n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subexpression8572); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

							}
							break;

					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2357:3: (v= value |ps= parenthesized_subexpression )
					int alt98=2;
					int LA98_0 = input.LA(1);
					if ( (LA98_0==AADL_STRING_LITERAL||LA98_0==ID||LA98_0==INTEGER_LIT||LA98_0==LBRACKET||LA98_0==LITERAL_false||LA98_0==LITERAL_in||LA98_0==LITERAL_now||LA98_0==LITERAL_null||LA98_0==LITERAL_self||LA98_0==LITERAL_timeout||LA98_0==LITERAL_tops||LA98_0==LITERAL_true||LA98_0==OCTOTHORPE||LA98_0==REAL_LIT) ) {
						alt98=1;
					}
					else if ( (LA98_0==LPAREN) ) {
						alt98=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 98, 0, input);
						throw nvae;
					}

					switch (alt98) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2357:5: v= value
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_value_in_subexpression8576);
=======
							pushFollow(FOLLOW_value_in_subexpression8584);
>>>>>>> origin/continuum
							v=value();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_value.add(v.getTree());
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2357:15: ps= parenthesized_subexpression
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression8582);
=======
							pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression8590);
>>>>>>> origin/continuum
							ps=parenthesized_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
							}
							break;

					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: ps, v, v, n, ps, v, n, ps
=======
					// elements: n, ps, v, v, n, v, ps, ps
>>>>>>> origin/continuum
					// token labels: n
					// rule labels: ps, v, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
					RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2358:5: -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v)
					if (m!=null&&v!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2358:28: ^( UNARY_MINUS[$m] $v)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_v.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2359:5: -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps)
					if (m!=null&&ps!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2359:29: ^( UNARY_MINUS[$m] $ps)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_ps.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2360:5: -> {n!=null&&v!=null}? ^( $n $v)
					if (n!=null&&v!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2360:28: ^( $n $v)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_v.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2361:5: -> {n!=null&&ps!=null}? ^( $n $ps)
					if (n!=null&&ps!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2361:29: ^( $n $ps)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ps.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2362:5: -> {v!=null}? $v
					if (v!=null) {
						adaptor.addChild(root_0, stream_v.nextTree());
					}

					else // 2363:5: -> $ps
					{
						adaptor.addChild(root_0, stream_ps.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2364:5: tc= type_conversion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_type_conversion_in_subexpression8682);
=======
					pushFollow(FOLLOW_type_conversion_in_subexpression8690);
>>>>>>> origin/continuum
					tc=type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_conversion.add(tc.getTree());
					// AST REWRITE
					// elements: tc
					// token labels: 
					// rule labels: retval, tc
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_tc=new RewriteRuleSubtreeStream(adaptor,"rule tc",tc!=null?tc.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2365:5: -> $tc
					{
						adaptor.addChild(root_0, stream_tc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2367:3: fc= function_call
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_function_call_in_subexpression8702);
=======
					pushFollow(FOLLOW_function_call_in_subexpression8710);
>>>>>>> origin/continuum
					fc=function_call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_function_call.add(fc.getTree());
					// AST REWRITE
					// elements: fc
					// token labels: 
					// rule labels: fc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_fc=new RewriteRuleSubtreeStream(adaptor,"rule fc",fc!=null?fc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2367:20: -> $fc
					{
						adaptor.addChild(root_0, stream_fc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subexpression"


	public static class type_conversion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2372:1: type_conversion : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression -> ^( $n $ps) ;
	public final BLESStoASTParser.type_conversion_return type_conversion() throws RecognitionException {
		BLESStoASTParser.type_conversion_return retval = new BLESStoASTParser.type_conversion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2373:2: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression -> ^( $n $ps) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2374:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2374:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt100=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt100=1;
				}
				break;
			case LITERAL_integer:
				{
				alt100=2;
				}
				break;
			case LITERAL_rational:
				{
				alt100=3;
				}
				break;
			case LITERAL_real:
				{
				alt100=4;
				}
				break;
			case LITERAL_complex:
				{
				alt100=5;
				}
				break;
			case LITERAL_time:
				{
				alt100=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 100, 0, input);
				throw nvae;
			}
			switch (alt100) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2374:4: n= LITERAL_natural
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_type_conversion8732); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_type_conversion8740); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2375:3: n= LITERAL_integer
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_type_conversion8741); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_type_conversion8749); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2376:3: n= LITERAL_rational
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_type_conversion8750); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_type_conversion8758); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2377:3: n= LITERAL_real
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_type_conversion8759); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_type_conversion8767); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2378:3: n= LITERAL_complex
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_type_conversion8768); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_type_conversion8776); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2379:3: n= LITERAL_time
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_type_conversion8776); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_type_conversion8784); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion8785);
=======
			pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion8793);
>>>>>>> origin/continuum
			ps=parenthesized_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
			// AST REWRITE
			// elements: ps, n
			// token labels: n
			// rule labels: ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2381:5: -> ^( $n $ps)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2381:8: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_conversion"


	public static class assertion_type_conversion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2385:1: assertion_type_conversion : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression -> ^( $n $ps) ;
	public final BLESStoASTParser.assertion_type_conversion_return assertion_type_conversion() throws RecognitionException {
		BLESStoASTParser.assertion_type_conversion_return retval = new BLESStoASTParser.assertion_type_conversion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_parenthesized_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2386:2: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression -> ^( $n $ps) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2387:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2387:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt101=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt101=1;
				}
				break;
			case LITERAL_integer:
				{
				alt101=2;
				}
				break;
			case LITERAL_rational:
				{
				alt101=3;
				}
				break;
			case LITERAL_real:
				{
				alt101=4;
				}
				break;
			case LITERAL_complex:
				{
				alt101=5;
				}
				break;
			case LITERAL_time:
				{
				alt101=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 101, 0, input);
				throw nvae;
			}
			switch (alt101) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2387:4: n= LITERAL_natural
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type_conversion8816); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type_conversion8824); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2388:3: n= LITERAL_integer
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type_conversion8825); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type_conversion8833); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2389:3: n= LITERAL_rational
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type_conversion8834); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type_conversion8842); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2390:3: n= LITERAL_real
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type_conversion8843); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type_conversion8851); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2391:3: n= LITERAL_complex
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type_conversion8852); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type_conversion8860); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2392:3: n= LITERAL_time
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type_conversion8860); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type_conversion8868); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8869);
=======
			pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8877);
>>>>>>> origin/continuum
			ps=parenthesized_assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parenthesized_assertion_expression.add(ps.getTree());
			// AST REWRITE
			// elements: ps, n
			// token labels: n
			// rule labels: ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2394:5: -> ^( $n $ps)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2394:8: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type_conversion"


	public static class boolean_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2398:1: boolean_expression : a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.boolean_expression_return boolean_expression() throws RecognitionException {
		BLESStoASTParser.boolean_expression_return retval = new BLESStoASTParser.boolean_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_cor=new RewriteRuleTokenStream(adaptor,"token LITERAL_cor");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleTokenStream stream_LITERAL_cand=new RewriteRuleTokenStream(adaptor,"token LITERAL_cand");
		RewriteRuleSubtreeStream stream_boolean_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2400:3: (a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2401:3: a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |)
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8904);
=======
			pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8912);
>>>>>>> origin/continuum
			a1=boolean_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_boolean_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2402:3: ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |)
			int alt105=6;
			switch ( input.LA(1) ) {
			case LITERAL_and:
				{
				alt105=1;
				}
				break;
			case LITERAL_or:
				{
				alt105=2;
				}
				break;
			case LITERAL_xor:
				{
				alt105=3;
				}
				break;
			case LITERAL_cand:
				{
				alt105=4;
				}
				break;
			case LITERAL_cor:
				{
				alt105=5;
				}
				break;
			case LITERAL_then:
			case QQ:
			case RPAREN:
				{
				alt105=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 105, 0, input);
				throw nvae;
			}
			switch (alt105) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:3: (o= LITERAL_and a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:3: (o= LITERAL_and a+= boolean_subexpression )+
					int cnt102=0;
					loop102:
					while (true) {
						int alt102=2;
						int LA102_0 = input.LA(1);
						if ( (LA102_0==LITERAL_and) ) {
							alt102=1;
						}

						switch (alt102) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:5: o= LITERAL_and a+= boolean_subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_boolean_expression8920); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8924);
=======
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_boolean_expression8928); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8932);
>>>>>>> origin/continuum
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt102 >= 1 ) break loop102;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(102, input);
							throw eee;
						}
						cnt102++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:3: (o= LITERAL_or a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:3: (o= LITERAL_or a+= boolean_subexpression )+
					int cnt103=0;
					loop103:
					while (true) {
						int alt103=2;
						int LA103_0 = input.LA(1);
						if ( (LA103_0==LITERAL_or) ) {
							alt103=1;
						}

						switch (alt103) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:5: o= LITERAL_or a+= boolean_subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_boolean_expression8940); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8944);
=======
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_boolean_expression8948); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8952);
>>>>>>> origin/continuum
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt103 >= 1 ) break loop103;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(103, input);
							throw eee;
						}
						cnt103++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:3: (o= LITERAL_xor a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:3: (o= LITERAL_xor a+= boolean_subexpression )+
					int cnt104=0;
					loop104:
					while (true) {
						int alt104=2;
						int LA104_0 = input.LA(1);
						if ( (LA104_0==LITERAL_xor) ) {
							alt104=1;
						}

						switch (alt104) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:5: o= LITERAL_xor a+= boolean_subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_boolean_expression8960); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8964);
=======
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_boolean_expression8968); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8972);
>>>>>>> origin/continuum
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt104 >= 1 ) break loop104;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(104, input);
							throw eee;
						}
						cnt104++;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2410:3: o= LITERAL_cand a+= boolean_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_boolean_expression8978); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8982);
=======
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_boolean_expression8986); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8990);
>>>>>>> origin/continuum
					a=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2412:3: o= LITERAL_cor a+= boolean_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_boolean_expression8993); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8997);
=======
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_boolean_expression9001); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression9005);
>>>>>>> origin/continuum
					a=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2414:3: 
					{
					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: a, a1, o, a1
=======
			// elements: a1, o, a1, a
>>>>>>> origin/continuum
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2416:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2416:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2418:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression"


	public static class boolean_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2423:1: boolean_subexpression : (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps;
	public final BLESStoASTParser.boolean_subexpression_return boolean_subexpression() throws RecognitionException {
		BLESStoASTParser.boolean_subexpression_return retval = new BLESStoASTParser.boolean_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2425:3: ( (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2426:3: (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2426:3: (n= LITERAL_not )?
			int alt106=2;
			int LA106_0 = input.LA(1);
			if ( (LA106_0==LITERAL_not) ) {
				alt106=1;
			}
			switch (alt106) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2426:5: n= LITERAL_not
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_boolean_subexpression9069); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_boolean_subexpression9077); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2427:3: (v= value |ps= parenthesized_subexpression )
			int alt107=2;
			int LA107_0 = input.LA(1);
			if ( (LA107_0==AADL_STRING_LITERAL||LA107_0==ID||LA107_0==INTEGER_LIT||LA107_0==LBRACKET||LA107_0==LITERAL_false||LA107_0==LITERAL_in||LA107_0==LITERAL_now||LA107_0==LITERAL_null||LA107_0==LITERAL_self||LA107_0==LITERAL_timeout||LA107_0==LITERAL_tops||LA107_0==LITERAL_true||LA107_0==OCTOTHORPE||LA107_0==REAL_LIT) ) {
				alt107=1;
			}
			else if ( (LA107_0==LPAREN) ) {
				alt107=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 107, 0, input);
				throw nvae;
			}

			switch (alt107) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2427:5: v= value
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_value_in_boolean_subexpression9081);
=======
					pushFollow(FOLLOW_value_in_boolean_subexpression9089);
>>>>>>> origin/continuum
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2427:15: ps= parenthesized_subexpression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_parenthesized_subexpression_in_boolean_subexpression9087);
=======
					pushFollow(FOLLOW_parenthesized_subexpression_in_boolean_subexpression9095);
>>>>>>> origin/continuum
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: n, ps, ps, v, n, v
=======
			// elements: v, n, v, ps, n, ps
>>>>>>> origin/continuum
			// token labels: n
			// rule labels: ps, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2428:5: -> {n!=null&&v!=null}? ^( $n $v)
			if (n!=null&&v!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2428:28: ^( $n $v)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_v.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2429:5: -> {n!=null&&ps!=null}? ^( $n $ps)
			if (n!=null&&ps!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2429:29: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2430:5: -> {v!=null}? $v
			if (v!=null) {
				adaptor.addChild(root_0, stream_v.nextTree());
			}

			else // 2431:5: -> $ps
			{
				adaptor.addChild(root_0, stream_ps.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_subexpression"


	public static class numeric_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2436:1: numeric_expression : a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.numeric_expression_return numeric_expression() throws RecognitionException {
		BLESStoASTParser.numeric_expression_return retval = new BLESStoASTParser.numeric_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_numeric_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule numeric_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2438:3: (a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2439:3: a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |)
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9172);
=======
			pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9180);
>>>>>>> origin/continuum
			a1=numeric_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2440:3: ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |)
			int alt110=8;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt110=1;
				}
				break;
			case TIMES:
				{
				alt110=2;
				}
				break;
			case MINUS:
				{
				alt110=3;
				}
				break;
			case DIVIDE:
				{
				alt110=4;
				}
				break;
			case LITERAL_mod:
				{
				alt110=5;
				}
				break;
			case LITERAL_rem:
				{
				alt110=6;
				}
				break;
			case EXP:
				{
				alt110=7;
				}
				break;
			case COMMACOMMA:
			case COMMADOT:
			case DOTCOMMA:
			case DOTDOT:
			case LCURLY:
			case LITERAL_declare:
				{
				alt110=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 110, 0, input);
				throw nvae;
			}
			switch (alt110) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:3: (o= PLUS a+= numeric_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:3: (o= PLUS a+= numeric_subexpression )+
					int cnt108=0;
					loop108:
					while (true) {
						int alt108=2;
						int LA108_0 = input.LA(1);
						if ( (LA108_0==PLUS) ) {
							alt108=1;
						}

						switch (alt108) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:5: o= PLUS a+= numeric_subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_numeric_expression9188); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9192);
=======
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_numeric_expression9196); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9200);
>>>>>>> origin/continuum
							a=numeric_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt108 >= 1 ) break loop108;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(108, input);
							throw eee;
						}
						cnt108++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:3: (o= TIMES a+= numeric_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:3: (o= TIMES a+= numeric_subexpression )+
					int cnt109=0;
					loop109:
					while (true) {
						int alt109=2;
						int LA109_0 = input.LA(1);
						if ( (LA109_0==TIMES) ) {
							alt109=1;
						}

						switch (alt109) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:5: o= TIMES a+= numeric_subexpression
							{
<<<<<<< HEAD
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_numeric_expression9208); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9212);
=======
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_numeric_expression9216); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9220);
>>>>>>> origin/continuum
							a=numeric_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt109 >= 1 ) break loop109;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(109, input);
							throw eee;
						}
						cnt109++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2446:3: o= MINUS a+= numeric_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_expression9226); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9230);
=======
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_expression9234); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9238);
>>>>>>> origin/continuum
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2448:3: o= DIVIDE a+= numeric_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_numeric_expression9241); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9245);
=======
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_numeric_expression9249); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9253);
>>>>>>> origin/continuum
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2450:3: o= LITERAL_mod a+= numeric_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_numeric_expression9256); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9260);
=======
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_numeric_expression9264); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9268);
>>>>>>> origin/continuum
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2452:3: o= LITERAL_rem a+= numeric_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_numeric_expression9271); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9275);
=======
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_numeric_expression9279); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9283);
>>>>>>> origin/continuum
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2454:3: o= EXP a+= numeric_subexpression
					{
<<<<<<< HEAD
					o=(Token)match(input,EXP,FOLLOW_EXP_in_numeric_expression9286); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9290);
=======
					o=(Token)match(input,EXP,FOLLOW_EXP_in_numeric_expression9294); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9298);
>>>>>>> origin/continuum
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2456:3: 
					{
					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: a1, o, a1, a
=======
			// elements: o, a, a1, a1
>>>>>>> origin/continuum
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2458:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2458:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2460:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			     tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_expression"


	public static class numeric_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2466:1: numeric_subexpression : (m= MINUS )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {v!=null}? $v -> $ps;
	public final BLESStoASTParser.numeric_subexpression_return numeric_subexpression() throws RecognitionException {
		BLESStoASTParser.numeric_subexpression_return retval = new BLESStoASTParser.numeric_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;

		BAST m_tree=null;
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2468:3: ( (m= MINUS )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {v!=null}? $v -> $ps)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2469:3: (m= MINUS )? (v= value |ps= parenthesized_subexpression )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2469:3: (m= MINUS )?
			int alt111=2;
			int LA111_0 = input.LA(1);
			if ( (LA111_0==MINUS) ) {
				alt111=1;
			}
			switch (alt111) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2469:5: m= MINUS
					{
<<<<<<< HEAD
					m=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_subexpression9362); if (state.failed) return retval; 
=======
					m=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_subexpression9370); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(m);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2470:3: (v= value |ps= parenthesized_subexpression )
			int alt112=2;
			int LA112_0 = input.LA(1);
			if ( (LA112_0==AADL_STRING_LITERAL||LA112_0==ID||LA112_0==INTEGER_LIT||LA112_0==LBRACKET||LA112_0==LITERAL_false||LA112_0==LITERAL_in||LA112_0==LITERAL_now||LA112_0==LITERAL_null||LA112_0==LITERAL_self||LA112_0==LITERAL_timeout||LA112_0==LITERAL_tops||LA112_0==LITERAL_true||LA112_0==OCTOTHORPE||LA112_0==REAL_LIT) ) {
				alt112=1;
			}
			else if ( (LA112_0==LPAREN) ) {
				alt112=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 112, 0, input);
				throw nvae;
			}

			switch (alt112) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2470:5: v= value
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_value_in_numeric_subexpression9374);
=======
					pushFollow(FOLLOW_value_in_numeric_subexpression9382);
>>>>>>> origin/continuum
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2470:15: ps= parenthesized_subexpression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_parenthesized_subexpression_in_numeric_subexpression9380);
=======
					pushFollow(FOLLOW_parenthesized_subexpression_in_numeric_subexpression9388);
>>>>>>> origin/continuum
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: ps, v, ps, v
			// token labels: 
			// rule labels: ps, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2471:5: -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v)
			if (m!=null&&v!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2471:28: ^( UNARY_MINUS[$m] $v)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
				adaptor.addChild(root_1, stream_v.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2472:5: -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps)
			if (m!=null&&ps!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2472:29: ^( UNARY_MINUS[$m] $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2473:5: -> {v!=null}? $v
			if (v!=null) {
				adaptor.addChild(root_0, stream_v.nextTree());
			}

			else // 2474:5: -> $ps
			{
				adaptor.addChild(root_0, stream_ps.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_subexpression"


	public static class parenthesized_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2480:1: parenthesized_subexpression : ( ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression -> $ce| ( LPAREN case_choice )=>ce= case_expression -> $ce|lp= LPAREN eor= expression_or_relation rp= RPAREN -> ^( $lp $eor $rp) );
	public final BLESStoASTParser.parenthesized_subexpression_return parenthesized_subexpression() throws RecognitionException {
		BLESStoASTParser.parenthesized_subexpression_return retval = new BLESStoASTParser.parenthesized_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope ce =null;
		ParserRuleReturnScope eor =null;

		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_conditional_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_expression");
		RewriteRuleSubtreeStream stream_case_expression=new RewriteRuleSubtreeStream(adaptor,"rule case_expression");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2482:3: ( ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression -> $ce| ( LPAREN case_choice )=>ce= case_expression -> $ce|lp= LPAREN eor= expression_or_relation rp= RPAREN -> ^( $lp $eor $rp) )
			int alt113=3;
			int LA113_0 = input.LA(1);
			if ( (LA113_0==LPAREN) ) {
				int LA113_1 = input.LA(2);
				if ( (synpred1_BLESStoAST()) ) {
					alt113=1;
				}
				else if ( (synpred2_BLESStoAST()) ) {
					alt113=2;
				}
				else if ( (true) ) {
					alt113=3;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 113, 0, input);
				throw nvae;
			}

			switch (alt113) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2483:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_conditional_expression_in_parenthesized_subexpression9482);
=======
					pushFollow(FOLLOW_conditional_expression_in_parenthesized_subexpression9490);
>>>>>>> origin/continuum
					ce=conditional_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_expression.add(ce.getTree());
					// AST REWRITE
					// elements: ce
					// token labels: 
					// rule labels: ce, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ce=new RewriteRuleSubtreeStream(adaptor,"rule ce",ce!=null?ce.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2485:5: -> $ce
					{
						adaptor.addChild(root_0, stream_ce.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2487:3: ( LPAREN case_choice )=>ce= case_expression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_case_expression_in_parenthesized_subexpression9512);
=======
					pushFollow(FOLLOW_case_expression_in_parenthesized_subexpression9520);
>>>>>>> origin/continuum
					ce=case_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_expression.add(ce.getTree());
					// AST REWRITE
					// elements: ce
					// token labels: 
					// rule labels: ce, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ce=new RewriteRuleSubtreeStream(adaptor,"rule ce",ce!=null?ce.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2489:5: -> $ce
					{
						adaptor.addChild(root_0, stream_ce.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2491:3: lp= LPAREN eor= expression_or_relation rp= RPAREN
					{
<<<<<<< HEAD
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_subexpression9531); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_expression_or_relation_in_parenthesized_subexpression9535);
=======
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_subexpression9539); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_expression_or_relation_in_parenthesized_subexpression9543);
>>>>>>> origin/continuum
					eor=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_relation.add(eor.getTree());
<<<<<<< HEAD
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_subexpression9539); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: lp, eor, rp
=======
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_subexpression9547); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: rp, eor, lp
>>>>>>> origin/continuum
					// token labels: lp, rp
					// rule labels: eor, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_eor=new RewriteRuleSubtreeStream(adaptor,"rule eor",eor!=null?eor.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2492:5: -> ^( $lp $eor $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2492:8: ^( $lp $eor $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_eor.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_subexpression"


	public static class case_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "case_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2495:1: case_expression : lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN -> ^( CASE_EXPRESSION ( $cc)+ ) ;
	public final BLESStoASTParser.case_expression_return case_expression() throws RecognitionException {
		BLESStoASTParser.case_expression_return retval = new BLESStoASTParser.case_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token c=null;
		Token COMMA185=null;
		Token RPAREN186=null;
		List<Object> list_cc=null;
		RuleReturnScope cc = null;
		BAST lp_tree=null;
		BAST c_tree=null;
		BAST COMMA185_tree=null;
		BAST RPAREN186_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_case_choice=new RewriteRuleSubtreeStream(adaptor,"rule case_choice");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2496:3: (lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN -> ^( CASE_EXPRESSION ( $cc)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2497:3: lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN
			{
<<<<<<< HEAD
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_expression9576); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			pushFollow(FOLLOW_case_choice_in_case_expression9580);
=======
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_expression9584); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			pushFollow(FOLLOW_case_choice_in_case_expression9588);
>>>>>>> origin/continuum
			cc=case_choice();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
			if (list_cc==null) list_cc=new ArrayList<Object>();
			list_cc.add(cc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2497:29: (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2497:31: c= COMMA cc+= case_choice ( COMMA cc+= case_choice )*
			{
<<<<<<< HEAD
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9586); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_case_choice_in_case_expression9590);
=======
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9594); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_case_choice_in_case_expression9598);
>>>>>>> origin/continuum
			cc=case_choice();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
			if (list_cc==null) list_cc=new ArrayList<Object>();
			list_cc.add(cc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2497:55: ( COMMA cc+= case_choice )*
			loop114:
			while (true) {
				int alt114=2;
				int LA114_0 = input.LA(1);
				if ( (LA114_0==COMMA) ) {
					alt114=1;
				}

				switch (alt114) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2497:57: COMMA cc+= case_choice
					{
<<<<<<< HEAD
					COMMA185=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9594); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA185);

					pushFollow(FOLLOW_case_choice_in_case_expression9598);
=======
					COMMA185=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9602); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA185);

					pushFollow(FOLLOW_case_choice_in_case_expression9606);
>>>>>>> origin/continuum
					cc=case_choice();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
					if (list_cc==null) list_cc=new ArrayList<Object>();
					list_cc.add(cc.getTree());
					}
					break;

				default :
					break loop114;
				}
			}

			}

<<<<<<< HEAD
			RPAREN186=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_expression9605); if (state.failed) return retval; 
=======
			RPAREN186=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_expression9613); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN186);

			// AST REWRITE
			// elements: cc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: cc
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_cc=new RewriteRuleSubtreeStream(adaptor,"token cc",list_cc);
			root_0 = (BAST)adaptor.nil();
			// 2498:5: -> ^( CASE_EXPRESSION ( $cc)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2498:8: ^( CASE_EXPRESSION ( $cc)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CASE_EXPRESSION, "CASE_EXPRESSION"), root_1);
				if ( !(stream_cc.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_cc.hasNext() ) {
					adaptor.addChild(root_1, stream_cc.nextTree());
				}
				stream_cc.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_expression"


	public static class case_choice_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "case_choice"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2502:1: case_choice : LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression ;
	public final BLESStoASTParser.case_choice_return case_choice() throws RecognitionException {
		BLESStoASTParser.case_choice_return retval = new BLESStoASTParser.case_choice_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN187=null;
		Token RPAREN188=null;
		Token IMP189=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope exp =null;

		BAST LPAREN187_tree=null;
		BAST RPAREN188_tree=null;
		BAST IMP189_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2503:3: ( LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2504:3: LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LPAREN187=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_choice9642); if (state.failed) return retval;
			pushFollow(FOLLOW_boolean_expression_or_relation_in_case_choice9647);
=======
			LPAREN187=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_choice9650); if (state.failed) return retval;
			pushFollow(FOLLOW_boolean_expression_or_relation_in_case_choice9655);
>>>>>>> origin/continuum
			be=boolean_expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, be.getTree());

<<<<<<< HEAD
			RPAREN188=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_choice9649); if (state.failed) return retval;
			IMP189=(Token)match(input,IMP,FOLLOW_IMP_in_case_choice9652); if (state.failed) return retval;
=======
			RPAREN188=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_choice9657); if (state.failed) return retval;
			IMP189=(Token)match(input,IMP,FOLLOW_IMP_in_case_choice9660); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			IMP189_tree = (BAST)adaptor.create(IMP189);
			root_0 = (BAST)adaptor.becomeRoot(IMP189_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_expression_in_case_choice9657);
=======
			pushFollow(FOLLOW_expression_in_case_choice9665);
>>>>>>> origin/continuum
			exp=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, exp.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_choice"


	public static class conditional_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2507:1: conditional_expression : ( LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN -> ^( CONDITIONAL[$then] $be $t $f) | LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN -> ^( CONDITIONAL[$q] $be $t $f) );
	public final BLESStoASTParser.conditional_expression_return conditional_expression() throws RecognitionException {
		BLESStoASTParser.conditional_expression_return retval = new BLESStoASTParser.conditional_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token then=null;
		Token q=null;
		Token LPAREN190=null;
		Token LITERAL_if191=null;
		Token LITERAL_else192=null;
		Token RPAREN193=null;
		Token LPAREN194=null;
		Token COLON195=null;
		Token RPAREN196=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope f =null;

		BAST then_tree=null;
		BAST q_tree=null;
		BAST LPAREN190_tree=null;
		BAST LITERAL_if191_tree=null;
		BAST LITERAL_else192_tree=null;
		BAST RPAREN193_tree=null;
		BAST LPAREN194_tree=null;
		BAST COLON195_tree=null;
		BAST RPAREN196_tree=null;
		RewriteRuleTokenStream stream_QQ=new RewriteRuleTokenStream(adaptor,"token QQ");
		RewriteRuleTokenStream stream_LITERAL_else=new RewriteRuleTokenStream(adaptor,"token LITERAL_else");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_then=new RewriteRuleTokenStream(adaptor,"token LITERAL_then");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_boolean_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2508:3: ( LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN -> ^( CONDITIONAL[$then] $be $t $f) | LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN -> ^( CONDITIONAL[$q] $be $t $f) )
			int alt115=2;
			int LA115_0 = input.LA(1);
			if ( (LA115_0==LPAREN) ) {
				int LA115_1 = input.LA(2);
				if ( (LA115_1==LITERAL_if) ) {
					alt115=1;
				}
				else if ( (LA115_1==AADL_STRING_LITERAL||LA115_1==ID||LA115_1==INTEGER_LIT||LA115_1==LBRACKET||LA115_1==LITERAL_complex||LA115_1==LITERAL_false||LA115_1==LITERAL_in||LA115_1==LITERAL_integer||LA115_1==LITERAL_natural||(LA115_1 >= LITERAL_not && LA115_1 <= LITERAL_now)||LA115_1==LITERAL_null||(LA115_1 >= LITERAL_rational && LA115_1 <= LITERAL_real)||LA115_1==LITERAL_self||(LA115_1 >= LITERAL_time && LA115_1 <= LITERAL_timeout)||LA115_1==LITERAL_tops||LA115_1==LITERAL_true||LA115_1==LPAREN||LA115_1==MINUS||LA115_1==OCTOTHORPE||LA115_1==REAL_LIT) ) {
					alt115=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 115, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 115, 0, input);
				throw nvae;
			}

			switch (alt115) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2509:3: LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN
					{
<<<<<<< HEAD
					LPAREN190=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9672); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN190);

					LITERAL_if191=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_expression9674); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if191);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9678);
=======
					LPAREN190=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9680); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN190);

					LITERAL_if191=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_expression9682); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if191);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9686);
>>>>>>> origin/continuum
					be=boolean_expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression_or_relation.add(be.getTree());
<<<<<<< HEAD
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_expression9682); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_expression_in_conditional_expression9687);
=======
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_expression9690); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_expression_in_conditional_expression9695);
>>>>>>> origin/continuum
					t=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(t.getTree());
<<<<<<< HEAD
					LITERAL_else192=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_expression9689); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else192);

					pushFollow(FOLLOW_expression_in_conditional_expression9694);
=======
					LITERAL_else192=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_expression9697); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else192);

					pushFollow(FOLLOW_expression_in_conditional_expression9702);
>>>>>>> origin/continuum
					f=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(f.getTree());
<<<<<<< HEAD
					RPAREN193=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9696); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN193);

					// AST REWRITE
					// elements: be, f, t
=======
					RPAREN193=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9704); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN193);

					// AST REWRITE
					// elements: be, t, f
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: be, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2510:5: -> ^( CONDITIONAL[$then] $be $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2510:8: ^( CONDITIONAL[$then] $be $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, then), root_1);
						adaptor.addChild(root_1, stream_be.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2512:3: LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN
					{
<<<<<<< HEAD
					LPAREN194=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9726); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN194);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9730);
=======
					LPAREN194=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9734); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN194);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9738);
>>>>>>> origin/continuum
					be=boolean_expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression_or_relation.add(be.getTree());
<<<<<<< HEAD
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_expression9734); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_expression_in_conditional_expression9739);
=======
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_expression9742); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_expression_in_conditional_expression9747);
>>>>>>> origin/continuum
					t=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(t.getTree());
<<<<<<< HEAD
					COLON195=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_expression9741); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON195);

					pushFollow(FOLLOW_expression_in_conditional_expression9746);
=======
					COLON195=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_expression9749); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON195);

					pushFollow(FOLLOW_expression_in_conditional_expression9754);
>>>>>>> origin/continuum
					f=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(f.getTree());
<<<<<<< HEAD
					RPAREN196=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9748); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN196);

					// AST REWRITE
					// elements: be, t, f
=======
					RPAREN196=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9756); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN196);

					// AST REWRITE
					// elements: t, f, be
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: be, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2513:5: -> ^( CONDITIONAL[$q] $be $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2513:8: ^( CONDITIONAL[$q] $be $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, q), root_1);
						adaptor.addChild(root_1, stream_be.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_expression"


	public static class value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2516:1: value : (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops);
	public final BLESStoASTParser.value_return value() throws RecognitionException {
		BLESStoASTParser.value_return retval = new BLESStoASTParser.value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token q=null;
		Token tf=null;
		Token f=null;
		Token tc=null;
		Token c=null;
		Token u=null;
		Token li=null;
		Token timeout=null;
		Token nu=null;
		Token now=null;
		Token tops=null;
		Token string_literal197=null;
		Token LPAREN198=null;
		Token RPAREN199=null;
		List<Object> list_i=null;
		ParserRuleReturnScope vc =null;
		ParserRuleReturnScope pn =null;
		ParserRuleReturnScope nam =null;
		RuleReturnScope i = null;
		BAST q_tree=null;
		BAST tf_tree=null;
		BAST f_tree=null;
		BAST tc_tree=null;
		BAST c_tree=null;
		BAST u_tree=null;
		BAST li_tree=null;
		BAST timeout_tree=null;
		BAST nu_tree=null;
		BAST now_tree=null;
		BAST tops_tree=null;
		BAST string_literal197_tree=null;
		BAST LPAREN198_tree=null;
		BAST RPAREN199_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mode=new RewriteRuleTokenStream(adaptor,"token LITERAL_mode");
		RewriteRuleTokenStream stream_LITERAL_null=new RewriteRuleTokenStream(adaptor,"token LITERAL_null");
		RewriteRuleTokenStream stream_LITERAL_count=new RewriteRuleTokenStream(adaptor,"token LITERAL_count");
		RewriteRuleTokenStream stream_LITERAL_now=new RewriteRuleTokenStream(adaptor,"token LITERAL_now");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_timeout=new RewriteRuleTokenStream(adaptor,"token LITERAL_timeout");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_TICK=new RewriteRuleTokenStream(adaptor,"token TICK");
		RewriteRuleTokenStream stream_LITERAL_fresh=new RewriteRuleTokenStream(adaptor,"token LITERAL_fresh");
		RewriteRuleTokenStream stream_LITERAL_updated=new RewriteRuleTokenStream(adaptor,"token LITERAL_updated");
		RewriteRuleTokenStream stream_LITERAL_tops=new RewriteRuleTokenStream(adaptor,"token LITERAL_tops");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_value_constant=new RewriteRuleSubtreeStream(adaptor,"rule value_constant");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2517:3: (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops)
			int alt118=8;
			alt118 = dfa118.predict(input);
			switch (alt118) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2518:3: vc= value_constant
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_value_constant_in_value9788);
=======
					pushFollow(FOLLOW_value_constant_in_value9796);
>>>>>>> origin/continuum
					vc=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value_constant.add(vc.getTree());
					// AST REWRITE
					// elements: vc
					// token labels: 
					// rule labels: vc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_vc=new RewriteRuleSubtreeStream(adaptor,"rule vc",vc!=null?vc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2518:21: -> $vc
					{
						adaptor.addChild(root_0, stream_vc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated )
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_port_name_in_value9840);
=======
					pushFollow(FOLLOW_port_name_in_value9848);
>>>>>>> origin/continuum
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_name.add(pn.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2523:16: (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated )
					int alt116=4;
					int LA116_0 = input.LA(1);
					if ( (LA116_0==QUESTION) ) {
						alt116=1;
					}
					else if ( (LA116_0==TICK) ) {
						switch ( input.LA(2) ) {
						case LITERAL_fresh:
							{
							alt116=2;
							}
							break;
						case LITERAL_count:
							{
							alt116=3;
							}
							break;
						case LITERAL_updated:
							{
							alt116=4;
							}
							break;
						default:
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 116, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 116, 0, input);
						throw nvae;
					}

					switch (alt116) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2523:18: q= QUESTION
							{
<<<<<<< HEAD
							q=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_value9846); if (state.failed) return retval; 
=======
							q=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_value9854); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_QUESTION.add(q);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2523:31: tf= TICK f= LITERAL_fresh
							{
<<<<<<< HEAD
							tf=(Token)match(input,TICK,FOLLOW_TICK_in_value9852); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tf);

							f=(Token)match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_value9856); if (state.failed) return retval; 
=======
							tf=(Token)match(input,TICK,FOLLOW_TICK_in_value9860); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tf);

							f=(Token)match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_value9864); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_LITERAL_fresh.add(f);

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2523:57: tc= TICK c= LITERAL_count
							{
<<<<<<< HEAD
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9862); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							c=(Token)match(input,LITERAL_count,FOLLOW_LITERAL_count_in_value9866); if (state.failed) return retval; 
=======
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9870); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							c=(Token)match(input,LITERAL_count,FOLLOW_LITERAL_count_in_value9874); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_LITERAL_count.add(c);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2523:84: tc= TICK u= LITERAL_updated
							{
<<<<<<< HEAD
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9873); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							u=(Token)match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_value9877); if (state.failed) return retval; 
=======
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9881); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							u=(Token)match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_value9885); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_LITERAL_updated.add(u);

							}
							break;

					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: pn, u, pn, tc, c, f, tc, q, pn, pn, tf
=======
					// elements: c, pn, tc, f, u, pn, tf, tc, pn, q, pn
>>>>>>> origin/continuum
					// token labels: q, tf, c, u, f, tc
					// rule labels: pn, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_q=new RewriteRuleTokenStream(adaptor,"token q",q);
					RewriteRuleTokenStream stream_tf=new RewriteRuleTokenStream(adaptor,"token tf",tf);
					RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
					RewriteRuleTokenStream stream_u=new RewriteRuleTokenStream(adaptor,"token u",u);
					RewriteRuleTokenStream stream_f=new RewriteRuleTokenStream(adaptor,"token f",f);
					RewriteRuleTokenStream stream_tc=new RewriteRuleTokenStream(adaptor,"token tc",tc);
					RewriteRuleSubtreeStream stream_pn=new RewriteRuleSubtreeStream(adaptor,"rule pn",pn!=null?pn.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2524:5: -> {$f!=null}? ^( $tf $pn $f)
					if (f!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:20: ^( $tf $pn $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tf.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_f.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2525:5: -> {$c!=null}? ^( $tc $pn $c)
					if (c!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:20: ^( $tc $pn $c)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_c.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2526:5: -> {$u!=null}? ^( $tc $pn $u)
					if (u!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2526:20: ^( $tc $pn $u)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_u.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2527:5: -> ^( $q $pn)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2527:8: ^( $q $pn)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_q.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2532:3: nam= name
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_name_in_value9972);
=======
					pushFollow(FOLLOW_name_in_value9980);
>>>>>>> origin/continuum
					nam=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(nam.getTree());
					// AST REWRITE
					// elements: nam
					// token labels: 
					// rule labels: nam, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_nam=new RewriteRuleSubtreeStream(adaptor,"rule nam",nam!=null?nam.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2532:12: -> $nam
					{
						adaptor.addChild(root_0, stream_nam.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2534:3: li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN
					{
<<<<<<< HEAD
					li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_value9987); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

					string_literal197=(Token)match(input,LITERAL_mode,FOLLOW_LITERAL_mode_in_value9989); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mode.add(string_literal197);

					LPAREN198=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_value9991); if (state.failed) return retval; 
=======
					li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_value9995); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

					string_literal197=(Token)match(input,LITERAL_mode,FOLLOW_LITERAL_mode_in_value9997); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mode.add(string_literal197);

					LPAREN198=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_value9999); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN198);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2534:41: (i+= identifier )+
					int cnt117=0;
					loop117:
					while (true) {
						int alt117=2;
						int LA117_0 = input.LA(1);
						if ( (LA117_0==ID) ) {
							alt117=1;
						}

						switch (alt117) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2534:41: i+= identifier
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_identifier_in_value9996);
=======
							pushFollow(FOLLOW_identifier_in_value10004);
>>>>>>> origin/continuum
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							if ( cnt117 >= 1 ) break loop117;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(117, input);
							throw eee;
						}
						cnt117++;
					}

<<<<<<< HEAD
					RPAREN199=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_value9999); if (state.failed) return retval; 
=======
					RPAREN199=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_value10007); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN199);

					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: i
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
					root_0 = (BAST)adaptor.nil();
					// 2535:5: -> ^( INMODE[$li,\"in mode\"] ( $i)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2535:8: ^( INMODE[$li,\"in mode\"] ( $i)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INMODE, li, "in mode"), root_1);
						if ( !(stream_i.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_i.hasNext() ) {
							adaptor.addChild(root_1, stream_i.nextTree());
						}
						stream_i.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2537:3: timeout= LITERAL_timeout
					{
<<<<<<< HEAD
					timeout=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_value10025); if (state.failed) return retval; 
=======
					timeout=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_value10033); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_timeout.add(timeout);

					// AST REWRITE
					// elements: timeout
					// token labels: timeout
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_timeout=new RewriteRuleTokenStream(adaptor,"token timeout",timeout);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2537:27: -> $timeout
					{
						adaptor.addChild(root_0, stream_timeout.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2539:3: nu= LITERAL_null
					{
<<<<<<< HEAD
					nu=(Token)match(input,LITERAL_null,FOLLOW_LITERAL_null_in_value10040); if (state.failed) return retval; 
=======
					nu=(Token)match(input,LITERAL_null,FOLLOW_LITERAL_null_in_value10048); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_null.add(nu);

					// AST REWRITE
					// elements: nu
					// token labels: nu
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_nu=new RewriteRuleTokenStream(adaptor,"token nu",nu);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2539:19: -> $nu
					{
						adaptor.addChild(root_0, stream_nu.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2541:3: now= LITERAL_now
					{
<<<<<<< HEAD
					now=(Token)match(input,LITERAL_now,FOLLOW_LITERAL_now_in_value10055); if (state.failed) return retval; 
=======
					now=(Token)match(input,LITERAL_now,FOLLOW_LITERAL_now_in_value10063); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_now.add(now);

					// AST REWRITE
					// elements: now
					// token labels: now
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_now=new RewriteRuleTokenStream(adaptor,"token now",now);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2541:19: -> $now
					{
						adaptor.addChild(root_0, stream_now.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2543:3: tops= LITERAL_tops
					{
<<<<<<< HEAD
					tops=(Token)match(input,LITERAL_tops,FOLLOW_LITERAL_tops_in_value10070); if (state.failed) return retval; 
=======
					tops=(Token)match(input,LITERAL_tops,FOLLOW_LITERAL_tops_in_value10078); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_tops.add(tops);

					// AST REWRITE
					// elements: tops
					// token labels: tops
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_tops=new RewriteRuleTokenStream(adaptor,"token tops",tops);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2543:21: -> $tops
					{
						adaptor.addChild(root_0, stream_tops.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.value,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value"


	public static class value_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "value_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2548:1: value_constant : ( LITERAL_true | LITERAL_false | numeric_constant | AADL_STRING_LITERAL | enumeration_value );
	public final BLESStoASTParser.value_constant_return value_constant() throws RecognitionException {
		BLESStoASTParser.value_constant_return retval = new BLESStoASTParser.value_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_true200=null;
		Token LITERAL_false201=null;
		Token AADL_STRING_LITERAL203=null;
		ParserRuleReturnScope numeric_constant202 =null;
		ParserRuleReturnScope enumeration_value204 =null;

		BAST LITERAL_true200_tree=null;
		BAST LITERAL_false201_tree=null;
		BAST AADL_STRING_LITERAL203_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2549:3: ( LITERAL_true | LITERAL_false | numeric_constant | AADL_STRING_LITERAL | enumeration_value )
			int alt119=5;
			switch ( input.LA(1) ) {
			case LITERAL_true:
				{
				alt119=1;
				}
				break;
			case LITERAL_false:
				{
				alt119=2;
				}
				break;
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_self:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt119=3;
				}
				break;
			case ID:
				{
				int LA119_4 = input.LA(2);
				if ( (LA119_4==DOUBLE_COLON||LA119_4==OCTOTHORPE||LA119_4==PERIOD) ) {
					alt119=3;
				}
				else if ( (LA119_4==TICK) ) {
					alt119=5;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 119, 4, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				alt119=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 119, 0, input);
				throw nvae;
			}
			switch (alt119) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2550:3: LITERAL_true
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_true200=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_value_constant10098); if (state.failed) return retval;
=======
					LITERAL_true200=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_value_constant10106); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_true200_tree = (BAST)adaptor.create(LITERAL_true200);
					adaptor.addChild(root_0, LITERAL_true200_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2550:18: LITERAL_false
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_false201=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_value_constant10102); if (state.failed) return retval;
=======
					LITERAL_false201=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_value_constant10110); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_false201_tree = (BAST)adaptor.create(LITERAL_false201);
					adaptor.addChild(root_0, LITERAL_false201_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2551:5: numeric_constant
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_numeric_constant_in_value_constant10108);
=======
					pushFollow(FOLLOW_numeric_constant_in_value_constant10116);
>>>>>>> origin/continuum
					numeric_constant202=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_constant202.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2552:5: AADL_STRING_LITERAL
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					AADL_STRING_LITERAL203=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_value_constant10114); if (state.failed) return retval;
=======
					AADL_STRING_LITERAL203=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_value_constant10122); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					AADL_STRING_LITERAL203_tree = (BAST)adaptor.create(AADL_STRING_LITERAL203);
					adaptor.addChild(root_0, AADL_STRING_LITERAL203_tree);
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2553:5: enumeration_value
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_enumeration_value_in_value_constant10120);
=======
					pushFollow(FOLLOW_enumeration_value_in_value_constant10128);
>>>>>>> origin/continuum
					enumeration_value204=enumeration_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_value204.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.value,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value_constant"


	public static class enumeration_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2559:1: enumeration_value : enum_type= identifier tick= TICK enum_value= identifier -> ^( $tick $enum_type $enum_value) ;
	public final BLESStoASTParser.enumeration_value_return enumeration_value() throws RecognitionException {
		BLESStoASTParser.enumeration_value_return retval = new BLESStoASTParser.enumeration_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token tick=null;
		ParserRuleReturnScope enum_type =null;
		ParserRuleReturnScope enum_value =null;

		BAST tick_tree=null;
		RewriteRuleTokenStream stream_TICK=new RewriteRuleTokenStream(adaptor,"token TICK");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2560:3: (enum_type= identifier tick= TICK enum_value= identifier -> ^( $tick $enum_type $enum_value) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2561:3: enum_type= identifier tick= TICK enum_value= identifier
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_enumeration_value10151);
=======
			pushFollow(FOLLOW_identifier_in_enumeration_value10159);
>>>>>>> origin/continuum
			enum_type=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(enum_type.getTree());
<<<<<<< HEAD
			tick=(Token)match(input,TICK,FOLLOW_TICK_in_enumeration_value10155); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TICK.add(tick);

			pushFollow(FOLLOW_identifier_in_enumeration_value10159);
=======
			tick=(Token)match(input,TICK,FOLLOW_TICK_in_enumeration_value10163); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TICK.add(tick);

			pushFollow(FOLLOW_identifier_in_enumeration_value10167);
>>>>>>> origin/continuum
			enum_value=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(enum_value.getTree());
			// AST REWRITE
<<<<<<< HEAD
			// elements: enum_type, tick, enum_value
=======
			// elements: tick, enum_type, enum_value
>>>>>>> origin/continuum
			// token labels: tick
			// rule labels: enum_type, enum_value, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_tick=new RewriteRuleTokenStream(adaptor,"token tick",tick);
			RewriteRuleSubtreeStream stream_enum_type=new RewriteRuleSubtreeStream(adaptor,"rule enum_type",enum_type!=null?enum_type.getTree():null);
			RewriteRuleSubtreeStream stream_enum_value=new RewriteRuleSubtreeStream(adaptor,"rule enum_value",enum_value!=null?enum_value.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2562:5: -> ^( $tick $enum_type $enum_value)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2562:8: ^( $tick $enum_type $enum_value)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_tick.nextNode(), root_1);
				adaptor.addChild(root_1, stream_enum_type.nextTree());
				adaptor.addChild(root_1, stream_enum_value.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_value"


	public static class property_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2565:1: property : ( property_constant | property_reference );
	public final BLESStoASTParser.property_return property() throws RecognitionException {
		BLESStoASTParser.property_return retval = new BLESStoASTParser.property_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope property_constant205 =null;
		ParserRuleReturnScope property_reference206 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2566:3: ( property_constant | property_reference )
			int alt120=2;
			int LA120_0 = input.LA(1);
			if ( (LA120_0==ID) ) {
				int LA120_1 = input.LA(2);
				if ( (LA120_1==DOUBLE_COLON) ) {
					int LA120_3 = input.LA(3);
					if ( (LA120_3==ID) ) {
						int LA120_4 = input.LA(4);
						if ( (LA120_4==EOF||(LA120_4 >= AL && LA120_4 <= ANNEX_END)||LA120_4==AT_SIGN||(LA120_4 >= BOX && LA120_4 <= CARET)||LA120_4==COLON||(LA120_4 >= COMMA && LA120_4 <= COMMADOT)||LA120_4==DIVIDE||(LA120_4 >= DOTCOMMA && LA120_4 <= DOTDOT)||LA120_4==EQ||LA120_4==EXP||(LA120_4 >= GT && LA120_4 <= GUARD)||(LA120_4 >= ID && LA120_4 <= IMP)||LA120_4==LASS||LA120_4==LCURLY||LA120_4==LITERAL_and||LA120_4==LITERAL_are||LA120_4==LITERAL_cand||LA120_4==LITERAL_computation||LA120_4==LITERAL_cor||LA120_4==LITERAL_declare||(LA120_4 >= LITERAL_do && LA120_4 <= LITERAL_else)||LA120_4==LITERAL_exception||(LA120_4 >= LITERAL_fetchadd && LA120_4 <= LITERAL_fi)||(LA120_4 >= LITERAL_for && LA120_4 <= LITERAL_forall)||(LA120_4 >= LITERAL_hr && LA120_4 <= LITERAL_iff)||(LA120_4 >= LITERAL_implies && LA120_4 <= LITERAL_in)||LA120_4==LITERAL_invariant||(LA120_4 >= LITERAL_min && LA120_4 <= LITERAL_mod)||LA120_4==LITERAL_ms||LA120_4==LITERAL_ns||LA120_4==LITERAL_of||LA120_4==LITERAL_or||LA120_4==LITERAL_pause||LA120_4==LITERAL_ps||LA120_4==LITERAL_rem||LA120_4==LITERAL_sec||LA120_4==LITERAL_setmode||LA120_4==LITERAL_skip||LA120_4==LITERAL_swap||(LA120_4 >= LITERAL_that && LA120_4 <= LITERAL_then)||LA120_4==LITERAL_until||LA120_4==LITERAL_us||(LA120_4 >= LITERAL_when && LA120_4 <= LITERAL_while)||(LA120_4 >= LITERAL_xor && LA120_4 <= LT)||LA120_4==MINUS||LA120_4==NEQ||LA120_4==PLUS||LA120_4==QQ||LA120_4==RASS||(LA120_4 >= RBRACKET && LA120_4 <= RCURLY)||LA120_4==RPAREN||LA120_4==SEMICOLON||LA120_4==TICK||LA120_4==TIMES) ) {
							alt120=1;
						}
						else if ( (LA120_4==DOUBLE_COLON||LA120_4==OCTOTHORPE||LA120_4==PERIOD) ) {
							alt120=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 120, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 120, 3, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}
				else if ( (LA120_1==OCTOTHORPE||LA120_1==PERIOD) ) {
					alt120=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 120, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA120_0==LITERAL_self||LA120_0==OCTOTHORPE) ) {
				alt120=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 120, 0, input);
				throw nvae;
			}

			switch (alt120) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2567:3: property_constant
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_property_constant_in_property10195);
=======
					pushFollow(FOLLOW_property_constant_in_property10203);
>>>>>>> origin/continuum
					property_constant205=property_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property_constant205.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2567:23: property_reference
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_property_reference_in_property10199);
=======
					pushFollow(FOLLOW_property_reference_in_property10207);
>>>>>>> origin/continuum
					property_reference206=property_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property_reference206.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property"


	public static class property_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2570:1: property_constant : ps= identifier dc= DOUBLE_COLON ^p= identifier ;
	public final BLESStoASTParser.property_constant_return property_constant() throws RecognitionException {
		BLESStoASTParser.property_constant_return retval = new BLESStoASTParser.property_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dc=null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope p =null;

		BAST dc_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2571:3: (ps= identifier dc= DOUBLE_COLON ^p= identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2572:3: ps= identifier dc= DOUBLE_COLON ^p= identifier
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_property_constant10217);
=======
			pushFollow(FOLLOW_identifier_in_property_constant10225);
>>>>>>> origin/continuum
			ps=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ps.getTree());

<<<<<<< HEAD
			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_constant10221); if (state.failed) return retval;
=======
			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_constant10229); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			dc_tree = (BAST)adaptor.create(dc);
			root_0 = (BAST)adaptor.becomeRoot(dc_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_property_constant10227);
=======
			pushFollow(FOLLOW_identifier_in_property_constant10235);
>>>>>>> origin/continuum
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, p.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_constant"


	public static class property_reference_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2575:1: property_reference : (oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $pname ( $field)* ) |self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $self $pname ( $field)* ) |component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $component $pname ( $field)* ) );
	public final BLESStoASTParser.property_reference_return property_reference() throws RecognitionException {
		BLESStoASTParser.property_reference_return retval = new BLESStoASTParser.property_reference_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token oc=null;
		Token self=null;
		List<Object> list_field=null;
		ParserRuleReturnScope pname =null;
		ParserRuleReturnScope component =null;
		RuleReturnScope field = null;
		BAST oc_tree=null;
		BAST self_tree=null;
		RewriteRuleTokenStream stream_LITERAL_self=new RewriteRuleTokenStream(adaptor,"token LITERAL_self");
		RewriteRuleTokenStream stream_OCTOTHORPE=new RewriteRuleTokenStream(adaptor,"token OCTOTHORPE");
		RewriteRuleSubtreeStream stream_unique_component_classifier_reference=new RewriteRuleSubtreeStream(adaptor,"rule unique_component_classifier_reference");
		RewriteRuleSubtreeStream stream_property_field=new RewriteRuleSubtreeStream(adaptor,"rule property_field");
		RewriteRuleSubtreeStream stream_property_name=new RewriteRuleSubtreeStream(adaptor,"rule property_name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2576:3: (oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $pname ( $field)* ) |self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $self $pname ( $field)* ) |component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $component $pname ( $field)* ) )
			int alt124=3;
			switch ( input.LA(1) ) {
			case OCTOTHORPE:
				{
				alt124=1;
				}
				break;
			case LITERAL_self:
				{
				alt124=2;
				}
				break;
			case ID:
				{
				alt124=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 124, 0, input);
				throw nvae;
			}
			switch (alt124) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2577:3: oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
<<<<<<< HEAD
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10244); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10248);
=======
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10252); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10256);
>>>>>>> origin/continuum
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2579:5: (field+= property_field )*
					loop121:
					while (true) {
						int alt121=2;
						int LA121_0 = input.LA(1);
						if ( (LA121_0==LBRACKET||LA121_0==PERIOD) ) {
							alt121=1;
						}

						switch (alt121) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2579:7: field+= property_field
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_property_field_in_property_reference10263);
=======
							pushFollow(FOLLOW_property_field_in_property_reference10271);
>>>>>>> origin/continuum
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop121;
						}
					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: oc, field, pname
=======
					// elements: field, oc, pname
>>>>>>> origin/continuum
					// token labels: oc
					// rule labels: pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2580:5: -> ^( $oc $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2580:8: ^( $oc $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2580:22: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2582:5: self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
<<<<<<< HEAD
					self=(Token)match(input,LITERAL_self,FOLLOW_LITERAL_self_in_property_reference10293); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_self.add(self);

					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10297); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10301);
=======
					self=(Token)match(input,LITERAL_self,FOLLOW_LITERAL_self_in_property_reference10301); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_self.add(self);

					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10305); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10309);
>>>>>>> origin/continuum
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2582:57: (field+= property_field )*
					loop122:
					while (true) {
						int alt122=2;
						int LA122_0 = input.LA(1);
						if ( (LA122_0==LBRACKET||LA122_0==PERIOD) ) {
							alt122=1;
						}

						switch (alt122) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2582:59: field+= property_field
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_property_field_in_property_reference10307);
=======
							pushFollow(FOLLOW_property_field_in_property_reference10315);
>>>>>>> origin/continuum
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop122;
						}
					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: self, pname, oc, field
=======
					// elements: field, oc, self, pname
>>>>>>> origin/continuum
					// token labels: oc, self
					// rule labels: pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleTokenStream stream_self=new RewriteRuleTokenStream(adaptor,"token self",self);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2583:5: -> ^( $oc $self $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2583:8: ^( $oc $self $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_self.nextNode());
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2583:28: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2586:5: component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_unique_component_classifier_reference_in_property_reference10341);
=======
					pushFollow(FOLLOW_unique_component_classifier_reference_in_property_reference10349);
>>>>>>> origin/continuum
					component=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unique_component_classifier_reference.add(component.getTree());
<<<<<<< HEAD
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10345); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10349);
=======
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10353); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10357);
>>>>>>> origin/continuum
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2587:5: (field+= property_field )*
					loop123:
					while (true) {
						int alt123=2;
						int LA123_0 = input.LA(1);
						if ( (LA123_0==LBRACKET||LA123_0==PERIOD) ) {
							alt123=1;
						}

						switch (alt123) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2587:7: field+= property_field
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_property_field_in_property_reference10359);
=======
							pushFollow(FOLLOW_property_field_in_property_reference10367);
>>>>>>> origin/continuum
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop123;
						}
					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: component, pname, oc, field
=======
					// elements: pname, component, field, oc
>>>>>>> origin/continuum
					// token labels: oc
					// rule labels: component, pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleSubtreeStream stream_component=new RewriteRuleSubtreeStream(adaptor,"rule component",component!=null?component.getTree():null);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2588:5: -> ^( $oc $component $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2588:8: ^( $oc $component $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_component.nextTree());
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2588:33: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_reference"


	public static class property_field_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2591:1: property_field : ( LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET | PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound ) );
	public final BLESStoASTParser.property_field_return property_field() throws RecognitionException {
		BLESStoASTParser.property_field_return retval = new BLESStoASTParser.property_field_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET207=null;
		Token set208=null;
		Token RBRACKET209=null;
		Token PERIOD210=null;
		Token set211=null;

		BAST LBRACKET207_tree=null;
		BAST set208_tree=null;
		BAST RBRACKET209_tree=null;
		BAST PERIOD210_tree=null;
		BAST set211_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2592:3: ( LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET | PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound ) )
			int alt125=2;
			int LA125_0 = input.LA(1);
			if ( (LA125_0==LBRACKET) ) {
				alt125=1;
			}
			else if ( (LA125_0==PERIOD) ) {
				alt125=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 125, 0, input);
				throw nvae;
			}

			switch (alt125) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2593:3: LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LBRACKET207=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_property_field10399); if (state.failed) return retval;
=======
					LBRACKET207=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_property_field10407); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LBRACKET207_tree = (BAST)adaptor.create(LBRACKET207);
					root_0 = (BAST)adaptor.becomeRoot(LBRACKET207_tree, root_0);
					}

					set208=input.LT(1);
					if ( input.LA(1)==ID||input.LA(1)==INTEGER_LIT ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set208));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
<<<<<<< HEAD
					RBRACKET209=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_property_field10410); if (state.failed) return retval;
=======
					RBRACKET209=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_property_field10418); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					RBRACKET209_tree = (BAST)adaptor.create(RBRACKET209);
					adaptor.addChild(root_0, RBRACKET209_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2595:3: PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound )
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					PERIOD210=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_property_field10418); if (state.failed) return retval;
=======
					PERIOD210=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_property_field10426); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					PERIOD210_tree = (BAST)adaptor.create(PERIOD210);
					root_0 = (BAST)adaptor.becomeRoot(PERIOD210_tree, root_0);
					}

					set211=input.LT(1);
					if ( input.LA(1)==ID||input.LA(1)==LITERAL_lower_bound||input.LA(1)==LITERAL_upper_bound ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set211));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_field"


	public static class property_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2598:1: property_name : ps= identifier dc= DOUBLE_COLON p= identifier -> ^( $dc $ps $p) ;
	public final BLESStoASTParser.property_name_return property_name() throws RecognitionException {
		BLESStoASTParser.property_name_return retval = new BLESStoASTParser.property_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dc=null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope p =null;

		BAST dc_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2599:3: (ps= identifier dc= DOUBLE_COLON p= identifier -> ^( $dc $ps $p) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2600:3: ps= identifier dc= DOUBLE_COLON p= identifier
			{
<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_property_name10447);
=======
			pushFollow(FOLLOW_identifier_in_property_name10455);
>>>>>>> origin/continuum
			ps=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(ps.getTree());
<<<<<<< HEAD
			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_name10451); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(dc);

			pushFollow(FOLLOW_identifier_in_property_name10456);
=======
			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_name10459); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(dc);

			pushFollow(FOLLOW_identifier_in_property_name10464);
>>>>>>> origin/continuum
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
			// AST REWRITE
<<<<<<< HEAD
			// elements: p, ps, dc
=======
			// elements: dc, ps, p
>>>>>>> origin/continuum
			// token labels: dc
			// rule labels: p, ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dc=new RewriteRuleTokenStream(adaptor,"token dc",dc);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2601:5: -> ^( $dc $ps $p)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2601:8: ^( $dc $ps $p)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dc.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_1, stream_p.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_name"


	public static class numeric_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2605:1: numeric_constant : ( INTEGER_LIT | REAL_LIT | rational_literal | complex_literal | property );
	public final BLESStoASTParser.numeric_constant_return numeric_constant() throws RecognitionException {
		BLESStoASTParser.numeric_constant_return retval = new BLESStoASTParser.numeric_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token INTEGER_LIT212=null;
		Token REAL_LIT213=null;
		ParserRuleReturnScope rational_literal214 =null;
		ParserRuleReturnScope complex_literal215 =null;
		ParserRuleReturnScope property216 =null;

		BAST INTEGER_LIT212_tree=null;
		BAST REAL_LIT213_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2606:3: ( INTEGER_LIT | REAL_LIT | rational_literal | complex_literal | property )
			int alt126=5;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt126=1;
				}
				break;
			case REAL_LIT:
				{
				alt126=2;
				}
				break;
			case LBRACKET:
				{
				switch ( input.LA(2) ) {
				case MINUS:
					{
					int LA126_5 = input.LA(3);
					if ( (LA126_5==INTEGER_LIT) ) {
						alt126=3;
					}
					else if ( (LA126_5==REAL_LIT) ) {
						alt126=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 126, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

					}
					break;
				case INTEGER_LIT:
					{
					alt126=3;
					}
					break;
				case REAL_LIT:
					{
					alt126=4;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 126, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
				}
				break;
			case ID:
			case LITERAL_self:
			case OCTOTHORPE:
				{
				alt126=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 126, 0, input);
				throw nvae;
			}
			switch (alt126) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2607:3: INTEGER_LIT
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					INTEGER_LIT212=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_numeric_constant10494); if (state.failed) return retval;
=======
					INTEGER_LIT212=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_numeric_constant10502); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					INTEGER_LIT212_tree = (BAST)adaptor.create(INTEGER_LIT212);
					adaptor.addChild(root_0, INTEGER_LIT212_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2608:5: REAL_LIT
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					REAL_LIT213=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_numeric_constant10501); if (state.failed) return retval;
=======
					REAL_LIT213=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_numeric_constant10509); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					REAL_LIT213_tree = (BAST)adaptor.create(REAL_LIT213);
					adaptor.addChild(root_0, REAL_LIT213_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2610:3: rational_literal
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_rational_literal_in_numeric_constant10510);
=======
					pushFollow(FOLLOW_rational_literal_in_numeric_constant10518);
>>>>>>> origin/continuum
					rational_literal214=rational_literal();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rational_literal214.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2610:22: complex_literal
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_complex_literal_in_numeric_constant10514);
=======
					pushFollow(FOLLOW_complex_literal_in_numeric_constant10522);
>>>>>>> origin/continuum
					complex_literal215=complex_literal();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, complex_literal215.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2611:5: property
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_property_in_numeric_constant10520);
=======
					pushFollow(FOLLOW_property_in_numeric_constant10528);
>>>>>>> origin/continuum
					property216=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property216.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_constant"


	public static class expression_or_relation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2614:1: expression_or_relation : ( ( LPAREN ID ARROW )=>rt= record_term -> $rt| ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= expression -> $e);
	public final BLESStoASTParser.expression_or_relation_return expression_or_relation() throws RecognitionException {
		BLESStoASTParser.expression_or_relation_return retval = new BLESStoASTParser.expression_or_relation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_record_term=new RewriteRuleSubtreeStream(adaptor,"rule record_term");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2616:3: ( ( LPAREN ID ARROW )=>rt= record_term -> $rt| ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= expression -> $e)
			int alt127=3;
			switch ( input.LA(1) ) {
			case LPAREN:
				{
				int LA127_1 = input.LA(2);
				if ( (synpred4_BLESStoAST()) ) {
					alt127=1;
				}
				else if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case MINUS:
				{
				int LA127_2 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_not:
				{
				int LA127_3 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_true:
				{
				int LA127_4 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_false:
				{
				int LA127_5 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case INTEGER_LIT:
				{
				int LA127_6 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case REAL_LIT:
				{
				int LA127_7 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LBRACKET:
				{
				int LA127_8 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case ID:
				{
				int LA127_9 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case OCTOTHORPE:
				{
				int LA127_10 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_self:
				{
				int LA127_11 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				int LA127_12 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_in:
				{
				int LA127_13 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_timeout:
				{
				int LA127_14 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_null:
				{
				int LA127_15 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_now:
				{
				int LA127_16 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_tops:
				{
				int LA127_17 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_natural:
				{
				int LA127_18 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA127_19 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA127_20 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_real:
				{
				int LA127_21 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA127_22 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_time:
				{
				int LA127_23 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 127, 0, input);
				throw nvae;
			}
			switch (alt127) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2617:3: ( LPAREN ID ARROW )=>rt= record_term
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_record_term_in_expression_or_relation10552);
=======
					pushFollow(FOLLOW_record_term_in_expression_or_relation10560);
>>>>>>> origin/continuum
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_term.add(rt.getTree());
					// AST REWRITE
					// elements: rt
					// token labels: 
					// rule labels: rt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rt=new RewriteRuleSubtreeStream(adaptor,"rule rt",rt!=null?rt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2619:5: -> $rt
					{
						adaptor.addChild(root_0, stream_rt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2621:3: ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10582);
=======
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10590);
>>>>>>> origin/continuum
					e1=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e1.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_relation_symbol_in_expression_or_relation10591);
=======
					pushFollow(FOLLOW_relation_symbol_in_expression_or_relation10599);
>>>>>>> origin/continuum
					rs=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(rs.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10595);
=======
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10603);
>>>>>>> origin/continuum
					e2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e2.getTree());
					// AST REWRITE
					// elements: e1, e2, rs
					// token labels: 
					// rule labels: rs, e1, e2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
					RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2624:5: -> ^( $rs $e1 $e2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2624:8: ^( $rs $e1 $e2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_e1.nextTree());
						adaptor.addChild(root_1, stream_e2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2626:3: e= expression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_expression_in_expression_or_relation10623);
=======
					pushFollow(FOLLOW_expression_in_expression_or_relation10631);
>>>>>>> origin/continuum
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2627:3: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expressionOrRelation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_relation"


	public static class boolean_expression_or_relation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2633:1: boolean_expression_or_relation : ( ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= boolean_expression -> $e);
	public final BLESStoASTParser.boolean_expression_or_relation_return boolean_expression_or_relation() throws RecognitionException {
		BLESStoASTParser.boolean_expression_or_relation_return retval = new BLESStoASTParser.boolean_expression_or_relation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_boolean_expression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2635:3: ( ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= boolean_expression -> $e)
			int alt128=2;
			int LA128_0 = input.LA(1);
			if ( (LA128_0==MINUS) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_not) ) {
				int LA128_2 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_true) ) {
				int LA128_3 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_false) ) {
				int LA128_4 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==INTEGER_LIT) ) {
				int LA128_5 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==REAL_LIT) ) {
				int LA128_6 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LBRACKET) ) {
				int LA128_7 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==ID) ) {
				int LA128_8 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==OCTOTHORPE) ) {
				int LA128_9 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_self) ) {
				int LA128_10 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==AADL_STRING_LITERAL) ) {
				int LA128_11 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_in) ) {
				int LA128_12 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_timeout) ) {
				int LA128_13 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_null) ) {
				int LA128_14 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_now) ) {
				int LA128_15 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_tops) ) {
				int LA128_16 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LPAREN) ) {
				int LA128_17 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_natural) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_integer) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_rational) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_real) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_complex) && (synpred6_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_time) && (synpred6_BLESStoAST())) {
				alt128=1;
			}

			switch (alt128) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2636:3: ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10672);
=======
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10680);
>>>>>>> origin/continuum
					e1=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e1.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_relation_symbol_in_boolean_expression_or_relation10682);
=======
					pushFollow(FOLLOW_relation_symbol_in_boolean_expression_or_relation10690);
>>>>>>> origin/continuum
					rs=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(rs.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10686);
=======
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10694);
>>>>>>> origin/continuum
					e2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e2.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: e1, rs, e2
=======
					// elements: e1, e2, rs
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: rs, e1, e2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
					RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2641:3: -> ^( $rs $e1 $e2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2641:6: ^( $rs $e1 $e2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_e1.nextTree());
						adaptor.addChild(root_1, stream_e2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2643:3: e= boolean_expression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_boolean_expression_in_boolean_expression_or_relation10713);
=======
					pushFollow(FOLLOW_boolean_expression_in_boolean_expression_or_relation10721);
>>>>>>> origin/continuum
					e=boolean_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2644:3: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			      tellBNF(GrammarStrings.expressionOrRelation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression_or_relation"


	public static class function_call_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "function_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2651:1: function_call : (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? ) ;
	public final BLESStoASTParser.function_call_return function_call() throws RecognitionException {
		BLESStoASTParser.function_call_return retval = new BLESStoASTParser.function_call_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token DOUBLE_COLON217=null;
		Token RPAREN218=null;
		List<Object> list_p=null;
		ParserRuleReturnScope id =null;
		ParserRuleReturnScope fp =null;
		RuleReturnScope p = null;
		BAST lp_tree=null;
		BAST DOUBLE_COLON217_tree=null;
		BAST RPAREN218_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_function_parameters=new RewriteRuleSubtreeStream(adaptor,"rule function_parameters");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2653:3: ( (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:3: (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:3: (p+= identifier DOUBLE_COLON )+
			int cnt129=0;
			loop129:
			while (true) {
				int alt129=2;
				int LA129_0 = input.LA(1);
				if ( (LA129_0==ID) ) {
					int LA129_1 = input.LA(2);
					if ( (LA129_1==DOUBLE_COLON) ) {
						alt129=1;
					}

				}

				switch (alt129) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:17: p+= identifier DOUBLE_COLON
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_function_call10762);
=======
					pushFollow(FOLLOW_identifier_in_function_call10770);
>>>>>>> origin/continuum
					p=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
					if (list_p==null) list_p=new ArrayList<Object>();
					list_p.add(p.getTree());
<<<<<<< HEAD
					DOUBLE_COLON217=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_function_call10764); if (state.failed) return retval; 
=======
					DOUBLE_COLON217=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_function_call10772); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON217);

					}
					break;

				default :
					if ( cnt129 >= 1 ) break loop129;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(129, input);
					throw eee;
				}
				cnt129++;
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_function_call10774);
=======
			pushFollow(FOLLOW_identifier_in_function_call10782);
>>>>>>> origin/continuum
			id=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
<<<<<<< HEAD
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_function_call10778); if (state.failed) return retval; 
=======
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_function_call10786); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2655:42: (fp= function_parameters )?
			int alt130=2;
			int LA130_0 = input.LA(1);
			if ( (LA130_0==ID) ) {
				alt130=1;
			}
			switch (alt130) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2655:42: fp= function_parameters
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_function_parameters_in_function_call10782);
=======
					pushFollow(FOLLOW_function_parameters_in_function_call10790);
>>>>>>> origin/continuum
					fp=function_parameters();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_function_parameters.add(fp.getTree());
					}
					break;

			}

<<<<<<< HEAD
			RPAREN218=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_function_call10785); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN218);

			// AST REWRITE
			// elements: id, DOUBLE_COLON, p, fp
=======
			RPAREN218=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_function_call10793); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN218);

			// AST REWRITE
			// elements: fp, DOUBLE_COLON, id, p
>>>>>>> origin/continuum
			// token labels: 
			// rule labels: fp, id, retval
			// token list labels: 
			// rule list labels: p
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_fp=new RewriteRuleSubtreeStream(adaptor,"rule fp",fp!=null?fp.getTree():null);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"token p",list_p);
			root_0 = (BAST)adaptor.nil();
			// 2656:3: -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2656:6: ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(FUNCTION_CALL, lp, "FUNCTION_CALL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2656:43: ^( DOUBLE_COLON ( $p)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_2);
				if ( !(stream_p.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_p.hasNext() ) {
					adaptor.addChild(root_2, stream_p.nextTree());
				}
				stream_p.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_id.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2656:68: ( $fp)?
				if ( stream_fp.hasNext() ) {
					adaptor.addChild(root_1, stream_fp.nextTree());
				}
				stream_fp.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(id!=null?((BAST)id.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.functionCall,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_call"


	public static class function_parameters_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "function_parameters"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2665:1: function_parameters :param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )? ;
	public final BLESStoASTParser.function_parameters_return function_parameters() throws RecognitionException {
		BLESStoASTParser.function_parameters_return retval = new BLESStoASTParser.function_parameters_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA219=null;
		Token COMMA220=null;
		List<Object> list_param=null;
		RuleReturnScope param = null;
		BAST COMMA219_tree=null;
		BAST COMMA220_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2666:3: (param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2667:3: param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )?
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10844);
=======
			pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10852);
>>>>>>> origin/continuum
			param=formal_expression_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

			if (list_param==null) list_param=new ArrayList<Object>();
			list_param.add(param.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2667:33: ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )?
			int alt132=2;
			int LA132_0 = input.LA(1);
			if ( (LA132_0==COMMA) ) {
				alt132=1;
			}
			switch (alt132) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2667:35: COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )*
					{
<<<<<<< HEAD
					COMMA219=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10848); if (state.failed) return retval;
=======
					COMMA219=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10856); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					COMMA219_tree = (BAST)adaptor.create(COMMA219);
					root_0 = (BAST)adaptor.becomeRoot(COMMA219_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10854);
=======
					pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10862);
>>>>>>> origin/continuum
					param=formal_expression_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

					if (list_param==null) list_param=new ArrayList<Object>();
					list_param.add(param.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2668:5: ( COMMA param+= formal_expression_pair )*
					loop131:
					while (true) {
						int alt131=2;
						int LA131_0 = input.LA(1);
						if ( (LA131_0==COMMA) ) {
							alt131=1;
						}

						switch (alt131) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2668:7: COMMA param+= formal_expression_pair
							{
<<<<<<< HEAD
							COMMA220=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10864); if (state.failed) return retval;
=======
							COMMA220=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10872); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							COMMA220_tree = (BAST)adaptor.create(COMMA220);
							adaptor.addChild(root_0, COMMA220_tree);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10869);
=======
							pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10877);
>>>>>>> origin/continuum
							param=formal_expression_pair();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

							if (list_param==null) list_param=new ArrayList<Object>();
							list_param.add(param.getTree());
							}
							break;

						default :
							break loop131;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_parameters"


	public static class formal_expression_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_expression_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2671:1: formal_expression_pair : formal= ID COLON ^actual= expression ;
	public final BLESStoASTParser.formal_expression_pair_return formal_expression_pair() throws RecognitionException {
		BLESStoASTParser.formal_expression_pair_return retval = new BLESStoASTParser.formal_expression_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token formal=null;
		Token COLON221=null;
		ParserRuleReturnScope actual =null;

		BAST formal_tree=null;
		BAST COLON221_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2672:3: (formal= ID COLON ^actual= expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2673:3: formal= ID COLON ^actual= expression
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			formal=(Token)match(input,ID,FOLLOW_ID_in_formal_expression_pair10891); if (state.failed) return retval;
=======
			formal=(Token)match(input,ID,FOLLOW_ID_in_formal_expression_pair10899); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			formal_tree = (BAST)adaptor.create(formal);
			adaptor.addChild(root_0, formal_tree);
			}

<<<<<<< HEAD
			COLON221=(Token)match(input,COLON,FOLLOW_COLON_in_formal_expression_pair10893); if (state.failed) return retval;
=======
			COLON221=(Token)match(input,COLON,FOLLOW_COLON_in_formal_expression_pair10901); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			COLON221_tree = (BAST)adaptor.create(COLON221);
			root_0 = (BAST)adaptor.becomeRoot(COLON221_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_expression_in_formal_expression_pair10898);
=======
			pushFollow(FOLLOW_expression_in_formal_expression_pair10906);
>>>>>>> origin/continuum
			actual=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, actual.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_expression_pair"


	public static class type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2678:1: type : (tn= type_name -> $tn|et= enumeration_type -> $et|nt= number_type -> $nt|at= array_type -> $at|rt= record_type -> $rt|vt= variant_type -> $vt|b= LITERAL_boolean -> $b|s= LITERAL_string -> $s);
	public final BLESStoASTParser.type_return type() throws RecognitionException {
		BLESStoASTParser.type_return retval = new BLESStoASTParser.type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token b=null;
		Token s=null;
		ParserRuleReturnScope tn =null;
		ParserRuleReturnScope et =null;
		ParserRuleReturnScope nt =null;
		ParserRuleReturnScope at =null;
		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope vt =null;

		BAST b_tree=null;
		BAST s_tree=null;
		RewriteRuleTokenStream stream_LITERAL_string=new RewriteRuleTokenStream(adaptor,"token LITERAL_string");
		RewriteRuleTokenStream stream_LITERAL_boolean=new RewriteRuleTokenStream(adaptor,"token LITERAL_boolean");
		RewriteRuleSubtreeStream stream_type_name=new RewriteRuleSubtreeStream(adaptor,"rule type_name");
		RewriteRuleSubtreeStream stream_enumeration_type=new RewriteRuleSubtreeStream(adaptor,"rule enumeration_type");
		RewriteRuleSubtreeStream stream_variant_type=new RewriteRuleSubtreeStream(adaptor,"rule variant_type");
		RewriteRuleSubtreeStream stream_number_type=new RewriteRuleSubtreeStream(adaptor,"rule number_type");
		RewriteRuleSubtreeStream stream_array_type=new RewriteRuleSubtreeStream(adaptor,"rule array_type");
		RewriteRuleSubtreeStream stream_record_type=new RewriteRuleSubtreeStream(adaptor,"rule record_type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2679:3: (tn= type_name -> $tn|et= enumeration_type -> $et|nt= number_type -> $nt|at= array_type -> $at|rt= record_type -> $rt|vt= variant_type -> $vt|b= LITERAL_boolean -> $b|s= LITERAL_string -> $s)
			int alt133=8;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt133=1;
				}
				break;
			case LITERAL_enumeration:
				{
				alt133=2;
				}
				break;
			case LITERAL_complex:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
				{
				alt133=3;
				}
				break;
			case LITERAL_array:
				{
				alt133=4;
				}
				break;
			case LITERAL_record:
				{
				alt133=5;
				}
				break;
			case LITERAL_variant:
				{
				alt133=6;
				}
				break;
			case LITERAL_boolean:
				{
				alt133=7;
				}
				break;
			case LITERAL_string:
				{
				alt133=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 133, 0, input);
				throw nvae;
			}
			switch (alt133) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2681:3: tn= type_name
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_type_name_in_type10923);
=======
					pushFollow(FOLLOW_type_name_in_type10931);
>>>>>>> origin/continuum
					tn=type_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_name.add(tn.getTree());
					// AST REWRITE
					// elements: tn
					// token labels: 
					// rule labels: tn, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_tn=new RewriteRuleSubtreeStream(adaptor,"rule tn",tn!=null?tn.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2682:5: -> $tn
					{
						adaptor.addChild(root_0, stream_tn.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2684:3: et= enumeration_type
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_enumeration_type_in_type10942);
=======
					pushFollow(FOLLOW_enumeration_type_in_type10950);
>>>>>>> origin/continuum
					et=enumeration_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumeration_type.add(et.getTree());
					// AST REWRITE
					// elements: et
					// token labels: 
					// rule labels: retval, et
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_et=new RewriteRuleSubtreeStream(adaptor,"rule et",et!=null?et.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2685:5: -> $et
					{
						adaptor.addChild(root_0, stream_et.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2687:3: nt= number_type
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_number_type_in_type10961);
=======
					pushFollow(FOLLOW_number_type_in_type10969);
>>>>>>> origin/continuum
					nt=number_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_number_type.add(nt.getTree());
					// AST REWRITE
					// elements: nt
					// token labels: 
					// rule labels: nt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_nt=new RewriteRuleSubtreeStream(adaptor,"rule nt",nt!=null?nt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2688:5: -> $nt
					{
						adaptor.addChild(root_0, stream_nt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2690:3: at= array_type
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_array_type_in_type10980);
=======
					pushFollow(FOLLOW_array_type_in_type10988);
>>>>>>> origin/continuum
					at=array_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_array_type.add(at.getTree());
					// AST REWRITE
					// elements: at
					// token labels: 
					// rule labels: at, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_at=new RewriteRuleSubtreeStream(adaptor,"rule at",at!=null?at.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2691:5: -> $at
					{
						adaptor.addChild(root_0, stream_at.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2693:3: rt= record_type
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_record_type_in_type10999);
=======
					pushFollow(FOLLOW_record_type_in_type11007);
>>>>>>> origin/continuum
					rt=record_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_type.add(rt.getTree());
					// AST REWRITE
					// elements: rt
					// token labels: 
					// rule labels: rt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rt=new RewriteRuleSubtreeStream(adaptor,"rule rt",rt!=null?rt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2694:5: -> $rt
					{
						adaptor.addChild(root_0, stream_rt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2696:3: vt= variant_type
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_variant_type_in_type11018);
=======
					pushFollow(FOLLOW_variant_type_in_type11026);
>>>>>>> origin/continuum
					vt=variant_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_variant_type.add(vt.getTree());
					// AST REWRITE
					// elements: vt
					// token labels: 
					// rule labels: vt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_vt=new RewriteRuleSubtreeStream(adaptor,"rule vt",vt!=null?vt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2697:5: -> $vt
					{
						adaptor.addChild(root_0, stream_vt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2702:3: b= LITERAL_boolean
					{
<<<<<<< HEAD
					b=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_type11040); if (state.failed) return retval; 
=======
					b=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_type11048); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_boolean.add(b);

					// AST REWRITE
					// elements: b
					// token labels: b
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_b=new RewriteRuleTokenStream(adaptor,"token b",b);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2702:21: -> $b
					{
						adaptor.addChild(root_0, stream_b.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2704:3: s= LITERAL_string
					{
<<<<<<< HEAD
					s=(Token)match(input,LITERAL_string,FOLLOW_LITERAL_string_in_type11055); if (state.failed) return retval; 
=======
					s=(Token)match(input,LITERAL_string,FOLLOW_LITERAL_string_in_type11063); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_string.add(s);

					// AST REWRITE
					// elements: s
					// token labels: s
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2704:20: -> $s
					{
						adaptor.addChild(root_0, stream_s.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			  Dump.it("\n"+(saidTypeError?"That ":"Some ")+Global.dope+
			  " made "+(saidTypeError?"another":"an")+" error in grammar of a \"type\".\n");
			  Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  tellBNF(GrammarStrings.type,re,retval.tree);
			//  Dump.it("RecognitionException suppressed ");
			//  if ((retval!=null)&&(retval.getTree()!=null))
			//    Dump.it(((BAST)retval.getTree()).toStringTree());
			  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type"


	public static class enumeration_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2717:1: enumeration_type : LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
	public final BLESStoASTParser.enumeration_type_return enumeration_type() throws RecognitionException {
		BLESStoASTParser.enumeration_type_return retval = new BLESStoASTParser.enumeration_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_enumeration222=null;
		Token LPAREN223=null;
		Token COMMA225=null;
		Token RPAREN227=null;
		ParserRuleReturnScope identifier224 =null;
		ParserRuleReturnScope identifier226 =null;

		BAST LITERAL_enumeration222_tree=null;
		BAST LPAREN223_tree=null;
		BAST COMMA225_tree=null;
		BAST RPAREN227_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2718:3: ( LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2719:2: LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_enumeration222=(Token)match(input,LITERAL_enumeration,FOLLOW_LITERAL_enumeration_in_enumeration_type11084); if (state.failed) return retval;
=======
			LITERAL_enumeration222=(Token)match(input,LITERAL_enumeration,FOLLOW_LITERAL_enumeration_in_enumeration_type11092); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_enumeration222_tree = (BAST)adaptor.create(LITERAL_enumeration222);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_enumeration222_tree, root_0);
			}

<<<<<<< HEAD
			LPAREN223=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_enumeration_type11087); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_enumeration_type11092);
=======
			LPAREN223=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_enumeration_type11095); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_enumeration_type11100);
>>>>>>> origin/continuum
			identifier224=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier224.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2720:4: ( COMMA ! identifier )*
			loop134:
			while (true) {
				int alt134=2;
				int LA134_0 = input.LA(1);
				if ( (LA134_0==COMMA) ) {
					alt134=1;
				}

				switch (alt134) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2720:5: COMMA ! identifier
					{
<<<<<<< HEAD
					COMMA225=(Token)match(input,COMMA,FOLLOW_COMMA_in_enumeration_type11098); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_enumeration_type11101);
=======
					COMMA225=(Token)match(input,COMMA,FOLLOW_COMMA_in_enumeration_type11106); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_enumeration_type11109);
>>>>>>> origin/continuum
					identifier226=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier226.getTree());

					}
					break;

				default :
					break loop134;
				}
			}

<<<<<<< HEAD
			RPAREN227=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_enumeration_type11105); if (state.failed) return retval;
=======
			RPAREN227=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_enumeration_type11113); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			 Dump.it("Did you forget commas between your enumeration literals?");
			  Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.enumerationType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_type"


	public static class number_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "number_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2750:1: number_type : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )? -> {u!=null}? ^( $n ^( $u $ud) ( $r)? ) -> ^( $n ( $r)? ) ;
	public final BLESStoASTParser.number_type_return number_type() throws RecognitionException {
		BLESStoASTParser.number_type_return retval = new BLESStoASTParser.number_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token u=null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope ud =null;

		BAST n_tree=null;
		BAST u_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_units=new RewriteRuleTokenStream(adaptor,"token LITERAL_units");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_number_range=new RewriteRuleSubtreeStream(adaptor,"rule number_range");
		RewriteRuleSubtreeStream stream_units_designator=new RewriteRuleSubtreeStream(adaptor,"rule units_designator");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2751:3: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )? -> {u!=null}? ^( $n ^( $u $ud) ( $r)? ) -> ^( $n ( $r)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2752:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2752:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt135=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt135=1;
				}
				break;
			case LITERAL_integer:
				{
				alt135=2;
				}
				break;
			case LITERAL_rational:
				{
				alt135=3;
				}
				break;
			case LITERAL_real:
				{
				alt135=4;
				}
				break;
			case LITERAL_complex:
				{
				alt135=5;
				}
				break;
			case LITERAL_time:
				{
				alt135=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 135, 0, input);
				throw nvae;
			}
			switch (alt135) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2752:4: n= LITERAL_natural
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_number_type11160); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_number_type11168); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2753:3: n= LITERAL_integer
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_number_type11169); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_number_type11177); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2754:3: n= LITERAL_rational
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_number_type11178); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_number_type11186); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2755:3: n= LITERAL_real
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_number_type11187); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_number_type11195); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2756:3: n= LITERAL_complex
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_number_type11196); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_number_type11204); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2757:3: n= LITERAL_time
					{
<<<<<<< HEAD
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_number_type11204); if (state.failed) return retval; 
=======
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_number_type11212); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:4: (r= number_range )?
			int alt136=2;
			int LA136_0 = input.LA(1);
			if ( (LA136_0==LBRACKET) ) {
				alt136=1;
			}
			switch (alt136) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:4: r= number_range
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_number_range_in_number_type11212);
=======
					pushFollow(FOLLOW_number_range_in_number_type11220);
>>>>>>> origin/continuum
					r=number_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_number_range.add(r.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:19: (u= LITERAL_units ud= units_designator )?
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==LITERAL_units) ) {
				alt137=1;
			}
			switch (alt137) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:21: u= LITERAL_units ud= units_designator
					{
<<<<<<< HEAD
					u=(Token)match(input,LITERAL_units,FOLLOW_LITERAL_units_in_number_type11219); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_units.add(u);

					pushFollow(FOLLOW_units_designator_in_number_type11223);
=======
					u=(Token)match(input,LITERAL_units,FOLLOW_LITERAL_units_in_number_type11227); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_units.add(u);

					pushFollow(FOLLOW_units_designator_in_number_type11231);
>>>>>>> origin/continuum
					ud=units_designator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_units_designator.add(ud.getTree());
					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: u, ud, n, r, n, r
=======
			// elements: n, n, u, r, ud, r
>>>>>>> origin/continuum
			// token labels: u, n
			// rule labels: r, retval, ud
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_u=new RewriteRuleTokenStream(adaptor,"token u",u);
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ud=new RewriteRuleSubtreeStream(adaptor,"rule ud",ud!=null?ud.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2759:4: -> {u!=null}? ^( $n ^( $u $ud) ( $r)? )
			if (u!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2759:18: ^( $n ^( $u $ud) ( $r)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2759:23: ^( $u $ud)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_u.nextNode(), root_2);
				adaptor.addChild(root_2, stream_ud.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2759:34: ( $r)?
				if ( stream_r.hasNext() ) {
					adaptor.addChild(root_1, stream_r.nextTree());
				}
				stream_r.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2760:4: -> ^( $n ( $r)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2760:7: ^( $n ( $r)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2760:13: ( $r)?
				if ( stream_r.hasNext() ) {
					adaptor.addChild(root_1, stream_r.nextTree());
				}
				stream_r.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.numberType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_type"


	public static class number_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2765:1: number_range : LBRACKET ! constant_number_range RBRACKET !;
	public final BLESStoASTParser.number_range_return number_range() throws RecognitionException {
		BLESStoASTParser.number_range_return retval = new BLESStoASTParser.number_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET228=null;
		Token RBRACKET230=null;
		ParserRuleReturnScope constant_number_range229 =null;

		BAST LBRACKET228_tree=null;
		BAST RBRACKET230_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2766:3: ( LBRACKET ! constant_number_range RBRACKET !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2767:3: LBRACKET ! constant_number_range RBRACKET !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LBRACKET228=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_number_range11288); if (state.failed) return retval;
			pushFollow(FOLLOW_constant_number_range_in_number_range11291);
=======
			LBRACKET228=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_number_range11296); if (state.failed) return retval;
			pushFollow(FOLLOW_constant_number_range_in_number_range11299);
>>>>>>> origin/continuum
			constant_number_range229=constant_number_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_number_range229.getTree());

<<<<<<< HEAD
			RBRACKET230=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_number_range11293); if (state.failed) return retval;
=======
			RBRACKET230=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_number_range11301); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_range"


	public static class constant_number_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "constant_number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:1: constant_number_range : (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) ) -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub) -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) ) -> ^( $dd $lb $ub) ;
	public final BLESStoASTParser.constant_number_range_return constant_number_range() throws RecognitionException {
		BLESStoASTParser.constant_number_range_return retval = new BLESStoASTParser.constant_number_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lb_um=null;
		Token dd=null;
		Token ub_um=null;
		ParserRuleReturnScope lb =null;
		ParserRuleReturnScope ub =null;

		BAST lb_um_tree=null;
		BAST dd_tree=null;
		BAST ub_um_tree=null;
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_numeric_constant=new RewriteRuleSubtreeStream(adaptor,"rule numeric_constant");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2771:3: ( (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) ) -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub) -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) ) -> ^( $dd $lb $ub) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:3: (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:8: (lb_um= MINUS )?
			int alt138=2;
			int LA138_0 = input.LA(1);
			if ( (LA138_0==MINUS) ) {
				alt138=1;
			}
			switch (alt138) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:8: lb_um= MINUS
					{
<<<<<<< HEAD
					lb_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11311); if (state.failed) return retval; 
=======
					lb_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11319); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(lb_um);

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11316);
=======
			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11324);
>>>>>>> origin/continuum
			lb=numeric_constant();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_constant.add(lb.getTree());
<<<<<<< HEAD
			dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range11320); if (state.failed) return retval; 
=======
			dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range11328); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_DOTDOT.add(dd);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:51: (ub_um= MINUS )?
			int alt139=2;
			int LA139_0 = input.LA(1);
			if ( (LA139_0==MINUS) ) {
				alt139=1;
			}
			switch (alt139) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2772:51: ub_um= MINUS
					{
<<<<<<< HEAD
					ub_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11324); if (state.failed) return retval; 
=======
					ub_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11332); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(ub_um);

					}
					break;

			}

<<<<<<< HEAD
			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11329);
=======
			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11337);
>>>>>>> origin/continuum
			ub=numeric_constant();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_constant.add(ub.getTree());
			// AST REWRITE
<<<<<<< HEAD
			// elements: dd, ub, dd, dd, lb, ub, ub, lb, lb, lb, dd, ub
=======
			// elements: lb, dd, dd, ub, dd, ub, dd, ub, lb, ub, lb, lb
>>>>>>> origin/continuum
			// token labels: dd
			// rule labels: lb, ub, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dd=new RewriteRuleTokenStream(adaptor,"token dd",dd);
			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,"rule lb",lb!=null?lb.getTree():null);
			RewriteRuleSubtreeStream stream_ub=new RewriteRuleSubtreeStream(adaptor,"rule ub",ub!=null?ub.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2773:3: -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) )
			if ((lb_um!=null)&&(ub_um!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2773:38: ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2773:44: ^( UNARY_MINUS[$lb_um] $lb)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, lb_um), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2773:71: ^( UNARY_MINUS[$ub_um] $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, ub_um), root_2);
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2774:3: -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub)
			if (lb_um!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2774:21: ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2774:27: ^( UNARY_MINUS[$lb_um] $lb)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, lb_um), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_ub.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2775:3: -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) )
			if (ub_um!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:21: ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lb.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:31: ^( UNARY_MINUS[$ub_um] $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, ub_um), root_2);
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2776:3: -> ^( $dd $lb $ub)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2776:6: ^( $dd $lb $ub)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lb.nextTree());
				adaptor.addChild(root_1, stream_ub.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constant_number_range"


	public static class units_designator_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "units_designator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2779:1: units_designator : ( identifier | time_unit );
	public final BLESStoASTParser.units_designator_return units_designator() throws RecognitionException {
		BLESStoASTParser.units_designator_return retval = new BLESStoASTParser.units_designator_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope identifier231 =null;
		ParserRuleReturnScope time_unit232 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2780:3: ( identifier | time_unit )
			int alt140=2;
			int LA140_0 = input.LA(1);
			if ( (LA140_0==ID) ) {
				alt140=1;
			}
			else if ( (LA140_0==LITERAL_hr||LA140_0==LITERAL_min||LA140_0==LITERAL_ms||LA140_0==LITERAL_ns||LA140_0==LITERAL_ps||LA140_0==LITERAL_sec||LA140_0==LITERAL_us) ) {
				alt140=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 140, 0, input);
				throw nvae;
			}

			switch (alt140) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2781:34: identifier
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_units_designator11443);
=======
					pushFollow(FOLLOW_identifier_in_units_designator11451);
>>>>>>> origin/continuum
					identifier231=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier231.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2782:5: time_unit
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_time_unit_in_units_designator11449);
=======
					pushFollow(FOLLOW_time_unit_in_units_designator11457);
>>>>>>> origin/continuum
					time_unit232=time_unit();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_unit232.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.unitsDesignator,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "units_designator"


	public static class unique_component_classifier_reference_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "unique_component_classifier_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2797:1: unique_component_classifier_reference : (p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )? -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) ) -> ^( DOUBLE_COLON ( $p)+ ) |dci= identifier ( PERIOD ii= identifier )? -> {ii!=null}? ^( PERIOD $dci $ii) -> $dci);
	public final BLESStoASTParser.unique_component_classifier_reference_return unique_component_classifier_reference() throws RecognitionException {
		BLESStoASTParser.unique_component_classifier_reference_return retval = new BLESStoASTParser.unique_component_classifier_reference_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token DOUBLE_COLON233=null;
		Token PERIOD234=null;
		Token PERIOD235=null;
		List<Object> list_p=null;
		ParserRuleReturnScope ii =null;
		ParserRuleReturnScope dci =null;
		RuleReturnScope p = null;
		BAST DOUBLE_COLON233_tree=null;
		BAST PERIOD234_tree=null;
		BAST PERIOD235_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2798:3: (p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )? -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) ) -> ^( DOUBLE_COLON ( $p)+ ) |dci= identifier ( PERIOD ii= identifier )? -> {ii!=null}? ^( PERIOD $dci $ii) -> $dci)
			int alt144=2;
			int LA144_0 = input.LA(1);
			if ( (LA144_0==ID) ) {
				int LA144_1 = input.LA(2);
				if ( (LA144_1==DOUBLE_COLON) ) {
					alt144=1;
				}
				else if ( (LA144_1==LITERAL_in||LA144_1==LITERAL_of||LA144_1==LITERAL_that||LA144_1==OCTOTHORPE||LA144_1==PERIOD) ) {
					alt144=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 144, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 144, 0, input);
				throw nvae;
			}

			switch (alt144) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2799:3: p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )?
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11489);
=======
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11497);
>>>>>>> origin/continuum
					p=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
					if (list_p==null) list_p=new ArrayList<Object>();
					list_p.add(p.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2799:29: ( DOUBLE_COLON p+= identifier )+
					int cnt141=0;
					loop141:
					while (true) {
						int alt141=2;
						int LA141_0 = input.LA(1);
						if ( (LA141_0==DOUBLE_COLON) ) {
							alt141=1;
						}

						switch (alt141) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2799:31: DOUBLE_COLON p+= identifier
							{
<<<<<<< HEAD
							DOUBLE_COLON233=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11493); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON233);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11498);
=======
							DOUBLE_COLON233=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11501); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON233);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11506);
>>>>>>> origin/continuum
							p=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
							if (list_p==null) list_p=new ArrayList<Object>();
							list_p.add(p.getTree());
							}
							break;

						default :
							if ( cnt141 >= 1 ) break loop141;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(141, input);
							throw eee;
						}
						cnt141++;
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2800:5: ( PERIOD ii= identifier )?
					int alt142=2;
					int LA142_0 = input.LA(1);
					if ( (LA142_0==PERIOD) ) {
						alt142=1;
					}
					switch (alt142) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2800:7: PERIOD ii= identifier
							{
<<<<<<< HEAD
							PERIOD234=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11510); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD234);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11515);
=======
							PERIOD234=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11518); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD234);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11523);
>>>>>>> origin/continuum
							ii=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ii.getTree());
							}
							break;

					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: p, DOUBLE_COLON, DOUBLE_COLON, PERIOD, ii, p
=======
					// elements: PERIOD, ii, p, DOUBLE_COLON, DOUBLE_COLON, p
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: ii, retval
					// token list labels: 
					// rule list labels: p
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ii=new RewriteRuleSubtreeStream(adaptor,"rule ii",ii!=null?ii.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"token p",list_p);
					root_0 = (BAST)adaptor.nil();
					// 2801:5: -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) )
					if (ii!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2801:20: ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_1);
						if ( !(stream_p.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_p.hasNext() ) {
							adaptor.addChild(root_1, stream_p.nextTree());
						}
						stream_p.reset();

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2801:40: ^( PERIOD $ii)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_PERIOD.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ii.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2802:5: -> ^( DOUBLE_COLON ( $p)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2802:8: ^( DOUBLE_COLON ( $p)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_1);
						if ( !(stream_p.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_p.hasNext() ) {
							adaptor.addChild(root_1, stream_p.nextTree());
						}
						stream_p.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2807:3: dci= identifier ( PERIOD ii= identifier )?
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11573);
=======
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11581);
>>>>>>> origin/continuum
					dci=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(dci.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2808:5: ( PERIOD ii= identifier )?
					int alt143=2;
					int LA143_0 = input.LA(1);
					if ( (LA143_0==PERIOD) ) {
						alt143=1;
					}
					switch (alt143) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2808:7: PERIOD ii= identifier
							{
<<<<<<< HEAD
							PERIOD235=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11581); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD235);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11586);
=======
							PERIOD235=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11589); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD235);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11594);
>>>>>>> origin/continuum
							ii=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ii.getTree());
							}
							break;

					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: PERIOD, ii, dci, dci
=======
					// elements: PERIOD, dci, dci, ii
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: ii, dci, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ii=new RewriteRuleSubtreeStream(adaptor,"rule ii",ii!=null?ii.getTree():null);
					RewriteRuleSubtreeStream stream_dci=new RewriteRuleSubtreeStream(adaptor,"rule dci",dci!=null?dci.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2809:5: -> {ii!=null}? ^( PERIOD $dci $ii)
					if (ii!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2809:20: ^( PERIOD $dci $ii)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_PERIOD.nextNode(), root_1);
						adaptor.addChild(root_1, stream_dci.nextTree());
						adaptor.addChild(root_1, stream_ii.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2810:5: -> $dci
					{
						adaptor.addChild(root_0, stream_dci.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("\nIs this a unique_component_classifier_reference?\n");
			//    tellBNF(GrammarStrings.subcomponent,re,$subcomponent.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unique_component_classifier_reference"


	public static class type_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2818:1: type_name : p= ID (dc= DOUBLE_COLON ^x= ID )? ;
	public final BLESStoASTParser.type_name_return type_name() throws RecognitionException {
		BLESStoASTParser.type_name_return retval = new BLESStoASTParser.type_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token p=null;
		Token dc=null;
		Token x=null;

		BAST p_tree=null;
		BAST dc_tree=null;
		BAST x_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2819:3: (p= ID (dc= DOUBLE_COLON ^x= ID )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2821:3: p= ID (dc= DOUBLE_COLON ^x= ID )?
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			p=(Token)match(input,ID,FOLLOW_ID_in_type_name11662); if (state.failed) return retval;
=======
			p=(Token)match(input,ID,FOLLOW_ID_in_type_name11670); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			p_tree = (BAST)adaptor.create(p);
			adaptor.addChild(root_0, p_tree);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2821:8: (dc= DOUBLE_COLON ^x= ID )?
			int alt145=2;
			int LA145_0 = input.LA(1);
			if ( (LA145_0==DOUBLE_COLON) ) {
				alt145=1;
			}
			switch (alt145) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2821:9: dc= DOUBLE_COLON ^x= ID
					{
<<<<<<< HEAD
					dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_type_name11667); if (state.failed) return retval;
=======
					dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_type_name11675); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					dc_tree = (BAST)adaptor.create(dc);
					root_0 = (BAST)adaptor.becomeRoot(dc_tree, root_0);
					}

<<<<<<< HEAD
					x=(Token)match(input,ID,FOLLOW_ID_in_type_name11672); if (state.failed) return retval;
=======
					x=(Token)match(input,ID,FOLLOW_ID_in_type_name11680); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					x_tree = (BAST)adaptor.create(x);
					adaptor.addChild(root_0, x_tree);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.typeName,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_name"


	public static class array_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "array_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2826:1: array_type : LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type ;
	public final BLESStoASTParser.array_type_return array_type() throws RecognitionException {
		BLESStoASTParser.array_type_return retval = new BLESStoASTParser.array_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_array236=null;
		Token LBRACKET237=null;
		Token RBRACKET239=null;
		Token LITERAL_of240=null;
		ParserRuleReturnScope array_range_list238 =null;
		ParserRuleReturnScope type241 =null;

		BAST LITERAL_array236_tree=null;
		BAST LBRACKET237_tree=null;
		BAST RBRACKET239_tree=null;
		BAST LITERAL_of240_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2827:3: ( LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2828:3: LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_array236=(Token)match(input,LITERAL_array,FOLLOW_LITERAL_array_in_array_type11699); if (state.failed) return retval;
=======
			LITERAL_array236=(Token)match(input,LITERAL_array,FOLLOW_LITERAL_array_in_array_type11707); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_array236_tree = (BAST)adaptor.create(LITERAL_array236);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_array236_tree, root_0);
			}

<<<<<<< HEAD
			LBRACKET237=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_array_type11702); if (state.failed) return retval;
			pushFollow(FOLLOW_array_range_list_in_array_type11705);
=======
			LBRACKET237=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_array_type11710); if (state.failed) return retval;
			pushFollow(FOLLOW_array_range_list_in_array_type11713);
>>>>>>> origin/continuum
			array_range_list238=array_range_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, array_range_list238.getTree());

<<<<<<< HEAD
			RBRACKET239=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_array_type11707); if (state.failed) return retval;
			LITERAL_of240=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_array_type11710); if (state.failed) return retval;
=======
			RBRACKET239=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_array_type11715); if (state.failed) return retval;
			LITERAL_of240=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_array_type11718); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_of240_tree = (BAST)adaptor.create(LITERAL_of240);
			adaptor.addChild(root_0, LITERAL_of240_tree);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_type_in_array_type11712);
=======
			pushFollow(FOLLOW_type_in_array_type11720);
>>>>>>> origin/continuum
			type241=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type241.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.arrayType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_type"


	public static class record_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2834:1: record_type : LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !;
	public final BLESStoASTParser.record_type_return record_type() throws RecognitionException {
		BLESStoASTParser.record_type_return retval = new BLESStoASTParser.record_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_record242=null;
		Token LPAREN243=null;
		Token RPAREN245=null;
		ParserRuleReturnScope record_field244 =null;

		BAST LITERAL_record242_tree=null;
		BAST LPAREN243_tree=null;
		BAST RPAREN245_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2835:3: ( LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2836:3: LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_record242=(Token)match(input,LITERAL_record,FOLLOW_LITERAL_record_in_record_type11739); if (state.failed) return retval;
=======
			LITERAL_record242=(Token)match(input,LITERAL_record,FOLLOW_LITERAL_record_in_record_type11747); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_record242_tree = (BAST)adaptor.create(LITERAL_record242);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_record242_tree, root_0);
			}

<<<<<<< HEAD
			LPAREN243=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_type11742); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2834:27: ( record_field )+
=======
			LPAREN243=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_type11750); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2836:27: ( record_field )+
>>>>>>> origin/continuum
			int cnt146=0;
			loop146:
			while (true) {
				int alt146=2;
				int LA146_0 = input.LA(1);
				if ( (LA146_0==ID) ) {
					alt146=1;
				}

				switch (alt146) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2836:27: record_field
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_record_field_in_record_type11745);
=======
					pushFollow(FOLLOW_record_field_in_record_type11753);
>>>>>>> origin/continuum
					record_field244=record_field();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_field244.getTree());

					}
					break;

				default :
					if ( cnt146 >= 1 ) break loop146;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(146, input);
					throw eee;
				}
				cnt146++;
			}

<<<<<<< HEAD
			RPAREN245=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_type11748); if (state.failed) return retval;
=======
			RPAREN245=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_type11756); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.recordType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_type"


	public static class record_field_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2841:1: record_field : identifier COLON ^ type SEMICOLON !;
	public final BLESStoASTParser.record_field_return record_field() throws RecognitionException {
		BLESStoASTParser.record_field_return retval = new BLESStoASTParser.record_field_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COLON247=null;
		Token SEMICOLON249=null;
		ParserRuleReturnScope identifier246 =null;
		ParserRuleReturnScope type248 =null;

		BAST COLON247_tree=null;
		BAST SEMICOLON249_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2842:3: ( identifier COLON ^ type SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2843:22: identifier COLON ^ type SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_identifier_in_record_field11777);
=======
			pushFollow(FOLLOW_identifier_in_record_field11785);
>>>>>>> origin/continuum
			identifier246=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier246.getTree());

<<<<<<< HEAD
			COLON247=(Token)match(input,COLON,FOLLOW_COLON_in_record_field11779); if (state.failed) return retval;
=======
			COLON247=(Token)match(input,COLON,FOLLOW_COLON_in_record_field11787); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			COLON247_tree = (BAST)adaptor.create(COLON247);
			root_0 = (BAST)adaptor.becomeRoot(COLON247_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_type_in_record_field11782);
=======
			pushFollow(FOLLOW_type_in_record_field11790);
>>>>>>> origin/continuum
			type248=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type248.getTree());

<<<<<<< HEAD
			SEMICOLON249=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_field11784); if (state.failed) return retval;
=======
			SEMICOLON249=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_field11792); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("\nDid you forget a ; after a record or variant field?\n");
			    tellBNF(GrammarStrings.recordField,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_field"


	public static class array_range_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "array_range_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2853:1: array_range_list : natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )? ;
	public final BLESStoASTParser.array_range_list_return array_range_list() throws RecognitionException {
		BLESStoASTParser.array_range_list_return retval = new BLESStoASTParser.array_range_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA251=null;
		Token COMMA253=null;
		ParserRuleReturnScope natural_range250 =null;
		ParserRuleReturnScope natural_range252 =null;
		ParserRuleReturnScope natural_range254 =null;

		BAST COMMA251_tree=null;
		BAST COMMA253_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2854:3: ( natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2855:3: natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )?
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_natural_range_in_array_range_list11814);
=======
			pushFollow(FOLLOW_natural_range_in_array_range_list11822);
>>>>>>> origin/continuum
			natural_range250=natural_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range250.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2855:17: ( COMMA ^ natural_range ( COMMA ! natural_range )* )?
			int alt148=2;
			int LA148_0 = input.LA(1);
			if ( (LA148_0==COMMA) ) {
				alt148=1;
			}
			switch (alt148) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2855:19: COMMA ^ natural_range ( COMMA ! natural_range )*
					{
<<<<<<< HEAD
					COMMA251=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11818); if (state.failed) return retval;
=======
					COMMA251=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11826); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					COMMA251_tree = (BAST)adaptor.create(COMMA251);
					root_0 = (BAST)adaptor.becomeRoot(COMMA251_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_natural_range_in_array_range_list11821);
=======
					pushFollow(FOLLOW_natural_range_in_array_range_list11829);
>>>>>>> origin/continuum
					natural_range252=natural_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range252.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2855:40: ( COMMA ! natural_range )*
					loop147:
					while (true) {
						int alt147=2;
						int LA147_0 = input.LA(1);
						if ( (LA147_0==COMMA) ) {
							alt147=1;
						}

						switch (alt147) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2855:42: COMMA ! natural_range
							{
<<<<<<< HEAD
							COMMA253=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11825); if (state.failed) return retval;
							pushFollow(FOLLOW_natural_range_in_array_range_list11828);
=======
							COMMA253=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11833); if (state.failed) return retval;
							pushFollow(FOLLOW_natural_range_in_array_range_list11836);
>>>>>>> origin/continuum
							natural_range254=natural_range();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range254.getTree());

							}
							break;

						default :
							break loop147;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.arrayRangeList,re);
			      tellBNF(GrammarStrings.arrayRangeList,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_range_list"


	public static class natural_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "natural_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2862:1: natural_range : (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )? ;
	public final BLESStoASTParser.natural_range_return natural_range() throws RecognitionException {
		BLESStoASTParser.natural_range_return retval = new BLESStoASTParser.natural_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ilb=null;
		Token dd=null;
		Token iub=null;
		ParserRuleReturnScope elb =null;
		ParserRuleReturnScope pnlb =null;
		ParserRuleReturnScope eub =null;
		ParserRuleReturnScope pnub =null;

		BAST ilb_tree=null;
		BAST dd_tree=null;
		BAST iub_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2863:3: ( (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2864:3: (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2864:3: (ilb= INTEGER_LIT |elb= identifier |pnlb= property )
			int alt149=3;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt149=1;
				}
				break;
			case ID:
				{
				int LA149_2 = input.LA(2);
				if ( (LA149_2==COMMA||LA149_2==DOTDOT||LA149_2==RBRACKET) ) {
					alt149=2;
				}
				else if ( (LA149_2==DOUBLE_COLON||LA149_2==OCTOTHORPE||LA149_2==PERIOD) ) {
					alt149=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 149, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_self:
			case OCTOTHORPE:
				{
				alt149=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 149, 0, input);
				throw nvae;
			}
			switch (alt149) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2864:5: ilb= INTEGER_LIT
					{
<<<<<<< HEAD
					ilb=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11865); if (state.failed) return retval;
=======
					ilb=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11873); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					ilb_tree = (BAST)adaptor.create(ilb);
					adaptor.addChild(root_0, ilb_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2864:23: elb= identifier
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_natural_range11871);
=======
					pushFollow(FOLLOW_identifier_in_natural_range11879);
>>>>>>> origin/continuum
					elb=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, elb.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2864:40: pnlb= property
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_property_in_natural_range11877);
=======
					pushFollow(FOLLOW_property_in_natural_range11885);
>>>>>>> origin/continuum
					pnlb=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, pnlb.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:3: (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )?
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==DOTDOT) ) {
				alt151=1;
			}
			switch (alt151) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:5: dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property )
					{
<<<<<<< HEAD
					dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_natural_range11887); if (state.failed) return retval;
=======
					dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_natural_range11895); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					dd_tree = (BAST)adaptor.create(dd);
					root_0 = (BAST)adaptor.becomeRoot(dd_tree, root_0);
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:16: (iub= INTEGER_LIT |eub= identifier |pnub= property )
					int alt150=3;
					switch ( input.LA(1) ) {
					case INTEGER_LIT:
						{
						alt150=1;
						}
						break;
					case ID:
						{
						int LA150_2 = input.LA(2);
						if ( (LA150_2==COMMA||LA150_2==RBRACKET) ) {
							alt150=2;
						}
						else if ( (LA150_2==DOUBLE_COLON||LA150_2==OCTOTHORPE||LA150_2==PERIOD) ) {
							alt150=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 150, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					case LITERAL_self:
					case OCTOTHORPE:
						{
						alt150=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 150, 0, input);
						throw nvae;
					}
					switch (alt150) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:18: iub= INTEGER_LIT
							{
<<<<<<< HEAD
							iub=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11894); if (state.failed) return retval;
=======
							iub=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11902); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							iub_tree = (BAST)adaptor.create(iub);
							adaptor.addChild(root_0, iub_tree);
							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:36: eub= identifier
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_identifier_in_natural_range11900);
=======
							pushFollow(FOLLOW_identifier_in_natural_range11908);
>>>>>>> origin/continuum
							eub=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, eub.getTree());

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:53: pnub= property
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_property_in_natural_range11906);
=======
							pushFollow(FOLLOW_property_in_natural_range11914);
>>>>>>> origin/continuum
							pnub=property();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, pnub.getTree());

							}
							break;

					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.naturalRange,re);
			      tellBNF(GrammarStrings.naturalRange,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "natural_range"


	public static class variant_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variant_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2877:1: variant_type : LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !;
	public final BLESStoASTParser.variant_type_return variant_type() throws RecognitionException {
		BLESStoASTParser.variant_type_return retval = new BLESStoASTParser.variant_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_variant255=null;
		Token LPAREN256=null;
		Token RPAREN258=null;
		ParserRuleReturnScope record_field257 =null;

		BAST LITERAL_variant255_tree=null;
		BAST LPAREN256_tree=null;
		BAST RPAREN258_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2878:3: ( LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2879:3: LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_variant255=(Token)match(input,LITERAL_variant,FOLLOW_LITERAL_variant_in_variant_type11943); if (state.failed) return retval;
=======
			LITERAL_variant255=(Token)match(input,LITERAL_variant,FOLLOW_LITERAL_variant_in_variant_type11951); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_variant255_tree = (BAST)adaptor.create(LITERAL_variant255);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_variant255_tree, root_0);
			}

<<<<<<< HEAD
			LPAREN256=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_variant_type11951); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2878:13: ( record_field )+
=======
			LPAREN256=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_variant_type11959); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2880:13: ( record_field )+
>>>>>>> origin/continuum
			int cnt152=0;
			loop152:
			while (true) {
				int alt152=2;
				int LA152_0 = input.LA(1);
				if ( (LA152_0==ID) ) {
					alt152=1;
				}

				switch (alt152) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2880:13: record_field
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_record_field_in_variant_type11954);
=======
					pushFollow(FOLLOW_record_field_in_variant_type11962);
>>>>>>> origin/continuum
					record_field257=record_field();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_field257.getTree());

					}
					break;

				default :
					if ( cnt152 >= 1 ) break loop152;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(152, input);
					throw eee;
				}
				cnt152++;
			}

<<<<<<< HEAD
			RPAREN258=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_variant_type11957); if (state.failed) return retval;
=======
			RPAREN258=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_variant_type11965); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.variantType,re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variant_type"


	public static class assertion_annex_subclause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_annex_subclause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2887:1: assertion_annex_subclause : ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )? ;
	public final BLESStoASTParser.assertion_annex_subclause_return assertion_annex_subclause() throws RecognitionException {
		BLESStoASTParser.assertion_annex_subclause_return retval = new BLESStoASTParser.assertion_annex_subclause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START259=null;
		Token ANNEX_END260=null;
		List<Object> list_a=null;
		ParserRuleReturnScope p =null;
		RuleReturnScope a = null;
		BAST ANNEX_START259_tree=null;
		BAST ANNEX_END260_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2888:3: ( ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2889:3: ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2889:3: ( ANNEX_START )?
			int alt153=2;
			int LA153_0 = input.LA(1);
			if ( (LA153_0==ANNEX_START) ) {
				alt153=1;
			}
			switch (alt153) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2889:3: ANNEX_START
					{
<<<<<<< HEAD
					ANNEX_START259=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_subclause11986); if (state.failed) return retval; 
=======
					ANNEX_START259=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_subclause11994); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START259);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2890:3: ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) )
			int alt155=2;
			int LA155_0 = input.LA(1);
			if ( (LA155_0==LASS) ) {
				alt155=1;
			}
			else if ( (LA155_0==AADL_STRING_LITERAL||LA155_0==ID||LA155_0==INTEGER_LIT||LA155_0==LBRACKET||LA155_0==LITERAL_abs||LA155_0==LITERAL_all||LA155_0==LITERAL_complex||LA155_0==LITERAL_def||LA155_0==LITERAL_exists||LA155_0==LITERAL_false||LA155_0==LITERAL_in||LA155_0==LITERAL_integer||LA155_0==LITERAL_natural||(LA155_0 >= LITERAL_not && LA155_0 <= LITERAL_now)||LA155_0==LITERAL_null||(LA155_0 >= LITERAL_rational && LA155_0 <= LITERAL_real)||LA155_0==LITERAL_self||LA155_0==LITERAL_stop||(LA155_0 >= LITERAL_time && LA155_0 <= LITERAL_timeout)||LA155_0==LITERAL_tops||LA155_0==LITERAL_true||LA155_0==LPAREN||LA155_0==MINUS||LA155_0==OCTOTHORPE||LA155_0==REAL_LIT) ) {
				alt155=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 155, 0, input);
				throw nvae;
			}

			switch (alt155) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2891:3: (a+= assertion )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2891:4: (a+= assertion )+
					int cnt154=0;
					loop154:
					while (true) {
						int alt154=2;
						int LA154_0 = input.LA(1);
						if ( (LA154_0==LASS) ) {
							alt154=1;
						}

						switch (alt154) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2891:4: a+= assertion
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_assertion_in_assertion_annex_subclause11997);
=======
							pushFollow(FOLLOW_assertion_in_assertion_annex_subclause12005);
>>>>>>> origin/continuum
							a=assertion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt154 >= 1 ) break loop154;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(154, input);
							throw eee;
						}
						cnt154++;
					}

					// AST REWRITE
					// elements: a
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: a
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
					root_0 = (BAST)adaptor.nil();
					// 2892:5: -> ^( ASSERTION_ANNEX ( $a)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2892:8: ^( ASSERTION_ANNEX ( $a)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
						if ( !(stream_a.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_a.hasNext() ) {
							adaptor.addChild(root_1, stream_a.nextTree());
						}
						stream_a.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2893:5: p= predicate
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_predicate_in_assertion_annex_subclause12020);
=======
					pushFollow(FOLLOW_predicate_in_assertion_annex_subclause12028);
>>>>>>> origin/continuum
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					// AST REWRITE
					// elements: p
					// token labels: 
					// rule labels: p, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2894:5: -> ^( ASSERTION_ANNEX $p)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2894:8: ^( ASSERTION_ANNEX $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2896:3: ( ANNEX_END )?
			int alt156=2;
			int LA156_0 = input.LA(1);
			if ( (LA156_0==ANNEX_END) ) {
				alt156=1;
			}
			switch (alt156) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2896:3: ANNEX_END
					{
<<<<<<< HEAD
					ANNEX_END260=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_subclause12041); if (state.failed) return retval; 
=======
					ANNEX_END260=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_subclause12049); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END260);

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertionAnnexSubclause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_subclause"


	public static class assertion_annex_library_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_annex_library"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2903:1: assertion_annex_library : ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )? ;
	public final BLESStoASTParser.assertion_annex_library_return assertion_annex_library() throws RecognitionException {
		BLESStoASTParser.assertion_annex_library_return retval = new BLESStoASTParser.assertion_annex_library_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START261=null;
		Token ANNEX_END262=null;
		List<Object> list_a=null;
		RuleReturnScope a = null;
		BAST ANNEX_START261_tree=null;
		BAST ANNEX_END262_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2904:3: ( ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2905:3: ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2905:3: ( ANNEX_START )?
			int alt157=2;
			int LA157_0 = input.LA(1);
			if ( (LA157_0==ANNEX_START) ) {
				alt157=1;
			}
			switch (alt157) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2905:3: ANNEX_START
					{
<<<<<<< HEAD
					ANNEX_START261=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_library12069); if (state.failed) return retval; 
=======
					ANNEX_START261=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_library12077); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START261);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2906:3: ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2907:3: (a+= assertion )+
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2907:4: (a+= assertion )+
			int cnt158=0;
			loop158:
			while (true) {
				int alt158=2;
				int LA158_0 = input.LA(1);
				if ( (LA158_0==LASS) ) {
					alt158=1;
				}

				switch (alt158) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2907:4: a+= assertion
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_in_assertion_annex_library12080);
=======
					pushFollow(FOLLOW_assertion_in_assertion_annex_library12088);
>>>>>>> origin/continuum
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;

				default :
					if ( cnt158 >= 1 ) break loop158;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(158, input);
					throw eee;
				}
				cnt158++;
			}

			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2908:5: -> ^( ASSERTION_ANNEX ( $a)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2908:8: ^( ASSERTION_ANNEX ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2910:3: ( ANNEX_END )?
			int alt159=2;
			int LA159_0 = input.LA(1);
			if ( (LA159_0==ANNEX_END) ) {
				alt159=1;
			}
			switch (alt159) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2910:3: ANNEX_END
					{
<<<<<<< HEAD
					ANNEX_END262=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_library12103); if (state.failed) return retval; 
=======
					ANNEX_END262=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_library12111); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END262);

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertionAnnexLibrary,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_library"


	public static class assertion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2915:1: assertion : ll= LASS !ab= assertion_body RASS !;
	public final BLESStoASTParser.assertion_return assertion() throws RecognitionException {
		BLESStoASTParser.assertion_return retval = new BLESStoASTParser.assertion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ll=null;
		Token RASS263=null;
		ParserRuleReturnScope ab =null;

		BAST ll_tree=null;
		BAST RASS263_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2917:3: (ll= LASS !ab= assertion_body RASS !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2918:3: ll= LASS !ab= assertion_body RASS !
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			ll=(Token)match(input,LASS,FOLLOW_LASS_in_assertion12133); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_body_in_assertion12138);
=======
			ll=(Token)match(input,LASS,FOLLOW_LASS_in_assertion12141); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_body_in_assertion12146);
>>>>>>> origin/continuum
			ab=assertion_body();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ab.getTree());

<<<<<<< HEAD
			RASS263=(Token)match(input,RASS,FOLLOW_RASS_in_assertion12140); if (state.failed) return retval;
=======
			RASS263=(Token)match(input,RASS,FOLLOW_RASS_in_assertion12148); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (MismatchedTokenException mte) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(mte,(BAST)retval.getTree());
			    tellBNF("\ntry using more parentheses near line "+
			      Integer.toString(ll.getLine()+startingLine)+", as if you\'re not parenthetic enough already"+
			      "\n",mte,retval.tree);
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.AssertionBNF,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion"


	public static class assertion_body_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_body"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2931:1: assertion_body : ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) );
	public final BLESStoASTParser.assertion_body_return assertion_body() throws RecognitionException {
		BLESStoASTParser.assertion_body_return retval = new BLESStoASTParser.assertion_body_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token cln=null;
		Token COLON264=null;
		Token ASSIGN265=null;
		Token ASSIGN266=null;
		ParserRuleReturnScope a =null;
		ParserRuleReturnScope lv1 =null;
		ParserRuleReturnScope ae =null;
		ParserRuleReturnScope lv =null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope p3 =null;

		BAST cln_tree=null;
		BAST COLON264_tree=null;
		BAST ASSIGN265_tree=null;
		BAST ASSIGN266_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion_enumeration=new RewriteRuleSubtreeStream(adaptor,"rule assertion_enumeration");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_formal_assertion_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_assertion_parameter_list");
		RewriteRuleSubtreeStream stream_assertion_function_value=new RewriteRuleSubtreeStream(adaptor,"rule assertion_function_value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2938:3: ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) )
			int alt162=6;
			alt162 = dfa162.predict(input);
			switch (alt162) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2940:3: (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2940:3: (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2940:5: a= identifier cln= COLON lv1= identifier ae= assertion_enumeration
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_assertion_body12195);
=======
					pushFollow(FOLLOW_identifier_in_assertion_body12203);
>>>>>>> origin/continuum
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
<<<<<<< HEAD
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12199); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					pushFollow(FOLLOW_identifier_in_assertion_body12203);
=======
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12207); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					pushFollow(FOLLOW_identifier_in_assertion_body12211);
>>>>>>> origin/continuum
					lv1=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(lv1.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12207);
=======
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12215);
>>>>>>> origin/continuum
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_enumeration.add(ae.getTree());
					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: ae, a, lv1
=======
					// elements: lv1, a, ae
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: a, ae, lv1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
					RewriteRuleSubtreeStream stream_lv1=new RewriteRuleSubtreeStream(adaptor,"rule lv1",lv1!=null?lv1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2941:5: -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2941:8: ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ENUMERATION, (a!=null?((BAST)a.getTree()):null).getToken(), "ASSERTION_ENUMERATION["+Integer.toString((a!=null?((BAST)a.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2943:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2943:22: ^( PARAMETERS $lv1)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv1.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_ae.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2946:3: ae= assertion_enumeration
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12263);
=======
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12271);
>>>>>>> origin/continuum
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_enumeration.add(ae.getTree());
					// AST REWRITE
					// elements: ae
					// token labels: 
					// rule labels: ae, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2947:5: -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2947:8: ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ENUMERATION, (ae!=null?((BAST)ae.getTree()):null).getToken(), "ASSERTION_ENUMERATION["+Integer.toString((ae!=null?((BAST)ae.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_ae.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:5: a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_assertion_body12290);
=======
					pushFollow(FOLLOW_identifier_in_assertion_body12298);
>>>>>>> origin/continuum
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
<<<<<<< HEAD
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12294); if (state.failed) return retval; 
=======
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12302); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:30: (lv= formal_assertion_parameter_list )?
					int alt160=2;
					int LA160_0 = input.LA(1);
					if ( (LA160_0==ID) ) {
						alt160=1;
					}
					switch (alt160) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:30: lv= formal_assertion_parameter_list
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12298);
=======
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12306);
>>>>>>> origin/continuum
							lv=formal_assertion_parameter_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_formal_assertion_parameter_list.add(lv.getTree());
							}
							break;

					}

<<<<<<< HEAD
					COLON264=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12301); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON264);

					pushFollow(FOLLOW_predicate_in_assertion_body12305);
=======
					COLON264=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12309); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON264);

					pushFollow(FOLLOW_predicate_in_assertion_body12313);
>>>>>>> origin/continuum
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					}

					// AST REWRITE
					// elements: a, p, p, a, lv
					// token labels: 
					// rule labels: p, a, lv, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2951:5: -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p)
					if (lv!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2951:20: ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p!=null?((BAST)p.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2952:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2952:22: ^( PARAMETERS $lv)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2953:5: -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2953:9: ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p!=null?((BAST)p.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2956:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2956:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2956:5: a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_assertion_body12397);
=======
					pushFollow(FOLLOW_identifier_in_assertion_body12405);
>>>>>>> origin/continuum
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
<<<<<<< HEAD
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12401); if (state.failed) return retval; 
=======
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12409); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2956:30: (lv= formal_assertion_parameter_list )?
					int alt161=2;
					int LA161_0 = input.LA(1);
					if ( (LA161_0==ID) ) {
						alt161=1;
					}
					switch (alt161) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2956:30: lv= formal_assertion_parameter_list
							{
<<<<<<< HEAD
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12405);
=======
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12413);
>>>>>>> origin/continuum
							lv=formal_assertion_parameter_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_formal_assertion_parameter_list.add(lv.getTree());
							}
							break;

					}

<<<<<<< HEAD
					ASSIGN265=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12408); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN265);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12412);
=======
					ASSIGN265=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12416); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN265);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12420);
>>>>>>> origin/continuum
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_value.add(e.getTree());
					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: a, e, e, a, lv
=======
					// elements: a, lv, e, a, e
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: a, e, lv, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2957:5: -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e)
					if (lv!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2957:20: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:22: ^( PARAMETERS $lv)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2960:5: -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2960:8: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2962:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2967:5: ( ASSIGN e= assertion_function_value )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2967:5: ( ASSIGN e= assertion_function_value )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2967:7: ASSIGN e= assertion_function_value
					{
<<<<<<< HEAD
					ASSIGN266=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12503); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN266);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12507);
=======
					ASSIGN266=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12511); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN266);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12515);
>>>>>>> origin/continuum
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_value.add(e.getTree());
					}

					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2968:5: -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2968:8: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2972:5: p3= predicate
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_predicate_in_assertion_body12543);
=======
					pushFollow(FOLLOW_predicate_in_assertion_body12551);
>>>>>>> origin/continuum
					p3=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p3.getTree());
					// AST REWRITE
					// elements: p3
					// token labels: 
					// rule labels: p3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p3=new RewriteRuleSubtreeStream(adaptor,"rule p3",p3!=null?p3.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2973:5: -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2973:8: ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p3!=null?((BAST)p3.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p3!=null?((BAST)p3.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_p3.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (YouIdiot yi) {
			yi.handleException();
		}
		catch (RecognitionException re) {
			 
			    Dump.it("Could you be missing parentheses?");
			    tellBNF(GrammarStrings.assertionBody,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_body"


	public static class formal_assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2982:1: formal_assertion_parameter : ID TILDE ^ type_name ;
	public final BLESStoASTParser.formal_assertion_parameter_return formal_assertion_parameter() throws RecognitionException {
		BLESStoASTParser.formal_assertion_parameter_return retval = new BLESStoASTParser.formal_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID267=null;
		Token TILDE268=null;
		ParserRuleReturnScope type_name269 =null;

		BAST ID267_tree=null;
		BAST TILDE268_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2983:3: ( ID TILDE ^ type_name )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2984:17: ID TILDE ^ type_name
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			ID267=(Token)match(input,ID,FOLLOW_ID_in_formal_assertion_parameter12594); if (state.failed) return retval;
=======
			ID267=(Token)match(input,ID,FOLLOW_ID_in_formal_assertion_parameter12602); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ID267_tree = (BAST)adaptor.create(ID267);
			adaptor.addChild(root_0, ID267_tree);
			}

<<<<<<< HEAD
			TILDE268=(Token)match(input,TILDE,FOLLOW_TILDE_in_formal_assertion_parameter12596); if (state.failed) return retval;
=======
			TILDE268=(Token)match(input,TILDE,FOLLOW_TILDE_in_formal_assertion_parameter12604); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			TILDE268_tree = (BAST)adaptor.create(TILDE268);
			root_0 = (BAST)adaptor.becomeRoot(TILDE268_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_type_name_in_formal_assertion_parameter12599);
=======
			pushFollow(FOLLOW_type_name_in_formal_assertion_parameter12607);
>>>>>>> origin/continuum
			type_name269=type_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type_name269.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter"


	public static class formal_assertion_parameter_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_assertion_parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2987:1: formal_assertion_parameter_list : formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )? ;
	public final BLESStoASTParser.formal_assertion_parameter_list_return formal_assertion_parameter_list() throws RecognitionException {
		BLESStoASTParser.formal_assertion_parameter_list_return retval = new BLESStoASTParser.formal_assertion_parameter_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA271=null;
		Token COMMA273=null;
		ParserRuleReturnScope formal_assertion_parameter270 =null;
		ParserRuleReturnScope formal_assertion_parameter272 =null;
		ParserRuleReturnScope formal_assertion_parameter274 =null;

		BAST COMMA271_tree=null;
		BAST COMMA273_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2988:3: ( formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2989:3: formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )?
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12615);
=======
			pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12623);
>>>>>>> origin/continuum
			formal_assertion_parameter270=formal_assertion_parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter270.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2989:30: ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )?
			int alt164=2;
			int LA164_0 = input.LA(1);
			if ( (LA164_0==COMMA) ) {
				alt164=1;
			}
			switch (alt164) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2989:32: COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )*
					{
<<<<<<< HEAD
					COMMA271=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12619); if (state.failed) return retval;
=======
					COMMA271=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12627); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					COMMA271_tree = (BAST)adaptor.create(COMMA271);
					root_0 = (BAST)adaptor.becomeRoot(COMMA271_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12622);
=======
					pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12630);
>>>>>>> origin/continuum
					formal_assertion_parameter272=formal_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter272.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2990:6: ( COMMA formal_assertion_parameter )*
					loop163:
					while (true) {
						int alt163=2;
						int LA163_0 = input.LA(1);
						if ( (LA163_0==COMMA) ) {
							alt163=1;
						}

						switch (alt163) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2990:8: COMMA formal_assertion_parameter
							{
<<<<<<< HEAD
							COMMA273=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12631); if (state.failed) return retval;
=======
							COMMA273=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12639); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							COMMA273_tree = (BAST)adaptor.create(COMMA273);
							adaptor.addChild(root_0, COMMA273_tree);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12633);
=======
							pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12641);
>>>>>>> origin/continuum
							formal_assertion_parameter274=formal_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter274.getTree());

							}
							break;

						default :
							break loop163;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter_list"


	public static class assertion_function_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_function_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2993:1: assertion_function_value : ( ( parenthesized_predicate IMP )=>cae= conditional_assertion_function -> $cae|e= assertion_expression -> $e);
	public final BLESStoASTParser.assertion_function_value_return assertion_function_value() throws RecognitionException {
		BLESStoASTParser.assertion_function_value_return retval = new BLESStoASTParser.assertion_function_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope cae =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_conditional_assertion_function=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_function");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2994:3: ( ( parenthesized_predicate IMP )=>cae= conditional_assertion_function -> $cae|e= assertion_expression -> $e)
			int alt165=2;
			int LA165_0 = input.LA(1);
			if ( (LA165_0==LPAREN) ) {
				int LA165_1 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt165=1;
				}
				else if ( (true) ) {
					alt165=2;
				}

			}
			else if ( (LA165_0==AADL_STRING_LITERAL||LA165_0==ID||LA165_0==INTEGER_LIT||LA165_0==LBRACKET||LA165_0==LITERAL_abs||LA165_0==LITERAL_complex||LA165_0==LITERAL_false||LA165_0==LITERAL_in||LA165_0==LITERAL_integer||LA165_0==LITERAL_natural||LA165_0==LITERAL_now||(LA165_0 >= LITERAL_null && LA165_0 <= LITERAL_numberof)||LA165_0==LITERAL_product||(LA165_0 >= LITERAL_rational && LA165_0 <= LITERAL_real)||LA165_0==LITERAL_self||LA165_0==LITERAL_sum||(LA165_0 >= LITERAL_time && LA165_0 <= LITERAL_timeout)||LA165_0==LITERAL_tops||LA165_0==LITERAL_true||LA165_0==MINUS||LA165_0==OCTOTHORPE||LA165_0==REAL_LIT) ) {
				alt165=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 165, 0, input);
				throw nvae;
			}

			switch (alt165) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2995:3: ( parenthesized_predicate IMP )=>cae= conditional_assertion_function
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_conditional_assertion_function_in_assertion_function_value12667);
=======
					pushFollow(FOLLOW_conditional_assertion_function_in_assertion_function_value12675);
>>>>>>> origin/continuum
					cae=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_function.add(cae.getTree());
					// AST REWRITE
					// elements: cae
					// token labels: 
					// rule labels: cae, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cae=new RewriteRuleSubtreeStream(adaptor,"rule cae",cae!=null?cae.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2997:5: -> $cae
					{
						adaptor.addChild(root_0, stream_cae.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2999:3: e= assertion_expression
					{
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_expression_in_assertion_function_value12686);
=======
					pushFollow(FOLLOW_assertion_expression_in_assertion_function_value12694);
>>>>>>> origin/continuum
					e=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3000:5: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_value"


	public static class conditional_assertion_function_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_assertion_function"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3003:1: conditional_assertion_function : ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN ) -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ ) ;
	public final BLESStoASTParser.conditional_assertion_function_return conditional_assertion_function() throws RecognitionException {
		BLESStoASTParser.conditional_assertion_function_return retval = new BLESStoASTParser.conditional_assertion_function_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token LPAREN275=null;
		Token COMMA276=null;
		Token RPAREN277=null;
		List<Object> list_cvp=null;
		RuleReturnScope cvp = null;
		BAST c_tree=null;
		BAST LPAREN275_tree=null;
		BAST COMMA276_tree=null;
		BAST RPAREN277_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_condition_value_pair=new RewriteRuleSubtreeStream(adaptor,"rule condition_value_pair");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3004:3: ( ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN ) -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3005:3: ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3005:3: ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3005:5: LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN
			{
<<<<<<< HEAD
			LPAREN275=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_function12712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN275);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12719);
=======
			LPAREN275=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_function12720); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN275);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12727);
>>>>>>> origin/continuum
			cvp=condition_value_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
			if (list_cvp==null) list_cvp=new ArrayList<Object>();
			list_cvp.add(cvp.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3006:30: (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3006:32: c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )*
			{
<<<<<<< HEAD
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12725); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12729);
=======
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12733); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12737);
>>>>>>> origin/continuum
			cvp=condition_value_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
			if (list_cvp==null) list_cvp=new ArrayList<Object>();
			list_cvp.add(cvp.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3007:4: ( COMMA cvp+= condition_value_pair )*
			loop166:
			while (true) {
				int alt166=2;
				int LA166_0 = input.LA(1);
				if ( (LA166_0==COMMA) ) {
					alt166=1;
				}

				switch (alt166) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3007:5: COMMA cvp+= condition_value_pair
					{
<<<<<<< HEAD
					COMMA276=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12736); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA276);

					pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12740);
=======
					COMMA276=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12744); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA276);

					pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12748);
>>>>>>> origin/continuum
					cvp=condition_value_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
					if (list_cvp==null) list_cvp=new ArrayList<Object>();
					list_cvp.add(cvp.getTree());
					}
					break;

				default :
					break loop166;
				}
			}

			}

<<<<<<< HEAD
			RPAREN277=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_function12750); if (state.failed) return retval; 
=======
			RPAREN277=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_function12758); if (state.failed) return retval; 
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN277);

			}

			// AST REWRITE
			// elements: cvp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: cvp
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_cvp=new RewriteRuleSubtreeStream(adaptor,"token cvp",list_cvp);
			root_0 = (BAST)adaptor.nil();
			// 3009:5: -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3009:8: ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL_FUNCTION, c), root_1);
				if ( !(stream_cvp.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_cvp.hasNext() ) {
					adaptor.addChild(root_1, stream_cvp.nextTree());
				}
				stream_cvp.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_function"


	public static class condition_value_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "condition_value_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3013:1: condition_value_pair : parenthesized_predicate IMP ^ assertion_expression ;
	public final BLESStoASTParser.condition_value_pair_return condition_value_pair() throws RecognitionException {
		BLESStoASTParser.condition_value_pair_return retval = new BLESStoASTParser.condition_value_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token IMP279=null;
		ParserRuleReturnScope parenthesized_predicate278 =null;
		ParserRuleReturnScope assertion_expression280 =null;

		BAST IMP279_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3014:3: ( parenthesized_predicate IMP ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3015:3: parenthesized_predicate IMP ^ assertion_expression
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_parenthesized_predicate_in_condition_value_pair12791);
=======
			pushFollow(FOLLOW_parenthesized_predicate_in_condition_value_pair12799);
>>>>>>> origin/continuum
			parenthesized_predicate278=parenthesized_predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_predicate278.getTree());

<<<<<<< HEAD
			IMP279=(Token)match(input,IMP,FOLLOW_IMP_in_condition_value_pair12793); if (state.failed) return retval;
=======
			IMP279=(Token)match(input,IMP,FOLLOW_IMP_in_condition_value_pair12801); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			IMP279_tree = (BAST)adaptor.create(IMP279);
			root_0 = (BAST)adaptor.becomeRoot(IMP279_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_assertion_expression_in_condition_value_pair12796);
=======
			pushFollow(FOLLOW_assertion_expression_in_condition_value_pair12804);
>>>>>>> origin/continuum
			assertion_expression280=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression280.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "condition_value_pair"


	public static class assertion_enumeration_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_enumeration"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3016:1: assertion_enumeration : ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:1: assertion_enumeration : ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_enumeration_return assertion_enumeration() throws RecognitionException {
		BLESStoASTParser.assertion_enumeration_return retval = new BLESStoASTParser.assertion_enumeration_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token PLUS_ARROW281=null;
		Token COMMA283=null;
		Token PLUS_ARROW285=null;
		ParserRuleReturnScope enumeration_pair282 =null;
		ParserRuleReturnScope enumeration_pair284 =null;
		ParserRuleReturnScope predicate_invocation286 =null;

		BAST PLUS_ARROW281_tree=null;
		BAST COMMA283_tree=null;
		BAST PLUS_ARROW285_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3017:3: ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3019:3: ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) )
>>>>>>> origin/continuum
			int alt168=2;
			int LA168_0 = input.LA(1);
			if ( (LA168_0==PLUS_ARROW) ) {
				int LA168_1 = input.LA(2);
				if ( (LA168_1==ID) ) {
					int LA168_2 = input.LA(3);
					if ( (LA168_2==IMP) ) {
						alt168=1;
					}
					else if ( (LA168_2==LPAREN) ) {
						alt168=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 168, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 168, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 168, 0, input);
				throw nvae;
			}

			switch (alt168) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:3: ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* )
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:3: ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:4: PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )*
					{
<<<<<<< HEAD
					PLUS_ARROW281=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12814); if (state.failed) return retval;
=======
					PLUS_ARROW281=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12822); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					PLUS_ARROW281_tree = (BAST)adaptor.create(PLUS_ARROW281);
					root_0 = (BAST)adaptor.becomeRoot(PLUS_ARROW281_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12817);
=======
					pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12825);
>>>>>>> origin/continuum
					enumeration_pair282=enumeration_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_pair282.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:33: ( COMMA ! enumeration_pair )*
					loop167:
					while (true) {
						int alt167=2;
						int LA167_0 = input.LA(1);
						if ( (LA167_0==COMMA) ) {
							alt167=1;
						}

						switch (alt167) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:34: COMMA ! enumeration_pair
							{
<<<<<<< HEAD
							COMMA283=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_enumeration12820); if (state.failed) return retval;
							pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12823);
=======
							COMMA283=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_enumeration12828); if (state.failed) return retval;
							pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12831);
>>>>>>> origin/continuum
							enumeration_pair284=enumeration_pair();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_pair284.getTree());

							}
							break;

						default :
							break loop167;
						}
					}

					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:3: ( PLUS_ARROW ^ predicate_invocation )
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3022:3: ( PLUS_ARROW ^ predicate_invocation )
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:3: ( PLUS_ARROW ^ predicate_invocation )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3020:4: PLUS_ARROW ^ predicate_invocation
					{
					PLUS_ARROW285=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12838); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3022:3: ( PLUS_ARROW ^ predicate_invocation )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3022:4: PLUS_ARROW ^ predicate_invocation
					{
					PLUS_ARROW285=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12846); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					PLUS_ARROW285_tree = (BAST)adaptor.create(PLUS_ARROW285);
					root_0 = (BAST)adaptor.becomeRoot(PLUS_ARROW285_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_predicate_invocation_in_assertion_enumeration12841);
=======
					pushFollow(FOLLOW_predicate_invocation_in_assertion_enumeration12849);
>>>>>>> origin/continuum
					predicate_invocation286=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate_invocation286.getTree());

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_enumeration"


	public static class enumeration_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3025:1: enumeration_pair : ID ^ IMP ! predicate ;
	public final BLESStoASTParser.enumeration_pair_return enumeration_pair() throws RecognitionException {
		BLESStoASTParser.enumeration_pair_return retval = new BLESStoASTParser.enumeration_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID287=null;
		Token IMP288=null;
		ParserRuleReturnScope predicate289 =null;

		BAST ID287_tree=null;
		BAST IMP288_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3026:3: ( ID ^ IMP ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3027:27: ID ^ IMP ! predicate
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			ID287=(Token)match(input,ID,FOLLOW_ID_in_enumeration_pair12860); if (state.failed) return retval;
=======
			ID287=(Token)match(input,ID,FOLLOW_ID_in_enumeration_pair12868); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ID287_tree = (BAST)adaptor.create(ID287);
			root_0 = (BAST)adaptor.becomeRoot(ID287_tree, root_0);
			}

<<<<<<< HEAD
			IMP288=(Token)match(input,IMP,FOLLOW_IMP_in_enumeration_pair12863); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_enumeration_pair12866);
=======
			IMP288=(Token)match(input,IMP,FOLLOW_IMP_in_enumeration_pair12871); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_enumeration_pair12874);
>>>>>>> origin/continuum
			predicate289=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate289.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_pair"


	public static class universal_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "universal_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3030:1: universal_quantification : a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate ;
	public final BLESStoASTParser.universal_quantification_return universal_quantification() throws RecognitionException {
		BLESStoASTParser.universal_quantification_return retval = new BLESStoASTParser.universal_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		Token r=null;
		ParserRuleReturnScope logic_variables290 =null;
		ParserRuleReturnScope logic_variable_domain291 =null;
		ParserRuleReturnScope predicate292 =null;

		BAST a_tree=null;
		BAST r_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3031:3: (a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3032:3: a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_universal_quantification12885); if (state.failed) return retval;
=======
			a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_universal_quantification12893); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			a_tree = (BAST)adaptor.create(a);
			root_0 = (BAST)adaptor.becomeRoot(a_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_logic_variables_in_universal_quantification12888);
=======
			pushFollow(FOLLOW_logic_variables_in_universal_quantification12896);
>>>>>>> origin/continuum
			logic_variables290=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variables290.getTree());

<<<<<<< HEAD
			pushFollow(FOLLOW_logic_variable_domain_in_universal_quantification12890);
=======
			pushFollow(FOLLOW_logic_variable_domain_in_universal_quantification12898);
>>>>>>> origin/continuum
			logic_variable_domain291=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variable_domain291.getTree());

<<<<<<< HEAD
			r=(Token)match(input,LITERAL_are,FOLLOW_LITERAL_are_in_universal_quantification12894); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_universal_quantification12897);
=======
			r=(Token)match(input,LITERAL_are,FOLLOW_LITERAL_are_in_universal_quantification12902); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_universal_quantification12905);
>>>>>>> origin/continuum
			predicate292=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate292.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			   Dump.it("RecognitionException caught by BLESStoAST.universal_quantification");
			   Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
			    tellBNF(GrammarStrings.universalQuantification,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_quantification"


	public static class existential_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "existential_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3040:1: existential_quantification : e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate ;
	public final BLESStoASTParser.existential_quantification_return existential_quantification() throws RecognitionException {
		BLESStoASTParser.existential_quantification_return retval = new BLESStoASTParser.existential_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token e=null;
		Token t=null;
		ParserRuleReturnScope logic_variables293 =null;
		ParserRuleReturnScope logic_variable_domain294 =null;
		ParserRuleReturnScope predicate295 =null;

		BAST e_tree=null;
		BAST t_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3041:3: (e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3042:3: e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			e=(Token)match(input,LITERAL_exists,FOLLOW_LITERAL_exists_in_existential_quantification12923); if (state.failed) return retval;
=======
			e=(Token)match(input,LITERAL_exists,FOLLOW_LITERAL_exists_in_existential_quantification12931); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			e_tree = (BAST)adaptor.create(e);
			root_0 = (BAST)adaptor.becomeRoot(e_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_logic_variables_in_existential_quantification12926);
=======
			pushFollow(FOLLOW_logic_variables_in_existential_quantification12934);
>>>>>>> origin/continuum
			logic_variables293=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variables293.getTree());

<<<<<<< HEAD
			pushFollow(FOLLOW_logic_variable_domain_in_existential_quantification12928);
=======
			pushFollow(FOLLOW_logic_variable_domain_in_existential_quantification12936);
>>>>>>> origin/continuum
			logic_variable_domain294=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variable_domain294.getTree());

<<<<<<< HEAD
			t=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_existential_quantification12932); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_existential_quantification12935);
=======
			t=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_existential_quantification12940); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_existential_quantification12943);
>>>>>>> origin/continuum
			predicate295=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate295.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("RecognitionException caught by BLESStoAST.existential_quantification");
			    tellBNF(GrammarStrings.existentialQuantification,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_quantification"


	public static class logic_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logic_variables"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3047:1: logic_variables : (i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) |i2= identifier TILDE aty2= assertion_type -> ^( COLON $aty2 $i2) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:1: logic_variables :i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.logic_variables_return logic_variables() throws RecognitionException {
		BLESStoASTParser.logic_variables_return retval = new BLESStoASTParser.logic_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token coln=null;
		Token COMMA296=null;
		Token TILDE297=null;
		List<Object> list_i=null;
		ParserRuleReturnScope aty =null;
		ParserRuleReturnScope i2 =null;
		ParserRuleReturnScope aty2 =null;
		RuleReturnScope i = null;
		BAST coln_tree=null;
		BAST COMMA296_tree=null;
		BAST TILDE297_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_TILDE=new RewriteRuleTokenStream(adaptor,"token TILDE");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion_type=new RewriteRuleSubtreeStream(adaptor,"rule assertion_type");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3048:3: (i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) |i2= identifier TILDE aty2= assertion_type -> ^( COLON $aty2 $i2) )
			int alt170=2;
			int LA170_0 = input.LA(1);
			if ( (LA170_0==ID) ) {
				int LA170_1 = input.LA(2);
				if ( ((LA170_1 >= COLON && LA170_1 <= COMMA)) ) {
					alt170=1;
				}
				else if ( (LA170_1==TILDE) ) {
					alt170=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 170, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 170, 0, input);
				throw nvae;
			}

			switch (alt170) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:3: i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type
					{
					pushFollow(FOLLOW_identifier_in_logic_variables12963);
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3050:3: (i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3051:3: i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type
			{
			pushFollow(FOLLOW_identifier_in_logic_variables12971);
			i=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
			if (list_i==null) list_i=new ArrayList<Object>();
			list_i.add(i.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3051:17: ( COMMA i+= identifier )*
			loop169:
			while (true) {
				int alt169=2;
				int LA169_0 = input.LA(1);
				if ( (LA169_0==COMMA) ) {
					alt169=1;
				}

				switch (alt169) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3051:18: COMMA i+= identifier
					{
					COMMA296=(Token)match(input,COMMA,FOLLOW_COMMA_in_logic_variables12974); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA296);

					pushFollow(FOLLOW_identifier_in_logic_variables12978);
>>>>>>> origin/continuum
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:17: ( COMMA i+= identifier )*
					loop169:
					while (true) {
						int alt169=2;
						int LA169_0 = input.LA(1);
						if ( (LA169_0==COMMA) ) {
							alt169=1;
						}

						switch (alt169) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3049:18: COMMA i+= identifier
							{
							COMMA296=(Token)match(input,COMMA,FOLLOW_COMMA_in_logic_variables12966); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA296);

							pushFollow(FOLLOW_identifier_in_logic_variables12970);
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							break loop169;
						}
					}

					coln=(Token)match(input,COLON,FOLLOW_COLON_in_logic_variables12976); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(coln);

					pushFollow(FOLLOW_assertion_type_in_logic_variables12980);
					aty=assertion_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_type.add(aty.getTree());
					// AST REWRITE
					// elements: i, aty, coln
					// token labels: coln
					// rule labels: aty, retval
					// token list labels: 
					// rule list labels: i
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_coln=new RewriteRuleTokenStream(adaptor,"token coln",coln);
					RewriteRuleSubtreeStream stream_aty=new RewriteRuleSubtreeStream(adaptor,"rule aty",aty!=null?aty.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
					root_0 = (BAST)adaptor.nil();
					// 3050:5: -> ^( $coln $aty ( $i)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3050:8: ^( $coln $aty ( $i)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_coln.nextNode(), root_1);
						adaptor.addChild(root_1, stream_aty.nextTree());
						if ( !(stream_i.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_i.hasNext() ) {
							adaptor.addChild(root_1, stream_i.nextTree());
						}
						stream_i.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3052:3: i2= identifier TILDE aty2= assertion_type
					{
					pushFollow(FOLLOW_identifier_in_logic_variables13012);
					i2=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i2.getTree());
					TILDE297=(Token)match(input,TILDE,FOLLOW_TILDE_in_logic_variables13014); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TILDE.add(TILDE297);

					pushFollow(FOLLOW_assertion_type_in_logic_variables13018);
					aty2=assertion_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_type.add(aty2.getTree());
					// AST REWRITE
					// elements: i2, aty2
					// token labels: 
					// rule labels: aty2, i2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_aty2=new RewriteRuleSubtreeStream(adaptor,"rule aty2",aty2!=null?aty2.getTree():null);
					RewriteRuleSubtreeStream stream_i2=new RewriteRuleSubtreeStream(adaptor,"rule i2",i2!=null?i2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3053:5: -> ^( COLON $aty2 $i2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3053:8: ^( COLON $aty2 $i2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COLON, "COLON"), root_1);
						adaptor.addChild(root_1, stream_aty2.nextTree());
						adaptor.addChild(root_1, stream_i2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
<<<<<<< HEAD
=======

			coln=(Token)match(input,COLON,FOLLOW_COLON_in_logic_variables12984); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(coln);

			pushFollow(FOLLOW_assertion_type_in_logic_variables12988);
			aty=assertion_type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion_type.add(aty.getTree());
			// AST REWRITE
			// elements: aty, i, coln
			// token labels: coln
			// rule labels: aty, retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_coln=new RewriteRuleTokenStream(adaptor,"token coln",coln);
			RewriteRuleSubtreeStream stream_aty=new RewriteRuleSubtreeStream(adaptor,"rule aty",aty!=null?aty.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (BAST)adaptor.nil();
			// 3052:5: -> ^( $coln $aty ( $i)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3052:8: ^( $coln $aty ( $i)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_coln.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aty.nextTree());
				if ( !(stream_i.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_i.hasNext() ) {
					adaptor.addChild(root_1, stream_i.nextTree());
				}
				stream_i.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

>>>>>>> origin/continuum
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("RecognitionException caught by BLESStoAST.logic_variables");
			    tellBNF(GrammarStrings.logicVariables,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variables"


	public static class logic_variable_domain_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logic_variable_domain"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3061:1: logic_variable_domain : i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3060:1: logic_variable_domain : i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.logic_variable_domain_return logic_variable_domain() throws RecognitionException {
		BLESStoASTParser.logic_variable_domain_return retval = new BLESStoASTParser.logic_variable_domain_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token i=null;
		ParserRuleReturnScope l =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope predicate298 =null;

		BAST i_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleSubtreeStream stream_range_symbol=new RewriteRuleSubtreeStream(adaptor,"rule range_symbol");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3062:3: (i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3063:3: i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			{
			i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_logic_variable_domain13065); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:3: ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			int alt171=2;
			int LA171_0 = input.LA(1);
			if ( (LA171_0==LITERAL_sum) && (synpred8_BLESStoAST())) {
				alt171=1;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3061:3: (i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3062:3: i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			{
			i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_logic_variable_domain13040); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3063:3: ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			int alt170=2;
			int LA170_0 = input.LA(1);
			if ( (LA170_0==LITERAL_sum) && (synpred8_BLESStoAST())) {
				alt170=1;
>>>>>>> origin/continuum
			}
			else if ( (LA171_0==LITERAL_product) && (synpred8_BLESStoAST())) {
				alt171=1;
			}
			else if ( (LA171_0==LITERAL_numberof) && (synpred8_BLESStoAST())) {
				alt171=1;
			}
			else if ( (LA171_0==MINUS) ) {
				int LA171_4 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_abs) ) {
				int LA171_5 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_true) ) {
				int LA171_6 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_false) ) {
				int LA171_7 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==INTEGER_LIT) ) {
				int LA171_8 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==REAL_LIT) ) {
				int LA171_9 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LBRACKET) ) {
				int LA171_10 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==ID) ) {
				int LA171_11 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==OCTOTHORPE) ) {
				int LA171_12 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_self) ) {
				int LA171_13 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==AADL_STRING_LITERAL) ) {
				int LA171_14 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_in) ) {
				int LA171_15 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_timeout) ) {
				int LA171_16 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_null) ) {
				int LA171_17 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_now) ) {
				int LA171_18 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_tops) ) {
				int LA171_19 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LPAREN) ) {
				int LA171_20 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_natural) ) {
				int LA171_21 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_integer) ) {
				int LA171_22 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_rational) ) {
				int LA171_23 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_real) ) {
				int LA171_24 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_complex) ) {
				int LA171_25 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_time) ) {
				int LA171_26 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt171=1;
				}
				else if ( (true) ) {
					alt171=2;
				}

			}
			else if ( (LA171_0==LITERAL_all||LA171_0==LITERAL_def||LA171_0==LITERAL_exists||LA171_0==LITERAL_not||LA171_0==LITERAL_stop) ) {
				alt171=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 171, 0, input);
				throw nvae;
			}

			switch (alt171) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3065:5: ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13094);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:5: ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13069);
>>>>>>> origin/continuum
					l=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(l.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_range_symbol_in_logic_variable_domain13098);
=======
					pushFollow(FOLLOW_range_symbol_in_logic_variable_domain13073);
>>>>>>> origin/continuum
					rs=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_range_symbol.add(rs.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13102);
=======
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13077);
>>>>>>> origin/continuum
					r=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(r.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: i, r, rs, l
=======
					// elements: l, i, rs, r
>>>>>>> origin/continuum
					// token labels: i
					// rule labels: rs, r, l, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
					RewriteRuleSubtreeStream stream_l=new RewriteRuleSubtreeStream(adaptor,"rule l",l!=null?l.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3067:5: -> ^( $i ^( $rs $l $r) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3067:8: ^( $i ^( $rs $l $r) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3067:13: ^( $rs $l $r)
=======
					// 3066:5: -> ^( $i ^( $rs $l $r) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3066:8: ^( $i ^( $rs $l $r) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3066:13: ^( $rs $l $r)
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_2);
						adaptor.addChild(root_2, stream_l.nextTree());
						adaptor.addChild(root_2, stream_r.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3069:3: predicate
					{
					pushFollow(FOLLOW_predicate_in_logic_variable_domain13137);
					predicate298=predicate();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3068:3: predicate
					{
					pushFollow(FOLLOW_predicate_in_logic_variable_domain13112);
					predicate297=predicate();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(predicate298.getTree());
					// AST REWRITE
					// elements: predicate, i
					// token labels: i
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3070:5: -> ^( $i predicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3070:8: ^( $i predicate )
=======
					// 3069:5: -> ^( $i predicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3069:8: ^( $i predicate )
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						adaptor.addChild(root_1, stream_predicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (MismatchedTokenException re) {
			Dump.it("MismatchedTokenException caught by BLESStoAST.logic_variable_domain");
			    Dump.it("\ntry bounding your quantification, eat less food too\n");
			    tellBNF(GrammarStrings.logicVariableDomain,re,retval.tree);
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.logic_variable_domain");
			    tellBNF(GrammarStrings.logicVariableDomain,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variable_domain"


	public static class predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "predicate"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3080:1: predicate : ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3079:1: predicate : ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? );
>>>>>>> origin/continuum
	public final BLESStoASTParser.predicate_return predicate() throws RecognitionException {
		BLESStoASTParser.predicate_return retval = new BLESStoASTParser.predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token imp=null;
		Token i=null;
		Token a=null;
		Token LITERAL_and302=null;
		Token LITERAL_and304=null;
		Token LITERAL_or306=null;
		Token LITERAL_or308=null;
		Token LITERAL_xor310=null;
		Token LITERAL_xor312=null;
		ParserRuleReturnScope universal_quantification299 =null;
		ParserRuleReturnScope existential_quantification300 =null;
		ParserRuleReturnScope subpredicate301 =null;
		ParserRuleReturnScope subpredicate303 =null;
		ParserRuleReturnScope subpredicate305 =null;
		ParserRuleReturnScope subpredicate307 =null;
		ParserRuleReturnScope subpredicate309 =null;
		ParserRuleReturnScope subpredicate311 =null;
		ParserRuleReturnScope subpredicate313 =null;
		ParserRuleReturnScope subpredicate314 =null;
		ParserRuleReturnScope subpredicate315 =null;
		ParserRuleReturnScope subpredicate316 =null;

		BAST imp_tree=null;
		BAST i_tree=null;
		BAST a_tree=null;
		BAST LITERAL_and302_tree=null;
		BAST LITERAL_and304_tree=null;
		BAST LITERAL_or306_tree=null;
		BAST LITERAL_or308_tree=null;
		BAST LITERAL_xor310_tree=null;
		BAST LITERAL_xor312_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3081:3: ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? )
			int alt176=3;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3080:3: ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? )
			int alt175=3;
>>>>>>> origin/continuum
			switch ( input.LA(1) ) {
			case LITERAL_all:
				{
				alt176=1;
				}
				break;
			case LITERAL_exists:
				{
				alt176=2;
				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_def:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_stop:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt176=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 176, 0, input);
				throw nvae;
			}
			switch (alt176) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3082:3: universal_quantification
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3081:3: universal_quantification
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_universal_quantification_in_predicate13197);
					universal_quantification299=universal_quantification();
=======
					pushFollow(FOLLOW_universal_quantification_in_predicate13172);
					universal_quantification298=universal_quantification();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, universal_quantification299.getTree());

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3084:3: existential_quantification
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3083:3: existential_quantification
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_existential_quantification_in_predicate13205);
					existential_quantification300=existential_quantification();
=======
					pushFollow(FOLLOW_existential_quantification_in_predicate13180);
					existential_quantification299=existential_quantification();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, existential_quantification300.getTree());

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3086:3: subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3085:3: subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_subpredicate_in_predicate13214);
					subpredicate301=subpredicate();
=======
					pushFollow(FOLLOW_subpredicate_in_predicate13189);
					subpredicate300=subpredicate();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate301.getTree());

<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:5: ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
					int alt175=7;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3086:5: ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
					int alt174=7;
>>>>>>> origin/continuum
					switch ( input.LA(1) ) {
						case LITERAL_and:
							{
							alt175=1;
							}
							break;
						case LITERAL_or:
							{
							alt175=2;
							}
							break;
						case LITERAL_xor:
							{
							alt175=3;
							}
							break;
						case LITERAL_implies:
							{
							alt175=4;
							}
							break;
						case LITERAL_iff:
							{
							alt175=5;
							}
							break;
						case IMP:
							{
							alt175=6;
							}
							break;
					}
					switch (alt175) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3088:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3088:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3088:7: LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )*
							{
							LITERAL_and302=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13232); if (state.failed) return retval;
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:7: LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )*
							{
							LITERAL_and301=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13207); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							LITERAL_and302_tree = (BAST)adaptor.create(LITERAL_and302);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_and302_tree, root_0);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_subpredicate_in_predicate13235);
							subpredicate303=subpredicate();
=======
							pushFollow(FOLLOW_subpredicate_in_predicate13210);
							subpredicate302=subpredicate();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate303.getTree());

<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3088:33: ( LITERAL_and ! subpredicate )*
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:33: ( LITERAL_and ! subpredicate )*
							loop171:
							while (true) {
								int alt171=2;
								int LA171_0 = input.LA(1);
								if ( (LA171_0==LITERAL_and) ) {
									alt171=1;
								}

								switch (alt171) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3087:35: LITERAL_and ! subpredicate
									{
									LITERAL_and303=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13214); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13217);
									subpredicate304=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate304.getTree());

									}
									break;

								default :
									break loop171;
								}
							}

							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:7: LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )*
							{
							LITERAL_or305=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13237); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_or305_tree = (BAST)adaptor.create(LITERAL_or305);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_or305_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13240);
							subpredicate306=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate306.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:32: ( LITERAL_or ! subpredicate )*
>>>>>>> origin/continuum
							loop172:
							while (true) {
								int alt172=2;
								int LA172_0 = input.LA(1);
								if ( (LA172_0==LITERAL_and) ) {
									alt172=1;
								}

								switch (alt172) {
								case 1 :
<<<<<<< HEAD
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3088:35: LITERAL_and ! subpredicate
									{
									LITERAL_and304=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13239); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13242);
									subpredicate305=subpredicate();
=======
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:34: LITERAL_or ! subpredicate
									{
									LITERAL_or307=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13244); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13247);
									subpredicate308=subpredicate();
>>>>>>> origin/continuum
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate305.getTree());

									}
									break;

								default :
									break loop172;
								}
							}

							}

							}
							break;
<<<<<<< HEAD
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:7: LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )*
							{
							LITERAL_or306=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13262); if (state.failed) return retval;
=======
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3091:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3091:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3091:7: LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )*
							{
							LITERAL_xor309=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13270); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							LITERAL_or306_tree = (BAST)adaptor.create(LITERAL_or306);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_or306_tree, root_0);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_subpredicate_in_predicate13265);
							subpredicate307=subpredicate();
=======
							pushFollow(FOLLOW_subpredicate_in_predicate13273);
							subpredicate310=subpredicate();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate307.getTree());

<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:32: ( LITERAL_or ! subpredicate )*
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3091:33: ( LITERAL_xor ! subpredicate )*
>>>>>>> origin/continuum
							loop173:
							while (true) {
								int alt173=2;
								int LA173_0 = input.LA(1);
								if ( (LA173_0==LITERAL_or) ) {
									alt173=1;
								}

								switch (alt173) {
								case 1 :
<<<<<<< HEAD
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:34: LITERAL_or ! subpredicate
									{
									LITERAL_or308=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13269); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13272);
									subpredicate309=subpredicate();
=======
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3091:35: LITERAL_xor ! subpredicate
									{
									LITERAL_xor311=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13277); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13280);
									subpredicate312=subpredicate();
>>>>>>> origin/continuum
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate309.getTree());

									}
									break;

								default :
									break loop173;
								}
							}

							}

							}
							break;
<<<<<<< HEAD
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:7: LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )*
							{
							LITERAL_xor310=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13295); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_xor310_tree = (BAST)adaptor.create(LITERAL_xor310);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_xor310_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13298);
							subpredicate311=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate311.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:33: ( LITERAL_xor ! subpredicate )*
							loop174:
							while (true) {
								int alt174=2;
								int LA174_0 = input.LA(1);
								if ( (LA174_0==LITERAL_xor) ) {
									alt174=1;
								}

								switch (alt174) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:35: LITERAL_xor ! subpredicate
									{
									LITERAL_xor312=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13302); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13305);
									subpredicate313=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate313.getTree());

									}
									break;

								default :
									break loop174;
								}
							}

							}

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3094:5: imp= LITERAL_implies ^ subpredicate
							{
							imp=(Token)match(input,LITERAL_implies,FOLLOW_LITERAL_implies_in_predicate13327); if (state.failed) return retval;
=======
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3093:5: imp= LITERAL_implies ^ subpredicate
							{
							imp=(Token)match(input,LITERAL_implies,FOLLOW_LITERAL_implies_in_predicate13302); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							imp_tree = (BAST)adaptor.create(imp);
							root_0 = (BAST)adaptor.becomeRoot(imp_tree, root_0);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_subpredicate_in_predicate13330);
=======
							pushFollow(FOLLOW_subpredicate_in_predicate13305);
							subpredicate313=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate313.getTree());

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3095:5: i= LITERAL_iff ^ subpredicate
							{
							i=(Token)match(input,LITERAL_iff,FOLLOW_LITERAL_iff_in_predicate13324); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							i_tree = (BAST)adaptor.create(i);
							root_0 = (BAST)adaptor.becomeRoot(i_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13327);
>>>>>>> origin/continuum
							subpredicate314=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate314.getTree());

							}
							break;
<<<<<<< HEAD
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3096:5: i= LITERAL_iff ^ subpredicate
							{
							i=(Token)match(input,LITERAL_iff,FOLLOW_LITERAL_iff_in_predicate13349); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							i_tree = (BAST)adaptor.create(i);
							root_0 = (BAST)adaptor.becomeRoot(i_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13352);
							subpredicate315=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate315.getTree());

							}
							break;
						case 6 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3098:5: a= IMP ^ subpredicate
							{
							a=(Token)match(input,IMP,FOLLOW_IMP_in_predicate13370); if (state.failed) return retval;
=======
						case 6 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3097:5: a= IMP ^ subpredicate
							{
							a=(Token)match(input,IMP,FOLLOW_IMP_in_predicate13345); if (state.failed) return retval;
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) {
							a_tree = (BAST)adaptor.create(a);
							root_0 = (BAST)adaptor.becomeRoot(a_tree, root_0);
							}

<<<<<<< HEAD
							pushFollow(FOLLOW_subpredicate_in_predicate13373);
							subpredicate316=subpredicate();
=======
							pushFollow(FOLLOW_subpredicate_in_predicate13348);
							subpredicate315=subpredicate();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate316.getTree());

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.predicate");
			    tellBNF(GrammarStrings.predicate,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate"


	public static class subpredicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subpredicate"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3105:1: subpredicate : (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3104:1: subpredicate : (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.subpredicate_return subpredicate() throws RecognitionException {
		BLESStoASTParser.subpredicate_return retval = new BLESStoASTParser.subpredicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token i=null;
		Token pe=null;
		Token tr=null;
		Token fa=null;
		Token st=null;
		Token d=null;
		ParserRuleReturnScope lhs =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope rhs =null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope ra =null;
		ParserRuleReturnScope target =null;
		ParserRuleReturnScope increment =null;
		ParserRuleReturnScope definedLogicVariable =null;
		ParserRuleReturnScope predicate_invocation317 =null;
		ParserRuleReturnScope timed_predicate318 =null;

		BAST n_tree=null;
		BAST i_tree=null;
		BAST pe_tree=null;
		BAST tr_tree=null;
		BAST fa_tree=null;
		BAST st_tree=null;
		BAST d_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_def=new RewriteRuleTokenStream(adaptor,"token LITERAL_def");
		RewriteRuleTokenStream stream_LITERAL_stop=new RewriteRuleTokenStream(adaptor,"token LITERAL_stop");
		RewriteRuleTokenStream stream_LITERAL_true=new RewriteRuleTokenStream(adaptor,"token LITERAL_true");
		RewriteRuleTokenStream stream_LITERAL_false=new RewriteRuleTokenStream(adaptor,"token LITERAL_false");
		RewriteRuleTokenStream stream_PLUS_EQUALS=new RewriteRuleTokenStream(adaptor,"token PLUS_EQUALS");
		RewriteRuleSubtreeStream stream_assertion_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_subexpression");
		RewriteRuleSubtreeStream stream_assertion_range=new RewriteRuleSubtreeStream(adaptor,"rule assertion_range");
		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_predicate_invocation=new RewriteRuleSubtreeStream(adaptor,"rule predicate_invocation");
		RewriteRuleSubtreeStream stream_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule assertion_parameter");
		RewriteRuleSubtreeStream stream_timed_predicate=new RewriteRuleSubtreeStream(adaptor,"rule timed_predicate");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:3: ( (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3108:3: (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3108:3: (n= LITERAL_not )?
			int alt177=2;
			int LA177_0 = input.LA(1);
			if ( (LA177_0==LITERAL_not) ) {
				alt177=1;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3106:3: ( (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:3: (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:3: (n= LITERAL_not )?
			int alt176=2;
			int LA176_0 = input.LA(1);
			if ( (LA176_0==LITERAL_not) ) {
				alt176=1;
>>>>>>> origin/continuum
			}
			switch (alt177) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3108:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subpredicate13415); if (state.failed) return retval; 
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subpredicate13390); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:3: ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			int alt178=9;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3108:3: ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			int alt177=9;
>>>>>>> origin/continuum
			switch ( input.LA(1) ) {
			case MINUS:
				{
				int LA178_1 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_abs:
				{
				int LA178_2 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_true:
				{
				int LA178_3 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}
				else if ( (true) ) {
					alt178=4;
				}

				}
				break;
			case LITERAL_false:
				{
				int LA178_4 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}
				else if ( (true) ) {
					alt178=5;
				}

				}
				break;
			case INTEGER_LIT:
				{
				int LA178_5 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 5, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case REAL_LIT:
				{
				int LA178_6 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 6, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LBRACKET:
				{
				int LA178_7 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 7, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				int LA178_8 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt178=3;
				}
				else if ( (synpred12_BLESStoAST()) ) {
					alt178=7;
				}
				else if ( (true) ) {
					alt178=8;
				}

				}
				break;
			case OCTOTHORPE:
				{
				int LA178_9 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 9, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_self:
				{
				int LA178_10 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 10, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				int LA178_11 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 11, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_in:
				{
				int LA178_12 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 12, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_timeout:
				{
				int LA178_13 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 13, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_null:
				{
				int LA178_14 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 14, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_now:
				{
				int LA178_15 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 15, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_tops:
				{
				int LA178_16 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 16, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				int LA178_17 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}
				else if ( (true) ) {
					alt178=8;
				}

				}
				break;
			case LITERAL_natural:
				{
				int LA178_18 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 18, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA178_19 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 19, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA178_20 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 20, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_real:
				{
				int LA178_21 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 21, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA178_22 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 22, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_time:
				{
				int LA178_23 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt178=1;
				}
				else if ( (synpred10_BLESStoAST()) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 23, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_stop:
				{
				alt178=6;
				}
				break;
			case LITERAL_def:
				{
				alt178=9;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 178, 0, input);
				throw nvae;
			}
			switch (alt178) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:3: ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13445);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:3: ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13420);
>>>>>>> origin/continuum
					lhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(lhs.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_relation_symbol_in_subpredicate13449);
=======
					pushFollow(FOLLOW_relation_symbol_in_subpredicate13424);
>>>>>>> origin/continuum
					r=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(r.getTree());
<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13453);
=======
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13428);
>>>>>>> origin/continuum
					rhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(rhs.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: r, r, rhs, n, lhs, rhs, lhs
=======
					// elements: rhs, n, rhs, lhs, r, lhs, r
>>>>>>> origin/continuum
					// token labels: n
					// rule labels: r, lhs, rhs, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
					RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs",lhs!=null?lhs.getTree():null);
					RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"rule rhs",rhs!=null?rhs.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3112:6: -> {n!=null}? ^( $n ^( $r $lhs $rhs) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:20: ^( $n ^( $r $lhs $rhs) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:26: ^( $r $lhs $rhs)
=======
					// 3111:6: -> {n!=null}? ^( $n ^( $r $lhs $rhs) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3111:20: ^( $n ^( $r $lhs $rhs) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3111:26: ^( $r $lhs $rhs)
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_r.nextNode(), root_2);
						adaptor.addChild(root_2, stream_lhs.nextTree());
						adaptor.addChild(root_2, stream_rhs.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3113:5: -> ^( $r $lhs $rhs)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3113:8: ^( $r $lhs $rhs)
=======
					else // 3112:5: -> ^( $r $lhs $rhs)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:8: ^( $r $lhs $rhs)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_r.nextNode(), root_1);
						adaptor.addChild(root_1, stream_lhs.nextTree());
						adaptor.addChild(root_1, stream_rhs.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3115:3: ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13528);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3114:3: ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13503);
>>>>>>> origin/continuum
					p=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(p.getTree());
<<<<<<< HEAD
					i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_subpredicate13532); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

					pushFollow(FOLLOW_assertion_range_in_subpredicate13536);
=======
					i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_subpredicate13507); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

					pushFollow(FOLLOW_assertion_range_in_subpredicate13511);
>>>>>>> origin/continuum
					ra=assertion_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_range.add(ra.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: i, ra, n, p, p, ra, i
=======
					// elements: n, p, i, i, p, ra, ra
>>>>>>> origin/continuum
					// token labels: i, n
					// rule labels: p, retval, ra
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ra=new RewriteRuleSubtreeStream(adaptor,"rule ra",ra!=null?ra.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3120:6: -> {n!=null}? ^( $n ^( $i $p $ra) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3120:20: ^( $n ^( $i $p $ra) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3120:26: ^( $i $p $ra)
=======
					// 3119:6: -> {n!=null}? ^( $n ^( $i $p $ra) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3119:20: ^( $n ^( $i $p $ra) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3119:26: ^( $i $p $ra)
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						adaptor.addChild(root_2, stream_p.nextTree());
						adaptor.addChild(root_2, stream_ra.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3121:5: -> ^( $i $p $ra)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3121:8: ^( $i $p $ra)
=======
					else // 3120:5: -> ^( $i $p $ra)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3120:8: ^( $i $p $ra)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_ra.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3123:3: ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression
					{
					pushFollow(FOLLOW_name_in_subpredicate13604);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3122:3: ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression
					{
					pushFollow(FOLLOW_name_in_subpredicate13579);
>>>>>>> origin/continuum
					target=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(target.getTree());
<<<<<<< HEAD
					pe=(Token)match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_subpredicate13608); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS_EQUALS.add(pe);

					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13614);
=======
					pe=(Token)match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_subpredicate13583); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS_EQUALS.add(pe);

					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13589);
>>>>>>> origin/continuum
					increment=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(increment.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: increment, pe, target
=======
					// elements: increment, target, pe
>>>>>>> origin/continuum
					// token labels: pe
					// rule labels: increment, retval, target
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_pe=new RewriteRuleTokenStream(adaptor,"token pe",pe);
					RewriteRuleSubtreeStream stream_increment=new RewriteRuleSubtreeStream(adaptor,"rule increment",increment!=null?increment.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target",target!=null?target.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3125:5: -> {n!=null}?
=======
					// 3124:5: -> {n!=null}?
>>>>>>> origin/continuum
					if (n!=null) {
						root_0 = null;
					}

<<<<<<< HEAD
					else // 3126:5: -> ^( $pe $target $increment)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3126:8: ^( $pe $target $increment)
=======
					else // 3125:5: -> ^( $pe $target $increment)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3125:8: ^( $pe $target $increment)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_pe.nextNode(), root_1);
						adaptor.addChild(root_1, stream_target.nextTree());
						adaptor.addChild(root_1, stream_increment.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3128:5: tr= LITERAL_true
					{
					tr=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_subpredicate13656); if (state.failed) return retval; 
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3127:5: tr= LITERAL_true
					{
					tr=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_subpredicate13631); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_true.add(tr);

					// AST REWRITE
					// elements: tr, n, tr
					// token labels: tr, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_tr=new RewriteRuleTokenStream(adaptor,"token tr",tr);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3129:5: -> {n!=null}? ^( $n $tr)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3129:19: ^( $n $tr)
=======
					// 3128:5: -> {n!=null}? ^( $n $tr)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3128:19: ^( $n $tr)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_tr.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3130:5: -> $tr
=======
					else // 3129:5: -> $tr
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_tr.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3131:5: fa= LITERAL_false
					{
					fa=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_subpredicate13694); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_false.add(fa);

					// AST REWRITE
					// elements: n, fa, fa
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3130:5: fa= LITERAL_false
					{
					fa=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_subpredicate13669); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_false.add(fa);

					// AST REWRITE
					// elements: fa, fa, n
>>>>>>> origin/continuum
					// token labels: fa, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_fa=new RewriteRuleTokenStream(adaptor,"token fa",fa);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3132:5: -> {n!=null}? ^( $n $fa)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3132:19: ^( $n $fa)
=======
					// 3131:5: -> {n!=null}? ^( $n $fa)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3131:19: ^( $n $fa)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_fa.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3133:5: -> $fa
=======
					else // 3132:5: -> $fa
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_fa.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3134:5: st= LITERAL_stop
					{
					st=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_subpredicate13730); if (state.failed) return retval; 
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3133:5: st= LITERAL_stop
					{
					st=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_subpredicate13705); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_stop.add(st);

					// AST REWRITE
					// elements: st, n, st
					// token labels: st, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_st=new RewriteRuleTokenStream(adaptor,"token st",st);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3135:5: -> {n!=null}? ^( $n $st)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3135:19: ^( $n $st)
=======
					// 3134:5: -> {n!=null}? ^( $n $st)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3134:19: ^( $n $st)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_st.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3136:5: -> $st
=======
					else // 3135:5: -> $st
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_st.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3137:5: ( ID LPAREN )=> predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_subpredicate13775);
					predicate_invocation317=predicate_invocation();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3136:5: ( ID LPAREN )=> predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_subpredicate13750);
					predicate_invocation316=predicate_invocation();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate_invocation.add(predicate_invocation317.getTree());
					// AST REWRITE
					// elements: predicate_invocation, n, predicate_invocation
					// token labels: n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3139:5: -> {n!=null}? ^( $n predicate_invocation )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3139:19: ^( $n predicate_invocation )
=======
					// 3138:5: -> {n!=null}? ^( $n predicate_invocation )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3138:19: ^( $n predicate_invocation )
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_predicate_invocation.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3140:5: -> predicate_invocation
=======
					else // 3139:5: -> predicate_invocation
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_predicate_invocation.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3142:3: timed_predicate
					{
					pushFollow(FOLLOW_timed_predicate_in_subpredicate13809);
					timed_predicate318=timed_predicate();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3141:3: timed_predicate
					{
					pushFollow(FOLLOW_timed_predicate_in_subpredicate13784);
					timed_predicate317=timed_predicate();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_timed_predicate.add(timed_predicate318.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: timed_predicate, n, timed_predicate
=======
					// elements: n, timed_predicate, timed_predicate
>>>>>>> origin/continuum
					// token labels: n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3143:5: -> {n!=null}? ^( $n timed_predicate )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3143:19: ^( $n timed_predicate )
=======
					// 3142:5: -> {n!=null}? ^( $n timed_predicate )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3142:19: ^( $n timed_predicate )
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_timed_predicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3144:5: -> timed_predicate
=======
					else // 3143:5: -> timed_predicate
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_timed_predicate.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3147:3: d= LITERAL_def definedLogicVariable= assertion_parameter
					{
					d=(Token)match(input,LITERAL_def,FOLLOW_LITERAL_def_in_subpredicate13846); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_def.add(d);

					pushFollow(FOLLOW_assertion_parameter_in_subpredicate13850);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3146:3: d= LITERAL_def definedLogicVariable= assertion_parameter
					{
					d=(Token)match(input,LITERAL_def,FOLLOW_LITERAL_def_in_subpredicate13821); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_def.add(d);

					pushFollow(FOLLOW_assertion_parameter_in_subpredicate13825);
>>>>>>> origin/continuum
					definedLogicVariable=assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_parameter.add(definedLogicVariable.getTree());
					// AST REWRITE
					// elements: definedLogicVariable, d
					// token labels: d
					// rule labels: definedLogicVariable, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
					RewriteRuleSubtreeStream stream_definedLogicVariable=new RewriteRuleSubtreeStream(adaptor,"rule definedLogicVariable",definedLogicVariable!=null?definedLogicVariable.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3148:5: -> ^( $d $definedLogicVariable)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3148:8: ^( $d $definedLogicVariable)
=======
					// 3147:5: -> ^( $d $definedLogicVariable)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3147:8: ^( $d $definedLogicVariable)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_d.nextNode(), root_1);
						adaptor.addChild(root_1, stream_definedLogicVariable.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.subpredicate");
			    tellBNF(GrammarStrings.predicateAtom,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subpredicate"


	public static class timed_predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timed_predicate"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3156:1: timed_predicate : ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3155:1: timed_predicate : ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.timed_predicate_return timed_predicate() throws RecognitionException {
		BLESStoASTParser.timed_predicate_return retval = new BLESStoASTParser.timed_predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK322=null;
		Token AT_SIGN323=null;
		Token CARET325=null;
		ParserRuleReturnScope name319 =null;
		ParserRuleReturnScope parenthesized_predicate320 =null;
		ParserRuleReturnScope predicate_invocation321 =null;
		ParserRuleReturnScope time_subexpression324 =null;
		ParserRuleReturnScope period_shift326 =null;

		BAST TICK322_tree=null;
		BAST AT_SIGN323_tree=null;
		BAST CARET325_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:3: ( ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:3: ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3156:3: ( ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:3: ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:3: ( name | parenthesized_predicate | predicate_invocation )
			int alt179=3;
			int LA179_0 = input.LA(1);
			if ( (LA179_0==ID) ) {
				int LA179_1 = input.LA(2);
				if ( (LA179_1==EOF||LA179_1==ANNEX_END||LA179_1==AT_SIGN||LA179_1==CARET||(LA179_1 >= COLON && LA179_1 <= COMMADOT)||(LA179_1 >= DOTCOMMA && LA179_1 <= DOTDOT)||LA179_1==IMP||LA179_1==LBRACKET||LA179_1==LITERAL_and||LA179_1==LITERAL_are||LA179_1==LITERAL_else||LA179_1==LITERAL_iff||LA179_1==LITERAL_implies||LA179_1==LITERAL_of||LA179_1==LITERAL_or||(LA179_1 >= LITERAL_that && LA179_1 <= LITERAL_then)||LA179_1==LITERAL_xor||LA179_1==PERIOD||LA179_1==QQ||LA179_1==RASS||LA179_1==RPAREN||LA179_1==TICK) ) {
					alt179=1;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:3: ( name | parenthesized_predicate | predicate_invocation )
			int alt178=3;
			int LA178_0 = input.LA(1);
			if ( (LA178_0==ID) ) {
				int LA178_1 = input.LA(2);
				if ( (LA178_1==EOF||LA178_1==ANNEX_END||LA178_1==AT_SIGN||LA178_1==CARET||LA178_1==COLON||(LA178_1 >= COMMA && LA178_1 <= COMMADOT)||(LA178_1 >= DOTCOMMA && LA178_1 <= DOTDOT)||LA178_1==IMP||LA178_1==LBRACKET||LA178_1==LITERAL_and||LA178_1==LITERAL_are||LA178_1==LITERAL_else||LA178_1==LITERAL_iff||LA178_1==LITERAL_implies||LA178_1==LITERAL_of||LA178_1==LITERAL_or||(LA178_1 >= LITERAL_that && LA178_1 <= LITERAL_then)||LA178_1==LITERAL_xor||LA178_1==PERIOD||LA178_1==QQ||LA178_1==RASS||LA178_1==RPAREN||LA178_1==TICK) ) {
					alt178=1;
>>>>>>> origin/continuum
				}
				else if ( (LA179_1==LPAREN) ) {
					alt179=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 179, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA179_0==LPAREN) ) {
				alt179=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 179, 0, input);
				throw nvae;
			}

			switch (alt179) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:4: name
					{
					pushFollow(FOLLOW_name_in_timed_predicate13899);
					name319=name();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:4: name
					{
					pushFollow(FOLLOW_name_in_timed_predicate13874);
					name318=name();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, name319.getTree());

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:11: parenthesized_predicate
					{
					pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate13903);
					parenthesized_predicate320=parenthesized_predicate();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:11: parenthesized_predicate
					{
					pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate13878);
					parenthesized_predicate319=parenthesized_predicate();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_predicate320.getTree());

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:37: predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_timed_predicate13907);
					predicate_invocation321=predicate_invocation();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3157:37: predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_timed_predicate13882);
					predicate_invocation320=predicate_invocation();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate_invocation321.getTree());

					}
					break;

			}

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3159:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			int alt180=4;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			int alt179=4;
>>>>>>> origin/continuum
			switch ( input.LA(1) ) {
				case TICK:
					{
					alt180=1;
					}
					break;
				case AT_SIGN:
					{
					alt180=2;
					}
					break;
				case CARET:
					{
					alt180=3;
					}
					break;
			}
			switch (alt180) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3159:4: TICK ^
					{
					TICK322=(Token)match(input,TICK,FOLLOW_TICK_in_timed_predicate13913); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:4: TICK ^
					{
					TICK321=(Token)match(input,TICK,FOLLOW_TICK_in_timed_predicate13888); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					TICK322_tree = (BAST)adaptor.create(TICK322);
					root_0 = (BAST)adaptor.becomeRoot(TICK322_tree, root_0);
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN323=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_predicate13921); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3159:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN322=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_predicate13896); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					AT_SIGN323_tree = (BAST)adaptor.create(AT_SIGN323);
					root_0 = (BAST)adaptor.becomeRoot(AT_SIGN323_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_time_subexpression_in_timed_predicate13924);
					time_subexpression324=time_subexpression();
=======
					pushFollow(FOLLOW_time_subexpression_in_timed_predicate13899);
					time_subexpression323=time_subexpression();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_subexpression324.getTree());

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3161:6: CARET ^ period_shift
					{
					CARET325=(Token)match(input,CARET,FOLLOW_CARET_in_timed_predicate13933); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:6: CARET ^ period_shift
					{
					CARET324=(Token)match(input,CARET,FOLLOW_CARET_in_timed_predicate13908); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					CARET325_tree = (BAST)adaptor.create(CARET325);
					root_0 = (BAST)adaptor.becomeRoot(CARET325_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_period_shift_in_timed_predicate13936);
					period_shift326=period_shift();
=======
					pushFollow(FOLLOW_period_shift_in_timed_predicate13911);
					period_shift325=period_shift();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, period_shift326.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.timed_predicate");
			    tellBNF(GrammarStrings.timeExpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_predicate"


	public static class parenthesized_predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_predicate"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3168:1: parenthesized_predicate : LPAREN ^ predicate RPAREN ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3167:1: parenthesized_predicate : LPAREN ^ predicate RPAREN ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.parenthesized_predicate_return parenthesized_predicate() throws RecognitionException {
		BLESStoASTParser.parenthesized_predicate_return retval = new BLESStoASTParser.parenthesized_predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN327=null;
		Token RPAREN329=null;
		ParserRuleReturnScope predicate328 =null;

		BAST LPAREN327_tree=null;
		BAST RPAREN329_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3169:3: ( LPAREN ^ predicate RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3170:3: LPAREN ^ predicate RPAREN
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3168:3: ( LPAREN ^ predicate RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3169:3: LPAREN ^ predicate RPAREN
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LPAREN327=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_predicate13974); if (state.failed) return retval;
=======
			LPAREN326=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_predicate13949); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LPAREN327_tree = (BAST)adaptor.create(LPAREN327);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN327_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_predicate_in_parenthesized_predicate13977);
			predicate328=predicate();
=======
			pushFollow(FOLLOW_predicate_in_parenthesized_predicate13952);
			predicate327=predicate();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate328.getTree());

<<<<<<< HEAD
			RPAREN329=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_predicate13979); if (state.failed) return retval;
=======
			RPAREN328=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_predicate13954); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			RPAREN329_tree = (BAST)adaptor.create(RPAREN329);
			adaptor.addChild(root_0, RPAREN329_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_predicate"


	public static class floatingAtom_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "floatingAtom"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3173:1: floatingAtom : value ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3172:1: floatingAtom : value ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.floatingAtom_return floatingAtom() throws RecognitionException {
		BLESStoASTParser.floatingAtom_return retval = new BLESStoASTParser.floatingAtom_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope value330 =null;


		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3174:3: ( value )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3175:3: value
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3173:3: ( value )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3174:3: value
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_value_in_floatingAtom13999);
			value330=value();
=======
			pushFollow(FOLLOW_value_in_floatingAtom13974);
			value329=value();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value330.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "floatingAtom"


	public static class period_shift_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "period_shift"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3178:1: period_shift : (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3177:1: period_shift : (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.period_shift_return period_shift() throws RecognitionException {
		BLESStoASTParser.period_shift_return retval = new BLESStoASTParser.period_shift_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m2=null;
		Token lp=null;
		Token mia=null;
		Token rp=null;
		Token dia=null;
		Token pia=null;
		Token tia=null;
		Token PLUS331=null;
		Token TIMES332=null;
		List<Object> list_ia3=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope x =null;
		ParserRuleReturnScope ia =null;
		ParserRuleReturnScope ia2 =null;
		RuleReturnScope ia3 = null;
		BAST m2_tree=null;
		BAST lp_tree=null;
		BAST mia_tree=null;
		BAST rp_tree=null;
		BAST dia_tree=null;
		BAST pia_tree=null;
		BAST tia_tree=null;
		BAST PLUS331_tree=null;
		BAST TIMES332_tree=null;
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleSubtreeStream stream_period_shift=new RewriteRuleSubtreeStream(adaptor,"rule period_shift");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3180:3: (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) )
			int alt184=3;
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3179:3: (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) )
			int alt183=3;
>>>>>>> origin/continuum
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt184=1;
				}
				break;
			case MINUS:
				{
				alt184=2;
				}
				break;
			case LPAREN:
				{
				alt184=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 184, 0, input);
				throw nvae;
			}
			switch (alt184) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3184:3: v= value
					{
					pushFollow(FOLLOW_value_in_period_shift14027);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3183:3: v= value
					{
					pushFollow(FOLLOW_value_in_period_shift14002);
>>>>>>> origin/continuum
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					// AST REWRITE
					// elements: v
					// token labels: 
					// rule labels: v, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3186:3: -> $v
=======
					// 3185:3: -> $v
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_v.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3188:3: m2= MINUS x= period_shift
					{
					m2=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14045); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(m2);

					pushFollow(FOLLOW_period_shift_in_period_shift14049);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3187:3: m2= MINUS x= period_shift
					{
					m2=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14020); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(m2);

					pushFollow(FOLLOW_period_shift_in_period_shift14024);
>>>>>>> origin/continuum
					x=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_period_shift.add(x.getTree());
					// AST REWRITE
					// elements: x
					// token labels: 
					// rule labels: x, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3189:3: -> ^( UNARY_MINUS[$m2] $x)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3189:6: ^( UNARY_MINUS[$m2] $x)
=======
					// 3188:3: -> ^( UNARY_MINUS[$m2] $x)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3188:6: ^( UNARY_MINUS[$m2] $x)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m2), root_1);
						adaptor.addChild(root_1, stream_x.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3194:3: lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_period_shift14075); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_period_shift_in_period_shift14079);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3193:3: lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_period_shift14050); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_period_shift_in_period_shift14054);
>>>>>>> origin/continuum
					ia=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_period_shift.add(ia.getTree());
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3195:5: (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					int alt183=5;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3194:5: (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					int alt182=5;
>>>>>>> origin/continuum
					switch ( input.LA(1) ) {
					case MINUS:
						{
						alt183=1;
						}
						break;
					case DIVIDE:
						{
						alt183=2;
						}
						break;
					case PLUS:
						{
						alt183=3;
						}
						break;
					case TIMES:
						{
						alt183=4;
						}
						break;
					case RPAREN:
						{
						alt183=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 183, 0, input);
						throw nvae;
					}
					switch (alt183) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3195:7: mia= MINUS ia2= period_shift rp= RPAREN
							{
							mia=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14090); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(mia);

							pushFollow(FOLLOW_period_shift_in_period_shift14094);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3194:7: mia= MINUS ia2= period_shift rp= RPAREN
							{
							mia=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14065); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(mia);

							pushFollow(FOLLOW_period_shift_in_period_shift14069);
>>>>>>> origin/continuum
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
<<<<<<< HEAD
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14098); if (state.failed) return retval; 
=======
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14073); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 2 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3197:5: dia= DIVIDE ia2= period_shift rp= RPAREN
							{
							dia=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_period_shift14112); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(dia);

							pushFollow(FOLLOW_period_shift_in_period_shift14116);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3196:5: dia= DIVIDE ia2= period_shift rp= RPAREN
							{
							dia=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_period_shift14087); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(dia);

							pushFollow(FOLLOW_period_shift_in_period_shift14091);
>>>>>>> origin/continuum
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
<<<<<<< HEAD
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14120); if (state.failed) return retval; 
=======
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14095); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 3 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3199:5: pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN
							{
							pia=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14134); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(pia);

							pushFollow(FOLLOW_period_shift_in_period_shift14138);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3198:5: pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN
							{
							pia=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14109); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(pia);

							pushFollow(FOLLOW_period_shift_in_period_shift14113);
>>>>>>> origin/continuum
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3199:31: ( PLUS ia3+= period_shift )*
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3198:31: ( PLUS ia3+= period_shift )*
							loop180:
							while (true) {
								int alt180=2;
								int LA180_0 = input.LA(1);
								if ( (LA180_0==PLUS) ) {
									alt180=1;
								}

								switch (alt180) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3198:32: PLUS ia3+= period_shift
									{
									PLUS330=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14116); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS330);

									pushFollow(FOLLOW_period_shift_in_period_shift14120);
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop180;
								}
							}

							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14126); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3200:5: tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN
							{
							tia=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14142); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(tia);

							pushFollow(FOLLOW_period_shift_in_period_shift14146);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3200:32: ( TIMES ia3+= period_shift )*
>>>>>>> origin/continuum
							loop181:
							while (true) {
								int alt181=2;
								int LA181_0 = input.LA(1);
								if ( (LA181_0==PLUS) ) {
									alt181=1;
								}

								switch (alt181) {
								case 1 :
<<<<<<< HEAD
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3199:32: PLUS ia3+= period_shift
									{
									PLUS331=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14141); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS331);

									pushFollow(FOLLOW_period_shift_in_period_shift14145);
=======
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3200:33: TIMES ia3+= period_shift
									{
									TIMES331=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14149); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES331);

									pushFollow(FOLLOW_period_shift_in_period_shift14153);
>>>>>>> origin/continuum
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop181;
								}
							}

<<<<<<< HEAD
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14151); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3201:5: tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN
							{
							tia=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14167); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(tia);

							pushFollow(FOLLOW_period_shift_in_period_shift14171);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3201:32: ( TIMES ia3+= period_shift )*
							loop182:
							while (true) {
								int alt182=2;
								int LA182_0 = input.LA(1);
								if ( (LA182_0==TIMES) ) {
									alt182=1;
								}

								switch (alt182) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3201:33: TIMES ia3+= period_shift
									{
									TIMES332=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14174); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES332);

									pushFollow(FOLLOW_period_shift_in_period_shift14178);
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop182;
								}
							}

							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14184); if (state.failed) return retval; 
=======
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14159); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 5 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3203:5: rp= RPAREN
							{
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14200); if (state.failed) return retval; 
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3202:5: rp= RPAREN
							{
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14175); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;

					}

					// AST REWRITE
<<<<<<< HEAD
					// elements: lp, ia, pia, ia, ia3, rp, ia2, ia3, ia, mia, ia, ia, rp, ia2, lp, rp, rp, tia, lp, ia2, rp, lp, dia, lp, ia2
=======
					// elements: rp, pia, lp, mia, ia2, ia3, ia, ia2, lp, lp, tia, rp, dia, ia2, ia, rp, ia2, ia, lp, rp, ia, ia3, lp, rp, ia
>>>>>>> origin/continuum
					// token labels: lp, mia, pia, tia, dia, rp
					// rule labels: ia, ia2, retval
					// token list labels: 
					// rule list labels: ia3
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_mia=new RewriteRuleTokenStream(adaptor,"token mia",mia);
					RewriteRuleTokenStream stream_pia=new RewriteRuleTokenStream(adaptor,"token pia",pia);
					RewriteRuleTokenStream stream_tia=new RewriteRuleTokenStream(adaptor,"token tia",tia);
					RewriteRuleTokenStream stream_dia=new RewriteRuleTokenStream(adaptor,"token dia",dia);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_ia=new RewriteRuleSubtreeStream(adaptor,"rule ia",ia!=null?ia.getTree():null);
					RewriteRuleSubtreeStream stream_ia2=new RewriteRuleSubtreeStream(adaptor,"rule ia2",ia2!=null?ia2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ia3=new RewriteRuleSubtreeStream(adaptor,"token ia3",list_ia3);
					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3205:3: -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp)
					if (mia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:19: ^( $lp ^( $mia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:25: ^( $mia $ia $ia2)
=======
					// 3204:3: -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp)
					if (mia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3204:19: ^( $lp ^( $mia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3204:25: ^( $mia $ia $ia2)
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_mia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3206:3: -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp)
					if (dia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3206:19: ^( $lp ^( $dia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3206:25: ^( $dia $ia $ia2)
=======
					else // 3205:3: -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp)
					if (dia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:19: ^( $lp ^( $dia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:25: ^( $dia $ia $ia2)
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_dia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3207:3: -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
					if (pia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:19: ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:25: ^( $pia $ia $ia2 ( $ia3)* )
=======
					else // 3206:3: -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
					if (pia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3206:19: ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3206:25: ^( $pia $ia $ia2 ( $ia3)* )
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_pia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
<<<<<<< HEAD
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:42: ( $ia3)*
=======
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3206:42: ( $ia3)*
>>>>>>> origin/continuum
						while ( stream_ia3.hasNext() ) {
							adaptor.addChild(root_2, stream_ia3.nextTree());
						}
						stream_ia3.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3208:3: -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
					if (tia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3208:19: ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3208:25: ^( $tia $ia $ia2 ( $ia3)* )
=======
					else // 3207:3: -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
					if (tia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:19: ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:25: ^( $tia $ia $ia2 ( $ia3)* )
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_tia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
<<<<<<< HEAD
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3208:42: ( $ia3)*
=======
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:42: ( $ia3)*
>>>>>>> origin/continuum
						while ( stream_ia3.hasNext() ) {
							adaptor.addChild(root_2, stream_ia3.nextTree());
						}
						stream_ia3.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3209:3: -> ^( $lp $ia $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3209:6: ^( $lp $ia $rp)
=======
					else // 3208:3: -> ^( $lp $ia $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3208:6: ^( $lp $ia $rp)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ia.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    if ((re.getUnexpectedType()==BLESStoASTLexer.TICK)||(re.getUnexpectedType()==BLESStoASTLexer.CARET))
			      Dump.it("^ and ' are not allowed in integer atoms on rhs of ^");
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("RecognitionException caught by BLESStoAST.period_shift");
			//    tellBNF(GrammarStrings.predicateInvocation,re,$predicate_invocation.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "period_shift"


	public static class predicate_invocation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "predicate_invocation"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3221:1: predicate_invocation : (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3220:1: predicate_invocation : (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.predicate_invocation_return predicate_invocation() throws RecognitionException {
		BLESStoASTParser.predicate_invocation_return retval = new BLESStoASTParser.predicate_invocation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token RPAREN333=null;
		Token RPAREN334=null;
		Token COMMA335=null;
		Token RPAREN336=null;
		List<Object> list_params=null;
		ParserRuleReturnScope i =null;
		ParserRuleReturnScope exp =null;
		RuleReturnScope params = null;
		BAST lp_tree=null;
		BAST RPAREN333_tree=null;
		BAST RPAREN334_tree=null;
		BAST COMMA335_tree=null;
		BAST RPAREN336_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_actual_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule actual_assertion_parameter");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3223:3: (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) )
			int alt186=3;
			int LA186_0 = input.LA(1);
			if ( (LA186_0==ID) ) {
				int LA186_1 = input.LA(2);
				if ( (LA186_1==LPAREN) ) {
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3222:3: (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) )
			int alt185=3;
			int LA185_0 = input.LA(1);
			if ( (LA185_0==ID) ) {
				int LA185_1 = input.LA(2);
				if ( (LA185_1==LPAREN) ) {
>>>>>>> origin/continuum
					switch ( input.LA(3) ) {
					case RPAREN:
						{
						alt186=1;
						}
						break;
					case AADL_STRING_LITERAL:
					case INTEGER_LIT:
					case LBRACKET:
					case LITERAL_abs:
					case LITERAL_complex:
					case LITERAL_false:
					case LITERAL_in:
					case LITERAL_integer:
					case LITERAL_natural:
					case LITERAL_now:
					case LITERAL_null:
					case LITERAL_numberof:
					case LITERAL_product:
					case LITERAL_rational:
					case LITERAL_real:
					case LITERAL_self:
					case LITERAL_sum:
					case LITERAL_time:
					case LITERAL_timeout:
					case LITERAL_tops:
					case LITERAL_true:
					case LPAREN:
					case MINUS:
					case OCTOTHORPE:
					case REAL_LIT:
						{
						alt186=2;
						}
						break;
					case ID:
						{
						int LA186_5 = input.LA(4);
						if ( (LA186_5==AT_SIGN||LA186_5==CARET||LA186_5==DIVIDE||LA186_5==DOUBLE_COLON||LA186_5==EXP||LA186_5==LBRACKET||LA186_5==LITERAL_mod||LA186_5==LITERAL_rem||LA186_5==LPAREN||LA186_5==MINUS||LA186_5==OCTOTHORPE||(LA186_5 >= PERIOD && LA186_5 <= PLUS)||LA186_5==QUESTION||LA186_5==RPAREN||LA186_5==TICK||LA186_5==TIMES) ) {
							alt186=2;
						}
<<<<<<< HEAD
						else if ( (LA186_5==COLON) ) {
							alt186=3;
=======
						else if ( ((LA185_5 >= COLON && LA185_5 <= COLON_TILDE)) ) {
							alt185=3;
>>>>>>> origin/continuum
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 186, 5, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 186, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 186, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 186, 0, input);
				throw nvae;
			}

			switch (alt186) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3224:3: i= identifier lp= LPAREN RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14368);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3223:3: i= identifier lp= LPAREN RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14343);
>>>>>>> origin/continuum
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
<<<<<<< HEAD
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14372); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					RPAREN333=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14374); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN333);
=======
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14347); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					RPAREN332=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14349); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN332);
>>>>>>> origin/continuum

					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: i, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3225:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3225:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
=======
					// 3224:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3224:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_i.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3228:3: i= identifier lp= LPAREN exp= assertion_expression RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14409);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3227:3: i= identifier lp= LPAREN exp= assertion_expression RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14384);
>>>>>>> origin/continuum
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
<<<<<<< HEAD
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14413); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_predicate_invocation14417);
=======
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14388); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_predicate_invocation14392);
>>>>>>> origin/continuum
					exp=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(exp.getTree());
<<<<<<< HEAD
					RPAREN334=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14419); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN334);
=======
					RPAREN333=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14394); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN333);
>>>>>>> origin/continuum

					// AST REWRITE
					// elements: i, exp
					// token labels: 
					// rule labels: i, exp, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp",exp!=null?exp.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3229:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3229:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3230:9: ^( $i $exp)
=======
					// 3228:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3228:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3229:9: ^( $i $exp)
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						adaptor.addChild(root_2, stream_exp.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3232:3: i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14462);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3231:3: i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14437);
>>>>>>> origin/continuum
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
<<<<<<< HEAD
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14466); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14470);
=======
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14441); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14445);
>>>>>>> origin/continuum
					params=actual_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(params.getTree());
					if (list_params==null) list_params=new ArrayList<Object>();
					list_params.add(params.getTree());
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3232:61: ( COMMA params+= actual_assertion_parameter )*
					loop185:
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3231:61: ( COMMA params+= actual_assertion_parameter )*
					loop184:
>>>>>>> origin/continuum
					while (true) {
						int alt185=2;
						int LA185_0 = input.LA(1);
						if ( (LA185_0==COMMA) ) {
							alt185=1;
						}

						switch (alt185) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3232:63: COMMA params+= actual_assertion_parameter
							{
							COMMA335=(Token)match(input,COMMA,FOLLOW_COMMA_in_predicate_invocation14474); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA335);

							pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14478);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3231:63: COMMA params+= actual_assertion_parameter
							{
							COMMA334=(Token)match(input,COMMA,FOLLOW_COMMA_in_predicate_invocation14449); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA334);

							pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14453);
>>>>>>> origin/continuum
							params=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(params.getTree());
							if (list_params==null) list_params=new ArrayList<Object>();
							list_params.add(params.getTree());
							}
							break;

						default :
							break loop185;
						}
					}

<<<<<<< HEAD
					RPAREN336=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14484); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN336);
=======
					RPAREN335=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14459); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN335);
>>>>>>> origin/continuum

					// AST REWRITE
					// elements: params, i
					// token labels: 
					// rule labels: i, retval
					// token list labels: 
					// rule list labels: params
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"token params",list_params);
					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3233:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3233:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3234:9: ^( $i ( $params)+ )
=======
					// 3232:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3232:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3233:9: ^( $i ( $params)+ )
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						if ( !(stream_params.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_params.hasNext() ) {
							adaptor.addChild(root_2, stream_params.nextTree());
						}
						stream_params.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(i!=null?((BAST)i.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  Dump.it("RecognitionException caught by BLESStoAST.predicate_invocation"+
			  "\n\nDid you forget that parameters must be of the form \"formal:assertion_expression\"?");
			    tellBNF(GrammarStrings.predicateInvocation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate_invocation"


	public static class actual_assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "actual_assertion_parameter"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3242:1: actual_assertion_parameter : formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3241:1: actual_assertion_parameter : (formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) |formal= ID ct= COLON_TILDE pred= predicate -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.actual_assertion_parameter_return actual_assertion_parameter() throws RecognitionException {
		BLESStoASTParser.actual_assertion_parameter_return retval = new BLESStoASTParser.actual_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token formal=null;
		Token c=null;
		Token ct=null;
		ParserRuleReturnScope actual =null;
		ParserRuleReturnScope pred =null;

		BAST formal_tree=null;
		BAST c_tree=null;
		BAST ct_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_COLON_TILDE=new RewriteRuleTokenStream(adaptor,"token COLON_TILDE");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3243:3: (formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3244:3: formal= ID c= COLON actual= assertion_expression
			{
			formal=(Token)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter14541); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(formal);

			c=(Token)match(input,COLON,FOLLOW_COLON_in_actual_assertion_parameter14545); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			pushFollow(FOLLOW_assertion_expression_in_actual_assertion_parameter14549);
			actual=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
			// AST REWRITE
			// elements: actual, formal
			// token labels: formal
			// rule labels: actual, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_formal=new RewriteRuleTokenStream(adaptor,"token formal",formal);
			RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 3245:5: -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3245:8: ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETER, c, "PARAMETER["+(formal!=null?formal.getText():null)+"]"), root_1);
				adaptor.addChild(root_1, stream_formal.nextNode());
				adaptor.addChild(root_1, stream_actual.nextTree());
				adaptor.addChild(root_0, root_1);
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3242:3: (formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) |formal= ID ct= COLON_TILDE pred= predicate -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred) )
			int alt186=2;
			int LA186_0 = input.LA(1);
			if ( (LA186_0==ID) ) {
				int LA186_1 = input.LA(2);
				if ( (LA186_1==COLON) ) {
					alt186=1;
				}
				else if ( (LA186_1==COLON_TILDE) ) {
					alt186=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 186, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
>>>>>>> origin/continuum
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 186, 0, input);
				throw nvae;
			}

			switch (alt186) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3243:3: formal= ID c= COLON actual= assertion_expression
					{
					formal=(Token)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter14516); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(formal);

					c=(Token)match(input,COLON,FOLLOW_COLON_in_actual_assertion_parameter14520); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(c);

					pushFollow(FOLLOW_assertion_expression_in_actual_assertion_parameter14524);
					actual=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
					// AST REWRITE
					// elements: actual, formal
					// token labels: formal
					// rule labels: actual, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_formal=new RewriteRuleTokenStream(adaptor,"token formal",formal);
					RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3244:5: -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3244:8: ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETER, c, "PARAMETER["+(formal!=null?formal.getText():null)+"]"), root_1);
						adaptor.addChild(root_1, stream_formal.nextNode());
						adaptor.addChild(root_1, stream_actual.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3246:3: formal= ID ct= COLON_TILDE pred= predicate
					{
					formal=(Token)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter14553); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(formal);

					ct=(Token)match(input,COLON_TILDE,FOLLOW_COLON_TILDE_in_actual_assertion_parameter14557); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON_TILDE.add(ct);

					pushFollow(FOLLOW_predicate_in_actual_assertion_parameter14561);
					pred=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(pred.getTree());
					// AST REWRITE
					// elements: pred, formal, ct
					// token labels: formal, ct
					// rule labels: pred, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_formal=new RewriteRuleTokenStream(adaptor,"token formal",formal);
					RewriteRuleTokenStream stream_ct=new RewriteRuleTokenStream(adaptor,"token ct",ct);
					RewriteRuleSubtreeStream stream_pred=new RewriteRuleSubtreeStream(adaptor,"rule pred",pred!=null?pred.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3247:5: -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3247:8: ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETER, c, "PARAMETER["+(formal!=null?formal.getText():null)+"]"), root_1);
						adaptor.addChild(root_1, stream_ct.nextNode());
						adaptor.addChild(root_1, stream_formal.nextNode());
						adaptor.addChild(root_1, stream_pred.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_assertion_parameter"


	public static class range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "range"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3265:1: range : numeric_expression range_symbol ^ numeric_expression ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3267:1: range : numeric_expression range_symbol ^ numeric_expression ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.range_return range() throws RecognitionException {
		BLESStoASTParser.range_return retval = new BLESStoASTParser.range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope numeric_expression337 =null;
		ParserRuleReturnScope range_symbol338 =null;
		ParserRuleReturnScope numeric_expression339 =null;


		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3266:3: ( numeric_expression range_symbol ^ numeric_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3267:3: numeric_expression range_symbol ^ numeric_expression
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3268:3: ( numeric_expression range_symbol ^ numeric_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3269:3: numeric_expression range_symbol ^ numeric_expression
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_numeric_expression_in_range14595);
			numeric_expression337=numeric_expression();
=======
			pushFollow(FOLLOW_numeric_expression_in_range14612);
			numeric_expression336=numeric_expression();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_expression337.getTree());

<<<<<<< HEAD
			pushFollow(FOLLOW_range_symbol_in_range14597);
			range_symbol338=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol338.getTree(), root_0);
			pushFollow(FOLLOW_numeric_expression_in_range14600);
			numeric_expression339=numeric_expression();
=======
			pushFollow(FOLLOW_range_symbol_in_range14614);
			range_symbol337=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol337.getTree(), root_0);
			pushFollow(FOLLOW_numeric_expression_in_range14617);
			numeric_expression338=numeric_expression();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_expression339.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nDid you forget to put spaces around your range symbol?\n");
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.range");
			    tellBNF(GrammarStrings.range,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range"


	public static class assertion_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_range"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3277:1: assertion_range : assertion_expression range_symbol ^ assertion_expression ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3279:1: assertion_range : assertion_expression range_symbol ^ assertion_expression ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_range_return assertion_range() throws RecognitionException {
		BLESStoASTParser.assertion_range_return retval = new BLESStoASTParser.assertion_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope assertion_expression340 =null;
		ParserRuleReturnScope range_symbol341 =null;
		ParserRuleReturnScope assertion_expression342 =null;


		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3278:3: ( assertion_expression range_symbol ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3279:3: assertion_expression range_symbol ^ assertion_expression
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3280:3: ( assertion_expression range_symbol ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3281:3: assertion_expression range_symbol ^ assertion_expression
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_assertion_expression_in_assertion_range14626);
			assertion_expression340=assertion_expression();
=======
			pushFollow(FOLLOW_assertion_expression_in_assertion_range14643);
			assertion_expression339=assertion_expression();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression340.getTree());

<<<<<<< HEAD
			pushFollow(FOLLOW_range_symbol_in_assertion_range14628);
			range_symbol341=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol341.getTree(), root_0);
			pushFollow(FOLLOW_assertion_expression_in_assertion_range14631);
			assertion_expression342=assertion_expression();
=======
			pushFollow(FOLLOW_range_symbol_in_assertion_range14645);
			range_symbol340=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol340.getTree(), root_0);
			pushFollow(FOLLOW_assertion_expression_in_assertion_range14648);
			assertion_expression341=assertion_expression();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression342.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.assertion_range");
			    tellBNF(GrammarStrings.range,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_range"


	public static class assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3286:1: assertion_expression options {backtrack=true; } : ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3288:1: assertion_expression options {backtrack=true; } : ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_expression_return assertion_expression() throws RecognitionException {
		BLESStoASTParser.assertion_expression_return retval = new BLESStoASTParser.assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_sum343=null;
		Token LITERAL_of346=null;
		Token LITERAL_product348=null;
		Token LITERAL_of351=null;
		Token LITERAL_numberof353=null;
		Token LITERAL_that356=null;
		Token PLUS359=null;
		Token TIMES361=null;
		Token MINUS363=null;
		Token DIVIDE365=null;
		Token EXP367=null;
		Token LITERAL_mod369=null;
		Token LITERAL_rem371=null;
		ParserRuleReturnScope logic_variables344 =null;
		ParserRuleReturnScope logic_variable_domain345 =null;
		ParserRuleReturnScope assertion_expression347 =null;
		ParserRuleReturnScope logic_variables349 =null;
		ParserRuleReturnScope logic_variable_domain350 =null;
		ParserRuleReturnScope assertion_expression352 =null;
		ParserRuleReturnScope logic_variables354 =null;
		ParserRuleReturnScope logic_variable_domain355 =null;
		ParserRuleReturnScope subpredicate357 =null;
		ParserRuleReturnScope assertion_subexpression358 =null;
		ParserRuleReturnScope assertion_subexpression360 =null;
		ParserRuleReturnScope assertion_subexpression362 =null;
		ParserRuleReturnScope assertion_subexpression364 =null;
		ParserRuleReturnScope assertion_subexpression366 =null;
		ParserRuleReturnScope assertion_subexpression368 =null;
		ParserRuleReturnScope assertion_subexpression370 =null;
		ParserRuleReturnScope assertion_subexpression372 =null;

		BAST LITERAL_sum343_tree=null;
		BAST LITERAL_of346_tree=null;
		BAST LITERAL_product348_tree=null;
		BAST LITERAL_of351_tree=null;
		BAST LITERAL_numberof353_tree=null;
		BAST LITERAL_that356_tree=null;
		BAST PLUS359_tree=null;
		BAST TIMES361_tree=null;
		BAST MINUS363_tree=null;
		BAST DIVIDE365_tree=null;
		BAST EXP367_tree=null;
		BAST LITERAL_mod369_tree=null;
		BAST LITERAL_rem371_tree=null;
		RewriteRuleTokenStream stream_LITERAL_of=new RewriteRuleTokenStream(adaptor,"token LITERAL_of");
		RewriteRuleTokenStream stream_LITERAL_numberof=new RewriteRuleTokenStream(adaptor,"token LITERAL_numberof");
		RewriteRuleTokenStream stream_LITERAL_that=new RewriteRuleTokenStream(adaptor,"token LITERAL_that");
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_product=new RewriteRuleTokenStream(adaptor,"token LITERAL_product");
		RewriteRuleTokenStream stream_LITERAL_sum=new RewriteRuleTokenStream(adaptor,"token LITERAL_sum");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_logic_variables=new RewriteRuleSubtreeStream(adaptor,"rule logic_variables");
		RewriteRuleSubtreeStream stream_subpredicate=new RewriteRuleSubtreeStream(adaptor,"rule subpredicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_assertion_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_subexpression");
		RewriteRuleSubtreeStream stream_logic_variable_domain=new RewriteRuleSubtreeStream(adaptor,"rule logic_variable_domain");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3288:3: ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3290:3: ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) )
>>>>>>> origin/continuum
			int alt193=4;
			switch ( input.LA(1) ) {
			case LITERAL_sum:
				{
				alt193=1;
				}
				break;
			case LITERAL_product:
				{
				alt193=2;
				}
				break;
			case LITERAL_numberof:
				{
				alt193=3;
				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt193=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 193, 0, input);
				throw nvae;
			}
			switch (alt193) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3289:3: LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_sum343=(Token)match(input,LITERAL_sum,FOLLOW_LITERAL_sum_in_assertion_expression14666); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_sum.add(LITERAL_sum343);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14668);
					logic_variables344=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables344.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3289:31: ( logic_variable_domain )?
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3291:3: LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_sum342=(Token)match(input,LITERAL_sum,FOLLOW_LITERAL_sum_in_assertion_expression14683); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_sum.add(LITERAL_sum342);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14685);
					logic_variables343=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables343.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3291:31: ( logic_variable_domain )?
>>>>>>> origin/continuum
					int alt187=2;
					int LA187_0 = input.LA(1);
					if ( (LA187_0==LITERAL_in) ) {
						alt187=1;
					}
					switch (alt187) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3289:33: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14672);
							logic_variable_domain345=logic_variable_domain();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3291:33: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14689);
							logic_variable_domain344=logic_variable_domain();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain345.getTree());
							}
							break;

					}

<<<<<<< HEAD
					LITERAL_of346=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14677); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of346);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14679);
					assertion_expression347=assertion_expression();
=======
					LITERAL_of345=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14694); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of345);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14696);
					assertion_expression346=assertion_expression();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(assertion_expression347.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: logic_variables, LITERAL_sum, LITERAL_of, assertion_expression, logic_variable_domain
=======
					// elements: LITERAL_of, logic_variable_domain, LITERAL_sum, assertion_expression, logic_variables
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3290:5: -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3290:8: ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
=======
					// 3292:5: -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:8: ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_sum.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
<<<<<<< HEAD
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3290:39: ( logic_variable_domain )?
=======
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:39: ( logic_variable_domain )?
>>>>>>> origin/continuum
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_of.nextNode());
						adaptor.addChild(root_1, stream_assertion_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:3: LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_product348=(Token)match(input,LITERAL_product,FOLLOW_LITERAL_product_in_assertion_expression14711); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_product.add(LITERAL_product348);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14713);
					logic_variables349=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables349.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:35: ( logic_variable_domain )?
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3294:3: LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_product347=(Token)match(input,LITERAL_product,FOLLOW_LITERAL_product_in_assertion_expression14728); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_product.add(LITERAL_product347);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14730);
					logic_variables348=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables348.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3294:35: ( logic_variable_domain )?
>>>>>>> origin/continuum
					int alt188=2;
					int LA188_0 = input.LA(1);
					if ( (LA188_0==LITERAL_in) ) {
						alt188=1;
					}
					switch (alt188) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3292:37: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14717);
							logic_variable_domain350=logic_variable_domain();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3294:37: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14734);
							logic_variable_domain349=logic_variable_domain();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain350.getTree());
							}
							break;

					}

<<<<<<< HEAD
					LITERAL_of351=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14722); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of351);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14724);
					assertion_expression352=assertion_expression();
=======
					LITERAL_of350=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14739); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of350);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14741);
					assertion_expression351=assertion_expression();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(assertion_expression352.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: LITERAL_product, logic_variables, LITERAL_of, logic_variable_domain, assertion_expression
=======
					// elements: logic_variable_domain, LITERAL_of, LITERAL_product, logic_variables, assertion_expression
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3293:5: -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3293:8: ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
=======
					// 3295:5: -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:8: ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_product.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
<<<<<<< HEAD
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3293:43: ( logic_variable_domain )?
=======
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:43: ( logic_variable_domain )?
>>>>>>> origin/continuum
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_of.nextNode());
						adaptor.addChild(root_1, stream_assertion_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:3: LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate
					{
					LITERAL_numberof353=(Token)match(input,LITERAL_numberof,FOLLOW_LITERAL_numberof_in_assertion_expression14754); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_numberof.add(LITERAL_numberof353);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14756);
					logic_variables354=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables354.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:36: ( logic_variable_domain )?
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:3: LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate
					{
					LITERAL_numberof352=(Token)match(input,LITERAL_numberof,FOLLOW_LITERAL_numberof_in_assertion_expression14771); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_numberof.add(LITERAL_numberof352);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14773);
					logic_variables353=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables353.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:36: ( logic_variable_domain )?
>>>>>>> origin/continuum
					int alt189=2;
					int LA189_0 = input.LA(1);
					if ( (LA189_0==LITERAL_in) ) {
						alt189=1;
					}
					switch (alt189) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:38: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14760);
							logic_variable_domain355=logic_variable_domain();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:38: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14777);
							logic_variable_domain354=logic_variable_domain();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain355.getTree());
							}
							break;

					}

<<<<<<< HEAD
					LITERAL_that356=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_assertion_expression14765); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_that.add(LITERAL_that356);

					pushFollow(FOLLOW_subpredicate_in_assertion_expression14767);
					subpredicate357=subpredicate();
=======
					LITERAL_that355=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_assertion_expression14782); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_that.add(LITERAL_that355);

					pushFollow(FOLLOW_subpredicate_in_assertion_expression14784);
					subpredicate356=subpredicate();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subpredicate.add(subpredicate357.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: LITERAL_numberof, LITERAL_that, logic_variable_domain, logic_variables, subpredicate
=======
					// elements: logic_variables, logic_variable_domain, LITERAL_that, subpredicate, LITERAL_numberof
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3296:5: -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3296:8: ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
=======
					// 3298:5: -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3298:8: ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_numberof.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
<<<<<<< HEAD
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3296:44: ( logic_variable_domain )?
=======
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3298:44: ( logic_variable_domain )?
>>>>>>> origin/continuum
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_that.nextNode());
						adaptor.addChild(root_1, stream_subpredicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3298:3: assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
					{
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14801);
					assertion_subexpression358=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression358.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3299:3: ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:3: assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
					{
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14818);
					assertion_subexpression357=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression357.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3301:3: ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
>>>>>>> origin/continuum
					int alt192=8;
					switch ( input.LA(1) ) {
					case PLUS:
						{
						alt192=1;
						}
						break;
					case TIMES:
						{
						alt192=2;
						}
						break;
					case MINUS:
						{
						alt192=3;
						}
						break;
					case DIVIDE:
						{
						alt192=4;
						}
						break;
					case EXP:
						{
						alt192=5;
						}
						break;
					case LITERAL_mod:
						{
						alt192=6;
						}
						break;
					case LITERAL_rem:
						{
						alt192=7;
						}
						break;
					case EOF:
					case ANNEX_END:
					case COLON:
					case COMMA:
					case COMMACOMMA:
					case COMMADOT:
					case DOTCOMMA:
					case DOTDOT:
					case IMP:
					case LITERAL_and:
					case LITERAL_are:
					case LITERAL_else:
					case LITERAL_iff:
					case LITERAL_implies:
					case LITERAL_of:
					case LITERAL_or:
					case LITERAL_that:
					case LITERAL_then:
					case LITERAL_xor:
					case QQ:
					case RASS:
					case RPAREN:
						{
						alt192=8;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 192, 0, input);
						throw nvae;
					}
					switch (alt192) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:3: ( PLUS assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:3: ( PLUS assertion_subexpression )+
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3302:3: ( PLUS assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3302:3: ( PLUS assertion_subexpression )+
>>>>>>> origin/continuum
							int cnt190=0;
							loop190:
							while (true) {
								int alt190=2;
								int LA190_0 = input.LA(1);
								if ( (LA190_0==PLUS) ) {
									alt190=1;
								}

								switch (alt190) {
								case 1 :
<<<<<<< HEAD
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:5: PLUS assertion_subexpression
									{
									PLUS359=(Token)match(input,PLUS,FOLLOW_PLUS_in_assertion_expression14815); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS359);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14817);
									assertion_subexpression360=assertion_subexpression();
=======
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3302:5: PLUS assertion_subexpression
									{
									PLUS358=(Token)match(input,PLUS,FOLLOW_PLUS_in_assertion_expression14832); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS358);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14834);
									assertion_subexpression359=assertion_subexpression();
>>>>>>> origin/continuum
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression360.getTree());
									}
									break;

								default :
									if ( cnt190 >= 1 ) break loop190;
									if (state.backtracking>0) {state.failed=true; return retval;}
									EarlyExitException eee = new EarlyExitException(190, input);
									throw eee;
								}
								cnt190++;
							}

							// AST REWRITE
							// elements: PLUS, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3301:5: -> ^( PLUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3301:8: ^( PLUS ( assertion_subexpression )+ )
=======
							// 3303:5: -> ^( PLUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3303:8: ^( PLUS ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_PLUS.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 2 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3303:3: ( TIMES assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3303:3: ( TIMES assertion_subexpression )+
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3305:3: ( TIMES assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3305:3: ( TIMES assertion_subexpression )+
>>>>>>> origin/continuum
							int cnt191=0;
							loop191:
							while (true) {
								int alt191=2;
								int LA191_0 = input.LA(1);
								if ( (LA191_0==TIMES) ) {
									alt191=1;
								}

								switch (alt191) {
								case 1 :
<<<<<<< HEAD
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3303:5: TIMES assertion_subexpression
									{
									TIMES361=(Token)match(input,TIMES,FOLLOW_TIMES_in_assertion_expression14850); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES361);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14852);
									assertion_subexpression362=assertion_subexpression();
=======
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3305:5: TIMES assertion_subexpression
									{
									TIMES360=(Token)match(input,TIMES,FOLLOW_TIMES_in_assertion_expression14867); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES360);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14869);
									assertion_subexpression361=assertion_subexpression();
>>>>>>> origin/continuum
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression362.getTree());
									}
									break;

								default :
									if ( cnt191 >= 1 ) break loop191;
									if (state.backtracking>0) {state.failed=true; return retval;}
									EarlyExitException eee = new EarlyExitException(191, input);
									throw eee;
								}
								cnt191++;
							}

							// AST REWRITE
							// elements: TIMES, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3304:5: -> ^( TIMES ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3304:8: ^( TIMES ( assertion_subexpression )+ )
=======
							// 3306:5: -> ^( TIMES ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3306:8: ^( TIMES ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_TIMES.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 3 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3306:3: MINUS assertion_subexpression
							{
							MINUS363=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_expression14886); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(MINUS363);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14888);
							assertion_subexpression364=assertion_subexpression();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3308:3: MINUS assertion_subexpression
							{
							MINUS362=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_expression14903); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(MINUS362);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14905);
							assertion_subexpression363=assertion_subexpression();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression364.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, MINUS
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3307:5: -> ^( MINUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3307:8: ^( MINUS ( assertion_subexpression )+ )
=======
							// 3309:5: -> ^( MINUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3309:8: ^( MINUS ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_MINUS.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 4 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3309:3: DIVIDE assertion_subexpression
							{
							DIVIDE365=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_assertion_expression14919); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(DIVIDE365);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14921);
							assertion_subexpression366=assertion_subexpression();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3311:3: DIVIDE assertion_subexpression
							{
							DIVIDE364=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_assertion_expression14936); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(DIVIDE364);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14938);
							assertion_subexpression365=assertion_subexpression();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression366.getTree());
							// AST REWRITE
							// elements: DIVIDE, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3310:5: -> ^( DIVIDE ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3310:8: ^( DIVIDE ( assertion_subexpression )+ )
=======
							// 3312:5: -> ^( DIVIDE ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3312:8: ^( DIVIDE ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_DIVIDE.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 5 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3312:3: EXP assertion_subexpression
							{
							EXP367=(Token)match(input,EXP,FOLLOW_EXP_in_assertion_expression14953); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EXP.add(EXP367);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14955);
							assertion_subexpression368=assertion_subexpression();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3314:3: EXP assertion_subexpression
							{
							EXP366=(Token)match(input,EXP,FOLLOW_EXP_in_assertion_expression14970); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EXP.add(EXP366);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14972);
							assertion_subexpression367=assertion_subexpression();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression368.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, EXP
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3313:5: -> ^( EXP ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3313:8: ^( EXP ( assertion_subexpression )+ )
=======
							// 3315:5: -> ^( EXP ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3315:8: ^( EXP ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_EXP.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 6 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3315:3: LITERAL_mod assertion_subexpression
							{
							LITERAL_mod369=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_assertion_expression14987); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_mod.add(LITERAL_mod369);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14989);
							assertion_subexpression370=assertion_subexpression();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3317:3: LITERAL_mod assertion_subexpression
							{
							LITERAL_mod368=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_assertion_expression15004); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_mod.add(LITERAL_mod368);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression15006);
							assertion_subexpression369=assertion_subexpression();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression370.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, LITERAL_mod
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3316:5: -> ^( LITERAL_mod ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3316:8: ^( LITERAL_mod ( assertion_subexpression )+ )
=======
							// 3318:5: -> ^( LITERAL_mod ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3318:8: ^( LITERAL_mod ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_mod.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 7 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3318:3: LITERAL_rem assertion_subexpression
							{
							LITERAL_rem371=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_assertion_expression15014); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_rem.add(LITERAL_rem371);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression15016);
							assertion_subexpression372=assertion_subexpression();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3320:3: LITERAL_rem assertion_subexpression
							{
							LITERAL_rem370=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_assertion_expression15031); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_rem.add(LITERAL_rem370);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression15033);
							assertion_subexpression371=assertion_subexpression();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression372.getTree());
							// AST REWRITE
							// elements: LITERAL_rem, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3319:5: -> ^( LITERAL_rem ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3319:8: ^( LITERAL_rem ( assertion_subexpression )+ )
=======
							// 3321:5: -> ^( LITERAL_rem ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3321:8: ^( LITERAL_rem ( assertion_subexpression )+ )
>>>>>>> origin/continuum
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_rem.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 8 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3321:5: 
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3323:5: 
>>>>>>> origin/continuum
							{
							// AST REWRITE
							// elements: assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
							// 3321:5: -> assertion_subexpression
=======
							// 3323:5: -> assertion_subexpression
>>>>>>> origin/continuum
							{
								adaptor.addChild(root_0, stream_assertion_subexpression.nextTree());
							}


							retval.tree = root_0;
							}

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_expression"


	public static class assertion_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_subexpression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3329:1: assertion_subexpression : ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc);
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3331:1: assertion_subexpression : ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc);
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_subexpression_return assertion_subexpression() throws RecognitionException {
		BLESStoASTParser.assertion_subexpression_return retval = new BLESStoASTParser.assertion_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		Token abs=null;
		ParserRuleReturnScope ts =null;
		ParserRuleReturnScope atc =null;

		BAST m_tree=null;
		BAST abs_tree=null;
		RewriteRuleTokenStream stream_LITERAL_abs=new RewriteRuleTokenStream(adaptor,"token LITERAL_abs");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_timed_expression=new RewriteRuleSubtreeStream(adaptor,"rule timed_expression");
		RewriteRuleSubtreeStream stream_assertion_type_conversion=new RewriteRuleSubtreeStream(adaptor,"rule assertion_type_conversion");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3330:3: ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc)
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3332:3: ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc)
>>>>>>> origin/continuum
			int alt195=2;
			int LA195_0 = input.LA(1);
			if ( (LA195_0==AADL_STRING_LITERAL||LA195_0==ID||LA195_0==INTEGER_LIT||LA195_0==LBRACKET||LA195_0==LITERAL_abs||LA195_0==LITERAL_false||LA195_0==LITERAL_in||LA195_0==LITERAL_now||LA195_0==LITERAL_null||LA195_0==LITERAL_self||LA195_0==LITERAL_timeout||LA195_0==LITERAL_tops||LA195_0==LITERAL_true||LA195_0==LPAREN||LA195_0==MINUS||LA195_0==OCTOTHORPE||LA195_0==REAL_LIT) ) {
				alt195=1;
			}
			else if ( (LA195_0==LITERAL_complex||LA195_0==LITERAL_integer||LA195_0==LITERAL_natural||(LA195_0 >= LITERAL_rational && LA195_0 <= LITERAL_real)||LA195_0==LITERAL_time) ) {
				alt195=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 195, 0, input);
				throw nvae;
			}

			switch (alt195) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3331:3: (m= MINUS |abs= LITERAL_abs )? ts= timed_expression
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3331:3: (m= MINUS |abs= LITERAL_abs )?
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3333:3: (m= MINUS |abs= LITERAL_abs )? ts= timed_expression
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3333:3: (m= MINUS |abs= LITERAL_abs )?
>>>>>>> origin/continuum
					int alt194=3;
					int LA194_0 = input.LA(1);
					if ( (LA194_0==MINUS) ) {
						alt194=1;
					}
					else if ( (LA194_0==LITERAL_abs) ) {
						alt194=2;
					}
					switch (alt194) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3331:5: m= MINUS
							{
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_subexpression15076); if (state.failed) return retval; 
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3333:5: m= MINUS
							{
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_subexpression15093); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_MINUS.add(m);

							}
							break;
						case 2 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3331:15: abs= LITERAL_abs
							{
							abs=(Token)match(input,LITERAL_abs,FOLLOW_LITERAL_abs_in_assertion_subexpression15082); if (state.failed) return retval; 
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3333:15: abs= LITERAL_abs
							{
							abs=(Token)match(input,LITERAL_abs,FOLLOW_LITERAL_abs_in_assertion_subexpression15099); if (state.failed) return retval; 
>>>>>>> origin/continuum
							if ( state.backtracking==0 ) stream_LITERAL_abs.add(abs);

							}
							break;

					}

<<<<<<< HEAD
					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression15102);
=======
					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression15119);
>>>>>>> origin/continuum
					ts=timed_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_timed_expression.add(ts.getTree());
					// AST REWRITE
<<<<<<< HEAD
					// elements: ts, abs, ts, ts
=======
					// elements: ts, ts, abs, ts
>>>>>>> origin/continuum
					// token labels: abs
					// rule labels: retval, ts
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_abs=new RewriteRuleTokenStream(adaptor,"token abs",abs);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ts=new RewriteRuleSubtreeStream(adaptor,"rule ts",ts!=null?ts.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3359:5: -> {m!=null}? ^( UNARY_MINUS[$m] $ts)
					if (m!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3359:19: ^( UNARY_MINUS[$m] $ts)
=======
					// 3361:5: -> {m!=null}? ^( UNARY_MINUS[$m] $ts)
					if (m!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3361:19: ^( UNARY_MINUS[$m] $ts)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_ts.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3360:5: -> {abs!=null}? ^( $abs $ts)
					if (abs!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3360:21: ^( $abs $ts)
=======
					else // 3362:5: -> {abs!=null}? ^( $abs $ts)
					if (abs!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3362:21: ^( $abs $ts)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_abs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ts.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

<<<<<<< HEAD
					else // 3361:5: -> $ts
=======
					else // 3363:5: -> $ts
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_ts.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3367:6: atc= assertion_type_conversion
					{
					pushFollow(FOLLOW_assertion_type_conversion_in_assertion_subexpression15162);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3369:6: atc= assertion_type_conversion
					{
					pushFollow(FOLLOW_assertion_type_conversion_in_assertion_subexpression15179);
>>>>>>> origin/continuum
					atc=assertion_type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_type_conversion.add(atc.getTree());
					// AST REWRITE
					// elements: atc
					// token labels: 
					// rule labels: atc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_atc=new RewriteRuleSubtreeStream(adaptor,"rule atc",atc!=null?atc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3368:5: -> $atc
=======
					// 3370:5: -> $atc
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_atc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.assertion_subexpression");
			    tellBNF(GrammarStrings.predicateSubexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_subexpression"


	public static class timed_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timed_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3375:1: timed_expression : vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3377:1: timed_expression : vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.timed_expression_return timed_expression() throws RecognitionException {
		BLESStoASTParser.timed_expression_return retval = new BLESStoASTParser.timed_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK374=null;
		Token AT_SIGN375=null;
		Token CARET377=null;
		ParserRuleReturnScope vpa373 =null;
		ParserRuleReturnScope time_subexpression376 =null;
		ParserRuleReturnScope period_shift378 =null;

		BAST TICK374_tree=null;
		BAST AT_SIGN375_tree=null;
		BAST CARET377_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3376:3: ( vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3377:3: vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3378:3: ( vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3379:3: vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_vpa_in_timed_expression15195);
			vpa373=vpa();
=======
			pushFollow(FOLLOW_vpa_in_timed_expression15212);
			vpa372=vpa();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, vpa373.getTree());

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3378:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3380:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
>>>>>>> origin/continuum
			int alt196=4;
			switch ( input.LA(1) ) {
				case TICK:
					{
					alt196=1;
					}
					break;
				case AT_SIGN:
					{
					alt196=2;
					}
					break;
				case CARET:
					{
					alt196=3;
					}
					break;
			}
			switch (alt196) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3378:4: TICK ^
					{
					TICK374=(Token)match(input,TICK,FOLLOW_TICK_in_timed_expression15200); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3380:4: TICK ^
					{
					TICK373=(Token)match(input,TICK,FOLLOW_TICK_in_timed_expression15217); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					TICK374_tree = (BAST)adaptor.create(TICK374);
					root_0 = (BAST)adaptor.becomeRoot(TICK374_tree, root_0);
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3379:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN375=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_expression15208); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3381:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN374=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_expression15225); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					AT_SIGN375_tree = (BAST)adaptor.create(AT_SIGN375);
					root_0 = (BAST)adaptor.becomeRoot(AT_SIGN375_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_time_subexpression_in_timed_expression15211);
					time_subexpression376=time_subexpression();
=======
					pushFollow(FOLLOW_time_subexpression_in_timed_expression15228);
					time_subexpression375=time_subexpression();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_subexpression376.getTree());

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3380:6: CARET ^ period_shift
					{
					CARET377=(Token)match(input,CARET,FOLLOW_CARET_in_timed_expression15220); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3382:6: CARET ^ period_shift
					{
					CARET376=(Token)match(input,CARET,FOLLOW_CARET_in_timed_expression15237); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					CARET377_tree = (BAST)adaptor.create(CARET377);
					root_0 = (BAST)adaptor.becomeRoot(CARET377_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_period_shift_in_timed_expression15223);
					period_shift378=period_shift();
=======
					pushFollow(FOLLOW_period_shift_in_timed_expression15240);
					period_shift377=period_shift();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, period_shift378.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_expression"


	public static class vpa_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "vpa"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3384:1: vpa : (v= value | parenthesized_assertion_expression | assertion_function_invocation );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3386:1: vpa : (v= value | parenthesized_assertion_expression | assertion_function_invocation );
>>>>>>> origin/continuum
	public final BLESStoASTParser.vpa_return vpa() throws RecognitionException {
		BLESStoASTParser.vpa_return retval = new BLESStoASTParser.vpa_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope v =null;
		ParserRuleReturnScope parenthesized_assertion_expression379 =null;
		ParserRuleReturnScope assertion_function_invocation380 =null;


		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3385:3: (v= value | parenthesized_assertion_expression | assertion_function_invocation )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3387:3: (v= value | parenthesized_assertion_expression | assertion_function_invocation )
>>>>>>> origin/continuum
			int alt197=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt197=1;
				}
				break;
			case ID:
				{
				int LA197_2 = input.LA(2);
				if ( (LA197_2==LPAREN) ) {
					alt197=3;
				}
<<<<<<< HEAD
				else if ( (LA197_2==EOF||(LA197_2 >= AL && LA197_2 <= AM)||LA197_2==ANNEX_END||LA197_2==AT_SIGN||LA197_2==CARET||(LA197_2 >= COLON && LA197_2 <= COMMADOT)||LA197_2==DIVIDE||(LA197_2 >= DOTCOMMA && LA197_2 <= DOUBLE_COLON)||LA197_2==EQ||LA197_2==EXP||LA197_2==GT||LA197_2==IMP||LA197_2==LBRACKET||LA197_2==LITERAL_and||LA197_2==LITERAL_are||LA197_2==LITERAL_else||LA197_2==LITERAL_iff||(LA197_2 >= LITERAL_implies && LA197_2 <= LITERAL_in)||LA197_2==LITERAL_mod||LA197_2==LITERAL_of||LA197_2==LITERAL_or||LA197_2==LITERAL_rem||(LA197_2 >= LITERAL_that && LA197_2 <= LITERAL_then)||LA197_2==LITERAL_xor||LA197_2==LT||LA197_2==MINUS||LA197_2==NEQ||LA197_2==OCTOTHORPE||(LA197_2 >= PERIOD && LA197_2 <= PLUS)||(LA197_2 >= QQ && LA197_2 <= RASS)||LA197_2==RPAREN||LA197_2==TICK||LA197_2==TIMES) ) {
=======
				else if ( (LA197_2==EOF||(LA197_2 >= AL && LA197_2 <= AM)||LA197_2==ANNEX_END||LA197_2==AT_SIGN||LA197_2==CARET||LA197_2==COLON||(LA197_2 >= COMMA && LA197_2 <= COMMADOT)||LA197_2==DIVIDE||(LA197_2 >= DOTCOMMA && LA197_2 <= DOUBLE_COLON)||LA197_2==EQ||LA197_2==EXP||LA197_2==GT||LA197_2==IMP||LA197_2==LBRACKET||LA197_2==LITERAL_and||LA197_2==LITERAL_are||LA197_2==LITERAL_else||LA197_2==LITERAL_iff||(LA197_2 >= LITERAL_implies && LA197_2 <= LITERAL_in)||LA197_2==LITERAL_mod||LA197_2==LITERAL_of||LA197_2==LITERAL_or||LA197_2==LITERAL_rem||(LA197_2 >= LITERAL_that && LA197_2 <= LITERAL_then)||LA197_2==LITERAL_xor||LA197_2==LT||LA197_2==MINUS||LA197_2==NEQ||LA197_2==OCTOTHORPE||(LA197_2 >= PERIOD && LA197_2 <= PLUS)||(LA197_2 >= QQ && LA197_2 <= RASS)||LA197_2==RPAREN||LA197_2==TICK||LA197_2==TIMES) ) {
>>>>>>> origin/continuum
					alt197=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 197, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt197=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 197, 0, input);
				throw nvae;
			}
			switch (alt197) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3386:3: v= value
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3388:3: v= value
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_value_in_vpa15251);
=======
					pushFollow(FOLLOW_value_in_vpa15268);
>>>>>>> origin/continuum
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, v.getTree());

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3388:3: parenthesized_assertion_expression
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3390:3: parenthesized_assertion_expression
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_vpa15261);
					parenthesized_assertion_expression379=parenthesized_assertion_expression();
=======
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_vpa15278);
					parenthesized_assertion_expression378=parenthesized_assertion_expression();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_assertion_expression379.getTree());

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3390:3: assertion_function_invocation
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3392:3: assertion_function_invocation
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_assertion_function_invocation_in_vpa15271);
					assertion_function_invocation380=assertion_function_invocation();
=======
					pushFollow(FOLLOW_assertion_function_invocation_in_vpa15288);
					assertion_function_invocation379=assertion_function_invocation();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_function_invocation380.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vpa"


	public static class time_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3393:1: time_expression : lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3395:1: time_expression : lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.time_expression_return time_expression() throws RecognitionException {
		BLESStoASTParser.time_expression_return retval = new BLESStoASTParser.time_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token sym=null;
		Token PLUS381=null;
		Token TIMES382=null;
		List<Object> list_rhs=null;
		ParserRuleReturnScope lhs =null;
		RuleReturnScope rhs = null;
		BAST sym_tree=null;
		BAST PLUS381_tree=null;
		BAST TIMES382_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3394:3: (lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3395:3: lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:3: (lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:3: lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			pushFollow(FOLLOW_time_subexpression_in_time_expression15288);
=======
			pushFollow(FOLLOW_time_subexpression_in_time_expression15305);
>>>>>>> origin/continuum
			lhs=time_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, lhs.getTree());

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3396:3: ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3398:3: ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
>>>>>>> origin/continuum
			int alt200=8;
			switch ( input.LA(1) ) {
				case PLUS:
					{
					alt200=1;
					}
					break;
				case TIMES:
					{
					alt200=2;
					}
					break;
				case MINUS:
					{
					alt200=3;
					}
					break;
				case DIVIDE:
					{
					alt200=4;
					}
					break;
				case EXP:
					{
					alt200=5;
					}
					break;
				case LITERAL_mod:
					{
					alt200=6;
					}
					break;
				case LITERAL_rem:
					{
					alt200=7;
					}
					break;
			}
			switch (alt200) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:4: sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )*
					{
					sym=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15299); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:4: sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )*
					{
					sym=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15316); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_time_subexpression_in_time_expression15304);
=======
					pushFollow(FOLLOW_time_subexpression_in_time_expression15321);
>>>>>>> origin/continuum
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:38: ( PLUS rhs+= time_subexpression )*
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:38: ( PLUS rhs+= time_subexpression )*
>>>>>>> origin/continuum
					loop198:
					while (true) {
						int alt198=2;
						int LA198_0 = input.LA(1);
						if ( (LA198_0==PLUS) ) {
							alt198=1;
						}

						switch (alt198) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:40: PLUS rhs+= time_subexpression
							{
							PLUS381=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15308); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PLUS381_tree = (BAST)adaptor.create(PLUS381);
							adaptor.addChild(root_0, PLUS381_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15312);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:40: PLUS rhs+= time_subexpression
							{
							PLUS380=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15325); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PLUS380_tree = (BAST)adaptor.create(PLUS380);
							adaptor.addChild(root_0, PLUS380_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15329);
>>>>>>> origin/continuum
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop198;
						}
					}

					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:4: sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )*
					{
					sym=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15327); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15332);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:39: ( TIMES rhs+= time_subexpression )*
					loop199:
					while (true) {
						int alt199=2;
						int LA199_0 = input.LA(1);
						if ( (LA199_0==TIMES) ) {
							alt199=1;
						}

						switch (alt199) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3399:41: TIMES rhs+= time_subexpression
							{
							TIMES382=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15336); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							TIMES382_tree = (BAST)adaptor.create(TIMES382);
							adaptor.addChild(root_0, TIMES382_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15340);
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop199;
						}
					}

					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:3: (sym= MINUS ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:3: (sym= MINUS ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:4: sym= MINUS ^rhs+= time_subexpression
					{
					sym=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_expression15355); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15360);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:3: (sym= DIVIDE ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:3: (sym= DIVIDE ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:4: sym= DIVIDE ^rhs+= time_subexpression
					{
					sym=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_time_expression15373); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15378);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3405:3: (sym= EXP ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3405:3: (sym= EXP ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3405:4: sym= EXP ^rhs+= time_subexpression
					{
					sym=(Token)match(input,EXP,FOLLOW_EXP_in_time_expression15391); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15396);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3407:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3407:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3407:4: sym= LITERAL_mod ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_time_expression15409); if (state.failed) return retval;
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:4: sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )*
					{
					sym=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15344); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15349);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:39: ( TIMES rhs+= time_subexpression )*
					loop199:
					while (true) {
						int alt199=2;
						int LA199_0 = input.LA(1);
						if ( (LA199_0==TIMES) ) {
							alt199=1;
						}

						switch (alt199) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:41: TIMES rhs+= time_subexpression
							{
							TIMES381=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15353); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							TIMES381_tree = (BAST)adaptor.create(TIMES381);
							adaptor.addChild(root_0, TIMES381_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15357);
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop199;
						}
					}

					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:3: (sym= MINUS ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:3: (sym= MINUS ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:4: sym= MINUS ^rhs+= time_subexpression
					{
					sym=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_expression15372); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15414);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
<<<<<<< HEAD
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3409:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3409:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3409:4: sym= LITERAL_rem ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_time_expression15427); if (state.failed) return retval;
=======
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3405:3: (sym= DIVIDE ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3405:3: (sym= DIVIDE ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3405:4: sym= DIVIDE ^rhs+= time_subexpression
					{
					sym=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_time_expression15390); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15432);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3407:3: (sym= EXP ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3407:3: (sym= EXP ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3407:4: sym= EXP ^rhs+= time_subexpression
					{
					sym=(Token)match(input,EXP,FOLLOW_EXP_in_time_expression15408); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15413);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3409:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3409:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3409:4: sym= LITERAL_mod ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_time_expression15426); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15431);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3411:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3411:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3411:4: sym= LITERAL_rem ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_time_expression15444); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15449);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_expression"


	public static class time_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_subexpression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3413:1: time_subexpression : (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3415:1: time_subexpression : (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.time_subexpression_return time_subexpression() throws RecognitionException {
		BLESStoASTParser.time_subexpression_return retval = new BLESStoASTParser.time_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token um=null;
		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope val =null;
		ParserRuleReturnScope afi =null;
		ParserRuleReturnScope exp =null;

		BAST um_tree=null;
		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_time_expression=new RewriteRuleSubtreeStream(adaptor,"rule time_expression");
		RewriteRuleSubtreeStream stream_assertion_function_invocation=new RewriteRuleSubtreeStream(adaptor,"rule assertion_function_invocation");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3414:3: ( (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3415:3: (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3415:3: (um= MINUS )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3416:3: ( (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3417:3: (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3417:3: (um= MINUS )?
>>>>>>> origin/continuum
			int alt201=2;
			int LA201_0 = input.LA(1);
			if ( (LA201_0==MINUS) ) {
				alt201=1;
			}
			switch (alt201) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3415:4: um= MINUS
					{
					um=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_subexpression15459); if (state.failed) return retval; 
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3417:4: um= MINUS
					{
					um=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_subexpression15476); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_MINUS.add(um);

					}
					break;

			}

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3416:3: (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3418:3: (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
>>>>>>> origin/continuum
			int alt202=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt202=1;
				}
				break;
			case ID:
				{
				int LA202_2 = input.LA(2);
				if ( (LA202_2==LPAREN) ) {
					alt202=2;
				}
<<<<<<< HEAD
				else if ( (LA202_2==EOF||(LA202_2 >= AL && LA202_2 <= AM)||LA202_2==ANNEX_END||(LA202_2 >= COLON && LA202_2 <= COMMADOT)||LA202_2==DIVIDE||(LA202_2 >= DOTCOMMA && LA202_2 <= DOUBLE_COLON)||LA202_2==EQ||LA202_2==EXP||LA202_2==GT||LA202_2==IMP||LA202_2==LBRACKET||LA202_2==LITERAL_and||LA202_2==LITERAL_are||LA202_2==LITERAL_else||LA202_2==LITERAL_iff||(LA202_2 >= LITERAL_implies && LA202_2 <= LITERAL_in)||LA202_2==LITERAL_mod||LA202_2==LITERAL_of||LA202_2==LITERAL_or||LA202_2==LITERAL_rem||(LA202_2 >= LITERAL_that && LA202_2 <= LITERAL_then)||LA202_2==LITERAL_xor||LA202_2==LT||LA202_2==MINUS||LA202_2==NEQ||LA202_2==OCTOTHORPE||(LA202_2 >= PERIOD && LA202_2 <= PLUS)||(LA202_2 >= QQ && LA202_2 <= RASS)||LA202_2==RPAREN||LA202_2==TICK||LA202_2==TIMES) ) {
=======
				else if ( (LA202_2==EOF||(LA202_2 >= AL && LA202_2 <= AM)||LA202_2==ANNEX_END||LA202_2==COLON||(LA202_2 >= COMMA && LA202_2 <= COMMADOT)||LA202_2==DIVIDE||(LA202_2 >= DOTCOMMA && LA202_2 <= DOUBLE_COLON)||LA202_2==EQ||LA202_2==EXP||LA202_2==GT||LA202_2==IMP||LA202_2==LBRACKET||LA202_2==LITERAL_and||LA202_2==LITERAL_are||LA202_2==LITERAL_else||LA202_2==LITERAL_iff||(LA202_2 >= LITERAL_implies && LA202_2 <= LITERAL_in)||LA202_2==LITERAL_mod||LA202_2==LITERAL_of||LA202_2==LITERAL_or||LA202_2==LITERAL_rem||(LA202_2 >= LITERAL_that && LA202_2 <= LITERAL_then)||LA202_2==LITERAL_xor||LA202_2==LT||LA202_2==MINUS||LA202_2==NEQ||LA202_2==OCTOTHORPE||(LA202_2 >= PERIOD && LA202_2 <= PLUS)||(LA202_2 >= QQ && LA202_2 <= RASS)||LA202_2==RPAREN||LA202_2==TICK||LA202_2==TIMES) ) {
>>>>>>> origin/continuum
					alt202=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 202, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt202=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 202, 0, input);
				throw nvae;
			}
			switch (alt202) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3416:5: val= value
					{
					pushFollow(FOLLOW_value_in_time_subexpression15469);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3418:5: val= value
					{
					pushFollow(FOLLOW_value_in_time_subexpression15486);
>>>>>>> origin/continuum
					val=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(val.getTree());
					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3417:5: afi= assertion_function_invocation
					{
					pushFollow(FOLLOW_assertion_function_invocation_in_time_subexpression15477);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3419:5: afi= assertion_function_invocation
					{
					pushFollow(FOLLOW_assertion_function_invocation_in_time_subexpression15494);
>>>>>>> origin/continuum
					afi=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_invocation.add(afi.getTree());
					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3418:5: lp= LPAREN exp= time_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_time_subexpression15486); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_time_expression_in_time_subexpression15490);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3420:5: lp= LPAREN exp= time_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_time_subexpression15503); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_time_expression_in_time_subexpression15507);
>>>>>>> origin/continuum
					exp=time_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_time_expression.add(exp.getTree());
<<<<<<< HEAD
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_time_subexpression15494); if (state.failed) return retval; 
=======
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_time_subexpression15511); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: afi, afi, val, exp, exp, rp, val, lp, lp, rp
=======
			// elements: rp, exp, afi, exp, val, rp, lp, afi, val, lp
>>>>>>> origin/continuum
			// token labels: lp, rp
			// rule labels: val, afi, exp, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
			RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
			RewriteRuleSubtreeStream stream_val=new RewriteRuleSubtreeStream(adaptor,"rule val",val!=null?val.getTree():null);
			RewriteRuleSubtreeStream stream_afi=new RewriteRuleSubtreeStream(adaptor,"rule afi",afi!=null?afi.getTree():null);
			RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp",exp!=null?exp.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
			// 3420:5: -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val)
			if ((um!=null)&&(val!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3420:35: ^( UNARY_MINUS[$um] $val)
=======
			// 3422:5: -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val)
			if ((um!=null)&&(val!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:35: ^( UNARY_MINUS[$um] $val)
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				adaptor.addChild(root_1, stream_val.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3421:5: -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi)
			if ((um!=null)&&(afi!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3421:35: ^( UNARY_MINUS[$um] $afi)
=======
			else // 3423:5: -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi)
			if ((um!=null)&&(afi!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3423:35: ^( UNARY_MINUS[$um] $afi)
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				adaptor.addChild(root_1, stream_afi.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3422:5: -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
			if ((um!=null)&&(lp!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:34: ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:53: ^( $lp $exp $rp)
=======
			else // 3424:5: -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
			if ((um!=null)&&(lp!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3424:34: ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3424:53: ^( $lp $exp $rp)
>>>>>>> origin/continuum
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_2);
				adaptor.addChild(root_2, stream_exp.nextTree());
				adaptor.addChild(root_2, stream_rp.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3423:5: -> {val!=null}? $val
=======
			else // 3425:5: -> {val!=null}? $val
>>>>>>> origin/continuum
			if (val!=null) {
				adaptor.addChild(root_0, stream_val.nextTree());
			}

<<<<<<< HEAD
			else // 3424:5: -> {afi!=null}? $afi
=======
			else // 3426:5: -> {afi!=null}? $afi
>>>>>>> origin/continuum
			if (afi!=null) {
				adaptor.addChild(root_0, stream_afi.nextTree());
			}

<<<<<<< HEAD
			else // 3425:5: -> ^( $lp $exp $rp)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3425:8: ^( $lp $exp $rp)
=======
			else // 3427:5: -> ^( $lp $exp $rp)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3427:8: ^( $lp $exp $rp)
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
				adaptor.addChild(root_1, stream_exp.nextTree());
				adaptor.addChild(root_1, stream_rp.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_subexpression"


	public static class assertion_function_invocation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_function_invocation"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3428:1: assertion_function_invocation : (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3430:1: assertion_function_invocation : (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_function_invocation_return assertion_function_invocation() throws RecognitionException {
		BLESStoASTParser.assertion_function_invocation_return retval = new BLESStoASTParser.assertion_function_invocation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token assertion_function_identifier=null;
		Token lp=null;
		Token RPAREN383=null;
		Token COMMA384=null;
		Token RPAREN385=null;
		List<Object> list_list=null;
		ParserRuleReturnScope actual =null;
		RuleReturnScope list = null;
		BAST assertion_function_identifier_tree=null;
		BAST lp_tree=null;
		BAST RPAREN383_tree=null;
		BAST COMMA384_tree=null;
		BAST RPAREN385_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_actual_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule actual_assertion_parameter");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3429:3: (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3431:3: (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) )
>>>>>>> origin/continuum
			int alt205=2;
			int LA205_0 = input.LA(1);
			if ( (LA205_0==ID) ) {
				int LA205_1 = input.LA(2);
				if ( (LA205_1==LPAREN) ) {
					int LA205_2 = input.LA(3);
					if ( (LA205_2==AADL_STRING_LITERAL||LA205_2==INTEGER_LIT||LA205_2==LBRACKET||LA205_2==LITERAL_abs||LA205_2==LITERAL_complex||LA205_2==LITERAL_false||LA205_2==LITERAL_in||LA205_2==LITERAL_integer||LA205_2==LITERAL_natural||LA205_2==LITERAL_now||(LA205_2 >= LITERAL_null && LA205_2 <= LITERAL_numberof)||LA205_2==LITERAL_product||(LA205_2 >= LITERAL_rational && LA205_2 <= LITERAL_real)||LA205_2==LITERAL_self||LA205_2==LITERAL_sum||(LA205_2 >= LITERAL_time && LA205_2 <= LITERAL_timeout)||LA205_2==LITERAL_tops||LA205_2==LITERAL_true||LA205_2==LPAREN||LA205_2==MINUS||LA205_2==OCTOTHORPE||LA205_2==REAL_LIT||LA205_2==RPAREN) ) {
						alt205=1;
					}
					else if ( (LA205_2==ID) ) {
						int LA205_4 = input.LA(4);
						if ( (LA205_4==AT_SIGN||LA205_4==CARET||LA205_4==DIVIDE||LA205_4==DOUBLE_COLON||LA205_4==EXP||LA205_4==LBRACKET||LA205_4==LITERAL_mod||LA205_4==LITERAL_rem||LA205_4==LPAREN||LA205_4==MINUS||LA205_4==OCTOTHORPE||(LA205_4 >= PERIOD && LA205_4 <= PLUS)||LA205_4==QUESTION||LA205_4==RPAREN||LA205_4==TICK||LA205_4==TIMES) ) {
							alt205=1;
						}
<<<<<<< HEAD
						else if ( (LA205_4==COLON) ) {
=======
						else if ( ((LA205_4 >= COLON && LA205_4 <= COLON_TILDE)) ) {
>>>>>>> origin/continuum
							alt205=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 205, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 205, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 205, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 205, 0, input);
				throw nvae;
			}

			switch (alt205) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3430:3: assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15614); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15618); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3430:52: (actual= assertion_expression )?
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:3: assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15631); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15635); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:52: (actual= assertion_expression )?
>>>>>>> origin/continuum
					int alt203=2;
					int LA203_0 = input.LA(1);
					if ( (LA203_0==AADL_STRING_LITERAL||LA203_0==ID||LA203_0==INTEGER_LIT||LA203_0==LBRACKET||LA203_0==LITERAL_abs||LA203_0==LITERAL_complex||LA203_0==LITERAL_false||LA203_0==LITERAL_in||LA203_0==LITERAL_integer||LA203_0==LITERAL_natural||LA203_0==LITERAL_now||(LA203_0 >= LITERAL_null && LA203_0 <= LITERAL_numberof)||LA203_0==LITERAL_product||(LA203_0 >= LITERAL_rational && LA203_0 <= LITERAL_real)||LA203_0==LITERAL_self||LA203_0==LITERAL_sum||(LA203_0 >= LITERAL_time && LA203_0 <= LITERAL_timeout)||LA203_0==LITERAL_tops||LA203_0==LITERAL_true||LA203_0==LPAREN||LA203_0==MINUS||LA203_0==OCTOTHORPE||LA203_0==REAL_LIT) ) {
						alt203=1;
					}
					switch (alt203) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3430:52: actual= assertion_expression
							{
							pushFollow(FOLLOW_assertion_expression_in_assertion_function_invocation15622);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:52: actual= assertion_expression
							{
							pushFollow(FOLLOW_assertion_expression_in_assertion_function_invocation15639);
>>>>>>> origin/continuum
							actual=assertion_expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
							}
							break;

					}

<<<<<<< HEAD
					RPAREN383=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15625); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN383);
=======
					RPAREN382=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15642); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN382);
>>>>>>> origin/continuum

					// AST REWRITE
					// elements: actual, assertion_function_identifier
					// token labels: assertion_function_identifier
					// rule labels: actual, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_assertion_function_identifier=new RewriteRuleTokenStream(adaptor,"token assertion_function_identifier",assertion_function_identifier);
					RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3431:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3431:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:9: ^( $assertion_function_identifier ( $actual)? )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:45: ( $actual)?
=======
					// 3433:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3433:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3434:9: ^( $assertion_function_identifier ( $actual)? )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3434:45: ( $actual)?
>>>>>>> origin/continuum
						if ( stream_actual.hasNext() ) {
							adaptor.addChild(root_2, stream_actual.nextTree());
						}
						stream_actual.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3434:3: assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15672); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15676); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15685);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3436:3: assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15689); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15693); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15702);
>>>>>>> origin/continuum
					list=actual_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(list.getTree());
					if (list_list==null) list_list=new ArrayList<Object>();
					list_list.add(list.getTree());
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3435:38: ( COMMA list+= actual_assertion_parameter )*
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3437:38: ( COMMA list+= actual_assertion_parameter )*
>>>>>>> origin/continuum
					loop204:
					while (true) {
						int alt204=2;
						int LA204_0 = input.LA(1);
						if ( (LA204_0==COMMA) ) {
							alt204=1;
						}

						switch (alt204) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3435:40: COMMA list+= actual_assertion_parameter
							{
							COMMA384=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_function_invocation15689); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA384);

							pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15693);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3437:40: COMMA list+= actual_assertion_parameter
							{
							COMMA383=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_function_invocation15706); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA383);

							pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15710);
>>>>>>> origin/continuum
							list=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(list.getTree());
							if (list_list==null) list_list=new ArrayList<Object>();
							list_list.add(list.getTree());
							}
							break;

						default :
							break loop204;
						}
					}

<<<<<<< HEAD
					RPAREN385=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15698); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN385);
=======
					RPAREN384=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15715); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN384);
>>>>>>> origin/continuum

					// AST REWRITE
					// elements: assertion_function_identifier, list
					// token labels: assertion_function_identifier
					// rule labels: retval
					// token list labels: 
					// rule list labels: list
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_assertion_function_identifier=new RewriteRuleTokenStream(adaptor,"token assertion_function_identifier",assertion_function_identifier);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_list=new RewriteRuleSubtreeStream(adaptor,"token list",list_list);
					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3436:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3436:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3437:9: ^( $assertion_function_identifier ( $list)+ )
=======
					// 3438:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3438:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3439:9: ^( $assertion_function_identifier ( $list)+ )
>>>>>>> origin/continuum
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						if ( !(stream_list.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_list.hasNext() ) {
							adaptor.addChild(root_2, stream_list.nextTree());
						}
						stream_list.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("Did you forget the formal identifier when invoking an assertion-function?");
			  Dump.it("actual_assertion_parameter ::= formal_identifier : actual_assertion_expression"); 
			  throw re;
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_invocation"


	public static class parenthesized_assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_assertion_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3444:1: parenthesized_assertion_expression : ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3446:1: parenthesized_assertion_expression : ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.parenthesized_assertion_expression_return parenthesized_assertion_expression() throws RecognitionException {
		BLESStoASTParser.parenthesized_assertion_expression_return retval = new BLESStoASTParser.parenthesized_assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope cpe =null;
		ParserRuleReturnScope art =null;
		ParserRuleReturnScope caf =null;
		ParserRuleReturnScope pe =null;

		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_conditional_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_expression");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_conditional_assertion_function=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_function");
		RewriteRuleSubtreeStream stream_assertion_record_term=new RewriteRuleSubtreeStream(adaptor,"rule assertion_record_term");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3445:3: ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3447:3: ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) )
>>>>>>> origin/continuum
			int alt206=4;
			int LA206_0 = input.LA(1);
			if ( (LA206_0==LPAREN) ) {
				int LA206_1 = input.LA(2);
				if ( (synpred16_BLESStoAST()) ) {
					alt206=1;
				}
				else if ( (synpred17_BLESStoAST()) ) {
					alt206=2;
				}
				else if ( (synpred18_BLESStoAST()) ) {
					alt206=3;
				}
				else if ( (true) ) {
					alt206=4;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 206, 0, input);
				throw nvae;
			}

			switch (alt206) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3446:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression
					{
					pushFollow(FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15785);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3448:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression
					{
					pushFollow(FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15802);
>>>>>>> origin/continuum
					cpe=conditional_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_expression.add(cpe.getTree());
					// AST REWRITE
					// elements: cpe
					// token labels: 
					// rule labels: cpe, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cpe=new RewriteRuleSubtreeStream(adaptor,"rule cpe",cpe!=null?cpe.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3448:5: -> $cpe
=======
					// 3450:5: -> $cpe
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_cpe.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3450:3: ( LPAREN ID ARROW )=>art= assertion_record_term
					{
					pushFollow(FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15815);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3452:3: ( LPAREN ID ARROW )=>art= assertion_record_term
					{
					pushFollow(FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15832);
>>>>>>> origin/continuum
					art=assertion_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_record_term.add(art.getTree());
					// AST REWRITE
					// elements: art
					// token labels: 
					// rule labels: art, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_art=new RewriteRuleSubtreeStream(adaptor,"rule art",art!=null?art.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3452:5: -> $art
=======
					// 3454:5: -> $art
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_art.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3454:3: ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15849);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3456:3: ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15866);
>>>>>>> origin/continuum
					caf=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_function.add(caf.getTree());
					// AST REWRITE
					// elements: caf
					// token labels: 
					// rule labels: caf, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_caf=new RewriteRuleSubtreeStream(adaptor,"rule caf",caf!=null?caf.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3456:5: -> $caf
=======
					// 3458:5: -> $caf
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_caf.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3458:3: lp= LPAREN pe= assertion_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_assertion_expression15870); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_parenthesized_assertion_expression15874);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3460:3: lp= LPAREN pe= assertion_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_assertion_expression15887); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_parenthesized_assertion_expression15891);
>>>>>>> origin/continuum
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(pe.getTree());
<<<<<<< HEAD
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_assertion_expression15878); if (state.failed) return retval; 
=======
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_assertion_expression15895); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: pe, lp, rp
					// token labels: lp, rp
					// rule labels: pe, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_pe=new RewriteRuleSubtreeStream(adaptor,"rule pe",pe!=null?pe.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3459:5: -> ^( $lp $pe $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3459:8: ^( $lp $pe $rp)
=======
					// 3461:5: -> ^( $lp $pe $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3461:8: ^( $lp $pe $rp)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pe.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_assertion_expression"


	public static class conditional_assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_assertion_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3462:1: conditional_assertion_expression : ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3464:1: conditional_assertion_expression : ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) );
>>>>>>> origin/continuum
	public final BLESStoASTParser.conditional_assertion_expression_return conditional_assertion_expression() throws RecognitionException {
		BLESStoASTParser.conditional_assertion_expression_return retval = new BLESStoASTParser.conditional_assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token then=null;
		Token q=null;
		Token LPAREN386=null;
		Token LITERAL_if387=null;
		Token LITERAL_else388=null;
		Token RPAREN389=null;
		Token LPAREN390=null;
		Token COLON391=null;
		Token RPAREN392=null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope f =null;

		BAST then_tree=null;
		BAST q_tree=null;
		BAST LPAREN386_tree=null;
		BAST LITERAL_if387_tree=null;
		BAST LITERAL_else388_tree=null;
		BAST RPAREN389_tree=null;
		BAST LPAREN390_tree=null;
		BAST COLON391_tree=null;
		BAST RPAREN392_tree=null;
		RewriteRuleTokenStream stream_QQ=new RewriteRuleTokenStream(adaptor,"token QQ");
		RewriteRuleTokenStream stream_LITERAL_else=new RewriteRuleTokenStream(adaptor,"token LITERAL_else");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_then=new RewriteRuleTokenStream(adaptor,"token LITERAL_then");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3463:3: ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3465:3: ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) )
>>>>>>> origin/continuum
			int alt207=2;
			int LA207_0 = input.LA(1);
			if ( (LA207_0==LPAREN) ) {
				int LA207_1 = input.LA(2);
				if ( (LA207_1==LITERAL_if) ) {
					alt207=1;
				}
				else if ( (LA207_1==AADL_STRING_LITERAL||LA207_1==ID||LA207_1==INTEGER_LIT||LA207_1==LBRACKET||LA207_1==LITERAL_abs||LA207_1==LITERAL_all||LA207_1==LITERAL_complex||LA207_1==LITERAL_def||LA207_1==LITERAL_exists||LA207_1==LITERAL_false||LA207_1==LITERAL_in||LA207_1==LITERAL_integer||LA207_1==LITERAL_natural||(LA207_1 >= LITERAL_not && LA207_1 <= LITERAL_now)||LA207_1==LITERAL_null||(LA207_1 >= LITERAL_rational && LA207_1 <= LITERAL_real)||LA207_1==LITERAL_self||LA207_1==LITERAL_stop||(LA207_1 >= LITERAL_time && LA207_1 <= LITERAL_timeout)||LA207_1==LITERAL_tops||LA207_1==LITERAL_true||LA207_1==LPAREN||LA207_1==MINUS||LA207_1==OCTOTHORPE||LA207_1==REAL_LIT) ) {
					alt207=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 207, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 207, 0, input);
				throw nvae;
			}

			switch (alt207) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3464:3: LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN
					{
					LPAREN386=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15910); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN386);

					LITERAL_if387=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_assertion_expression15912); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if387);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15916);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3466:3: LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN
					{
					LPAREN385=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15927); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN385);

					LITERAL_if386=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_assertion_expression15929); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if386);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15933);
>>>>>>> origin/continuum
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
<<<<<<< HEAD
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_assertion_expression15920); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15925);
=======
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_assertion_expression15937); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15942);
>>>>>>> origin/continuum
					t=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(t.getTree());
<<<<<<< HEAD
					LITERAL_else388=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_assertion_expression15927); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else388);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15932);
=======
					LITERAL_else387=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_assertion_expression15944); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else387);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15949);
>>>>>>> origin/continuum
					f=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(f.getTree());
<<<<<<< HEAD
					RPAREN389=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression15934); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN389);

					// AST REWRITE
					// elements: p, t, f
=======
					RPAREN388=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression15951); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN388);

					// AST REWRITE
					// elements: t, p, f
>>>>>>> origin/continuum
					// token labels: 
					// rule labels: p, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3465:5: -> ^( CONDITIONAL[$then] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3465:8: ^( CONDITIONAL[$then] $p $t $f)
=======
					// 3467:5: -> ^( CONDITIONAL[$then] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3467:8: ^( CONDITIONAL[$then] $p $t $f)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, then), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3467:3: LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN
					{
					LPAREN390=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15962); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN390);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15966);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3469:3: LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN
					{
					LPAREN389=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15979); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN389);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15983);
>>>>>>> origin/continuum
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
<<<<<<< HEAD
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_assertion_expression15970); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15975);
=======
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_assertion_expression15987); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15992);
>>>>>>> origin/continuum
					t=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(t.getTree());
<<<<<<< HEAD
					COLON391=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_assertion_expression15977); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON391);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15982);
=======
					COLON390=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_assertion_expression15994); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON390);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15999);
>>>>>>> origin/continuum
					f=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(f.getTree());
<<<<<<< HEAD
					RPAREN392=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression15984); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN392);
=======
					RPAREN391=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression16001); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN391);
>>>>>>> origin/continuum

					// AST REWRITE
					// elements: p, t, f
					// token labels: 
					// rule labels: p, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3468:5: -> ^( CONDITIONAL[$q] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3468:8: ^( CONDITIONAL[$q] $p $t $f)
=======
					// 3470:5: -> ^( CONDITIONAL[$q] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3470:8: ^( CONDITIONAL[$q] $p $t $f)
>>>>>>> origin/continuum
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, q), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_expression"


	public static class assertion_record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_record_term"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3471:1: assertion_record_term : LPAREN ^ ( assertion_record_value )+ RPAREN ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3473:1: assertion_record_term : LPAREN ^ ( assertion_record_value )+ RPAREN ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_record_term_return assertion_record_term() throws RecognitionException {
		BLESStoASTParser.assertion_record_term_return retval = new BLESStoASTParser.assertion_record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN393=null;
		Token RPAREN395=null;
		ParserRuleReturnScope assertion_record_value394 =null;

		BAST LPAREN393_tree=null;
		BAST RPAREN395_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3472:3: ( LPAREN ^ ( assertion_record_value )+ RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3473:5: LPAREN ^ ( assertion_record_value )+ RPAREN
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3474:3: ( LPAREN ^ ( assertion_record_value )+ RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3475:5: LPAREN ^ ( assertion_record_value )+ RPAREN
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LPAREN393=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_record_term16022); if (state.failed) return retval;
=======
			LPAREN392=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_record_term16039); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LPAREN393_tree = (BAST)adaptor.create(LPAREN393);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN393_tree, root_0);
			}

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3473:13: ( assertion_record_value )+
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3475:13: ( assertion_record_value )+
>>>>>>> origin/continuum
			int cnt208=0;
			loop208:
			while (true) {
				int alt208=2;
				int LA208_0 = input.LA(1);
				if ( (LA208_0==ID) ) {
					alt208=1;
				}

				switch (alt208) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3473:13: assertion_record_value
					{
					pushFollow(FOLLOW_assertion_record_value_in_assertion_record_term16025);
					assertion_record_value394=assertion_record_value();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3475:13: assertion_record_value
					{
					pushFollow(FOLLOW_assertion_record_value_in_assertion_record_term16042);
					assertion_record_value393=assertion_record_value();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_record_value394.getTree());

					}
					break;

				default :
					if ( cnt208 >= 1 ) break loop208;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(208, input);
					throw eee;
				}
				cnt208++;
			}

<<<<<<< HEAD
			RPAREN395=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_record_term16028); if (state.failed) return retval;
=======
			RPAREN394=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_record_term16045); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			RPAREN395_tree = (BAST)adaptor.create(RPAREN395);
			adaptor.addChild(root_0, RPAREN395_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_term"


	public static class assertion_record_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_record_value"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3476:1: assertion_record_value : ID ARROW ^ value SEMICOLON !;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3478:1: assertion_record_value : ID ARROW ^ value SEMICOLON !;
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_record_value_return assertion_record_value() throws RecognitionException {
		BLESStoASTParser.assertion_record_value_return retval = new BLESStoASTParser.assertion_record_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID396=null;
		Token ARROW397=null;
		Token SEMICOLON399=null;
		ParserRuleReturnScope value398 =null;

		BAST ID396_tree=null;
		BAST ARROW397_tree=null;
		BAST SEMICOLON399_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3477:3: ( ID ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3478:3: ID ARROW ^ value SEMICOLON !
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3479:3: ( ID ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3480:3: ID ARROW ^ value SEMICOLON !
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			ID396=(Token)match(input,ID,FOLLOW_ID_in_assertion_record_value16043); if (state.failed) return retval;
=======
			ID395=(Token)match(input,ID,FOLLOW_ID_in_assertion_record_value16060); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ID396_tree = (BAST)adaptor.create(ID396);
			adaptor.addChild(root_0, ID396_tree);
			}

<<<<<<< HEAD
			ARROW397=(Token)match(input,ARROW,FOLLOW_ARROW_in_assertion_record_value16045); if (state.failed) return retval;
=======
			ARROW396=(Token)match(input,ARROW,FOLLOW_ARROW_in_assertion_record_value16062); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ARROW397_tree = (BAST)adaptor.create(ARROW397);
			root_0 = (BAST)adaptor.becomeRoot(ARROW397_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_value_in_assertion_record_value16048);
			value398=value();
=======
			pushFollow(FOLLOW_value_in_assertion_record_value16065);
			value397=value();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value398.getTree());

<<<<<<< HEAD
			SEMICOLON399=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_assertion_record_value16050); if (state.failed) return retval;
=======
			SEMICOLON398=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_assertion_record_value16067); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_value"


	public static class assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_parameter"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3481:1: assertion_parameter : ID ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3483:1: assertion_parameter : ID ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_parameter_return assertion_parameter() throws RecognitionException {
		BLESStoASTParser.assertion_parameter_return retval = new BLESStoASTParser.assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID400=null;

		BAST ID400_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3482:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3483:3: ID
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3484:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:3: ID
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			ID400=(Token)match(input,ID,FOLLOW_ID_in_assertion_parameter16066); if (state.failed) return retval;
=======
			ID399=(Token)match(input,ID,FOLLOW_ID_in_assertion_parameter16083); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			ID400_tree = (BAST)adaptor.create(ID400);
			adaptor.addChild(root_0, ID400_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_parameter"


	public static class assertion_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_type"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3486:1: assertion_type : ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference );
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:1: assertion_type : ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference );
>>>>>>> origin/continuum
	public final BLESStoASTParser.assertion_type_return assertion_type() throws RecognitionException {
		BLESStoASTParser.assertion_type_return retval = new BLESStoASTParser.assertion_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_boolean401=null;
		Token LITERAL_natural402=null;
		Token LITERAL_integer403=null;
		Token LITERAL_rational404=null;
		Token LITERAL_real405=null;
		Token LITERAL_complex406=null;
		Token LITERAL_time407=null;
		ParserRuleReturnScope unique_component_classifier_reference408 =null;

		BAST LITERAL_boolean401_tree=null;
		BAST LITERAL_natural402_tree=null;
		BAST LITERAL_integer403_tree=null;
		BAST LITERAL_rational404_tree=null;
		BAST LITERAL_real405_tree=null;
		BAST LITERAL_complex406_tree=null;
		BAST LITERAL_time407_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3487:3: ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3489:3: ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference )
>>>>>>> origin/continuum
			int alt209=8;
			switch ( input.LA(1) ) {
			case LITERAL_boolean:
				{
				alt209=1;
				}
				break;
			case LITERAL_natural:
				{
				alt209=2;
				}
				break;
			case LITERAL_integer:
				{
				alt209=3;
				}
				break;
			case LITERAL_rational:
				{
				alt209=4;
				}
				break;
			case LITERAL_real:
				{
				alt209=5;
				}
				break;
			case LITERAL_complex:
				{
				alt209=6;
				}
				break;
			case LITERAL_time:
				{
				alt209=7;
				}
				break;
			case ID:
				{
				alt209=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 209, 0, input);
				throw nvae;
			}
			switch (alt209) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:3: LITERAL_boolean
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:3: LITERAL_boolean
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_boolean401=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_assertion_type16084); if (state.failed) return retval;
=======
					LITERAL_boolean400=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_assertion_type16101); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_boolean401_tree = (BAST)adaptor.create(LITERAL_boolean401);
					adaptor.addChild(root_0, LITERAL_boolean401_tree);
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:21: LITERAL_natural
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:21: LITERAL_natural
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_natural402=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type16088); if (state.failed) return retval;
=======
					LITERAL_natural401=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type16105); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_natural402_tree = (BAST)adaptor.create(LITERAL_natural402);
					adaptor.addChild(root_0, LITERAL_natural402_tree);
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:39: LITERAL_integer
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:39: LITERAL_integer
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_integer403=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type16092); if (state.failed) return retval;
=======
					LITERAL_integer402=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type16109); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_integer403_tree = (BAST)adaptor.create(LITERAL_integer403);
					adaptor.addChild(root_0, LITERAL_integer403_tree);
					}

					}
					break;
				case 4 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:57: LITERAL_rational
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:57: LITERAL_rational
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_rational404=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type16096); if (state.failed) return retval;
=======
					LITERAL_rational403=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type16113); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_rational404_tree = (BAST)adaptor.create(LITERAL_rational404);
					adaptor.addChild(root_0, LITERAL_rational404_tree);
					}

					}
					break;
				case 5 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:76: LITERAL_real
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:76: LITERAL_real
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_real405=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type16100); if (state.failed) return retval;
=======
					LITERAL_real404=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type16117); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_real405_tree = (BAST)adaptor.create(LITERAL_real405);
					adaptor.addChild(root_0, LITERAL_real405_tree);
					}

					}
					break;
				case 6 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:91: LITERAL_complex
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:91: LITERAL_complex
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_complex406=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type16104); if (state.failed) return retval;
=======
					LITERAL_complex405=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type16121); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_complex406_tree = (BAST)adaptor.create(LITERAL_complex406);
					adaptor.addChild(root_0, LITERAL_complex406_tree);
					}

					}
					break;
				case 7 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3489:4: LITERAL_time
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3491:4: LITERAL_time
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_time407=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type16109); if (state.failed) return retval;
=======
					LITERAL_time406=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type16126); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_time407_tree = (BAST)adaptor.create(LITERAL_time407);
					adaptor.addChild(root_0, LITERAL_time407_tree);
					}

					}
					break;
				case 8 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3491:5: unique_component_classifier_reference
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3493:5: unique_component_classifier_reference
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_unique_component_classifier_reference_in_assertion_type16116);
					unique_component_classifier_reference408=unique_component_classifier_reference();
=======
					pushFollow(FOLLOW_unique_component_classifier_reference_in_assertion_type16133);
					unique_component_classifier_reference407=unique_component_classifier_reference();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unique_component_classifier_reference408.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type"


	public static class availability_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3496:1: availability : LITERAL_availability ^ availability_subexpression ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3498:1: availability : LITERAL_availability ^ availability_subexpression ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.availability_return availability() throws RecognitionException {
		BLESStoASTParser.availability_return retval = new BLESStoASTParser.availability_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_availability409=null;
		ParserRuleReturnScope availability_subexpression410 =null;

		BAST LITERAL_availability409_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3497:3: ( LITERAL_availability ^ availability_subexpression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3498:3: LITERAL_availability ^ availability_subexpression
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3499:3: ( LITERAL_availability ^ availability_subexpression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3500:3: LITERAL_availability ^ availability_subexpression
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_availability409=(Token)match(input,LITERAL_availability,FOLLOW_LITERAL_availability_in_availability16142); if (state.failed) return retval;
=======
			LITERAL_availability408=(Token)match(input,LITERAL_availability,FOLLOW_LITERAL_availability_in_availability16159); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_availability409_tree = (BAST)adaptor.create(LITERAL_availability409);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_availability409_tree, root_0);
			}

<<<<<<< HEAD
			pushFollow(FOLLOW_availability_subexpression_in_availability16146);
			availability_subexpression410=availability_subexpression();
=======
			pushFollow(FOLLOW_availability_subexpression_in_availability16163);
			availability_subexpression409=availability_subexpression();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, availability_subexpression410.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability"


	public static class availability_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3501:1: availability_expression :ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3503:1: availability_expression :ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae;
>>>>>>> origin/continuum
	public final BLESStoASTParser.availability_expression_return availability_expression() throws RecognitionException {
		BLESStoASTParser.availability_expression_return retval = new BLESStoASTParser.availability_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dna=null;
		Token ro=null;
		Token rox=null;
		List<Object> list_ae=null;
		RuleReturnScope ae = null;
		BAST dna_tree=null;
		BAST ro_tree=null;
		BAST rox_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleSubtreeStream stream_availability_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule availability_subexpression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3502:3: (ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3503:3: ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
			{
			pushFollow(FOLLOW_availability_subexpression_in_availability_expression16167);
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3504:3: (ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3505:3: ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
			{
			pushFollow(FOLLOW_availability_subexpression_in_availability_expression16184);
>>>>>>> origin/continuum
			ae=availability_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
			if (list_ae==null) list_ae=new ArrayList<Object>();
			list_ae.add(ae.getTree());
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3504:3: ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3506:3: ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
>>>>>>> origin/continuum
			int alt213=4;
			switch ( input.LA(1) ) {
				case LITERAL_and:
					{
					alt213=1;
					}
					break;
				case LITERAL_or:
					{
					alt213=2;
					}
					break;
				case LITERAL_xor:
					{
					alt213=3;
					}
					break;
			}
			switch (alt213) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3505:5: (dna= LITERAL_and ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3505:5: (dna= LITERAL_and ae+= availability_subexpression )+
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3507:5: (dna= LITERAL_and ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3507:5: (dna= LITERAL_and ae+= availability_subexpression )+
>>>>>>> origin/continuum
					int cnt210=0;
					loop210:
					while (true) {
						int alt210=2;
						int LA210_0 = input.LA(1);
						if ( (LA210_0==LITERAL_and) ) {
							alt210=1;
						}

						switch (alt210) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3505:7: dna= LITERAL_and ae+= availability_subexpression
							{
							dna=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_availability_expression16181); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(dna);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16185);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3507:7: dna= LITERAL_and ae+= availability_subexpression
							{
							dna=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_availability_expression16198); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(dna);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16202);
>>>>>>> origin/continuum
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt210 >= 1 ) break loop210;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(210, input);
							throw eee;
						}
						cnt210++;
					}

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3507:5: (ro= LITERAL_or ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3507:5: (ro= LITERAL_or ae+= availability_subexpression )+
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:5: (ro= LITERAL_or ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:5: (ro= LITERAL_or ae+= availability_subexpression )+
>>>>>>> origin/continuum
					int cnt211=0;
					loop211:
					while (true) {
						int alt211=2;
						int LA211_0 = input.LA(1);
						if ( (LA211_0==LITERAL_or) ) {
							alt211=1;
						}

						switch (alt211) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3507:7: ro= LITERAL_or ae+= availability_subexpression
							{
							ro=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_availability_expression16204); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(ro);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16208);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:7: ro= LITERAL_or ae+= availability_subexpression
							{
							ro=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_availability_expression16221); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(ro);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16225);
>>>>>>> origin/continuum
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt211 >= 1 ) break loop211;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(211, input);
							throw eee;
						}
						cnt211++;
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:5: (rox= LITERAL_xor ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:5: (rox= LITERAL_xor ae+= availability_subexpression )+
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3511:5: (rox= LITERAL_xor ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3511:5: (rox= LITERAL_xor ae+= availability_subexpression )+
>>>>>>> origin/continuum
					int cnt212=0;
					loop212:
					while (true) {
						int alt212=2;
						int LA212_0 = input.LA(1);
						if ( (LA212_0==LITERAL_xor) ) {
							alt212=1;
						}

						switch (alt212) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:7: rox= LITERAL_xor ae+= availability_subexpression
							{
							rox=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_availability_expression16227); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(rox);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16231);
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3511:7: rox= LITERAL_xor ae+= availability_subexpression
							{
							rox=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_availability_expression16244); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(rox);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16248);
>>>>>>> origin/continuum
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt212 >= 1 ) break loop212;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(212, input);
							throw eee;
						}
						cnt212++;
					}

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: ro, ae, dna, ae, ae, rox, ae
=======
			// elements: ae, ae, ro, ae, rox, dna, ae
>>>>>>> origin/continuum
			// token labels: dna, rox, ro
			// rule labels: retval
			// token list labels: 
			// rule list labels: ae
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dna=new RewriteRuleTokenStream(adaptor,"token dna",dna);
			RewriteRuleTokenStream stream_rox=new RewriteRuleTokenStream(adaptor,"token rox",rox);
			RewriteRuleTokenStream stream_ro=new RewriteRuleTokenStream(adaptor,"token ro",ro);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"token ae",list_ae);
			root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
			// 3511:5: -> {dna!=null}? ^( $dna ( $ae)+ )
			if (dna!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3511:21: ^( $dna ( $ae)+ )
=======
			// 3513:5: -> {dna!=null}? ^( $dna ( $ae)+ )
			if (dna!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3513:21: ^( $dna ( $ae)+ )
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dna.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3512:5: -> {ro!=null}? ^( $ro ( $ae)+ )
			if (ro!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3512:20: ^( $ro ( $ae)+ )
=======
			else // 3514:5: -> {ro!=null}? ^( $ro ( $ae)+ )
			if (ro!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3514:20: ^( $ro ( $ae)+ )
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_ro.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3513:5: -> {rox!=null}? ^( $rox ( $ae)+ )
			if (rox!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3513:21: ^( $rox ( $ae)+ )
=======
			else // 3515:5: -> {rox!=null}? ^( $rox ( $ae)+ )
			if (rox!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3515:21: ^( $rox ( $ae)+ )
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_rox.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3514:5: -> $ae
=======
			else // 3516:5: -> $ae
>>>>>>> origin/continuum
			{
				adaptor.addChild(root_0, stream_ae.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_expression"


	public static class availability_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability_subexpression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3517:1: availability_subexpression : (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3519:1: availability_subexpression : (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id;
>>>>>>> origin/continuum
	public final BLESStoASTParser.availability_subexpression_return availability_subexpression() throws RecognitionException {
		BLESStoASTParser.availability_subexpression_return retval = new BLESStoASTParser.availability_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token l=null;
		Token RPAREN411=null;
		ParserRuleReturnScope id =null;
		ParserRuleReturnScope ae =null;

		BAST n_tree=null;
		BAST l_tree=null;
		BAST RPAREN411_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_availability_expression=new RewriteRuleSubtreeStream(adaptor,"rule availability_expression");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3518:3: ( (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3519:3: (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3519:3: (n= LITERAL_not )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3520:3: ( (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3521:3: (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3521:3: (n= LITERAL_not )?
>>>>>>> origin/continuum
			int alt214=2;
			int LA214_0 = input.LA(1);
			if ( (LA214_0==LITERAL_not) ) {
				alt214=1;
			}
			switch (alt214) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3519:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_availability_subexpression16323); if (state.failed) return retval; 
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3521:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_availability_subexpression16340); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3520:3: (id= identifier |l= LPAREN ae= availability_expression RPAREN )
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3522:3: (id= identifier |l= LPAREN ae= availability_expression RPAREN )
>>>>>>> origin/continuum
			int alt215=2;
			int LA215_0 = input.LA(1);
			if ( (LA215_0==ID) ) {
				alt215=1;
			}
			else if ( (LA215_0==LPAREN) ) {
				alt215=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 215, 0, input);
				throw nvae;
			}

			switch (alt215) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3521:3: id= identifier
					{
					pushFollow(FOLLOW_identifier_in_availability_subexpression16338);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3523:3: id= identifier
					{
					pushFollow(FOLLOW_identifier_in_availability_subexpression16355);
>>>>>>> origin/continuum
					id=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3523:3: l= LPAREN ae= availability_expression RPAREN
					{
					l=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_availability_subexpression16348); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(l);

					pushFollow(FOLLOW_availability_expression_in_availability_subexpression16352);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3525:3: l= LPAREN ae= availability_expression RPAREN
					{
					l=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_availability_subexpression16365); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(l);

					pushFollow(FOLLOW_availability_expression_in_availability_subexpression16369);
>>>>>>> origin/continuum
					ae=availability_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_availability_expression.add(ae.getTree());
<<<<<<< HEAD
					RPAREN411=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_availability_subexpression16354); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN411);
=======
					RPAREN410=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_availability_subexpression16371); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN410);
>>>>>>> origin/continuum

					}
					break;

			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: id, ae, l, l, id, n, n, ae
=======
			// elements: n, n, ae, id, l, id, l, ae
>>>>>>> origin/continuum
			// token labels: l, n
			// rule labels: ae, id, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_l=new RewriteRuleTokenStream(adaptor,"token l",l);
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
			// 3525:5: -> {n!=null&&id!=null}? ^( $n $id)
			if (n!=null&&id!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3525:29: ^( $n $id)
=======
			// 3527:5: -> {n!=null&&id!=null}? ^( $n $id)
			if (n!=null&&id!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3527:29: ^( $n $id)
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_id.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3526:5: -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) )
			if (n!=null&&ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3526:29: ^( $n ^( $l $ae) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3526:34: ^( $l $ae)
=======
			else // 3528:5: -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) )
			if (n!=null&&ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3528:29: ^( $n ^( $l $ae) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3528:34: ^( $l $ae)
>>>>>>> origin/continuum
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_l.nextNode(), root_2);
				adaptor.addChild(root_2, stream_ae.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3527:5: -> {ae!=null}? ^( $l $ae)
			if (ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3527:20: ^( $l $ae)
=======
			else // 3529:5: -> {ae!=null}? ^( $l $ae)
			if (ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3529:20: ^( $l $ae)
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_l.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ae.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3528:5: -> $id
=======
			else // 3530:5: -> $id
>>>>>>> origin/continuum
			{
				adaptor.addChild(root_0, stream_id.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_subexpression"


	public static class dispatch_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_condition"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3534:1: dispatch_condition : 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? ;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3536:1: dispatch_condition : 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? ;
>>>>>>> origin/continuum
	public final BLESStoASTParser.dispatch_condition_return dispatch_condition() throws RecognitionException {
		BLESStoASTParser.dispatch_condition_return retval = new BLESStoASTParser.dispatch_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token string_literal412=null;
		Token LITERAL_dispatch413=null;
		ParserRuleReturnScope dispatch_expression414 =null;

		BAST string_literal412_tree=null;
		BAST LITERAL_dispatch413_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3535:3: ( 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3536:3: 'on' ! LITERAL_dispatch ^ ( dispatch_expression )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3537:3: ( 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3538:3: 'on' ! LITERAL_dispatch ^ ( dispatch_expression )?
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			string_literal412=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_dispatch_condition16442); if (state.failed) return retval;
			LITERAL_dispatch413=(Token)match(input,LITERAL_dispatch,FOLLOW_LITERAL_dispatch_in_dispatch_condition16445); if (state.failed) return retval;
=======
			string_literal411=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_dispatch_condition16459); if (state.failed) return retval;
			LITERAL_dispatch412=(Token)match(input,LITERAL_dispatch,FOLLOW_LITERAL_dispatch_in_dispatch_condition16462); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_dispatch413_tree = (BAST)adaptor.create(LITERAL_dispatch413);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_dispatch413_tree, root_0);
			}

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3536:28: ( dispatch_expression )?
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3538:28: ( dispatch_expression )?
>>>>>>> origin/continuum
			int alt216=2;
			int LA216_0 = input.LA(1);
			if ( (LA216_0==ID||LA216_0==LITERAL_stop||LA216_0==LITERAL_timeout) ) {
				alt216=1;
			}
			switch (alt216) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3536:28: dispatch_expression
					{
					pushFollow(FOLLOW_dispatch_expression_in_dispatch_condition16449);
					dispatch_expression414=dispatch_expression();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3538:28: dispatch_expression
					{
					pushFollow(FOLLOW_dispatch_expression_in_dispatch_condition16466);
					dispatch_expression413=dispatch_expression();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dispatch_expression414.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("RecognitionException caught by BLESStoAST.dispatch_condition");
			    tellBNF(GrammarStrings.dispatchCondition,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_condition"


	public static class dispatch_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_expression"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3544:1: dispatch_expression : dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3546:1: dispatch_expression : dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc;
>>>>>>> origin/continuum
	public final BLESStoASTParser.dispatch_expression_return dispatch_expression() throws RecognitionException {
		BLESStoASTParser.dispatch_expression_return retval = new BLESStoASTParser.dispatch_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_dc2=null;
		ParserRuleReturnScope dc =null;
		RuleReturnScope dc2 = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleSubtreeStream stream_dispatch_conjunction=new RewriteRuleSubtreeStream(adaptor,"rule dispatch_conjunction");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3545:3: (dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3546:3: dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )*
			{
			pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16477);
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3547:3: (dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3548:3: dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )*
			{
			pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16494);
>>>>>>> origin/continuum
			dc=dispatch_conjunction();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dispatch_conjunction.add(dc.getTree());
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3546:27: (o= LITERAL_or dc2+= dispatch_conjunction )*
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3548:27: (o= LITERAL_or dc2+= dispatch_conjunction )*
>>>>>>> origin/continuum
			loop217:
			while (true) {
				int alt217=2;
				int LA217_0 = input.LA(1);
				if ( (LA217_0==LITERAL_or) ) {
					alt217=1;
				}

				switch (alt217) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3546:29: o= LITERAL_or dc2+= dispatch_conjunction
					{
					o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_dispatch_expression16483); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

					pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16487);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3548:29: o= LITERAL_or dc2+= dispatch_conjunction
					{
					o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_dispatch_expression16500); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

					pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16504);
>>>>>>> origin/continuum
					dc2=dispatch_conjunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dispatch_conjunction.add(dc2.getTree());
					if (list_dc2==null) list_dc2=new ArrayList<Object>();
					list_dc2.add(dc2.getTree());
					}
					break;

				default :
					break loop217;
				}
			}

			// AST REWRITE
			// elements: dc2, o, dc, dc
			// token labels: o
			// rule labels: retval, dc
			// token list labels: 
			// rule list labels: dc2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_dc=new RewriteRuleSubtreeStream(adaptor,"rule dc",dc!=null?dc.getTree():null);
			RewriteRuleSubtreeStream stream_dc2=new RewriteRuleSubtreeStream(adaptor,"token dc2",list_dc2);
			root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
			// 3547:5: -> {o!=null}? ^( $o $dc ( $dc2)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3547:19: ^( $o $dc ( $dc2)+ )
=======
			// 3549:5: -> {o!=null}? ^( $o $dc ( $dc2)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3549:19: ^( $o $dc ( $dc2)+ )
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dc.nextTree());
				if ( !(stream_dc2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_dc2.hasNext() ) {
					adaptor.addChild(root_1, stream_dc2.nextTree());
				}
				stream_dc2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3548:5: -> $dc
=======
			else // 3550:5: -> $dc
>>>>>>> origin/continuum
			{
				adaptor.addChild(root_0, stream_dc.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_expression"


	public static class dispatch_conjunction_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_conjunction"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3551:1: dispatch_conjunction : dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:1: dispatch_conjunction : dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt;
>>>>>>> origin/continuum
	public final BLESStoASTParser.dispatch_conjunction_return dispatch_conjunction() throws RecognitionException {
		BLESStoASTParser.dispatch_conjunction_return retval = new BLESStoASTParser.dispatch_conjunction_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		List<Object> list_dt2=null;
		ParserRuleReturnScope dt =null;
		RuleReturnScope dt2 = null;
		BAST a_tree=null;
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleSubtreeStream stream_dispatch_trigger=new RewriteRuleSubtreeStream(adaptor,"rule dispatch_trigger");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3552:3: (dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:3: dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )*
			{
			pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16536);
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3554:3: (dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3555:3: dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )*
			{
			pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16553);
>>>>>>> origin/continuum
			dt=dispatch_trigger();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dispatch_trigger.add(dt.getTree());
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:23: (a= LITERAL_and dt2+= dispatch_trigger )*
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3555:23: (a= LITERAL_and dt2+= dispatch_trigger )*
>>>>>>> origin/continuum
			loop218:
			while (true) {
				int alt218=2;
				int LA218_0 = input.LA(1);
				if ( (LA218_0==LITERAL_and) ) {
					alt218=1;
				}

				switch (alt218) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:25: a= LITERAL_and dt2+= dispatch_trigger
					{
					a=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_dispatch_conjunction16542); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_and.add(a);

					pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16546);
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3555:25: a= LITERAL_and dt2+= dispatch_trigger
					{
					a=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_dispatch_conjunction16559); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_and.add(a);

					pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16563);
>>>>>>> origin/continuum
					dt2=dispatch_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dispatch_trigger.add(dt2.getTree());
					if (list_dt2==null) list_dt2=new ArrayList<Object>();
					list_dt2.add(dt2.getTree());
					}
					break;

				default :
					break loop218;
				}
			}

			// AST REWRITE
<<<<<<< HEAD
			// elements: dt, dt2, dt, a
=======
			// elements: dt2, a, dt, dt
>>>>>>> origin/continuum
			// token labels: a
			// rule labels: dt, retval
			// token list labels: 
			// rule list labels: dt2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_dt=new RewriteRuleSubtreeStream(adaptor,"rule dt",dt!=null?dt.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_dt2=new RewriteRuleSubtreeStream(adaptor,"token dt2",list_dt2);
			root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
			// 3554:5: -> {a!=null}? ^( $a $dt $dt2)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3554:19: ^( $a $dt $dt2)
=======
			// 3556:5: -> {a!=null}? ^( $a $dt $dt2)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3556:19: ^( $a $dt $dt2)
>>>>>>> origin/continuum
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dt.nextTree());
				adaptor.addChild(root_1, stream_dt2.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

<<<<<<< HEAD
			else // 3555:5: -> $dt
=======
			else // 3557:5: -> $dt
>>>>>>> origin/continuum
			{
				adaptor.addChild(root_0, stream_dt.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_conjunction"


	public static class dispatch_trigger_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_trigger"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3565:1: dispatch_trigger : ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop);
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3567:1: dispatch_trigger : ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop);
>>>>>>> origin/continuum
	public final BLESStoASTParser.dispatch_trigger_return dispatch_trigger() throws RecognitionException {
		BLESStoASTParser.dispatch_trigger_return retval = new BLESStoASTParser.dispatch_trigger_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token stop=null;
		Token LITERAL_timeout415=null;
		Token LPAREN416=null;
		Token RPAREN418=null;
		Token LITERAL_timeout420=null;
		ParserRuleReturnScope identifier417 =null;
		ParserRuleReturnScope behavior_time419 =null;
		ParserRuleReturnScope identifier421 =null;

		BAST stop_tree=null;
		BAST LITERAL_timeout415_tree=null;
		BAST LPAREN416_tree=null;
		BAST RPAREN418_tree=null;
		BAST LITERAL_timeout420_tree=null;
		RewriteRuleTokenStream stream_LITERAL_stop=new RewriteRuleTokenStream(adaptor,"token LITERAL_stop");

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3566:3: ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop)
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3568:3: ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop)
>>>>>>> origin/continuum
			int alt220=4;
			switch ( input.LA(1) ) {
			case LITERAL_timeout:
				{
				int LA220_1 = input.LA(2);
				if ( (LA220_1==LPAREN) ) {
					alt220=1;
				}
				else if ( (LA220_1==LITERAL_and||LA220_1==LITERAL_or||LA220_1==RCON) ) {
					alt220=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 220, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				alt220=3;
				}
				break;
			case LITERAL_stop:
				{
				alt220=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 220, 0, input);
				throw nvae;
			}
			switch (alt220) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3568:3: LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3570:3: LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_timeout415=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16603); if (state.failed) return retval;
=======
					LITERAL_timeout414=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16620); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_timeout415_tree = (BAST)adaptor.create(LITERAL_timeout415);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout415_tree, root_0);
					}

<<<<<<< HEAD
					LPAREN416=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_dispatch_trigger16606); if (state.failed) return retval;
=======
					LPAREN415=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_dispatch_trigger16623); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LPAREN416_tree = (BAST)adaptor.create(LPAREN416);
					adaptor.addChild(root_0, LPAREN416_tree);
					}

<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3568:67: ( identifier )+
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3570:67: ( identifier )+
>>>>>>> origin/continuum
					int cnt219=0;
					loop219:
					while (true) {
						int alt219=2;
						int LA219_0 = input.LA(1);
						if ( (LA219_0==ID) ) {
							alt219=1;
						}

						switch (alt219) {
						case 1 :
<<<<<<< HEAD
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3568:67: identifier
							{
							pushFollow(FOLLOW_identifier_in_dispatch_trigger16609);
							identifier417=identifier();
=======
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3570:67: identifier
							{
							pushFollow(FOLLOW_identifier_in_dispatch_trigger16626);
							identifier416=identifier();
>>>>>>> origin/continuum
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier417.getTree());

							}
							break;

						default :
							if ( cnt219 >= 1 ) break loop219;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(219, input);
							throw eee;
						}
						cnt219++;
					}

<<<<<<< HEAD
					RPAREN418=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_dispatch_trigger16612); if (state.failed) return retval;
=======
					RPAREN417=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_dispatch_trigger16629); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					RPAREN418_tree = (BAST)adaptor.create(RPAREN418);
					adaptor.addChild(root_0, RPAREN418_tree);
					}

<<<<<<< HEAD
					pushFollow(FOLLOW_behavior_time_in_dispatch_trigger16615);
					behavior_time419=behavior_time();
=======
					pushFollow(FOLLOW_behavior_time_in_dispatch_trigger16632);
					behavior_time418=behavior_time();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time419.getTree());

					}
					break;
				case 2 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3570:3: LITERAL_timeout ^
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3572:3: LITERAL_timeout ^
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					LITERAL_timeout420=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16624); if (state.failed) return retval;
=======
					LITERAL_timeout419=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16641); if (state.failed) return retval;
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) {
					LITERAL_timeout420_tree = (BAST)adaptor.create(LITERAL_timeout420);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout420_tree, root_0);
					}

					}
					break;
				case 3 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3572:43: identifier
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3574:43: identifier
>>>>>>> origin/continuum
					{
					root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
					pushFollow(FOLLOW_identifier_in_dispatch_trigger16635);
					identifier421=identifier();
=======
					pushFollow(FOLLOW_identifier_in_dispatch_trigger16652);
					identifier420=identifier();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier421.getTree());

					}
					break;
				case 4 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3574:3: stop= LITERAL_stop
					{
					stop=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_dispatch_trigger16645); if (state.failed) return retval; 
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3576:3: stop= LITERAL_stop
					{
					stop=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_dispatch_trigger16662); if (state.failed) return retval; 
>>>>>>> origin/continuum
					if ( state.backtracking==0 ) stream_LITERAL_stop.add(stop);

					// AST REWRITE
					// elements: stop
					// token labels: stop
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_stop=new RewriteRuleTokenStream(adaptor,"token stop",stop);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
<<<<<<< HEAD
					// 3575:5: -> $stop
=======
					// 3577:5: -> $stop
>>>>>>> origin/continuum
					{
						adaptor.addChild(root_0, stream_stop.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_trigger"


	public static class in_modes_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "in_modes"
<<<<<<< HEAD
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3663:1: in_modes : LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
=======
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3665:1: in_modes : LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
>>>>>>> origin/continuum
	public final BLESStoASTParser.in_modes_return in_modes() throws RecognitionException {
		BLESStoASTParser.in_modes_return retval = new BLESStoASTParser.in_modes_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_in422=null;
		Token LITERAL_modes423=null;
		Token LPAREN424=null;
		Token COMMA426=null;
		Token RPAREN428=null;
		ParserRuleReturnScope identifier425 =null;
		ParserRuleReturnScope identifier427 =null;

		BAST LITERAL_in422_tree=null;
		BAST LITERAL_modes423_tree=null;
		BAST LPAREN424_tree=null;
		BAST COMMA426_tree=null;
		BAST RPAREN428_tree=null;

		try {
<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3664:3: ( LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3665:3: LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3666:3: ( LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3667:3: LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
>>>>>>> origin/continuum
			{
			root_0 = (BAST)adaptor.nil();


<<<<<<< HEAD
			LITERAL_in422=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_in_modes16696); if (state.failed) return retval;
=======
			LITERAL_in421=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_in_modes16713); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_in422_tree = (BAST)adaptor.create(LITERAL_in422);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_in422_tree, root_0);
			}

<<<<<<< HEAD
			LITERAL_modes423=(Token)match(input,LITERAL_modes,FOLLOW_LITERAL_modes_in_in_modes16699); if (state.failed) return retval;
=======
			LITERAL_modes422=(Token)match(input,LITERAL_modes,FOLLOW_LITERAL_modes_in_in_modes16716); if (state.failed) return retval;
>>>>>>> origin/continuum
			if ( state.backtracking==0 ) {
			LITERAL_modes423_tree = (BAST)adaptor.create(LITERAL_modes423);
			adaptor.addChild(root_0, LITERAL_modes423_tree);
			}

<<<<<<< HEAD
			LPAREN424=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_in_modes16703); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_in_modes16709);
			identifier425=identifier();
=======
			LPAREN423=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_in_modes16720); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_in_modes16726);
			identifier424=identifier();
>>>>>>> origin/continuum
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier425.getTree());

<<<<<<< HEAD
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3667:23: ( COMMA ! identifier )*
=======
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3669:23: ( COMMA ! identifier )*
>>>>>>> origin/continuum
			loop221:
			while (true) {
				int alt221=2;
				int LA221_0 = input.LA(1);
				if ( (LA221_0==COMMA) ) {
					alt221=1;
				}

				switch (alt221) {
				case 1 :
<<<<<<< HEAD
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3667:25: COMMA ! identifier
					{
					COMMA426=(Token)match(input,COMMA,FOLLOW_COMMA_in_in_modes16713); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_in_modes16717);
					identifier427=identifier();
=======
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3669:25: COMMA ! identifier
					{
					COMMA425=(Token)match(input,COMMA,FOLLOW_COMMA_in_in_modes16730); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_in_modes16734);
					identifier426=identifier();
>>>>>>> origin/continuum
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier427.getTree());

					}
					break;

				default :
					break loop221;
				}
			}

<<<<<<< HEAD
			RPAREN428=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_in_modes16724); if (state.failed) return retval;
=======
			RPAREN427=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_in_modes16741); if (state.failed) return retval;
>>>>>>> origin/continuum
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "in_modes"

	// $ANTLR start synpred1_BLESStoAST
	public final void synpred1_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2483:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )
>>>>>>> origin/continuum
		int alt222=2;
		int LA222_0 = input.LA(1);
		if ( (LA222_0==LPAREN) ) {
			int LA222_1 = input.LA(2);
			if ( (LA222_1==LITERAL_if) ) {
				alt222=1;
			}
			else if ( (LA222_1==AADL_STRING_LITERAL||LA222_1==ID||LA222_1==INTEGER_LIT||LA222_1==LBRACKET||LA222_1==LITERAL_complex||LA222_1==LITERAL_false||LA222_1==LITERAL_in||LA222_1==LITERAL_integer||LA222_1==LITERAL_natural||(LA222_1 >= LITERAL_not && LA222_1 <= LITERAL_now)||LA222_1==LITERAL_null||(LA222_1 >= LITERAL_rational && LA222_1 <= LITERAL_real)||LA222_1==LITERAL_self||(LA222_1 >= LITERAL_time && LA222_1 <= LITERAL_timeout)||LA222_1==LITERAL_tops||LA222_1==LITERAL_true||LA222_1==LPAREN||LA222_1==MINUS||LA222_1==OCTOTHORPE||LA222_1==REAL_LIT) ) {
				alt222=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 222, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 222, 0, input);
<<<<<<< HEAD
			throw nvae;
		}

		switch (alt222) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred1_BLESStoAST9464); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred1_BLESStoAST9466); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2481:24: LPAREN boolean_expression_or_relation QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred1_BLESStoAST9470); if (state.failed) return;

				pushFollow(FOLLOW_boolean_expression_or_relation_in_synpred1_BLESStoAST9472);
				boolean_expression_or_relation();
				state._fsp--;
				if (state.failed) return;

				match(input,QQ,FOLLOW_QQ_in_synpred1_BLESStoAST9474); if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred1_BLESStoAST

	// $ANTLR start synpred2_BLESStoAST
	public final void synpred2_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:3: ( LPAREN case_choice )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:4: LPAREN case_choice
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred2_BLESStoAST9502); if (state.failed) return;

		pushFollow(FOLLOW_case_choice_in_synpred2_BLESStoAST9504);
		case_choice();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_BLESStoAST

	// $ANTLR start synpred3_BLESStoAST
	public final void synpred3_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:4: port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		{
		pushFollow(FOLLOW_port_name_in_synpred3_BLESStoAST9809);
		port_name();
		state._fsp--;
		if (state.failed) return;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:14: ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		int alt223=4;
		int LA223_0 = input.LA(1);
		if ( (LA223_0==QUESTION) ) {
			alt223=1;
		}
		else if ( (LA223_0==TICK) ) {
			switch ( input.LA(2) ) {
			case LITERAL_fresh:
				{
				alt223=2;
				}
				break;
			case LITERAL_count:
				{
				alt223=3;
				}
				break;
			case LITERAL_updated:
				{
				alt223=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 223, 2, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 223, 0, input);
=======
>>>>>>> origin/continuum
			throw nvae;
		}

		switch (alt223) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2483:4: LPAREN LITERAL_if
				{
<<<<<<< HEAD
				match(input,QUESTION,FOLLOW_QUESTION_in_synpred3_BLESStoAST9813); if (state.failed) return;
=======
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred1_BLESStoAST9472); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred1_BLESStoAST9474); if (state.failed) return;
>>>>>>> origin/continuum

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2483:24: LPAREN boolean_expression_or_relation QQ
				{
<<<<<<< HEAD
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9817); if (state.failed) return;

				match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_synpred3_BLESStoAST9819); if (state.failed) return;
=======
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred1_BLESStoAST9478); if (state.failed) return;

				pushFollow(FOLLOW_boolean_expression_or_relation_in_synpred1_BLESStoAST9480);
				boolean_expression_or_relation();
				state._fsp--;
				if (state.failed) return;

				match(input,QQ,FOLLOW_QQ_in_synpred1_BLESStoAST9482); if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred1_BLESStoAST

	// $ANTLR start synpred2_BLESStoAST
	public final void synpred2_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2487:3: ( LPAREN case_choice )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2487:4: LPAREN case_choice
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred2_BLESStoAST9510); if (state.failed) return;

		pushFollow(FOLLOW_case_choice_in_synpred2_BLESStoAST9512);
		case_choice();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_BLESStoAST

	// $ANTLR start synpred3_BLESStoAST
	public final void synpred3_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:4: port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		{
		pushFollow(FOLLOW_port_name_in_synpred3_BLESStoAST9817);
		port_name();
		state._fsp--;
		if (state.failed) return;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:14: ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		int alt223=4;
		int LA223_0 = input.LA(1);
		if ( (LA223_0==QUESTION) ) {
			alt223=1;
		}
		else if ( (LA223_0==TICK) ) {
			switch ( input.LA(2) ) {
			case LITERAL_fresh:
				{
				alt223=2;
				}
				break;
			case LITERAL_count:
				{
				alt223=3;
				}
				break;
			case LITERAL_updated:
				{
				alt223=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 223, 2, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 223, 0, input);
			throw nvae;
		}

		switch (alt223) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:16: QUESTION
				{
				match(input,QUESTION,FOLLOW_QUESTION_in_synpred3_BLESStoAST9821); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:27: TICK LITERAL_fresh
				{
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9825); if (state.failed) return;

				match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_synpred3_BLESStoAST9827); if (state.failed) return;
>>>>>>> origin/continuum

				}
				break;
			case 3 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:48: TICK LITERAL_count
				{
<<<<<<< HEAD
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9823); if (state.failed) return;

				match(input,LITERAL_count,FOLLOW_LITERAL_count_in_synpred3_BLESStoAST9825); if (state.failed) return;
=======
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9831); if (state.failed) return;

				match(input,LITERAL_count,FOLLOW_LITERAL_count_in_synpred3_BLESStoAST9833); if (state.failed) return;
>>>>>>> origin/continuum

				}
				break;
			case 4 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2522:68: TICK LITERAL_updated
				{
<<<<<<< HEAD
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9828); if (state.failed) return;

				match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_synpred3_BLESStoAST9830); if (state.failed) return;
=======
				match(input,TICK,FOLLOW_TICK_in_synpred3_BLESStoAST9836); if (state.failed) return;

				match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_synpred3_BLESStoAST9838); if (state.failed) return;
>>>>>>> origin/continuum

				}
				break;

		}

		}

	}
	// $ANTLR end synpred3_BLESStoAST

	// $ANTLR start synpred4_BLESStoAST
	public final void synpred4_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2617:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2617:4: LPAREN ID ARROW
		{
<<<<<<< HEAD
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred4_BLESStoAST10540); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred4_BLESStoAST10542); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred4_BLESStoAST10544); if (state.failed) return;
=======
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred4_BLESStoAST10548); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred4_BLESStoAST10550); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred4_BLESStoAST10552); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred4_BLESStoAST

	// $ANTLR start synpred5_BLESStoAST
	public final void synpred5_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2621:3: ( subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2621:4: subexpression relation_symbol
		{
<<<<<<< HEAD
		pushFollow(FOLLOW_subexpression_in_synpred5_BLESStoAST10572);
=======
		pushFollow(FOLLOW_subexpression_in_synpred5_BLESStoAST10580);
>>>>>>> origin/continuum
		subexpression();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		pushFollow(FOLLOW_relation_symbol_in_synpred5_BLESStoAST10574);
=======
		pushFollow(FOLLOW_relation_symbol_in_synpred5_BLESStoAST10582);
>>>>>>> origin/continuum
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_BLESStoAST

	// $ANTLR start synpred6_BLESStoAST
	public final void synpred6_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2636:3: ( subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2636:4: subexpression relation_symbol
		{
<<<<<<< HEAD
		pushFollow(FOLLOW_subexpression_in_synpred6_BLESStoAST10662);
=======
		pushFollow(FOLLOW_subexpression_in_synpred6_BLESStoAST10670);
>>>>>>> origin/continuum
		subexpression();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		pushFollow(FOLLOW_relation_symbol_in_synpred6_BLESStoAST10664);
=======
		pushFollow(FOLLOW_relation_symbol_in_synpred6_BLESStoAST10672);
>>>>>>> origin/continuum
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred6_BLESStoAST

	// $ANTLR start synpred7_BLESStoAST
	public final void synpred7_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2995:3: ( parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2995:4: parenthesized_predicate IMP
		{
<<<<<<< HEAD
		pushFollow(FOLLOW_parenthesized_predicate_in_synpred7_BLESStoAST12657);
=======
		pushFollow(FOLLOW_parenthesized_predicate_in_synpred7_BLESStoAST12665);
>>>>>>> origin/continuum
		parenthesized_predicate();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		match(input,IMP,FOLLOW_IMP_in_synpred7_BLESStoAST12659); if (state.failed) return;
=======
		match(input,IMP,FOLLOW_IMP_in_synpred7_BLESStoAST12667); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred7_BLESStoAST

	// $ANTLR start synpred8_BLESStoAST
	public final void synpred8_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3065:5: ( assertion_expression range_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3065:7: assertion_expression range_symbol
		{
		pushFollow(FOLLOW_assertion_expression_in_synpred8_BLESStoAST13081);
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:5: ( assertion_expression range_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:7: assertion_expression range_symbol
		{
		pushFollow(FOLLOW_assertion_expression_in_synpred8_BLESStoAST13056);
>>>>>>> origin/continuum
		assertion_expression();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		pushFollow(FOLLOW_range_symbol_in_synpred8_BLESStoAST13083);
=======
		pushFollow(FOLLOW_range_symbol_in_synpred8_BLESStoAST13058);
>>>>>>> origin/continuum
		range_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred8_BLESStoAST

	// $ANTLR start synpred9_BLESStoAST
	public final void synpred9_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:3: ( assertion_subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:4: assertion_subexpression relation_symbol
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred9_BLESStoAST13431);
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:3: ( assertion_subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:4: assertion_subexpression relation_symbol
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred9_BLESStoAST13406);
>>>>>>> origin/continuum
		assertion_subexpression();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		pushFollow(FOLLOW_relation_symbol_in_synpred9_BLESStoAST13433);
=======
		pushFollow(FOLLOW_relation_symbol_in_synpred9_BLESStoAST13408);
>>>>>>> origin/continuum
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred9_BLESStoAST

	// $ANTLR start synpred10_BLESStoAST
	public final void synpred10_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3115:3: ( assertion_subexpression LITERAL_in )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3115:4: assertion_subexpression LITERAL_in
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13512);
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3114:3: ( assertion_subexpression LITERAL_in )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3114:4: assertion_subexpression LITERAL_in
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13487);
>>>>>>> origin/continuum
		assertion_subexpression();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		match(input,LITERAL_in,FOLLOW_LITERAL_in_in_synpred10_BLESStoAST13514); if (state.failed) return;
=======
		match(input,LITERAL_in,FOLLOW_LITERAL_in_in_synpred10_BLESStoAST13489); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred10_BLESStoAST

	// $ANTLR start synpred11_BLESStoAST
	public final void synpred11_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3123:3: ( name PLUS_EQUALS )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3123:4: name PLUS_EQUALS
		{
		pushFollow(FOLLOW_name_in_synpred11_BLESStoAST13593);
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3122:3: ( name PLUS_EQUALS )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3122:4: name PLUS_EQUALS
		{
		pushFollow(FOLLOW_name_in_synpred11_BLESStoAST13568);
>>>>>>> origin/continuum
		name();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_synpred11_BLESStoAST13595); if (state.failed) return;
=======
		match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_synpred11_BLESStoAST13570); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred11_BLESStoAST

	// $ANTLR start synpred12_BLESStoAST
	public final void synpred12_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3137:5: ( ID LPAREN )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3137:6: ID LPAREN
		{
		match(input,ID,FOLLOW_ID_in_synpred12_BLESStoAST13765); if (state.failed) return;

		match(input,LPAREN,FOLLOW_LPAREN_in_synpred12_BLESStoAST13767); if (state.failed) return;
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3136:5: ( ID LPAREN )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3136:6: ID LPAREN
		{
		match(input,ID,FOLLOW_ID_in_synpred12_BLESStoAST13740); if (state.failed) return;

		match(input,LPAREN,FOLLOW_LPAREN_in_synpred12_BLESStoAST13742); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred12_BLESStoAST

	// $ANTLR start synpred16_BLESStoAST
	public final void synpred16_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3446:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3448:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )
>>>>>>> origin/continuum
		int alt227=2;
		int LA227_0 = input.LA(1);
		if ( (LA227_0==LPAREN) ) {
			int LA227_1 = input.LA(2);
			if ( (LA227_1==LITERAL_if) ) {
				alt227=1;
			}
			else if ( (LA227_1==AADL_STRING_LITERAL||LA227_1==ID||LA227_1==INTEGER_LIT||LA227_1==LBRACKET||LA227_1==LITERAL_abs||LA227_1==LITERAL_all||LA227_1==LITERAL_complex||LA227_1==LITERAL_def||LA227_1==LITERAL_exists||LA227_1==LITERAL_false||LA227_1==LITERAL_in||LA227_1==LITERAL_integer||LA227_1==LITERAL_natural||(LA227_1 >= LITERAL_not && LA227_1 <= LITERAL_now)||LA227_1==LITERAL_null||(LA227_1 >= LITERAL_rational && LA227_1 <= LITERAL_real)||LA227_1==LITERAL_self||LA227_1==LITERAL_stop||(LA227_1 >= LITERAL_time && LA227_1 <= LITERAL_timeout)||LA227_1==LITERAL_tops||LA227_1==LITERAL_true||LA227_1==LPAREN||LA227_1==MINUS||LA227_1==OCTOTHORPE||LA227_1==REAL_LIT) ) {
				alt227=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 227, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 227, 0, input);
			throw nvae;
		}

		switch (alt227) {
			case 1 :
<<<<<<< HEAD
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3446:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred16_BLESStoAST15767); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred16_BLESStoAST15769); if (state.failed) return;
=======
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3448:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred16_BLESStoAST15784); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred16_BLESStoAST15786); if (state.failed) return;
>>>>>>> origin/continuum

				}
				break;
			case 2 :
<<<<<<< HEAD
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3446:24: LPAREN predicate QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred16_BLESStoAST15773); if (state.failed) return;

				pushFollow(FOLLOW_predicate_in_synpred16_BLESStoAST15775);
=======
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3448:24: LPAREN predicate QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred16_BLESStoAST15790); if (state.failed) return;

				pushFollow(FOLLOW_predicate_in_synpred16_BLESStoAST15792);
>>>>>>> origin/continuum
				predicate();
				state._fsp--;
				if (state.failed) return;

<<<<<<< HEAD
				match(input,QQ,FOLLOW_QQ_in_synpred16_BLESStoAST15777); if (state.failed) return;
=======
				match(input,QQ,FOLLOW_QQ_in_synpred16_BLESStoAST15794); if (state.failed) return;
>>>>>>> origin/continuum

				}
				break;

		}
	}
	// $ANTLR end synpred16_BLESStoAST

	// $ANTLR start synpred17_BLESStoAST
	public final void synpred17_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3450:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3450:4: LPAREN ID ARROW
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred17_BLESStoAST15803); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred17_BLESStoAST15805); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred17_BLESStoAST15807); if (state.failed) return;
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3452:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3452:4: LPAREN ID ARROW
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred17_BLESStoAST15820); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred17_BLESStoAST15822); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred17_BLESStoAST15824); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred17_BLESStoAST

	// $ANTLR start synpred18_BLESStoAST
	public final void synpred18_BLESStoAST_fragment() throws RecognitionException {
<<<<<<< HEAD
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3454:3: ( LPAREN parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3454:4: LPAREN parenthesized_predicate IMP
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred18_BLESStoAST15837); if (state.failed) return;

		pushFollow(FOLLOW_parenthesized_predicate_in_synpred18_BLESStoAST15839);
=======
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3456:3: ( LPAREN parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3456:4: LPAREN parenthesized_predicate IMP
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred18_BLESStoAST15854); if (state.failed) return;

		pushFollow(FOLLOW_parenthesized_predicate_in_synpred18_BLESStoAST15856);
>>>>>>> origin/continuum
		parenthesized_predicate();
		state._fsp--;
		if (state.failed) return;

<<<<<<< HEAD
		match(input,IMP,FOLLOW_IMP_in_synpred18_BLESStoAST15841); if (state.failed) return;
=======
		match(input,IMP,FOLLOW_IMP_in_synpred18_BLESStoAST15858); if (state.failed) return;
>>>>>>> origin/continuum

		}

	}
	// $ANTLR end synpred18_BLESStoAST

	// Delegated rules

	public final boolean synpred3_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred16_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred16_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred11_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred11_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred8_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred8_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred6_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred6_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred17_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred17_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred9_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred9_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred7_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred7_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred12_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred12_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred10_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred10_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred18_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred18_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred5_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA55 dfa55 = new DFA55(this);
	protected DFA63 dfa63 = new DFA63(this);
	protected DFA99 dfa99 = new DFA99(this);
	protected DFA118 dfa118 = new DFA118(this);
	protected DFA162 dfa162 = new DFA162(this);
	static final String DFA55_eotS =
		"\22\uffff";
	static final String DFA55_eofS =
		"\22\uffff";
	static final String DFA55_minS =
		"\1\77\1\uffff\1\21\7\uffff\1\4\1\77\1\uffff\1\37\2\21\1\77\1\21";
	static final String DFA55_maxS =
<<<<<<< HEAD
		"\1\u00f5\1\uffff\1\u0123\7\uffff\1\u0115\1\76\1\uffff\1\u0125\2\u0123"+
		"\1\76\1\u0123";
=======
		"\1\u00f6\1\uffff\1\u0124\7\uffff\1\u0116\1\77\1\uffff\1\u0126\2\u0124"+
		"\1\77\1\u0124";
>>>>>>> origin/continuum
	static final String DFA55_acceptS =
		"\1\uffff\1\1\1\uffff\1\3\1\4\1\5\1\6\1\7\1\10\1\11\2\uffff\1\2\5\uffff";
	static final String DFA55_specialS =
		"\22\uffff}>";
	static final String[] DFA55_transitionS = {
			"\1\2\60\uffff\1\4\20\uffff\1\11\5\uffff\4\7\53\uffff\1\3\32\uffff\1\5"+
			"\1\uffff\1\1\10\uffff\1\7\25\uffff\1\6\3\uffff\1\10",
			"",
<<<<<<< HEAD
			"\1\14\42\uffff\1\3\27\uffff\1\12\u00a8\uffff\1\3\14\uffff\1\13\14\uffff"+
=======
			"\1\14\43\uffff\1\3\27\uffff\1\12\u00a8\uffff\1\3\14\uffff\1\13\14\uffff"+
>>>>>>> origin/continuum
			"\1\3\23\uffff\1\14",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
<<<<<<< HEAD
			"\1\14\71\uffff\1\14\3\uffff\1\15\11\uffff\1\14\40\uffff\1\14\25\uffff"+
=======
			"\1\14\72\uffff\1\14\3\uffff\1\15\11\uffff\1\14\40\uffff\1\14\25\uffff"+
>>>>>>> origin/continuum
			"\1\14\24\uffff\1\14\2\uffff\1\14\13\uffff\1\14\2\uffff\2\14\1\uffff\1"+
			"\14\27\uffff\2\14\6\uffff\1\14\23\uffff\2\14\1\uffff\1\14\2\uffff\1\14"+
			"\15\uffff\1\14\3\uffff\1\14\3\uffff\1\14\27\uffff\1\14",
			"\1\16",
			"",
			"\2\14\11\uffff\1\14\1\uffff\2\14\10\uffff\1\14\46\uffff\1\14\14\uffff"+
			"\1\14\11\uffff\1\14\57\uffff\1\14\15\uffff\1\14\27\uffff\1\14\52\uffff"+
			"\1\14\4\uffff\1\14\11\uffff\1\14\16\uffff\1\17\22\uffff\1\14",
<<<<<<< HEAD
			"\1\14\42\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\14\42\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\14\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\21",
			"\1\14\42\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
=======
			"\1\14\43\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\14\43\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\14\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\21",
			"\1\14\43\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
>>>>>>> origin/continuum
			"\1\14"
	};

	static final short[] DFA55_eot = DFA.unpackEncodedString(DFA55_eotS);
	static final short[] DFA55_eof = DFA.unpackEncodedString(DFA55_eofS);
	static final char[] DFA55_min = DFA.unpackEncodedStringToUnsignedChars(DFA55_minS);
	static final char[] DFA55_max = DFA.unpackEncodedStringToUnsignedChars(DFA55_maxS);
	static final short[] DFA55_accept = DFA.unpackEncodedString(DFA55_acceptS);
	static final short[] DFA55_special = DFA.unpackEncodedString(DFA55_specialS);
	static final short[][] DFA55_transition;

	static {
		int numStates = DFA55_transitionS.length;
		DFA55_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA55_transition[i] = DFA.unpackEncodedString(DFA55_transitionS[i]);
		}
	}

	protected class DFA55 extends DFA {

		public DFA55(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 55;
			this.eot = DFA55_eot;
			this.eof = DFA55_eof;
			this.min = DFA55_min;
			this.max = DFA55_max;
			this.accept = DFA55_accept;
			this.special = DFA55_special;
			this.transition = DFA55_transition;
		}
		@Override
		public String getDescription() {
			return "2019:1: basic_action : ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception );";
		}
	}

	static final String DFA63_eotS =
		"\15\uffff";
	static final String DFA63_eofS =
		"\15\uffff";
	static final String DFA63_minS =
<<<<<<< HEAD
		"\1\76\1\64\2\uffff\1\76\1\uffff\1\102\1\uffff\1\64\1\u0112\1\76\2\64";
	static final String DFA63_maxS =
		"\1\u00b5\1\u010f\2\uffff\1\76\1\uffff\1\102\1\uffff\1\u010f\1\u0112\1"+
		"\76\2\u010f";
=======
		"\1\77\1\65\2\uffff\1\77\1\uffff\1\103\1\uffff\1\65\1\u0113\1\77\2\65";
	static final String DFA63_maxS =
		"\1\u00b6\1\u0110\2\uffff\1\77\1\uffff\1\103\1\uffff\1\u0110\1\u0113\1"+
		"\77\2\u0110";
>>>>>>> origin/continuum
	static final String DFA63_acceptS =
		"\2\uffff\1\4\1\1\1\uffff\1\2\1\uffff\1\3\5\uffff";
	static final String DFA63_specialS =
		"\15\uffff}>";
	static final String[] DFA63_transitionS = {
			"\1\1\166\uffff\1\2",
			"\1\5\27\uffff\1\6\u00a8\uffff\1\3\14\uffff\1\4\14\uffff\1\7",
			"",
			"",
			"\1\10",
			"",
			"\1\11",
			"",
			"\1\5\u00cd\uffff\1\12\14\uffff\1\7",
			"\1\13",
			"\1\14",
			"\1\5\u00da\uffff\1\7",
			"\1\5\u00cd\uffff\1\12\14\uffff\1\7"
	};

	static final short[] DFA63_eot = DFA.unpackEncodedString(DFA63_eotS);
	static final short[] DFA63_eof = DFA.unpackEncodedString(DFA63_eofS);
	static final char[] DFA63_min = DFA.unpackEncodedStringToUnsignedChars(DFA63_minS);
	static final char[] DFA63_max = DFA.unpackEncodedStringToUnsignedChars(DFA63_maxS);
	static final short[] DFA63_accept = DFA.unpackEncodedString(DFA63_acceptS);
	static final short[] DFA63_special = DFA.unpackEncodedString(DFA63_specialS);
	static final short[][] DFA63_transition;

	static {
		int numStates = DFA63_transitionS.length;
		DFA63_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA63_transition[i] = DFA.unpackEncodedString(DFA63_transitionS[i]);
		}
	}

	protected class DFA63 extends DFA {

		public DFA63(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 63;
			this.eot = DFA63_eot;
			this.eof = DFA63_eof;
			this.min = DFA63_min;
			this.max = DFA63_max;
			this.accept = DFA63_accept;
			this.special = DFA63_special;
			this.transition = DFA63_transition;
		}
		@Override
		public String getDescription() {
			return "2125:1: communication_action : (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause);";
		}
	}

	static final String DFA99_eotS =
		"\13\uffff";
	static final String DFA99_eofS =
		"\2\uffff\1\1\2\uffff\1\1\5\uffff";
	static final String DFA99_minS =
		"\1\4\1\uffff\1\7\1\uffff\1\77\1\7\2\77\1\34\1\uffff\1\56";
	static final String DFA99_maxS =
<<<<<<< HEAD
		"\1\u0115\1\uffff\1\u0125\1\uffff\1\76\1\u0125\1\u0117\1\76\1\u0123\1\uffff"+
		"\1\u0102";
=======
		"\1\u0116\1\uffff\1\u0126\1\uffff\1\77\1\u0126\1\u0118\1\77\1\u0124\1\uffff"+
		"\1\u0103";
>>>>>>> origin/continuum
	static final String DFA99_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\5\uffff\1\3\1\uffff";
	static final String DFA99_specialS =
		"\13\uffff}>";
	static final String[] DFA99_transitionS = {
<<<<<<< HEAD
			"\1\1\71\uffff\1\2\3\uffff\1\1\11\uffff\1\1\40\uffff\1\3\25\uffff\1\1"+
=======
			"\1\1\72\uffff\1\2\3\uffff\1\1\11\uffff\1\1\40\uffff\1\3\25\uffff\1\1"+
>>>>>>> origin/continuum
			"\24\uffff\1\1\2\uffff\1\3\13\uffff\1\3\2\uffff\2\1\1\uffff\1\1\27\uffff"+
			"\2\3\6\uffff\1\1\23\uffff\1\3\1\1\1\uffff\1\1\2\uffff\1\1\15\uffff\1"+
			"\1\3\uffff\1\1\3\uffff\1\1\27\uffff\1\1",
			"",
<<<<<<< HEAD
			"\3\1\17\uffff\1\1\2\uffff\4\1\11\uffff\1\1\1\uffff\2\1\1\4\5\uffff\1"+
			"\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\2\1\1\uffff\1\1\15\uffff"+
			"\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4\uffff\2\1\3\uffff"+
			"\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1\1\5\uffff\2\1\2\uffff"+
			"\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff\1\1\6\uffff\1\1\2\uffff"+
			"\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff\1\1\13\uffff\1\1\2"+
			"\uffff\1\1\3\uffff\2\1\1\uffff\3\1\2\uffff\1\1\1\uffff\1\1\1\uffff\1"+
			"\1\4\uffff\2\1\12\uffff\2\1\2\uffff\3\1\2\uffff\1\1\1\uffff\1\1\11\uffff"+
			"\1\1\1\uffff\1\1",
			"",
			"\1\5",
			"\3\1\17\uffff\1\1\2\uffff\4\1\11\uffff\1\1\1\uffff\2\1\1\7\5\uffff\1"+
			"\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\1\1\2\uffff\1\1\15\uffff"+
			"\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4\uffff\2\1\3\uffff"+
			"\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1\1\5\uffff\2\1\2\uffff"+
			"\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff\1\1\6\uffff\1\1\2\uffff"+
			"\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff\1\1\13\uffff\1\1\2"+
			"\uffff\1\1\3\uffff\2\1\1\uffff\1\1\1\6\1\1\2\uffff\1\1\1\uffff\1\1\1"+
			"\uffff\1\1\4\uffff\2\1\12\uffff\1\1\3\uffff\3\1\2\uffff\1\1\1\uffff\1"+
			"\1\13\uffff\1\1",
			"\1\10\u00d8\uffff\1\11",
			"\1\12",
			"\1\11\1\1\56\uffff\1\1\u00b5\uffff\1\1\40\uffff\1\1",
=======
			"\3\1\17\uffff\1\1\2\uffff\1\1\1\uffff\3\1\11\uffff\1\1\1\uffff\2\1\1"+
			"\4\5\uffff\1\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\2\1\1\uffff"+
			"\1\1\15\uffff\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4"+
			"\uffff\2\1\3\uffff\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1"+
			"\1\5\uffff\2\1\2\uffff\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff"+
			"\1\1\6\uffff\1\1\2\uffff\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff"+
			"\1\1\13\uffff\1\1\2\uffff\1\1\3\uffff\2\1\1\uffff\3\1\2\uffff\1\1\1\uffff"+
			"\1\1\1\uffff\1\1\4\uffff\2\1\12\uffff\2\1\2\uffff\3\1\2\uffff\1\1\1\uffff"+
			"\1\1\11\uffff\1\1\1\uffff\1\1",
			"",
			"\1\5",
			"\3\1\17\uffff\1\1\2\uffff\1\1\1\uffff\3\1\11\uffff\1\1\1\uffff\2\1\1"+
			"\7\5\uffff\1\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\1\1\2\uffff"+
			"\1\1\15\uffff\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4"+
			"\uffff\2\1\3\uffff\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1"+
			"\1\5\uffff\2\1\2\uffff\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff"+
			"\1\1\6\uffff\1\1\2\uffff\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff"+
			"\1\1\13\uffff\1\1\2\uffff\1\1\3\uffff\2\1\1\uffff\1\1\1\6\1\1\2\uffff"+
			"\1\1\1\uffff\1\1\1\uffff\1\1\4\uffff\2\1\12\uffff\1\1\3\uffff\3\1\2\uffff"+
			"\1\1\1\uffff\1\1\13\uffff\1\1",
			"\1\10\u00d8\uffff\1\11",
			"\1\12",
			"\1\11\1\uffff\1\1\56\uffff\1\1\u00b5\uffff\1\1\40\uffff\1\1",
>>>>>>> origin/continuum
			"",
			"\1\7\u00c7\uffff\1\11\7\uffff\1\1\4\uffff\1\1"
	};

	static final short[] DFA99_eot = DFA.unpackEncodedString(DFA99_eotS);
	static final short[] DFA99_eof = DFA.unpackEncodedString(DFA99_eofS);
	static final char[] DFA99_min = DFA.unpackEncodedStringToUnsignedChars(DFA99_minS);
	static final char[] DFA99_max = DFA.unpackEncodedStringToUnsignedChars(DFA99_maxS);
	static final short[] DFA99_accept = DFA.unpackEncodedString(DFA99_acceptS);
	static final short[] DFA99_special = DFA.unpackEncodedString(DFA99_specialS);
	static final short[][] DFA99_transition;

	static {
		int numStates = DFA99_transitionS.length;
		DFA99_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA99_transition[i] = DFA.unpackEncodedString(DFA99_transitionS[i]);
		}
	}

	protected class DFA99 extends DFA {

		public DFA99(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 99;
			this.eot = DFA99_eot;
			this.eof = DFA99_eof;
			this.min = DFA99_min;
			this.max = DFA99_max;
			this.accept = DFA99_accept;
			this.special = DFA99_special;
			this.transition = DFA99_transition;
		}
		@Override
		public String getDescription() {
			return "2353:1: subexpression : ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc);";
		}
	}

	static final String DFA118_eotS =
		"\26\uffff";
	static final String DFA118_eofS =
		"\2\uffff\1\14\6\uffff\1\14\3\uffff\1\14\5\uffff\3\14";
	static final String DFA118_minS =
		"\1\4\1\uffff\1\7\5\uffff\1\77\1\7\1\uffff\1\4\1\uffff\1\7\3\uffff\1\37"+
		"\1\77\3\7";
	static final String DFA118_maxS =
<<<<<<< HEAD
		"\1\u0115\1\uffff\1\u0125\5\uffff\1\76\1\u0125\1\uffff\1\u0115\1\uffff"+
		"\1\u0125\3\uffff\1\u0125\1\76\3\u0125";
=======
		"\1\u0116\1\uffff\1\u0126\5\uffff\1\77\1\u0126\1\uffff\1\u0116\1\uffff"+
		"\1\u0126\3\uffff\1\u0126\1\77\3\u0126";
>>>>>>> origin/continuum
	static final String DFA118_acceptS =
		"\1\uffff\1\1\1\uffff\1\4\1\5\1\6\1\7\1\10\2\uffff\1\2\1\uffff\1\3\1\uffff"+
		"\3\2\5\uffff";
	static final String DFA118_specialS =
<<<<<<< HEAD
		"\2\uffff\1\5\6\uffff\1\4\3\uffff\1\3\5\uffff\1\0\1\2\1\1}>";
	static final String[] DFA118_transitionS = {
			"\1\1\71\uffff\1\2\3\uffff\1\1\11\uffff\1\1\66\uffff\1\1\24\uffff\1\3"+
			"\22\uffff\1\6\1\uffff\1\5\37\uffff\1\1\24\uffff\1\4\1\uffff\1\7\2\uffff"+
			"\1\1\25\uffff\1\1\27\uffff\1\1",
			"",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\1\1\5\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff"+
			"\1\14\1\13\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff"+
			"\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14"+
			"\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff"+
			"\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1"+
			"\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14"+
			"\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2"+
			"\uffff\1\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\10\1\14\12\uffff\1\14"+
			"\1\12\1\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\11\1\uffff"+
			"\1\14",
=======
		"\2\uffff\1\5\6\uffff\1\3\3\uffff\1\2\5\uffff\1\4\1\0\1\1}>";
	static final String[] DFA118_transitionS = {
			"\1\1\72\uffff\1\2\3\uffff\1\1\11\uffff\1\1\66\uffff\1\1\24\uffff\1\3"+
			"\22\uffff\1\6\1\uffff\1\5\37\uffff\1\1\24\uffff\1\4\1\uffff\1\7\2\uffff"+
			"\1\1\25\uffff\1\1\27\uffff\1\1",
			"",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\1\1\5\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2"+
			"\14\13\uffff\1\14\1\13\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff"+
			"\1\14\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14"+
			"\5\uffff\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\2\14\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14"+
			"\14\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10"+
			"\uffff\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff"+
			"\3\14\2\uffff\1\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\10\1\14\12\uffff"+
			"\1\14\1\12\1\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\11"+
			"\1\uffff\1\14",
>>>>>>> origin/continuum
			"",
			"",
			"",
			"",
			"",
			"\1\15",
<<<<<<< HEAD
			"\2\14\1\uffff\1\14\21\uffff\4\14\11\uffff\1\14\1\uffff\2\14\6\uffff"+
			"\1\14\1\uffff\1\14\5\uffff\1\14\2\uffff\1\1\1\14\34\uffff\1\14\3\uffff"+
			"\1\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1\14\1\uffff\2"+
			"\14\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1\14\23\uffff\2"+
			"\14\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1\14\1\uffff\1\14"+
			"\7\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14\15\uffff\1\14",
			"",
			"\1\14\71\uffff\1\14\3\uffff\1\21\11\uffff\1\14\40\uffff\1\14\25\uffff"+
=======
			"\2\14\1\uffff\1\14\21\uffff\1\14\1\uffff\3\14\11\uffff\1\14\1\uffff"+
			"\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\1\14\2\uffff\1\1\1\14\34\uffff"+
			"\1\14\3\uffff\1\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1"+
			"\14\1\uffff\2\14\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1"+
			"\14\23\uffff\2\14\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1"+
			"\14\1\uffff\1\14\7\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14"+
			"\15\uffff\1\14",
			"",
			"\1\14\72\uffff\1\14\3\uffff\1\21\11\uffff\1\14\40\uffff\1\14\25\uffff"+
>>>>>>> origin/continuum
			"\1\14\24\uffff\1\14\2\uffff\1\14\13\uffff\1\14\2\uffff\2\14\1\uffff\1"+
			"\14\27\uffff\2\14\6\uffff\1\14\23\uffff\2\14\1\uffff\1\14\2\uffff\1\14"+
			"\15\uffff\1\14\3\uffff\1\14\3\uffff\1\14\27\uffff\1\14",
			"",
<<<<<<< HEAD
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff\2\14"+
			"\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff\1\14\3"+
			"\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14\3\uffff"+
			"\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff\1\14"+
			"\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1\14\6"+
			"\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14\1\uffff"+
			"\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2\uffff\1"+
			"\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\22\1\14\12\uffff\1\14\1\12\1\14"+
			"\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14",
=======
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14"+
			"\13\uffff\2\14\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14"+
			"\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14"+
			"\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14"+
			"\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff"+
			"\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\22\1\14\12\uffff"+
			"\1\14\1\12\1\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23"+
			"\1\uffff\1\14",
>>>>>>> origin/continuum
			"",
			"",
			"",
			"\2\14\11\uffff\1\14\1\uffff\2\14\10\uffff\1\14\46\uffff\1\14\14\uffff"+
			"\1\14\11\uffff\1\14\57\uffff\1\14\15\uffff\1\14\27\uffff\1\14\52\uffff"+
			"\1\14\4\uffff\1\14\11\uffff\1\14\16\uffff\1\24\22\uffff\1\14",
			"\1\25",
<<<<<<< HEAD
			"\2\14\1\uffff\1\14\21\uffff\4\14\11\uffff\1\14\1\uffff\2\14\6\uffff"+
			"\1\14\1\uffff\1\14\5\uffff\1\14\3\uffff\1\14\34\uffff\1\14\3\uffff\1"+
			"\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1\14\1\uffff\2\14"+
			"\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1\14\23\uffff\2\14"+
			"\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1\14\1\uffff\1\14\7"+
			"\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14\15\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff\2\14"+
			"\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff\1\14\3"+
			"\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14\3\uffff"+
			"\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff\1\14"+
			"\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1\14\6"+
			"\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14\1\uffff"+
			"\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2\uffff\1"+
			"\14\1\uffff\1\14\6\uffff\2\14\12\uffff\1\14\1\12\1\14\1\uffff\3\14\2"+
			"\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\4\14\11\uffff\1\14\1\uffff\2"+
			"\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14\13\uffff\2\14"+
			"\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14\5\uffff\1\14\3"+
			"\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff\5\14\3\uffff"+
			"\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14\2\uffff\1\14"+
			"\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14\uffff\1\14\6"+
			"\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff\1\14\1\uffff"+
			"\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3\14\2\uffff\1"+
			"\14\1\uffff\1\14\6\uffff\1\22\1\14\12\uffff\1\14\1\12\1\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14"
=======
			"\2\14\1\uffff\1\14\21\uffff\1\14\1\uffff\3\14\11\uffff\1\14\1\uffff"+
			"\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\1\14\3\uffff\1\14\34\uffff\1"+
			"\14\3\uffff\1\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1\14"+
			"\1\uffff\2\14\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1\14"+
			"\23\uffff\2\14\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1\14"+
			"\1\uffff\1\14\7\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14\15"+
			"\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14"+
			"\13\uffff\2\14\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14"+
			"\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14"+
			"\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14"+
			"\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff"+
			"\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\6\uffff\2\14\12\uffff\1\14\1\12\1\14\1"+
			"\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14"+
			"\13\uffff\2\14\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14"+
			"\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14"+
			"\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14"+
			"\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff"+
			"\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\6\uffff\1\22\1\14\12\uffff\1\14\1\12\1"+
			"\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14"
>>>>>>> origin/continuum
	};

	static final short[] DFA118_eot = DFA.unpackEncodedString(DFA118_eotS);
	static final short[] DFA118_eof = DFA.unpackEncodedString(DFA118_eofS);
	static final char[] DFA118_min = DFA.unpackEncodedStringToUnsignedChars(DFA118_minS);
	static final char[] DFA118_max = DFA.unpackEncodedStringToUnsignedChars(DFA118_maxS);
	static final short[] DFA118_accept = DFA.unpackEncodedString(DFA118_acceptS);
	static final short[] DFA118_special = DFA.unpackEncodedString(DFA118_specialS);
	static final short[][] DFA118_transition;

	static {
		int numStates = DFA118_transitionS.length;
		DFA118_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA118_transition[i] = DFA.unpackEncodedString(DFA118_transitionS[i]);
		}
	}

	protected class DFA118 extends DFA {

		public DFA118(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 118;
			this.eot = DFA118_eot;
			this.eof = DFA118_eof;
			this.min = DFA118_min;
			this.max = DFA118_max;
			this.accept = DFA118_accept;
			this.special = DFA118_special;
			this.transition = DFA118_transition;
		}
		@Override
		public String getDescription() {
			return "2516:1: value : (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops);";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
<<<<<<< HEAD
						int LA118_19 = input.LA(1);
						 
						int index118_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_19==LITERAL_fresh) && (synpred3_BLESStoAST())) {s = 14;}
						else if ( (LA118_19==LITERAL_count) && (synpred3_BLESStoAST())) {s = 15;}
						else if ( (LA118_19==LITERAL_updated) && (synpred3_BLESStoAST())) {s = 16;}
						else if ( (LA118_19==EOF||(LA118_19 >= AL && LA118_19 <= AM)||LA118_19==ANNEX_END||(LA118_19 >= COLON && LA118_19 <= COMMADOT)||LA118_19==DIVIDE||(LA118_19 >= DOTCOMMA && LA118_19 <= DOTDOT)||LA118_19==EQ||LA118_19==EXP||LA118_19==GT||LA118_19==IMP||LA118_19==LITERAL_and||LA118_19==LITERAL_are||LA118_19==LITERAL_else||LA118_19==LITERAL_iff||(LA118_19 >= LITERAL_implies && LA118_19 <= LITERAL_in)||LA118_19==LITERAL_mod||LA118_19==LITERAL_of||LA118_19==LITERAL_or||LA118_19==LITERAL_rem||(LA118_19 >= LITERAL_that && LA118_19 <= LITERAL_then)||LA118_19==LITERAL_xor||LA118_19==LT||LA118_19==MINUS||LA118_19==NEQ||LA118_19==PLUS||LA118_19==QQ||LA118_19==RASS||LA118_19==RPAREN||LA118_19==TIMES) ) {s = 12;}
						 
						input.seek(index118_19);
=======
						int LA118_20 = input.LA(1);
						 
						int index118_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_20==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_20==TICK) ) {s = 19;}
						else if ( (LA118_20==EOF||(LA118_20 >= AL && LA118_20 <= ANNEX_END)||LA118_20==AT_SIGN||(LA118_20 >= BOX && LA118_20 <= CARET)||LA118_20==COLON||(LA118_20 >= COMMA && LA118_20 <= COMMADOT)||LA118_20==DIVIDE||(LA118_20 >= DOTCOMMA && LA118_20 <= DOTDOT)||LA118_20==EQ||LA118_20==EXP||(LA118_20 >= GT && LA118_20 <= GUARD)||(LA118_20 >= ID && LA118_20 <= IMP)||(LA118_20 >= LASS && LA118_20 <= LBRACKET)||LA118_20==LCURLY||LA118_20==LITERAL_and||LA118_20==LITERAL_are||LA118_20==LITERAL_cand||LA118_20==LITERAL_computation||LA118_20==LITERAL_cor||LA118_20==LITERAL_declare||(LA118_20 >= LITERAL_do && LA118_20 <= LITERAL_else)||LA118_20==LITERAL_exception||(LA118_20 >= LITERAL_fetchadd && LA118_20 <= LITERAL_fi)||(LA118_20 >= LITERAL_for && LA118_20 <= LITERAL_forall)||(LA118_20 >= LITERAL_hr && LA118_20 <= LITERAL_iff)||(LA118_20 >= LITERAL_implies && LA118_20 <= LITERAL_in)||LA118_20==LITERAL_invariant||(LA118_20 >= LITERAL_min && LA118_20 <= LITERAL_mod)||LA118_20==LITERAL_ms||LA118_20==LITERAL_ns||LA118_20==LITERAL_of||LA118_20==LITERAL_or||LA118_20==LITERAL_pause||LA118_20==LITERAL_ps||LA118_20==LITERAL_rem||LA118_20==LITERAL_sec||LA118_20==LITERAL_setmode||LA118_20==LITERAL_skip||LA118_20==LITERAL_swap||(LA118_20 >= LITERAL_that && LA118_20 <= LITERAL_then)||LA118_20==LITERAL_until||LA118_20==LITERAL_us||(LA118_20 >= LITERAL_when && LA118_20 <= LITERAL_while)||(LA118_20 >= LITERAL_xor && LA118_20 <= LT)||LA118_20==MINUS||LA118_20==NEQ||(LA118_20 >= PERIOD && LA118_20 <= PLUS)||LA118_20==QQ||LA118_20==RASS||(LA118_20 >= RBRACKET && LA118_20 <= RCURLY)||LA118_20==RPAREN||LA118_20==SEMICOLON||LA118_20==TIMES) ) {s = 12;}
						 
						input.seek(index118_20);
>>>>>>> origin/continuum
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA118_21 = input.LA(1);
						 
						int index118_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_21==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_21==TICK) ) {s = 19;}
						else if ( (LA118_21==PERIOD) ) {s = 18;}
						else if ( (LA118_21==EOF||(LA118_21 >= AL && LA118_21 <= ANNEX_END)||LA118_21==AT_SIGN||(LA118_21 >= BOX && LA118_21 <= CARET)||LA118_21==COLON||(LA118_21 >= COMMA && LA118_21 <= COMMADOT)||LA118_21==DIVIDE||(LA118_21 >= DOTCOMMA && LA118_21 <= DOTDOT)||LA118_21==EQ||LA118_21==EXP||(LA118_21 >= GT && LA118_21 <= GUARD)||(LA118_21 >= ID && LA118_21 <= IMP)||(LA118_21 >= LASS && LA118_21 <= LBRACKET)||LA118_21==LCURLY||LA118_21==LITERAL_and||LA118_21==LITERAL_are||LA118_21==LITERAL_cand||LA118_21==LITERAL_computation||LA118_21==LITERAL_cor||LA118_21==LITERAL_declare||(LA118_21 >= LITERAL_do && LA118_21 <= LITERAL_else)||LA118_21==LITERAL_exception||(LA118_21 >= LITERAL_fetchadd && LA118_21 <= LITERAL_fi)||(LA118_21 >= LITERAL_for && LA118_21 <= LITERAL_forall)||(LA118_21 >= LITERAL_hr && LA118_21 <= LITERAL_iff)||(LA118_21 >= LITERAL_implies && LA118_21 <= LITERAL_in)||LA118_21==LITERAL_invariant||(LA118_21 >= LITERAL_min && LA118_21 <= LITERAL_mod)||LA118_21==LITERAL_ms||LA118_21==LITERAL_ns||LA118_21==LITERAL_of||LA118_21==LITERAL_or||LA118_21==LITERAL_pause||LA118_21==LITERAL_ps||LA118_21==LITERAL_rem||LA118_21==LITERAL_sec||LA118_21==LITERAL_setmode||LA118_21==LITERAL_skip||LA118_21==LITERAL_swap||(LA118_21 >= LITERAL_that && LA118_21 <= LITERAL_then)||LA118_21==LITERAL_until||LA118_21==LITERAL_us||(LA118_21 >= LITERAL_when && LA118_21 <= LITERAL_while)||(LA118_21 >= LITERAL_xor && LA118_21 <= LT)||LA118_21==MINUS||LA118_21==NEQ||LA118_21==PLUS||LA118_21==QQ||LA118_21==RASS||(LA118_21 >= RBRACKET && LA118_21 <= RCURLY)||LA118_21==RPAREN||LA118_21==SEMICOLON||LA118_21==TIMES) ) {s = 12;}
						 
						input.seek(index118_21);
						if ( s>=0 ) return s;
						break;

					case 2 : 
<<<<<<< HEAD
						int LA118_20 = input.LA(1);
						 
						int index118_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_20==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_20==TICK) ) {s = 19;}
						else if ( (LA118_20==EOF||(LA118_20 >= AL && LA118_20 <= ANNEX_END)||LA118_20==AT_SIGN||(LA118_20 >= BOX && LA118_20 <= CARET)||(LA118_20 >= COLON && LA118_20 <= COMMADOT)||LA118_20==DIVIDE||(LA118_20 >= DOTCOMMA && LA118_20 <= DOTDOT)||LA118_20==EQ||LA118_20==EXP||(LA118_20 >= GT && LA118_20 <= GUARD)||(LA118_20 >= ID && LA118_20 <= IMP)||(LA118_20 >= LASS && LA118_20 <= LBRACKET)||LA118_20==LCURLY||LA118_20==LITERAL_and||LA118_20==LITERAL_are||LA118_20==LITERAL_cand||LA118_20==LITERAL_computation||LA118_20==LITERAL_cor||LA118_20==LITERAL_declare||(LA118_20 >= LITERAL_do && LA118_20 <= LITERAL_else)||LA118_20==LITERAL_exception||(LA118_20 >= LITERAL_fetchadd && LA118_20 <= LITERAL_fi)||(LA118_20 >= LITERAL_for && LA118_20 <= LITERAL_forall)||(LA118_20 >= LITERAL_hr && LA118_20 <= LITERAL_iff)||(LA118_20 >= LITERAL_implies && LA118_20 <= LITERAL_in)||LA118_20==LITERAL_invariant||(LA118_20 >= LITERAL_min && LA118_20 <= LITERAL_mod)||LA118_20==LITERAL_ms||LA118_20==LITERAL_ns||LA118_20==LITERAL_of||LA118_20==LITERAL_or||LA118_20==LITERAL_pause||LA118_20==LITERAL_ps||LA118_20==LITERAL_rem||LA118_20==LITERAL_sec||LA118_20==LITERAL_setmode||LA118_20==LITERAL_skip||LA118_20==LITERAL_swap||(LA118_20 >= LITERAL_that && LA118_20 <= LITERAL_then)||LA118_20==LITERAL_until||LA118_20==LITERAL_us||(LA118_20 >= LITERAL_when && LA118_20 <= LITERAL_while)||(LA118_20 >= LITERAL_xor && LA118_20 <= LT)||LA118_20==MINUS||LA118_20==NEQ||(LA118_20 >= PERIOD && LA118_20 <= PLUS)||LA118_20==QQ||LA118_20==RASS||(LA118_20 >= RBRACKET && LA118_20 <= RCURLY)||LA118_20==RPAREN||LA118_20==SEMICOLON||LA118_20==TIMES) ) {s = 12;}
						 
						input.seek(index118_20);
						if ( s>=0 ) return s;
						break;

					case 3 : 
=======
>>>>>>> origin/continuum
						int LA118_13 = input.LA(1);
						 
						int index118_13 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_13==OCTOTHORPE) ) {s = 1;}
						else if ( (LA118_13==PERIOD) ) {s = 18;}
						else if ( (LA118_13==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_13==TICK) ) {s = 19;}
						else if ( (LA118_13==EOF||(LA118_13 >= AL && LA118_13 <= ANNEX_END)||LA118_13==AT_SIGN||(LA118_13 >= BOX && LA118_13 <= CARET)||LA118_13==COLON||(LA118_13 >= COMMA && LA118_13 <= COMMADOT)||LA118_13==DIVIDE||(LA118_13 >= DOTCOMMA && LA118_13 <= DOTDOT)||LA118_13==EQ||LA118_13==EXP||(LA118_13 >= GT && LA118_13 <= GUARD)||(LA118_13 >= ID && LA118_13 <= IMP)||(LA118_13 >= LASS && LA118_13 <= LBRACKET)||LA118_13==LCURLY||LA118_13==LITERAL_and||LA118_13==LITERAL_are||LA118_13==LITERAL_cand||LA118_13==LITERAL_computation||LA118_13==LITERAL_cor||LA118_13==LITERAL_declare||(LA118_13 >= LITERAL_do && LA118_13 <= LITERAL_else)||LA118_13==LITERAL_exception||(LA118_13 >= LITERAL_fetchadd && LA118_13 <= LITERAL_fi)||(LA118_13 >= LITERAL_for && LA118_13 <= LITERAL_forall)||(LA118_13 >= LITERAL_hr && LA118_13 <= LITERAL_iff)||(LA118_13 >= LITERAL_implies && LA118_13 <= LITERAL_in)||LA118_13==LITERAL_invariant||(LA118_13 >= LITERAL_min && LA118_13 <= LITERAL_mod)||LA118_13==LITERAL_ms||LA118_13==LITERAL_ns||LA118_13==LITERAL_of||LA118_13==LITERAL_or||LA118_13==LITERAL_pause||LA118_13==LITERAL_ps||LA118_13==LITERAL_rem||LA118_13==LITERAL_sec||LA118_13==LITERAL_setmode||LA118_13==LITERAL_skip||LA118_13==LITERAL_swap||(LA118_13 >= LITERAL_that && LA118_13 <= LITERAL_then)||LA118_13==LITERAL_until||LA118_13==LITERAL_us||(LA118_13 >= LITERAL_when && LA118_13 <= LITERAL_while)||(LA118_13 >= LITERAL_xor && LA118_13 <= LT)||LA118_13==MINUS||LA118_13==NEQ||LA118_13==PLUS||LA118_13==QQ||LA118_13==RASS||(LA118_13 >= RBRACKET && LA118_13 <= RCURLY)||LA118_13==RPAREN||LA118_13==SEMICOLON||LA118_13==TIMES) ) {s = 12;}
						 
						input.seek(index118_13);
						if ( s>=0 ) return s;
						break;

<<<<<<< HEAD
					case 4 : 
=======
					case 3 : 
>>>>>>> origin/continuum
						int LA118_9 = input.LA(1);
						 
						int index118_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_9==LITERAL_fresh) && (synpred3_BLESStoAST())) {s = 14;}
						else if ( (LA118_9==LITERAL_count) && (synpred3_BLESStoAST())) {s = 15;}
						else if ( (LA118_9==LITERAL_updated) && (synpred3_BLESStoAST())) {s = 16;}
						else if ( (LA118_9==ID) ) {s = 1;}
<<<<<<< HEAD
						else if ( (LA118_9==EOF||(LA118_9 >= AL && LA118_9 <= AM)||LA118_9==ANNEX_END||(LA118_9 >= COLON && LA118_9 <= COMMADOT)||LA118_9==DIVIDE||(LA118_9 >= DOTCOMMA && LA118_9 <= DOTDOT)||LA118_9==EQ||LA118_9==EXP||LA118_9==GT||LA118_9==IMP||LA118_9==LITERAL_and||LA118_9==LITERAL_are||LA118_9==LITERAL_else||LA118_9==LITERAL_iff||(LA118_9 >= LITERAL_implies && LA118_9 <= LITERAL_in)||LA118_9==LITERAL_mod||LA118_9==LITERAL_of||LA118_9==LITERAL_or||LA118_9==LITERAL_rem||(LA118_9 >= LITERAL_that && LA118_9 <= LITERAL_then)||LA118_9==LITERAL_xor||LA118_9==LT||LA118_9==MINUS||LA118_9==NEQ||LA118_9==PLUS||LA118_9==QQ||LA118_9==RASS||LA118_9==RPAREN||LA118_9==TIMES) ) {s = 12;}
=======
						else if ( (LA118_9==EOF||(LA118_9 >= AL && LA118_9 <= AM)||LA118_9==ANNEX_END||LA118_9==COLON||(LA118_9 >= COMMA && LA118_9 <= COMMADOT)||LA118_9==DIVIDE||(LA118_9 >= DOTCOMMA && LA118_9 <= DOTDOT)||LA118_9==EQ||LA118_9==EXP||LA118_9==GT||LA118_9==IMP||LA118_9==LITERAL_and||LA118_9==LITERAL_are||LA118_9==LITERAL_else||LA118_9==LITERAL_iff||(LA118_9 >= LITERAL_implies && LA118_9 <= LITERAL_in)||LA118_9==LITERAL_mod||LA118_9==LITERAL_of||LA118_9==LITERAL_or||LA118_9==LITERAL_rem||(LA118_9 >= LITERAL_that && LA118_9 <= LITERAL_then)||LA118_9==LITERAL_xor||LA118_9==LT||LA118_9==MINUS||LA118_9==NEQ||LA118_9==PLUS||LA118_9==QQ||LA118_9==RASS||LA118_9==RPAREN||LA118_9==TIMES) ) {s = 12;}
>>>>>>> origin/continuum
						 
						input.seek(index118_9);
						if ( s>=0 ) return s;
						break;

<<<<<<< HEAD
=======
					case 4 : 
						int LA118_19 = input.LA(1);
						 
						int index118_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_19==LITERAL_fresh) && (synpred3_BLESStoAST())) {s = 14;}
						else if ( (LA118_19==LITERAL_count) && (synpred3_BLESStoAST())) {s = 15;}
						else if ( (LA118_19==LITERAL_updated) && (synpred3_BLESStoAST())) {s = 16;}
						else if ( (LA118_19==EOF||(LA118_19 >= AL && LA118_19 <= AM)||LA118_19==ANNEX_END||LA118_19==COLON||(LA118_19 >= COMMA && LA118_19 <= COMMADOT)||LA118_19==DIVIDE||(LA118_19 >= DOTCOMMA && LA118_19 <= DOTDOT)||LA118_19==EQ||LA118_19==EXP||LA118_19==GT||LA118_19==IMP||LA118_19==LITERAL_and||LA118_19==LITERAL_are||LA118_19==LITERAL_else||LA118_19==LITERAL_iff||(LA118_19 >= LITERAL_implies && LA118_19 <= LITERAL_in)||LA118_19==LITERAL_mod||LA118_19==LITERAL_of||LA118_19==LITERAL_or||LA118_19==LITERAL_rem||(LA118_19 >= LITERAL_that && LA118_19 <= LITERAL_then)||LA118_19==LITERAL_xor||LA118_19==LT||LA118_19==MINUS||LA118_19==NEQ||LA118_19==PLUS||LA118_19==QQ||LA118_19==RASS||LA118_19==RPAREN||LA118_19==TIMES) ) {s = 12;}
						 
						input.seek(index118_19);
						if ( s>=0 ) return s;
						break;

>>>>>>> origin/continuum
					case 5 : 
						int LA118_2 = input.LA(1);
						 
						int index118_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_2==DOUBLE_COLON||LA118_2==OCTOTHORPE) ) {s = 1;}
						else if ( (LA118_2==PERIOD) ) {s = 8;}
						else if ( (LA118_2==TICK) ) {s = 9;}
						else if ( (LA118_2==QUESTION) && (synpred3_BLESStoAST())) {s = 10;}
						else if ( (LA118_2==LBRACKET) ) {s = 11;}
						else if ( (LA118_2==EOF||(LA118_2 >= AL && LA118_2 <= ANNEX_END)||LA118_2==AT_SIGN||(LA118_2 >= BOX && LA118_2 <= CARET)||LA118_2==COLON||(LA118_2 >= COMMA && LA118_2 <= COMMADOT)||LA118_2==DIVIDE||(LA118_2 >= DOTCOMMA && LA118_2 <= DOTDOT)||LA118_2==EQ||LA118_2==EXP||(LA118_2 >= GT && LA118_2 <= GUARD)||(LA118_2 >= ID && LA118_2 <= IMP)||LA118_2==LASS||LA118_2==LCURLY||LA118_2==LITERAL_and||LA118_2==LITERAL_are||LA118_2==LITERAL_cand||LA118_2==LITERAL_computation||LA118_2==LITERAL_cor||LA118_2==LITERAL_declare||(LA118_2 >= LITERAL_do && LA118_2 <= LITERAL_else)||LA118_2==LITERAL_exception||(LA118_2 >= LITERAL_fetchadd && LA118_2 <= LITERAL_fi)||(LA118_2 >= LITERAL_for && LA118_2 <= LITERAL_forall)||(LA118_2 >= LITERAL_hr && LA118_2 <= LITERAL_iff)||(LA118_2 >= LITERAL_implies && LA118_2 <= LITERAL_in)||LA118_2==LITERAL_invariant||(LA118_2 >= LITERAL_min && LA118_2 <= LITERAL_mod)||LA118_2==LITERAL_ms||LA118_2==LITERAL_ns||LA118_2==LITERAL_of||LA118_2==LITERAL_or||LA118_2==LITERAL_pause||LA118_2==LITERAL_ps||LA118_2==LITERAL_rem||LA118_2==LITERAL_sec||LA118_2==LITERAL_setmode||LA118_2==LITERAL_skip||LA118_2==LITERAL_swap||(LA118_2 >= LITERAL_that && LA118_2 <= LITERAL_then)||LA118_2==LITERAL_until||LA118_2==LITERAL_us||(LA118_2 >= LITERAL_when && LA118_2 <= LITERAL_while)||(LA118_2 >= LITERAL_xor && LA118_2 <= LT)||LA118_2==MINUS||LA118_2==NEQ||LA118_2==PLUS||LA118_2==QQ||LA118_2==RASS||(LA118_2 >= RBRACKET && LA118_2 <= RCURLY)||LA118_2==RPAREN||LA118_2==SEMICOLON||LA118_2==TIMES) ) {s = 12;}
						 
						input.seek(index118_2);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 118, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA162_eotS =
		"\32\uffff";
	static final String DFA162_eofS =
		"\32\uffff";
	static final String DFA162_minS =
<<<<<<< HEAD
		"\1\4\1\7\3\uffff\1\21\1\u0104\2\uffff\1\76\1\uffff\1\21\2\76\1\21\1\u0124"+
		"\1\76\1\21\2\76\1\21\1\u0124\1\76\1\21\1\76\1\21";
	static final String DFA162_maxS =
		"\1\u0115\1\u0123\3\uffff\1\76\1\u0124\2\uffff\1\76\1\uffff\1\55\2\76\1"+
		"\35\1\u0124\1\76\1\55\2\76\1\35\1\u0124\1\76\1\55\1\76\1\35";
=======
		"\1\4\1\7\3\uffff\1\21\1\u0105\2\uffff\1\77\1\uffff\1\21\2\77\1\21\1\u0125"+
		"\1\77\1\21\2\77\1\21\1\u0125\1\77\1\21\1\77\1\21";
	static final String DFA162_maxS =
		"\1\u0116\1\u0124\3\uffff\1\77\1\u0125\2\uffff\1\77\1\uffff\1\56\2\77\1"+
		"\36\1\u0125\1\77\1\56\2\77\1\36\1\u0125\1\77\1\56\1\77\1\36";
>>>>>>> origin/continuum
	static final String DFA162_acceptS =
		"\2\uffff\1\2\1\5\1\6\2\uffff\1\3\1\4\1\uffff\1\1\17\uffff";
	static final String DFA162_specialS =
		"\32\uffff}>";
	static final String[] DFA162_transitionS = {
<<<<<<< HEAD
			"\1\4\14\uffff\1\3\54\uffff\1\1\3\uffff\1\4\11\uffff\1\4\13\uffff\1\4"+
=======
			"\1\4\14\uffff\1\3\55\uffff\1\1\3\uffff\1\4\11\uffff\1\4\13\uffff\1\4"+
>>>>>>> origin/continuum
			"\2\uffff\1\4\21\uffff\1\4\11\uffff\1\4\11\uffff\1\4\1\uffff\1\4\24\uffff"+
			"\1\4\2\uffff\1\4\13\uffff\1\4\2\uffff\2\4\1\uffff\1\4\27\uffff\2\4\6"+
			"\uffff\1\4\10\uffff\1\4\12\uffff\2\4\1\uffff\1\4\2\uffff\1\4\15\uffff"+
			"\1\4\3\uffff\1\4\3\uffff\1\4\6\uffff\1\2\20\uffff\1\4",
<<<<<<< HEAD
			"\2\4\11\uffff\1\4\7\uffff\1\4\1\uffff\1\5\20\uffff\1\4\5\uffff\1\4\7"+
=======
			"\2\4\11\uffff\1\4\7\uffff\1\4\1\uffff\1\5\21\uffff\1\4\5\uffff\1\4\7"+
>>>>>>> origin/continuum
			"\uffff\1\4\3\uffff\1\4\14\uffff\1\4\17\uffff\1\4\70\uffff\1\4\1\uffff"+
			"\2\4\30\uffff\1\4\102\uffff\3\4\4\uffff\1\4\1\uffff\1\4\4\uffff\1\4\2"+
			"\uffff\1\4\11\uffff\2\4\22\uffff\1\4",
			"",
			"",
			"",
			"\1\10\12\uffff\1\7\42\uffff\1\6",
			"\1\12\37\uffff\1\11",
			"",
			"",
			"\1\13",
			"",
			"\1\10\12\uffff\1\7\1\uffff\1\15\17\uffff\1\14",
			"\1\16",
			"\1\17",
			"\1\10\12\uffff\1\7\1\uffff\1\15",
			"\1\20",
			"\1\21",
			"\1\10\12\uffff\1\7\1\uffff\1\23\17\uffff\1\22",
			"\1\24",
			"\1\25",
			"\1\10\12\uffff\1\7\1\uffff\1\23",
			"\1\26",
			"\1\27",
			"\1\10\12\uffff\1\7\1\uffff\1\23\17\uffff\1\30",
			"\1\31",
			"\1\10\12\uffff\1\7\1\uffff\1\23"
	};

	static final short[] DFA162_eot = DFA.unpackEncodedString(DFA162_eotS);
	static final short[] DFA162_eof = DFA.unpackEncodedString(DFA162_eofS);
	static final char[] DFA162_min = DFA.unpackEncodedStringToUnsignedChars(DFA162_minS);
	static final char[] DFA162_max = DFA.unpackEncodedStringToUnsignedChars(DFA162_maxS);
	static final short[] DFA162_accept = DFA.unpackEncodedString(DFA162_acceptS);
	static final short[] DFA162_special = DFA.unpackEncodedString(DFA162_specialS);
	static final short[][] DFA162_transition;

	static {
		int numStates = DFA162_transitionS.length;
		DFA162_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA162_transition[i] = DFA.unpackEncodedString(DFA162_transitionS[i]);
		}
	}

	protected class DFA162 extends DFA {

		public DFA162(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 162;
			this.eot = DFA162_eot;
			this.eof = DFA162_eof;
			this.min = DFA162_min;
			this.max = DFA162_max;
			this.accept = DFA162_accept;
			this.special = DFA162_special;
			this.transition = DFA162_transition;
		}
		@Override
		public String getDescription() {
			return "2931:1: assertion_body : ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) );";
		}
	}

<<<<<<< HEAD
	public static final BitSet FOLLOW_LBRACKET_in_rational_literal2624 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L,0x0000000000000000L,0x0200000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2628 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2633 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_303_in_rational_literal2635 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L,0x0000000000000000L,0x0200000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2639 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2644 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_rational_literal2646 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_complex_literal2743 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0200000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2747 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2752 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_complex_literal2754 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0200000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2758 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2763 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_complex_literal2765 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_identifier2919 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_annex_library_assertions3294 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_annex_library_assertions3304 = new BitSet(new long[]{0x0000000000000402L,0x0000000000000800L});
	public static final BitSet FOLLOW_ANNEX_END_in_annex_library_assertions3324 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_thread_behavior3999 = new BitSet(new long[]{0x0000800000000000L,0x0000000C00000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_thread_behavior4006 = new BitSet(new long[]{0x0000000000000000L,0x0000000C00000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_availability_in_thread_behavior4013 = new BitSet(new long[]{0x0000000000000000L,0x0000000400000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_assert_clause_in_thread_behavior4020 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000010000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_invariant_clause_in_thread_behavior4027 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000400000200000L});
	public static final BitSet FOLLOW_variables_in_thread_behavior4034 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_states_in_thread_behavior4041 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_state_in_thread_behavior4047 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_transitions_in_thread_behavior4056 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_thread_behavior4060 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_assert_in_assert_clause4149 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_assert_clause4153 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000800L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_invariant_clause4197 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_invariant_clause4201 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variables_in_variables4244 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_variables4250 = new BitSet(new long[]{0x4000000000000002L});
	public static final BitSet FOLLOW_LITERAL_declare_in_quantified_variables4302 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_quantified_variables4308 = new BitSet(new long[]{0x4000000000000002L});
	public static final BitSet FOLLOW_declarators_in_behavior_variable4368 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_variable4372 = new BitSet(new long[]{0x4000000000000000L,0x4004201200000000L,0x0000028008000800L,0x00008002008A00E0L});
	public static final BitSet FOLLOW_LITERAL_nonvolatile_in_behavior_variable4381 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_shared_in_behavior_variable4387 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_constant_in_behavior_variable4393 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_spread_in_behavior_variable4399 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_variable4407 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_type_in_behavior_variable4417 = new BitSet(new long[]{0x0000000000020000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_ASSIGN_in_behavior_variable4423 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_behavior_variable4427 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_variable4437 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_variable4446 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_declarators4583 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_declarators4588 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_declarators4593 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_state4677 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_state4682 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L,0x0000000004000800L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_initial_in_behavior_state4687 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_complete_in_behavior_state4693 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_state4699 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_state_in_behavior_state4705 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_state4709 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_state4712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_transitions_in_transitions4772 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_behavior_transition_in_transitions4776 = new BitSet(new long[]{0x4000000000000002L});
	public static final BitSet FOLLOW_behavior_transition_label_in_behavior_transition4823 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_transition4825 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4835 = new BitSet(new long[]{0x0000000020000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_COMMA_in_behavior_transition4839 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4844 = new BitSet(new long[]{0x0000000020000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_LCON_in_behavior_transition4853 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00012C8009000008L,0x2220009600002060L,0x0000000000280000L});
	public static final BitSet FOLLOW_behavior_condition_in_behavior_transition4857 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RCON_in_behavior_transition4860 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4867 = new BitSet(new long[]{0x0002000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCURLY_in_behavior_transition4874 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_behavior_transition4878 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCURLY_in_behavior_transition4880 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_EMPTY_CURLY_in_behavior_transition4884 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_transition4892 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_transition4897 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition_label5061 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_behavior_transition_label5065 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_behavior_transition_label5069 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_behavior_transition_label5071 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_condition_in_behavior_condition5109 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_execute_condition_in_behavior_condition5113 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_mode_condition_in_behavior_condition5117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_or_relation_in_execute_condition5135 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_mode_condition5151 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_mode_condition5154 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5172 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5178 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5182 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5192 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5196 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5267 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5269 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5276 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5278 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5288 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_event_trigger5294 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_event_trigger5297 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_event_trigger5299 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_subprogram_behavior5361 = new BitSet(new long[]{0x0000800000000000L,0x0040000400004000L,0x0180000000000000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5368 = new BitSet(new long[]{0x0000000000000000L,0x0040000400004000L,0x0180000000000000L});
	public static final BitSet FOLLOW_assert_clause_in_subprogram_behavior5376 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L,0x0180000000000000L});
	public static final BitSet FOLLOW_LITERAL_pre_in_subprogram_behavior5385 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5389 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L,0x0080000000000000L});
	public static final BitSet FOLLOW_LITERAL_post_in_subprogram_behavior5400 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5404 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_subprogram_behavior5413 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_subprogram_behavior5417 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5577 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004000L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_action_in_asserted_action5586 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5592 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_basic_action_in_action5713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_alternative_in_action5719 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_while_loop_in_action5725 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_loop_in_action5731 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_do_until_loop_in_action5737 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_action5743 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_lattice_quantification_in_action5749 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_if_in_alternative5776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5784 = new BitSet(new long[]{0x0000000002000000L});
	public static final BitSet FOLLOW_BOX_in_alternative5790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5794 = new BitSet(new long[]{0x0000000002000000L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_LITERAL_fi_in_alternative5802 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_guarded_action5845 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_guarded_action5849 = new BitSet(new long[]{0x1000000000000000L});
	public static final BitSet FOLLOW_GUARD_in_guarded_action5851 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_guarded_action5854 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_forall_in_universal_lattice_quantification5881 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_lattice_variables_in_universal_lattice_quantification5890 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_universal_lattice_quantification5894 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_range_in_universal_lattice_quantification5898 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5907 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5958 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5963 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5967 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5970 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5974 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_LITERAL_while_in_while_loop6036 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_while_loop6042 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_while_loop6047 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_while_loop6049 = new BitSet(new long[]{0x0000000000000000L,0x0040002000004000L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_while_loop6056 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_while_loop6060 = new BitSet(new long[]{0x0000000000000000L,0x0040002000004000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_while_loop6069 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_while_loop6074 = new BitSet(new long[]{0x0000000000000000L,0x0040000000004000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_while_loop6085 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_for_in_for_loop6150 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_for_loop6158 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_for_loop6163 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_for_loop6168 = new BitSet(new long[]{0x0000100000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_for_loop6170 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_for_loop6175 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_for_loop6184 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_for_loop6188 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCURLY_in_for_loop6195 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_for_loop6200 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCURLY_in_for_loop6202 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_do_in_do_until_loop6272 = new BitSet(new long[]{0x4000000000000000L,0x0840802000004800L,0x002000001010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_do_until_loop6280 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_do_until_loop6284 = new BitSet(new long[]{0x4000000000000000L,0x0840802000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_do_until_loop6293 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_do_until_loop6298 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_do_until_loop6309 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_until_in_do_until_loop6315 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_do_until_loop6317 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_do_until_loop6322 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_do_until_loop6324 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_skip_in_basic_action6394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_basic_action6400 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_communication_action_in_basic_action6407 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_computation_action_in_basic_action6414 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_setmode_in_basic_action6420 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_basic_action6423 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_throw_in_basic_action6429 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_combinable_operation_in_basic_action6435 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simultaneous_assignment_in_basic_action6441 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_issue_exception_in_basic_action6447 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_tick_in_assignment6474 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assignment6478 = new BitSet(new long[]{0x4000000000000010L,0x0000200040001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_assignment6482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_name_tick6526 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_name_tick6530 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_record_term6554 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_record_term6560 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_any_in_expression_or_record_term6566 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_record_term6581 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_record_value_in_record_term6586 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_record_term6589 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_value6607 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_record_value6609 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2000009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_record_value6612 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_value6614 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_simultaneous_assignment6640 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6644 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6650 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6654 = new BitSet(new long[]{0x0000000020020000L});
	public static final BitSet FOLLOW_ASSIGN_in_simultaneous_assignment6664 = new BitSet(new long[]{0x4000000000000010L,0x0000200040001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6668 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6674 = new BitSet(new long[]{0x4000000000000010L,0x0000200040001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6678 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_simultaneous_assignment6683 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exception_in_issue_exception6745 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_issue_exception6748 = new BitSet(new long[]{0x4000000000000010L});
	public static final BitSet FOLLOW_identifier_in_issue_exception6758 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_issue_exception6760 = new BitSet(new long[]{0x0000000000000010L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_issue_exception6768 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_issue_exception6770 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_computation_in_computation_action6799 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_computation_action6806 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6809 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_computation_action6813 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_computation_action6824 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_behavior_time6855 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000104400080000L,0x0000200000001004L});
	public static final BitSet FOLLOW_time_unit_in_behavior_time6860 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_procedure_call_in_communication_action6950 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_output_in_communication_action6968 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_input_in_communication_action6986 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_pause_in_communication_action7004 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_procedure_call7041 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_procedure_call7045 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000000000000008L,0x2020008000002000L,0x0000000000A00000L});
	public static final BitSet FOLLOW_formal_actual_list_in_procedure_call7049 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_procedure_call7052 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_output7109 = new BitSet(new long[]{0x0010000000000000L});
	public static final BitSet FOLLOW_EXCLAMATION_in_port_output7111 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_output7115 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_port_output7119 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_port_output7121 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_input7179 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QUESTION_in_port_input7181 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_input7183 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_name_in_port_input7188 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_port_input7190 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_port_name7233 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7236 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7239 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7242 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7245 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_identifier_in_port_name7259 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_port_name7261 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_port_name7265 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_port_name7267 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7286 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_actual_list7292 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000000000000008L,0x2020008000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7296 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_identifier_in_formal_actual7351 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_actual7353 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000000000000008L,0x2020008000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_actual_parameter_in_formal_actual7359 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_actual_parameter7378 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_actual_parameter7386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_actual_parameter7394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_quantified_variables_in_existential_lattice_quantification7420 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCURLY_in_existential_lattice_quantification7425 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_behavior_actions_in_existential_lattice_quantification7429 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCURLY_in_existential_lattice_quantification7431 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0000000000000000L,0x0000000400000000L});
	public static final BitSet FOLLOW_timeout_clause_in_existential_lattice_quantification7437 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
	public static final BitSet FOLLOW_catch_clause_in_existential_lattice_quantification7442 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_catch_in_catch_clause7466 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_catch_clause_term_in_catch_clause7469 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_timeout_clause7485 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_timeout_clause7488 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_catch_clause_term7509 = new BitSet(new long[]{0x4000000000000000L,0x0000000008000000L});
	public static final BitSet FOLLOW_identifier_in_catch_clause_term7516 = new BitSet(new long[]{0x4000000010000000L});
	public static final BitSet FOLLOW_LITERAL_all_in_catch_clause_term7523 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_catch_clause_term7529 = new BitSet(new long[]{0x4000000000000000L,0x0000800000000000L,0x00200000000003C1L,0x0022000008050000L});
	public static final BitSet FOLLOW_basic_action_in_catch_clause_term7533 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_catch_clause_term7535 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_when_in_when_throw7591 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_when_throw7594 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_when_throw7598 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_when_throw7600 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000100000000L});
	public static final BitSet FOLLOW_LITERAL_throw_in_when_throw7603 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_when_throw7606 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchadd_in_combinable_operation7621 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7624 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7628 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7630 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7641 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7645 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7649 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7654 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchor_in_combinable_operation7663 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7666 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7670 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7672 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7683 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7687 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7691 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7696 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchand_in_combinable_operation7705 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7708 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7712 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7714 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7725 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7729 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7733 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7738 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchxor_in_combinable_operation7747 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7750 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7754 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7756 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7767 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7771 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7775 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7780 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_swap_in_combinable_operation7789 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7793 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7797 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7799 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7810 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7814 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7818 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7823 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7846 = new BitSet(new long[]{0x0000000000000202L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7862 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7866 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7870 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7874 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7895 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7899 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7903 = new BitSet(new long[]{0x4000000000000000L,0x0840800000004800L,0x002000000010C3C1L,0x0026000008050000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7907 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_partial_name_in_name8002 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_name8008 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_partial_name_in_name8012 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_identifier_in_partial_name8079 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_partial_name8088 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_range_in_partial_name8092 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_partial_name8094 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8143 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_parameter_list8152 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8156 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8218 = new BitSet(new long[]{0x00001800C0000002L});
	public static final BitSet FOLLOW_range_symbol_in_expression_or_range8222 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8225 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_variable_name8252 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression8278 = new BitSet(new long[]{0x0020020000000002L,0x0008020010000000L,0x0002000800000000L,0x0210000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_expression8294 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8298 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_expression8314 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8318 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_expression8332 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8336 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_expression8347 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8351 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_expression8362 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8366 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_expression8377 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8381 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_expression8392 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8396 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_expression8409 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8413 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_expression8429 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8433 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_expression8449 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8453 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_expression8467 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_expression8482 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression8486 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_subexpression8558 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_not_in_subexpression8564 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_subexpression8576 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression8582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_conversion_in_subexpression8682 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_function_call_in_subexpression8702 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_type_conversion8732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_type_conversion8741 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_type_conversion8750 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_type_conversion8759 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_type_conversion8768 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_type_conversion8776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion8785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type_conversion8816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type_conversion8825 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type_conversion8834 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type_conversion8843 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type_conversion8852 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type_conversion8860 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8869 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8904 = new BitSet(new long[]{0x0000000000000002L,0x0008020010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_boolean_expression8920 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8924 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_boolean_expression8940 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8944 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_boolean_expression8960 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8964 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_boolean_expression8978 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8982 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_boolean_expression8993 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x00002C0001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8997 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_boolean_subexpression9069 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_boolean_subexpression9081 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_boolean_subexpression9087 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9172 = new BitSet(new long[]{0x0020020000000002L,0x0000000000000000L,0x0000000800000000L,0x0200000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_numeric_expression9188 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9192 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_numeric_expression9208 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9212 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_numeric_expression9226 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9230 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_numeric_expression9241 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9245 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_numeric_expression9256 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9260 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_numeric_expression9271 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_numeric_expression9286 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9290 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_numeric_subexpression9362 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_numeric_subexpression9374 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_numeric_subexpression9380 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_expression_in_parenthesized_subexpression9482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_expression_in_parenthesized_subexpression9512 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_subexpression9531 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_or_relation_in_parenthesized_subexpression9535 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_subexpression9539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_expression9576 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9580 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9586 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9590 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9598 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_case_expression9605 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_choice9642 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_case_choice9647 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_case_choice9649 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_case_choice9652 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_case_choice9657 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9672 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_expression9674 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9678 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_expression9682 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9687 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_expression9689 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9694 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9696 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9726 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9730 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_conditional_expression9734 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9739 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_expression9741 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9746 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_value9788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_value9840 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800008000L});
	public static final BitSet FOLLOW_QUESTION_in_value9846 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9852 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_value9856 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9862 = new BitSet(new long[]{0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_value9866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9873 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000080000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_value9877 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_value9972 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_value9987 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_LITERAL_mode_in_value9989 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_value9991 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_value9996 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_value9999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_value10025 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_null_in_value10040 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_now_in_value10055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_tops_in_value10070 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_value_constant10098 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_value_constant10102 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_constant_in_value_constant10108 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_value_constant10114 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_value_in_value_constant10120 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10151 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_enumeration_value10155 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10159 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_constant_in_property10195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_reference_in_property10199 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_constant10217 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_constant10221 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_constant10227 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10244 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10248 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_property_field_in_property_reference10263 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_self_in_property_reference10293 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10297 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10301 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_property_field_in_property_reference10307 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_property_reference10341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10345 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10349 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_property_field_in_property_reference10359 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_LBRACKET_in_property_field10399 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_set_in_property_field10402 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_property_field10410 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_property_field10418 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000100000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_set_in_property_field10421 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_name10447 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_name10451 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_name10456 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_numeric_constant10494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_LIT_in_numeric_constant10501 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rational_literal_in_numeric_constant10510 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_complex_literal_in_numeric_constant10514 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_numeric_constant10520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_relation10552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10582 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_expression_or_relation10591 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10595 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_relation10623 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10672 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_boolean_expression_or_relation10682 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10686 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_expression_in_boolean_expression_or_relation10713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_function_call10762 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_function_call10764 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_function_call10774 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_function_call10778 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_function_parameters_in_function_call10782 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_function_call10785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10844 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10848 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10854 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10864 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10869 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_ID_in_formal_expression_pair10891 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_expression_pair10893 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_expression_in_formal_expression_pair10898 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_name_in_type10923 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_type_in_type10942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_type_in_type10961 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_type_in_type10980 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_type_in_type10999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_variant_type_in_type11018 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_type11040 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_string_in_type11055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_enumeration_in_enumeration_type11084 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_enumeration_type11087 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11092 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_enumeration_type11098 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11101 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_enumeration_type11105 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_number_type11160 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_number_type11169 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_number_type11178 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_number_type11187 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_number_type11196 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_number_type11204 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_number_range_in_number_type11212 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LITERAL_units_in_number_type11219 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000104400080000L,0x0000200000001004L});
	public static final BitSet FOLLOW_units_designator_in_number_type11223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_number_range11288 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2200000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_constant_number_range_in_number_range11291 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_number_range11293 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11311 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2000000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11316 = new BitSet(new long[]{0x0000100000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range11320 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2200000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11324 = new BitSet(new long[]{0x4000000000000000L,0x0000000000001004L,0x0000000000000000L,0x2000000000002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11329 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_units_designator11443 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_unit_in_units_designator11449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11489 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11493 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11498 = new BitSet(new long[]{0x0000200000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11510 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11515 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11573 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11581 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11586 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_type_name11662 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_type_name11667 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_type_name11672 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_array_in_array_type11699 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_LBRACKET_in_array_type11702 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_array_range_list_in_array_type11705 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_RBRACKET_in_array_type11707 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_array_type11710 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_type_in_array_type11712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_record_in_record_type11739 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_record_type11742 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_record_field_in_record_type11745 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_record_type11748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_field11777 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_record_field11779 = new BitSet(new long[]{0x4000000000000000L,0x4000201200000000L,0x0000008008000000L,0x00008002008000E0L});
	public static final BitSet FOLLOW_type_in_record_field11782 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_field11784 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11814 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11818 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11821 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11825 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11828 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11865 = new BitSet(new long[]{0x0000100000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11871 = new BitSet(new long[]{0x0000100000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11877 = new BitSet(new long[]{0x0000100000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_natural_range11887 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000004L,0x0000000000000000L,0x2000000000002000L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11894 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11900 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11906 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variant_in_variant_type11943 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_variant_type11951 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_record_field_in_variant_type11954 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_variant_type11957 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_subclause11986 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001804L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_subclause11997 = new BitSet(new long[]{0x0000000000000402L,0x0000000000000800L});
	public static final BitSet FOLLOW_predicate_in_assertion_annex_subclause12020 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_subclause12041 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_library12069 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_library12080 = new BitSet(new long[]{0x0000000000000402L,0x0000000000000800L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_library12103 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LASS_in_assertion12133 = new BitSet(new long[]{0x4000000000020010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200010L});
	public static final BitSet FOLLOW_assertion_body_in_assertion12138 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RASS_in_assertion12140 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12195 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12199 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12203 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12207 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12263 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12290 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12294 = new BitSet(new long[]{0x4000000010000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12298 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12301 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12305 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12397 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12401 = new BitSet(new long[]{0x4000000000020000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12405 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12408 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12412 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12503 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12543 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_formal_assertion_parameter12594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TILDE_in_formal_assertion_parameter12596 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_type_name_in_formal_assertion_parameter12599 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12615 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12619 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12622 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12631 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12633 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_assertion_function_value12667 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_value12686 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_function12712 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12719 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12725 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12729 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12736 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12740 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_function12750 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_condition_value_pair12791 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_condition_value_pair12793 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_condition_value_pair12796 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12814 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12817 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_COMMA_in_assertion_enumeration12820 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12823 = new BitSet(new long[]{0x0000000020000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12838 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_assertion_enumeration12841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_enumeration_pair12860 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_enumeration_pair12863 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_enumeration_pair12866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_all_in_universal_quantification12885 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_universal_quantification12888 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_universal_quantification12890 = new BitSet(new long[]{0x0000000000000000L,0x0000000100000000L});
	public static final BitSet FOLLOW_LITERAL_are_in_universal_quantification12894 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_universal_quantification12897 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exists_in_existential_quantification12923 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_existential_quantification12926 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_existential_quantification12928 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_existential_quantification12932 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_existential_quantification12935 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_logic_variables12963 = new BitSet(new long[]{0x0000000030000000L});
	public static final BitSet FOLLOW_COMMA_in_logic_variables12966 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_logic_variables12970 = new BitSet(new long[]{0x0000000030000000L});
	public static final BitSet FOLLOW_COLON_in_logic_variables12976 = new BitSet(new long[]{0x4000000000000000L,0x0000201000000000L,0x0000008008000000L,0x0000000200000060L});
	public static final BitSet FOLLOW_assertion_type_in_logic_variables12980 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_logic_variables13012 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TILDE_in_logic_variables13014 = new BitSet(new long[]{0x4000000000000000L,0x0000201000000000L,0x0000008008000000L,0x0000000200000060L});
	public static final BitSet FOLLOW_assertion_type_in_logic_variables13018 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_logic_variable_domain13065 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x20006C800900000AL,0x2220009604402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13094 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_logic_variable_domain13098 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13102 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_logic_variable_domain13137 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_quantification_in_predicate13197 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_quantification_in_predicate13205 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13214 = new BitSet(new long[]{0x8000000000000002L,0x0000000010000000L,0x0002000000A00000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13232 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13235 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13239 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13242 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13262 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13265 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13269 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13272 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13295 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13298 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13302 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13305 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_implies_in_predicate13327 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13330 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_iff_in_predicate13349 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13352 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IMP_in_predicate13370 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13373 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_subpredicate13415 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x0000288009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13445 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_subpredicate13449 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13453 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13528 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_subpredicate13532 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_range_in_subpredicate13536 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_subpredicate13604 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_subpredicate13608 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13614 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_subpredicate13656 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_subpredicate13694 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_subpredicate13730 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_invocation_in_subpredicate13775 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_predicate_in_subpredicate13809 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_def_in_subpredicate13846 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_assertion_parameter_in_subpredicate13850 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_timed_predicate13899 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate13903 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate13907 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_timed_predicate13913 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_predicate13921 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_predicate13924 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_predicate13933 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_timed_predicate13936 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_predicate13974 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_parenthesized_predicate13977 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_predicate13979 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_floatingAtom13999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_period_shift14027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14045 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14049 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift14075 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14079 = new BitSet(new long[]{0x0000020000000000L,0x0000000000000000L,0x0000000000000000L,0x0200000000000000L,0x0000002000800008L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14090 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14094 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14098 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_period_shift14112 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14116 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14120 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14134 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14138 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800008L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14141 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14145 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800008L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14151 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14167 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14171 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000800000L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14174 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14178 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000800000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14184 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14200 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14368 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14372 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14374 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14409 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14413 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_invocation14417 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14419 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14462 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14466 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14470 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_predicate_invocation14474 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14478 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14484 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter14541 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_actual_assertion_parameter14545 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_actual_assertion_parameter14549 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_expression_in_range14595 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_range14597 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_numeric_expression_in_range14600 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14626 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_assertion_range14628 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14631 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_sum_in_assertion_expression14666 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14668 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14672 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14677 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14679 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_product_in_assertion_expression14711 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14713 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800001000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14717 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000800000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14722 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14724 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_numberof_in_assertion_expression14754 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14756 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14760 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_assertion_expression14765 = new BitSet(new long[]{0x4000000000000010L,0x0080200001001004L,0x00002C8009000008L,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_subpredicate_in_assertion_expression14767 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14801 = new BitSet(new long[]{0x0020020000000002L,0x0000000000000000L,0x0000000800000000L,0x0200000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_assertion_expression14815 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14817 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_assertion_expression14850 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14852 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_assertion_expression14886 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14888 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_assertion_expression14919 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14921 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_assertion_expression14953 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14955 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_assertion_expression14987 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14989 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_assertion_expression15014 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x0000288009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression15016 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_assertion_subexpression15076 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_abs_in_assertion_subexpression15082 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression15102 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_type_conversion_in_assertion_subexpression15162 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_vpa_in_timed_expression15195 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_TICK_in_timed_expression15200 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_expression15208 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_expression15211 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_expression15220 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_period_shift_in_timed_expression15223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_vpa15251 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_vpa15261 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_vpa15271 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15288 = new BitSet(new long[]{0x0020020000000002L,0x0000000000000000L,0x0000000800000000L,0x0200000000000200L,0x0000002000000008L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15299 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15304 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15308 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15312 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15327 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15332 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15336 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15340 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_MINUS_in_time_expression15355 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15360 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_time_expression15373 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15378 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_time_expression15391 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15396 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_time_expression15409 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15414 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_time_expression15427 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15432 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_time_subexpression15459 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2020009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_time_subexpression15469 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_time_subexpression15477 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_time_subexpression15486 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2220009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_time_expression_in_time_subexpression15490 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_time_subexpression15494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15614 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15618 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000A00000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_invocation15622 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15625 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15672 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15676 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15685 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_assertion_function_invocation15689 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15693 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15698 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15815 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15849 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_assertion_expression15870 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_parenthesized_assertion_expression15874 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_assertion_expression15878 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15910 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_assertion_expression15912 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15916 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_assertion_expression15920 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15925 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_assertion_expression15927 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15932 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression15934 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15962 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15966 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_conditional_assertion_expression15970 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15975 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_assertion_expression15977 = new BitSet(new long[]{0x4000000000000010L,0x0000200001001004L,0x2000688009000008L,0x2220009604002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15982 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression15984 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_record_term16022 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_assertion_record_value_in_assertion_record_term16025 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_record_term16028 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_record_value16043 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_assertion_record_value16045 = new BitSet(new long[]{0x4000000000000010L,0x0000000000001004L,0x0000280001000008L,0x2000009400002000L,0x0000000000200000L});
	public static final BitSet FOLLOW_value_in_assertion_record_value16048 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_assertion_record_value16050 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_parameter16066 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_assertion_type16084 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type16088 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type16092 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type16096 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type16100 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type16104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type16109 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_assertion_type16116 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_availability_in_availability16142 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability16146 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16167 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0002000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_availability_expression16181 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16185 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_availability_expression16204 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16208 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_availability_expression16227 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16231 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_not_in_availability_subexpression16323 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_identifier_in_availability_subexpression16338 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_availability_subexpression16348 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000040000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_availability_expression_in_availability_subexpression16352 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_availability_subexpression16354 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_dispatch_condition16442 = new BitSet(new long[]{0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_LITERAL_dispatch_in_dispatch_condition16445 = new BitSet(new long[]{0x4000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000400400000L});
	public static final BitSet FOLLOW_dispatch_expression_in_dispatch_condition16449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16477 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_dispatch_expression16483 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000400400000L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16487 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0002000000000000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16536 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_dispatch_conjunction16542 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000400400000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16546 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16603 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_dispatch_trigger16606 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16609 = new BitSet(new long[]{0x4000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_dispatch_trigger16612 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_behavior_time_in_dispatch_trigger16615 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16624 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16635 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_dispatch_trigger16645 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_in_modes16696 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_LITERAL_modes_in_in_modes16699 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_in_modes16703 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16709 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_COMMA_in_in_modes16713 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16717 = new BitSet(new long[]{0x0000000020000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000800000L});
	public static final BitSet FOLLOW_RPAREN_in_in_modes16724 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred1_BLESStoAST9464 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred1_BLESStoAST9466 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred1_BLESStoAST9470 = new BitSet(new long[]{0x4000000000000010L,0x0000200000001004L,0x00002C8009000008L,0x2220009600002060L,0x0000000000200000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_synpred1_BLESStoAST9472 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_synpred1_BLESStoAST9474 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred2_BLESStoAST9502 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_case_choice_in_synpred2_BLESStoAST9504 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_synpred3_BLESStoAST9809 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800008000L});
	public static final BitSet FOLLOW_QUESTION_in_synpred3_BLESStoAST9813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9817 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_synpred3_BLESStoAST9819 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9823 = new BitSet(new long[]{0x0000000000000000L,0x0010000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_synpred3_BLESStoAST9825 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9828 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000080000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_synpred3_BLESStoAST9830 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred4_BLESStoAST10540 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred4_BLESStoAST10542 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred4_BLESStoAST10544 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred5_BLESStoAST10572 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred5_BLESStoAST10574 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred6_BLESStoAST10662 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred6_BLESStoAST10664 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred7_BLESStoAST12657 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_synpred7_BLESStoAST12659 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_synpred8_BLESStoAST13081 = new BitSet(new long[]{0x00001800C0000000L});
	public static final BitSet FOLLOW_range_symbol_in_synpred8_BLESStoAST13083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred9_BLESStoAST13431 = new BitSet(new long[]{0x0808000000000180L,0x0000000000000000L,0x0000000000000000L,0x0840000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred9_BLESStoAST13433 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13512 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_synpred10_BLESStoAST13514 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_synpred11_BLESStoAST13593 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_synpred11_BLESStoAST13595 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_synpred12_BLESStoAST13765 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_synpred12_BLESStoAST13767 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred16_BLESStoAST15767 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred16_BLESStoAST15769 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred16_BLESStoAST15773 = new BitSet(new long[]{0x4000000000000010L,0x0080200009001004L,0x00002C800900000AL,0x2220009600402060L,0x0000000000200000L});
	public static final BitSet FOLLOW_predicate_in_synpred16_BLESStoAST15775 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_QQ_in_synpred16_BLESStoAST15777 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred17_BLESStoAST15803 = new BitSet(new long[]{0x4000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred17_BLESStoAST15805 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred17_BLESStoAST15807 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred18_BLESStoAST15837 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred18_BLESStoAST15839 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_IMP_in_synpred18_BLESStoAST15841 = new BitSet(new long[]{0x0000000000000002L});
=======
	public static final BitSet FOLLOW_LBRACKET_in_rational_literal2632 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L,0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2636 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2641 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_304_in_rational_literal2643 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L,0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2647 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2652 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_rational_literal2654 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_complex_literal2751 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2755 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2760 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_complex_literal2762 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2766 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2771 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_complex_literal2773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_identifier2927 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_annex_library_assertions3302 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_annex_library_assertions3312 = new BitSet(new long[]{0x0000000000000402L,0x0000000000001000L});
	public static final BitSet FOLLOW_ANNEX_END_in_annex_library_assertions3332 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_thread_behavior4007 = new BitSet(new long[]{0x0001000000000000L,0x0000001800000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_thread_behavior4014 = new BitSet(new long[]{0x0000000000000000L,0x0000001800000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_availability_in_thread_behavior4021 = new BitSet(new long[]{0x0000000000000000L,0x0000000800000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_assert_clause_in_thread_behavior4028 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_invariant_clause_in_thread_behavior4035 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_variables_in_thread_behavior4042 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_LITERAL_states_in_thread_behavior4049 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_state_in_thread_behavior4055 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000008000000000L});
	public static final BitSet FOLLOW_transitions_in_thread_behavior4064 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_thread_behavior4068 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_assert_in_assert_clause4157 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_assert_clause4161 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_invariant_clause4205 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_invariant_clause4209 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variables_in_variables4252 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_variables4258 = new BitSet(new long[]{0x8000000000000002L});
	public static final BitSet FOLLOW_LITERAL_declare_in_quantified_variables4310 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_quantified_variables4316 = new BitSet(new long[]{0x8000000000000002L});
	public static final BitSet FOLLOW_declarators_in_behavior_variable4376 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_variable4380 = new BitSet(new long[]{0x8000000000000000L,0x8008402400000000L,0x0000050010001000L,0x00010004011401C0L});
	public static final BitSet FOLLOW_LITERAL_nonvolatile_in_behavior_variable4389 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_shared_in_behavior_variable4395 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_constant_in_behavior_variable4401 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_spread_in_behavior_variable4407 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_variable4415 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_type_in_behavior_variable4425 = new BitSet(new long[]{0x0000000000020000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_ASSIGN_in_behavior_variable4431 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_behavior_variable4435 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_variable4445 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_variable4454 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_declarators4591 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_declarators4596 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_declarators4601 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_state4685 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_state4690 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L,0x0000000008001000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_initial_in_behavior_state4695 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_complete_in_behavior_state4701 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_state4707 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_state_in_behavior_state4713 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_state4717 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_state4720 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_transitions_in_transitions4780 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_transition_in_transitions4784 = new BitSet(new long[]{0x8000000000000002L});
	public static final BitSet FOLLOW_behavior_transition_label_in_behavior_transition4831 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_transition4833 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4843 = new BitSet(new long[]{0x0000000040000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_COMMA_in_behavior_transition4847 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4852 = new BitSet(new long[]{0x0000000040000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCON_in_behavior_transition4861 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0002590012000010L,0x4440012C000040C0L,0x0000000000500000L});
	public static final BitSet FOLLOW_behavior_condition_in_behavior_transition4865 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCON_in_behavior_transition4868 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4875 = new BitSet(new long[]{0x0004000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_LCURLY_in_behavior_transition4882 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_behavior_transition4886 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_behavior_transition4888 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_EMPTY_CURLY_in_behavior_transition4892 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_transition4900 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_transition4905 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition_label5069 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_behavior_transition_label5073 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_behavior_transition_label5077 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_behavior_transition_label5079 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_condition_in_behavior_condition5117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_execute_condition_in_behavior_condition5121 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_mode_condition_in_behavior_condition5125 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_or_relation_in_execute_condition5143 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_mode_condition5159 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_mode_condition5162 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5180 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5186 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5190 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5200 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5204 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5275 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5277 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5284 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5286 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_event_trigger5302 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_event_trigger5305 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_event_trigger5307 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_subprogram_behavior5369 = new BitSet(new long[]{0x0001000000000000L,0x0080000800008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5376 = new BitSet(new long[]{0x0000000000000000L,0x0080000800008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_assert_clause_in_subprogram_behavior5384 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_LITERAL_pre_in_subprogram_behavior5393 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5397 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L,0x0100000000000000L});
	public static final BitSet FOLLOW_LITERAL_post_in_subprogram_behavior5408 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5412 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_subprogram_behavior5421 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_subprogram_behavior5425 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5585 = new BitSet(new long[]{0x8000000000000000L,0x1081000000008000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_action_in_asserted_action5594 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5600 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_basic_action_in_action5721 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_alternative_in_action5727 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_while_loop_in_action5733 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_loop_in_action5739 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_do_until_loop_in_action5745 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_action5751 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_lattice_quantification_in_action5757 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_if_in_alternative5784 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5792 = new BitSet(new long[]{0x0000000002000000L});
	public static final BitSet FOLLOW_BOX_in_alternative5798 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5802 = new BitSet(new long[]{0x0000000002000000L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_LITERAL_fi_in_alternative5810 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_guarded_action5853 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_guarded_action5857 = new BitSet(new long[]{0x2000000000000000L});
	public static final BitSet FOLLOW_GUARD_in_guarded_action5859 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_guarded_action5862 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_forall_in_universal_lattice_quantification5889 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_lattice_variables_in_universal_lattice_quantification5898 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_universal_lattice_quantification5902 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_range_in_universal_lattice_quantification5906 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5915 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5966 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5971 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5975 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5978 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5982 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_LITERAL_while_in_while_loop6044 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_while_loop6050 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_while_loop6055 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_while_loop6057 = new BitSet(new long[]{0x0000000000000000L,0x0080004000008000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_while_loop6064 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_while_loop6068 = new BitSet(new long[]{0x0000000000000000L,0x0080004000008000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_while_loop6077 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_while_loop6082 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_while_loop6093 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_for_in_for_loop6158 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_for_loop6166 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_for_loop6171 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_for_loop6176 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_for_loop6178 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_for_loop6183 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_for_loop6192 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_for_loop6196 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_LCURLY_in_for_loop6203 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_for_loop6208 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_for_loop6210 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_do_in_do_until_loop6280 = new BitSet(new long[]{0x8000000000000000L,0x1081004000009000L,0x0040000020218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_do_until_loop6288 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_do_until_loop6292 = new BitSet(new long[]{0x8000000000000000L,0x1081004000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_do_until_loop6301 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_do_until_loop6306 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_do_until_loop6317 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000080000000000L});
	public static final BitSet FOLLOW_LITERAL_until_in_do_until_loop6323 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_do_until_loop6325 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_do_until_loop6330 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_do_until_loop6332 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_skip_in_basic_action6402 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_basic_action6408 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_communication_action_in_basic_action6415 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_computation_action_in_basic_action6422 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_setmode_in_basic_action6428 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_basic_action6431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_throw_in_basic_action6437 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_combinable_operation_in_basic_action6443 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simultaneous_assignment_in_basic_action6449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_issue_exception_in_basic_action6455 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_tick_in_assignment6482 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assignment6486 = new BitSet(new long[]{0x8000000000000010L,0x0000400080002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_assignment6490 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_name_tick6534 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_name_tick6538 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_record_term6562 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_record_term6568 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_any_in_expression_or_record_term6574 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_record_term6589 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_record_value_in_record_term6594 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_record_term6597 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_value6615 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_record_value6617 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4000012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_record_value6620 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_value6622 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_simultaneous_assignment6648 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6652 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6658 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6662 = new BitSet(new long[]{0x0000000040020000L});
	public static final BitSet FOLLOW_ASSIGN_in_simultaneous_assignment6672 = new BitSet(new long[]{0x8000000000000010L,0x0000400080002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6676 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6682 = new BitSet(new long[]{0x8000000000000010L,0x0000400080002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6686 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_simultaneous_assignment6691 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exception_in_issue_exception6753 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_issue_exception6756 = new BitSet(new long[]{0x8000000000000010L});
	public static final BitSet FOLLOW_identifier_in_issue_exception6766 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_issue_exception6768 = new BitSet(new long[]{0x0000000000000010L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_issue_exception6776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_issue_exception6778 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_computation_in_computation_action6807 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_computation_action6814 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6817 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_computation_action6821 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6824 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_computation_action6832 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_behavior_time6863 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000208800100000L,0x0000400000002008L});
	public static final BitSet FOLLOW_time_unit_in_behavior_time6868 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_procedure_call_in_communication_action6958 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_output_in_communication_action6976 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_input_in_communication_action6994 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_pause_in_communication_action7012 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_procedure_call7049 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_procedure_call7053 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000000000000010L,0x4040010000004000L,0x0000000001400000L});
	public static final BitSet FOLLOW_formal_actual_list_in_procedure_call7057 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_procedure_call7060 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_output7117 = new BitSet(new long[]{0x0020000000000000L});
	public static final BitSet FOLLOW_EXCLAMATION_in_port_output7119 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_output7123 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_port_output7127 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_port_output7129 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_input7187 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_QUESTION_in_port_input7189 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_input7191 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_name_in_port_input7196 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_port_input7198 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_port_name7241 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7244 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7247 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7250 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7253 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_identifier_in_port_name7267 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_port_name7269 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_port_name7273 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_port_name7275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7294 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_actual_list7300 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000000000000010L,0x4040010000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7304 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_identifier_in_formal_actual7359 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_actual7361 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000000000000010L,0x4040010000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_actual_parameter_in_formal_actual7367 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_actual_parameter7386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_actual_parameter7394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_actual_parameter7402 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_quantified_variables_in_existential_lattice_quantification7428 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_LCURLY_in_existential_lattice_quantification7433 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_existential_lattice_quantification7437 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_existential_lattice_quantification7439 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_timeout_clause_in_existential_lattice_quantification7445 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L});
	public static final BitSet FOLLOW_catch_clause_in_existential_lattice_quantification7450 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_catch_in_catch_clause7474 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_catch_clause_term_in_catch_clause7477 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_timeout_clause7493 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_timeout_clause7496 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_catch_clause_term7517 = new BitSet(new long[]{0x8000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_identifier_in_catch_clause_term7524 = new BitSet(new long[]{0x8000000010000000L});
	public static final BitSet FOLLOW_LITERAL_all_in_catch_clause_term7531 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_catch_clause_term7537 = new BitSet(new long[]{0x8000000000000000L,0x0001000000000000L,0x0040000000000782L,0x00440000100A0000L});
	public static final BitSet FOLLOW_basic_action_in_catch_clause_term7541 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_catch_clause_term7543 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_when_in_when_throw7599 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_when_throw7602 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_when_throw7606 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_when_throw7608 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_LITERAL_throw_in_when_throw7611 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_when_throw7614 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchadd_in_combinable_operation7629 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7632 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7636 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7638 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7649 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7653 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7657 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7662 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchor_in_combinable_operation7671 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7674 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7678 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7680 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7691 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7695 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7699 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7704 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchand_in_combinable_operation7713 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7716 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7720 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7722 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7733 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7737 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7741 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7746 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchxor_in_combinable_operation7755 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7758 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7762 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7764 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7775 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7779 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7783 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_swap_in_combinable_operation7797 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7801 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7805 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7807 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7818 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7822 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7826 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7831 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7854 = new BitSet(new long[]{0x0000000000000202L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7870 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7874 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7878 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7882 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7903 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7907 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7911 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7915 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_partial_name_in_name8010 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_name8016 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_partial_name_in_name8020 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_identifier_in_partial_name8087 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_partial_name8096 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_range_in_partial_name8100 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_partial_name8102 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8151 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_parameter_list8160 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8164 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8226 = new BitSet(new long[]{0x0000300180000002L});
	public static final BitSet FOLLOW_range_symbol_in_expression_or_range8230 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8233 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_variable_name8260 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression8286 = new BitSet(new long[]{0x0040040000000002L,0x0010040020000000L,0x0004001000000000L,0x0420000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_expression8302 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8306 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_expression8322 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8326 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_expression8340 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8344 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_expression8355 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8359 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_expression8370 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8374 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_expression8385 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8389 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_expression8400 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8404 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_expression8417 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8421 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_expression8437 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8441 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_expression8457 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8461 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_expression8475 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8479 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_expression8490 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_subexpression8566 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_LITERAL_not_in_subexpression8572 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_subexpression8584 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression8590 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_conversion_in_subexpression8690 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_function_call_in_subexpression8710 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_type_conversion8740 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_type_conversion8749 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_type_conversion8758 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_type_conversion8767 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_type_conversion8776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_type_conversion8784 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion8793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type_conversion8824 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type_conversion8833 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type_conversion8842 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type_conversion8851 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type_conversion8860 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type_conversion8868 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8877 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8912 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_boolean_expression8928 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8932 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_boolean_expression8948 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8952 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_boolean_expression8968 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8972 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_boolean_expression8986 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8990 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_boolean_expression9001 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression9005 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_boolean_subexpression9077 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_boolean_subexpression9089 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_boolean_subexpression9095 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9180 = new BitSet(new long[]{0x0040040000000002L,0x0000000000000000L,0x0000001000000000L,0x0400000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_numeric_expression9196 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9200 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_numeric_expression9216 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9220 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_numeric_expression9234 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9238 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_numeric_expression9249 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9253 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_numeric_expression9264 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9268 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_numeric_expression9279 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9283 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_numeric_expression9294 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9298 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_numeric_subexpression9370 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_numeric_subexpression9382 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_numeric_subexpression9388 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_expression_in_parenthesized_subexpression9490 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_expression_in_parenthesized_subexpression9520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_subexpression9539 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_parenthesized_subexpression9543 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_subexpression9547 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_expression9584 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9588 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9598 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9602 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9606 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_case_expression9613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_choice9650 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_case_choice9655 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_case_choice9657 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_case_choice9660 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_case_choice9665 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9680 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_expression9682 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9686 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_expression9690 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9695 = new BitSet(new long[]{0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_expression9697 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9702 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9704 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9734 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9738 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_conditional_expression9742 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9747 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_expression9749 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9754 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9756 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_value9796 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_value9848 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000010000L});
	public static final BitSet FOLLOW_QUESTION_in_value9854 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9860 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_value9864 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9870 = new BitSet(new long[]{0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_value9874 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9881 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_value9885 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_value9980 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_value9995 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_LITERAL_mode_in_value9997 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_value9999 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_value10004 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_value10007 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_value10033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_null_in_value10048 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_now_in_value10063 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_tops_in_value10078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_value_constant10106 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_value_constant10110 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_constant_in_value_constant10116 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_value_constant10122 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_value_in_value_constant10128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10159 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_enumeration_value10163 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_constant_in_property10203 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_reference_in_property10207 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_constant10225 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_constant10229 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_constant10235 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10252 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10256 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference10271 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_self_in_property_reference10301 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10305 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10309 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference10315 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_property_reference10349 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10353 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10357 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference10367 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_LBRACKET_in_property_field10407 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_set_in_property_field10410 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_property_field10418 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_property_field10426 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000200000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_set_in_property_field10429 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_name10455 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_name10459 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_name10464 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_numeric_constant10502 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_LIT_in_numeric_constant10509 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rational_literal_in_numeric_constant10518 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_complex_literal_in_numeric_constant10522 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_numeric_constant10528 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_relation10560 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10590 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_expression_or_relation10599 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10603 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_relation10631 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10680 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_boolean_expression_or_relation10690 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10694 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_expression_in_boolean_expression_or_relation10721 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_function_call10770 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_function_call10772 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_function_call10782 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_function_call10786 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_function_parameters_in_function_call10790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_function_call10793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10852 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10856 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10862 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10872 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10877 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_ID_in_formal_expression_pair10899 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_expression_pair10901 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_formal_expression_pair10906 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_name_in_type10931 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_type_in_type10950 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_type_in_type10969 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_type_in_type10988 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_type_in_type11007 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_variant_type_in_type11026 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_type11048 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_string_in_type11063 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_enumeration_in_enumeration_type11092 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_enumeration_type11095 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11100 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_enumeration_type11106 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11109 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_enumeration_type11113 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_number_type11168 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_number_type11177 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_number_type11186 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_number_type11195 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_number_type11204 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_number_type11212 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_number_range_in_number_type11220 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_units_in_number_type11227 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000208800100000L,0x0000400000002008L});
	public static final BitSet FOLLOW_units_designator_in_number_type11231 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_number_range11296 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4400000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_constant_number_range_in_number_range11299 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_number_range11301 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11319 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4000000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11324 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range11328 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4400000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11332 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4000000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11337 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_units_designator11451 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_unit_in_units_designator11457 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11497 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11501 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11506 = new BitSet(new long[]{0x0000400000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11518 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11523 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11581 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11589 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11594 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_type_name11670 = new BitSet(new long[]{0x0000400000000002L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_type_name11675 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_type_name11680 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_array_in_array_type11707 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_array_type11710 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_array_range_list_in_array_type11713 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_array_type11715 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_array_type11718 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_type_in_array_type11720 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_record_in_record_type11747 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_record_type11750 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_record_field_in_record_type11753 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_record_type11756 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_field11785 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_record_field11787 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_type_in_record_field11790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_field11792 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11822 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11826 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11829 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11833 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11836 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11873 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11879 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11885 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_natural_range11895 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11902 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11908 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variant_in_variant_type11951 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_variant_type11959 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_record_field_in_variant_type11962 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_variant_type11965 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_subclause11994 = new BitSet(new long[]{0x8000000000000010L,0x0100400012003008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_subclause12005 = new BitSet(new long[]{0x0000000000000402L,0x0000000000001000L});
	public static final BitSet FOLLOW_predicate_in_assertion_annex_subclause12028 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_subclause12049 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_library12077 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_library12088 = new BitSet(new long[]{0x0000000000000402L,0x0000000000001000L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_library12111 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LASS_in_assertion12141 = new BitSet(new long[]{0x8000000000020010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400020L});
	public static final BitSet FOLLOW_assertion_body_in_assertion12146 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_RASS_in_assertion12148 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12203 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12207 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12211 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12215 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12271 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12298 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12302 = new BitSet(new long[]{0x8000000010000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12306 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12309 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12313 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12405 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12409 = new BitSet(new long[]{0x8000000000020000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12413 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12416 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12420 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12511 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12515 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12551 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_formal_assertion_parameter12602 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_TILDE_in_formal_assertion_parameter12604 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_type_name_in_formal_assertion_parameter12607 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12623 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12627 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12630 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12639 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12641 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_assertion_function_value12675 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_value12694 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_function12720 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12727 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12733 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12737 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12744 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12748 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_function12758 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_condition_value_pair12799 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_condition_value_pair12801 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_condition_value_pair12804 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12822 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12825 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_assertion_enumeration12828 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12831 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12846 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_assertion_enumeration12849 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_enumeration_pair12868 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_enumeration_pair12871 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_enumeration_pair12874 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_all_in_universal_quantification12893 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_universal_quantification12896 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_universal_quantification12898 = new BitSet(new long[]{0x0000000000000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_LITERAL_are_in_universal_quantification12902 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_universal_quantification12905 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exists_in_existential_quantification12931 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_existential_quantification12934 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_existential_quantification12936 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_existential_quantification12940 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_existential_quantification12943 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_logic_variables12971 = new BitSet(new long[]{0x0000000050000000L});
	public static final BitSet FOLLOW_COMMA_in_logic_variables12974 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_logic_variables12978 = new BitSet(new long[]{0x0000000050000000L});
	public static final BitSet FOLLOW_COLON_in_logic_variables12984 = new BitSet(new long[]{0x8000000000000000L,0x0000402000000000L,0x0000010010000000L,0x00000004000000C0L});
	public static final BitSet FOLLOW_assertion_type_in_logic_variables12988 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_logic_variable_domain13040 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x4000D90012000014L,0x4440012C088040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13069 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_logic_variable_domain13073 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13077 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_logic_variable_domain13112 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_quantification_in_predicate13172 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_quantification_in_predicate13180 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13189 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000001L,0x0004000001400000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13207 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13210 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13214 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13217 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13237 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13240 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13244 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13247 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13270 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13273 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13277 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13280 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_implies_in_predicate13302 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13305 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_iff_in_predicate13324 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13327 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IMP_in_predicate13345 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13348 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_subpredicate13390 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000510012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13420 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_subpredicate13424 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13428 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13503 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_subpredicate13507 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_range_in_subpredicate13511 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_subpredicate13579 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000040L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_subpredicate13583 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13589 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_subpredicate13631 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_subpredicate13669 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_subpredicate13705 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_invocation_in_subpredicate13750 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_predicate_in_subpredicate13784 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_def_in_subpredicate13821 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_assertion_parameter_in_subpredicate13825 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_timed_predicate13874 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate13878 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate13882 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_timed_predicate13888 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_predicate13896 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_predicate13899 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_predicate13908 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_timed_predicate13911 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_predicate13949 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_parenthesized_predicate13952 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_predicate13954 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_floatingAtom13974 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_period_shift14002 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14020 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14024 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift14050 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14054 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L,0x0000004001000010L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14065 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14069 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14073 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_period_shift14087 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14091 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14095 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14109 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14113 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000010L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14116 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14120 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000010L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14126 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14142 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14146 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004001000000L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14149 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14153 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14159 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14175 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14343 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14347 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14349 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14384 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14388 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_invocation14392 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14437 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14441 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14445 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_predicate_invocation14449 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14453 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14459 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter14516 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_actual_assertion_parameter14520 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_actual_assertion_parameter14524 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter14553 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COLON_TILDE_in_actual_assertion_parameter14557 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_actual_assertion_parameter14561 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_expression_in_range14612 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_range14614 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_expression_in_range14617 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14643 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_assertion_range14645 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14648 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_sum_in_assertion_expression14683 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14685 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14689 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14694 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14696 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_product_in_assertion_expression14728 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14730 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14734 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14739 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14741 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_numberof_in_assertion_expression14771 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14773 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14777 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_assertion_expression14782 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_assertion_expression14784 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14818 = new BitSet(new long[]{0x0040040000000002L,0x0000000000000000L,0x0000001000000000L,0x0400000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_assertion_expression14832 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14834 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_assertion_expression14867 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14869 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_assertion_expression14903 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14905 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_assertion_expression14936 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14938 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_assertion_expression14970 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14972 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_assertion_expression15004 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression15006 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_assertion_expression15031 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression15033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_assertion_subexpression15093 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_LITERAL_abs_in_assertion_subexpression15099 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression15119 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_type_conversion_in_assertion_subexpression15179 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_vpa_in_timed_expression15212 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_timed_expression15217 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_expression15225 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_expression15228 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_expression15237 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_timed_expression15240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_vpa15268 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_vpa15278 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_vpa15288 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15305 = new BitSet(new long[]{0x0040040000000002L,0x0000000000000000L,0x0000001000000000L,0x0400000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15316 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15321 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15325 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15329 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15344 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15349 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15353 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15357 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_time_expression15372 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15377 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_time_expression15390 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15395 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_time_expression15408 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_time_expression15426 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_time_expression15444 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_time_subexpression15476 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_time_subexpression15486 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_time_subexpression15494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_time_subexpression15503 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_expression_in_time_subexpression15507 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_time_subexpression15511 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15631 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15635 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000001400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_invocation15639 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15642 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15689 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15693 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15702 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_assertion_function_invocation15706 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15710 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15715 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15802 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15832 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_assertion_expression15887 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_parenthesized_assertion_expression15891 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_assertion_expression15895 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15927 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_assertion_expression15929 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15933 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_assertion_expression15937 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15942 = new BitSet(new long[]{0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_assertion_expression15944 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15949 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression15951 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15979 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15983 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_conditional_assertion_expression15987 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15992 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_assertion_expression15994 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15999 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression16001 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_record_term16039 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_assertion_record_value_in_assertion_record_term16042 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_record_term16045 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_record_value16060 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_assertion_record_value16062 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4000012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_assertion_record_value16065 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_assertion_record_value16067 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_parameter16083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_assertion_type16101 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type16105 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type16109 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type16113 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type16117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type16121 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type16126 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_assertion_type16133 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_availability_in_availability16159 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability16163 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16184 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_availability_expression16198 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16202 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_availability_expression16221 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16225 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_availability_expression16244 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16248 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_not_in_availability_subexpression16340 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_identifier_in_availability_subexpression16355 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_availability_subexpression16365 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_expression_in_availability_subexpression16369 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_availability_subexpression16371 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_dispatch_condition16459 = new BitSet(new long[]{0x0000000000000000L,0x0800000000000000L});
	public static final BitSet FOLLOW_LITERAL_dispatch_in_dispatch_condition16462 = new BitSet(new long[]{0x8000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_expression_in_dispatch_condition16466 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16494 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_dispatch_expression16500 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16504 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16553 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_dispatch_conjunction16559 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16563 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16620 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_dispatch_trigger16623 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16626 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_dispatch_trigger16629 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_dispatch_trigger16632 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16641 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16652 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_dispatch_trigger16662 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_in_modes16713 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_LITERAL_modes_in_in_modes16716 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_in_modes16720 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16726 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_in_modes16730 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16734 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_in_modes16741 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred1_BLESStoAST9472 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred1_BLESStoAST9474 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred1_BLESStoAST9478 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_synpred1_BLESStoAST9480 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_synpred1_BLESStoAST9482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred2_BLESStoAST9510 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_synpred2_BLESStoAST9512 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_synpred3_BLESStoAST9817 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000010000L});
	public static final BitSet FOLLOW_QUESTION_in_synpred3_BLESStoAST9821 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9825 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_synpred3_BLESStoAST9827 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9831 = new BitSet(new long[]{0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_synpred3_BLESStoAST9833 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred3_BLESStoAST9836 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_synpred3_BLESStoAST9838 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred4_BLESStoAST10548 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred4_BLESStoAST10550 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred4_BLESStoAST10552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred5_BLESStoAST10580 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred5_BLESStoAST10582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred6_BLESStoAST10670 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred6_BLESStoAST10672 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred7_BLESStoAST12665 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_synpred7_BLESStoAST12667 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_synpred8_BLESStoAST13056 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_synpred8_BLESStoAST13058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred9_BLESStoAST13406 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred9_BLESStoAST13408 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13487 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_synpred10_BLESStoAST13489 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_synpred11_BLESStoAST13568 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000040L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_synpred11_BLESStoAST13570 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_synpred12_BLESStoAST13740 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_synpred12_BLESStoAST13742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred16_BLESStoAST15784 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred16_BLESStoAST15786 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred16_BLESStoAST15790 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_synpred16_BLESStoAST15792 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_synpred16_BLESStoAST15794 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred17_BLESStoAST15820 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred17_BLESStoAST15822 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred17_BLESStoAST15824 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred18_BLESStoAST15854 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred18_BLESStoAST15856 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_synpred18_BLESStoAST15858 = new BitSet(new long[]{0x0000000000000002L});
>>>>>>> origin/continuum
}
