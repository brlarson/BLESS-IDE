// $ANTLR 3.5.2 /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g 2023-04-01 05:46:57

//copyright 2020 Multitude Corporation
package com.multitude.bless.antlr3generated;
import java.util.HashMap;
import java.util.Vector;
//import com.multitude.bless.BAST;
import org.antlr.runtime.Parser;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.UnwantedTokenException;
import com.multitude.bless.exceptions.*;
import com.multitude.bless.tree.BAST;
import com.multitude.bless.ui.preferences.ConfigurationPreferencePage;
import com.multitude.bless.app.Global;
import com.multitude.bless.record.ParseRecord;
import com.multitude.bless.record.PackageRecord;
import com.multitude.bless.record.ThreadRecord;
import com.multitude.bless.record.DataRecord;
import com.multitude.bless.record.SubprogramRecord;
import com.multitude.bless.record.PropertySetRecord;
//import com.multitude.bless.symbol.Model;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings("all")
public class BLESStoASTParser extends Parser {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AADL_STRING_LITERAL", "AADL_STRING_PART", 
		"ACTION", "AL", "AM", "AMPERSAND", "ANNEX_END", "ANNEX_START", "ARROW", 
		"ASSERTION", "ASSERTION_ANNEX", "ASSERTION_ENUMERATION", "ASSERTION_FUNCTION", 
		"ASSIGN", "AT_SIGN", "BASE", "BASED_INTEGER", "BEHAVIOR_GUARD", "BEHAVIOR_TIME", 
		"BI", "BOUND", "BOX", "CARET", "CASE_EXPRESSION", "COLON", "COLON_TILDE", 
		"COMMA", "COMMACOMMA", "COMMADOT", "COMPLEX", "COMPONENT", "CONDITION", 
		"CONDITIONAL", "CONDITIONAL_FUNCTION", "CONNECTION", "COUNTING_TRIGGER", 
		"DESTINATION", "DIGIT", "DIVIDE", "DOLLAR", "DOTCOMMA", "DOTDOT", "DOUBLE_COLON", 
		"DOUBLE_QUOTE", "DO_NOT_PROVE", "DUMMY", "EMPTY_CURLY", "END_ASSERTION_PROPERTY", 
		"EQ", "EXCLAMATION", "EXP", "EXPONENT", "EXTENDED_DIGIT", "FLOATING", 
		"FUNCTION", "FUNCTION_CALL", "GT", "GUARD", "HEX_DIGIT", "ID", "IMP", 
		"INMODE", "INOUT", "INTEGER_LIT", "INT_EXPONENT", "INVARIANT", "INVOKE", 
		"INVOKE_FUNCTION", "IP_NAME", "IP_PE", "IP_PRED", "LABEL", "LASS", "LBRACKET", 
		"LCON", "LCURLY", "LITERAL_Assertion", "LITERAL_Invariant", "LITERAL_Postcondition", 
		"LITERAL_Precondition", "LITERAL_Typed", "LITERAL_aadlboolean", "LITERAL_aadlinteger", 
		"LITERAL_aadlreal", "LITERAL_aadlstring", "LITERAL_abs", "LITERAL_abstract", 
		"LITERAL_access", "LITERAL_all", "LITERAL_and", "LITERAL_annex", "LITERAL_any", 
		"LITERAL_applies", "LITERAL_are", "LITERAL_array", "LITERAL_assert", "LITERAL_availability", 
		"LITERAL_boolean", "LITERAL_bound", "LITERAL_bus", "LITERAL_call", "LITERAL_calls", 
		"LITERAL_cand", "LITERAL_catch", "LITERAL_classifier", "LITERAL_complete", 
		"LITERAL_complex", "LITERAL_component", "LITERAL_computation", "LITERAL_connection", 
		"LITERAL_connections", "LITERAL_constant", "LITERAL_cor", "LITERAL_count", 
		"LITERAL_data", "LITERAL_declare", "LITERAL_def", "LITERAL_delay", "LITERAL_device", 
		"LITERAL_dispatch", "LITERAL_do", "LITERAL_else", "LITERAL_end", "LITERAL_enumeration", 
		"LITERAL_event", "LITERAL_exception", "LITERAL_exists", "LITERAL_extends", 
		"LITERAL_false", "LITERAL_feature", "LITERAL_features", "LITERAL_fetchadd", 
		"LITERAL_fetchand", "LITERAL_fetchor", "LITERAL_fetchxor", "LITERAL_fi", 
		"LITERAL_final", "LITERAL_flow", "LITERAL_flows", "LITERAL_for", "LITERAL_forall", 
		"LITERAL_fresh", "LITERAL_function", "LITERAL_group", "LITERAL_hr", "LITERAL_if", 
		"LITERAL_iff", "LITERAL_implementation", "LITERAL_implies", "LITERAL_in", 
		"LITERAL_inherit", "LITERAL_initial", "LITERAL_integer", "LITERAL_invariant", 
		"LITERAL_inverse", "LITERAL_is", "LITERAL_list", "LITERAL_lower_bound", 
		"LITERAL_memory", "LITERAL_min", "LITERAL_mod", "LITERAL_mode", "LITERAL_modes", 
		"LITERAL_ms", "LITERAL_natural", "LITERAL_none", "LITERAL_nonvolatile", 
		"LITERAL_not", "LITERAL_now", "LITERAL_ns", "LITERAL_null", "LITERAL_numberof", 
		"LITERAL_of", "LITERAL_on", "LITERAL_or", "LITERAL_out", "LITERAL_package", 
		"LITERAL_parameter", "LITERAL_pause", "LITERAL_port", "LITERAL_post", 
		"LITERAL_pre", "LITERAL_private", "LITERAL_procedure", "LITERAL_process", 
		"LITERAL_processor", "LITERAL_product", "LITERAL_properties", "LITERAL_property", 
		"LITERAL_prototypes", "LITERAL_provides", "LITERAL_ps", "LITERAL_public", 
		"LITERAL_range", "LITERAL_rational", "LITERAL_real", "LITERAL_record", 
		"LITERAL_reference", "LITERAL_rem", "LITERAL_renames", "LITERAL_requires", 
		"LITERAL_sec", "LITERAL_self", "LITERAL_sequence", "LITERAL_set", "LITERAL_setmode", 
		"LITERAL_shared", "LITERAL_skip", "LITERAL_spread", "LITERAL_state", "LITERAL_states", 
		"LITERAL_stop", "LITERAL_string", "LITERAL_subcomponents", "LITERAL_subprogram", 
		"LITERAL_sum", "LITERAL_swap", "LITERAL_system", "LITERAL_that", "LITERAL_then", 
		"LITERAL_thread", "LITERAL_throw", "LITERAL_time", "LITERAL_timeout", 
		"LITERAL_to", "LITERAL_tops", "LITERAL_transition", "LITERAL_transitions", 
		"LITERAL_true", "LITERAL_type", "LITERAL_units", "LITERAL_until", "LITERAL_updated", 
		"LITERAL_upper_bound", "LITERAL_us", "LITERAL_variables", "LITERAL_variant", 
		"LITERAL_virtual", "LITERAL_when", "LITERAL_while", "LITERAL_with", "LITERAL_xor", 
		"LPAREN", "LT", "LTE_STRING", "LT_STRING", "MINUS", "MT_STRING", "NEQ", 
		"OBLIGATION", "OCTOTHORPE", "ON", "P", "PARAMETER", "PARAMETERS", "PERIOD", 
		"PLUS", "PLUS_ARROW", "PLUS_EQUALS", "PORT", "PORT_INPUT", "PORT_OUTPUT", 
		"PREDICATE_RELATION", "PROCEDURE", "PROCEDURE_CALL", "PROPERTY_LIST", 
		"Q", "QQ", "QUESTION", "RASS", "RATIONAL", "RBRACKET", "RCON", "RCURLY", 
		"REAL_LIT", "RECORD_TERM", "RPAREN", "S", "SEMICOLON", "SLCOMMENT", "SOURCE", 
		"START", "START_ASSERTION_PROPERTY", "STOP", "SUBCOMPONENT", "SUBPROGRAM_ANNEX", 
		"THREAD_ANNEX", "THREAD_GROUP", "TICK", "TILDE", "TIMES", "TOP", "TRANSITION", 
		"TYPE", "TYPE_OPERATOR", "TYPE_OPERATOR_INVOCATION", "UNARY_MINUS", "VALUE", 
		"WP", "WS", "'|'"
	};
	public static final int EOF=-1;
	public static final int T__304=304;
	public static final int AADL_STRING_LITERAL=4;
	public static final int AADL_STRING_PART=5;
	public static final int ACTION=6;
	public static final int AL=7;
	public static final int AM=8;
	public static final int AMPERSAND=9;
	public static final int ANNEX_END=10;
	public static final int ANNEX_START=11;
	public static final int ARROW=12;
	public static final int ASSERTION=13;
	public static final int ASSERTION_ANNEX=14;
	public static final int ASSERTION_ENUMERATION=15;
	public static final int ASSERTION_FUNCTION=16;
	public static final int ASSIGN=17;
	public static final int AT_SIGN=18;
	public static final int BASE=19;
	public static final int BASED_INTEGER=20;
	public static final int BEHAVIOR_GUARD=21;
	public static final int BEHAVIOR_TIME=22;
	public static final int BI=23;
	public static final int BOUND=24;
	public static final int BOX=25;
	public static final int CARET=26;
	public static final int CASE_EXPRESSION=27;
	public static final int COLON=28;
	public static final int COLON_TILDE=29;
	public static final int COMMA=30;
	public static final int COMMACOMMA=31;
	public static final int COMMADOT=32;
	public static final int COMPLEX=33;
	public static final int COMPONENT=34;
	public static final int CONDITION=35;
	public static final int CONDITIONAL=36;
	public static final int CONDITIONAL_FUNCTION=37;
	public static final int CONNECTION=38;
	public static final int COUNTING_TRIGGER=39;
	public static final int DESTINATION=40;
	public static final int DIGIT=41;
	public static final int DIVIDE=42;
	public static final int DOLLAR=43;
	public static final int DOTCOMMA=44;
	public static final int DOTDOT=45;
	public static final int DOUBLE_COLON=46;
	public static final int DOUBLE_QUOTE=47;
	public static final int DO_NOT_PROVE=48;
	public static final int DUMMY=49;
	public static final int EMPTY_CURLY=50;
	public static final int END_ASSERTION_PROPERTY=51;
	public static final int EQ=52;
	public static final int EXCLAMATION=53;
	public static final int EXP=54;
	public static final int EXPONENT=55;
	public static final int EXTENDED_DIGIT=56;
	public static final int FLOATING=57;
	public static final int FUNCTION=58;
	public static final int FUNCTION_CALL=59;
	public static final int GT=60;
	public static final int GUARD=61;
	public static final int HEX_DIGIT=62;
	public static final int ID=63;
	public static final int IMP=64;
	public static final int INMODE=65;
	public static final int INOUT=66;
	public static final int INTEGER_LIT=67;
	public static final int INT_EXPONENT=68;
	public static final int INVARIANT=69;
	public static final int INVOKE=70;
	public static final int INVOKE_FUNCTION=71;
	public static final int IP_NAME=72;
	public static final int IP_PE=73;
	public static final int IP_PRED=74;
	public static final int LABEL=75;
	public static final int LASS=76;
	public static final int LBRACKET=77;
	public static final int LCON=78;
	public static final int LCURLY=79;
	public static final int LITERAL_Assertion=80;
	public static final int LITERAL_Invariant=81;
	public static final int LITERAL_Postcondition=82;
	public static final int LITERAL_Precondition=83;
	public static final int LITERAL_Typed=84;
	public static final int LITERAL_aadlboolean=85;
	public static final int LITERAL_aadlinteger=86;
	public static final int LITERAL_aadlreal=87;
	public static final int LITERAL_aadlstring=88;
	public static final int LITERAL_abs=89;
	public static final int LITERAL_abstract=90;
	public static final int LITERAL_access=91;
	public static final int LITERAL_all=92;
	public static final int LITERAL_and=93;
	public static final int LITERAL_annex=94;
	public static final int LITERAL_any=95;
	public static final int LITERAL_applies=96;
	public static final int LITERAL_are=97;
	public static final int LITERAL_array=98;
	public static final int LITERAL_assert=99;
	public static final int LITERAL_availability=100;
	public static final int LITERAL_boolean=101;
	public static final int LITERAL_bound=102;
	public static final int LITERAL_bus=103;
	public static final int LITERAL_call=104;
	public static final int LITERAL_calls=105;
	public static final int LITERAL_cand=106;
	public static final int LITERAL_catch=107;
	public static final int LITERAL_classifier=108;
	public static final int LITERAL_complete=109;
	public static final int LITERAL_complex=110;
	public static final int LITERAL_component=111;
	public static final int LITERAL_computation=112;
	public static final int LITERAL_connection=113;
	public static final int LITERAL_connections=114;
	public static final int LITERAL_constant=115;
	public static final int LITERAL_cor=116;
	public static final int LITERAL_count=117;
	public static final int LITERAL_data=118;
	public static final int LITERAL_declare=119;
	public static final int LITERAL_def=120;
	public static final int LITERAL_delay=121;
	public static final int LITERAL_device=122;
	public static final int LITERAL_dispatch=123;
	public static final int LITERAL_do=124;
	public static final int LITERAL_else=125;
	public static final int LITERAL_end=126;
	public static final int LITERAL_enumeration=127;
	public static final int LITERAL_event=128;
	public static final int LITERAL_exception=129;
	public static final int LITERAL_exists=130;
	public static final int LITERAL_extends=131;
	public static final int LITERAL_false=132;
	public static final int LITERAL_feature=133;
	public static final int LITERAL_features=134;
	public static final int LITERAL_fetchadd=135;
	public static final int LITERAL_fetchand=136;
	public static final int LITERAL_fetchor=137;
	public static final int LITERAL_fetchxor=138;
	public static final int LITERAL_fi=139;
	public static final int LITERAL_final=140;
	public static final int LITERAL_flow=141;
	public static final int LITERAL_flows=142;
	public static final int LITERAL_for=143;
	public static final int LITERAL_forall=144;
	public static final int LITERAL_fresh=145;
	public static final int LITERAL_function=146;
	public static final int LITERAL_group=147;
	public static final int LITERAL_hr=148;
	public static final int LITERAL_if=149;
	public static final int LITERAL_iff=150;
	public static final int LITERAL_implementation=151;
	public static final int LITERAL_implies=152;
	public static final int LITERAL_in=153;
	public static final int LITERAL_inherit=154;
	public static final int LITERAL_initial=155;
	public static final int LITERAL_integer=156;
	public static final int LITERAL_invariant=157;
	public static final int LITERAL_inverse=158;
	public static final int LITERAL_is=159;
	public static final int LITERAL_list=160;
	public static final int LITERAL_lower_bound=161;
	public static final int LITERAL_memory=162;
	public static final int LITERAL_min=163;
	public static final int LITERAL_mod=164;
	public static final int LITERAL_mode=165;
	public static final int LITERAL_modes=166;
	public static final int LITERAL_ms=167;
	public static final int LITERAL_natural=168;
	public static final int LITERAL_none=169;
	public static final int LITERAL_nonvolatile=170;
	public static final int LITERAL_not=171;
	public static final int LITERAL_now=172;
	public static final int LITERAL_ns=173;
	public static final int LITERAL_null=174;
	public static final int LITERAL_numberof=175;
	public static final int LITERAL_of=176;
	public static final int LITERAL_on=177;
	public static final int LITERAL_or=178;
	public static final int LITERAL_out=179;
	public static final int LITERAL_package=180;
	public static final int LITERAL_parameter=181;
	public static final int LITERAL_pause=182;
	public static final int LITERAL_port=183;
	public static final int LITERAL_post=184;
	public static final int LITERAL_pre=185;
	public static final int LITERAL_private=186;
	public static final int LITERAL_procedure=187;
	public static final int LITERAL_process=188;
	public static final int LITERAL_processor=189;
	public static final int LITERAL_product=190;
	public static final int LITERAL_properties=191;
	public static final int LITERAL_property=192;
	public static final int LITERAL_prototypes=193;
	public static final int LITERAL_provides=194;
	public static final int LITERAL_ps=195;
	public static final int LITERAL_public=196;
	public static final int LITERAL_range=197;
	public static final int LITERAL_rational=198;
	public static final int LITERAL_real=199;
	public static final int LITERAL_record=200;
	public static final int LITERAL_reference=201;
	public static final int LITERAL_rem=202;
	public static final int LITERAL_renames=203;
	public static final int LITERAL_requires=204;
	public static final int LITERAL_sec=205;
	public static final int LITERAL_self=206;
	public static final int LITERAL_sequence=207;
	public static final int LITERAL_set=208;
	public static final int LITERAL_setmode=209;
	public static final int LITERAL_shared=210;
	public static final int LITERAL_skip=211;
	public static final int LITERAL_spread=212;
	public static final int LITERAL_state=213;
	public static final int LITERAL_states=214;
	public static final int LITERAL_stop=215;
	public static final int LITERAL_string=216;
	public static final int LITERAL_subcomponents=217;
	public static final int LITERAL_subprogram=218;
	public static final int LITERAL_sum=219;
	public static final int LITERAL_swap=220;
	public static final int LITERAL_system=221;
	public static final int LITERAL_that=222;
	public static final int LITERAL_then=223;
	public static final int LITERAL_thread=224;
	public static final int LITERAL_throw=225;
	public static final int LITERAL_time=226;
	public static final int LITERAL_timeout=227;
	public static final int LITERAL_to=228;
	public static final int LITERAL_tops=229;
	public static final int LITERAL_transition=230;
	public static final int LITERAL_transitions=231;
	public static final int LITERAL_true=232;
	public static final int LITERAL_type=233;
	public static final int LITERAL_units=234;
	public static final int LITERAL_until=235;
	public static final int LITERAL_updated=236;
	public static final int LITERAL_upper_bound=237;
	public static final int LITERAL_us=238;
	public static final int LITERAL_variables=239;
	public static final int LITERAL_variant=240;
	public static final int LITERAL_virtual=241;
	public static final int LITERAL_when=242;
	public static final int LITERAL_while=243;
	public static final int LITERAL_with=244;
	public static final int LITERAL_xor=245;
	public static final int LPAREN=246;
	public static final int LT=247;
	public static final int LTE_STRING=248;
	public static final int LT_STRING=249;
	public static final int MINUS=250;
	public static final int MT_STRING=251;
	public static final int NEQ=252;
	public static final int OBLIGATION=253;
	public static final int OCTOTHORPE=254;
	public static final int ON=255;
	public static final int P=256;
	public static final int PARAMETER=257;
	public static final int PARAMETERS=258;
	public static final int PERIOD=259;
	public static final int PLUS=260;
	public static final int PLUS_ARROW=261;
	public static final int PLUS_EQUALS=262;
	public static final int PORT=263;
	public static final int PORT_INPUT=264;
	public static final int PORT_OUTPUT=265;
	public static final int PREDICATE_RELATION=266;
	public static final int PROCEDURE=267;
	public static final int PROCEDURE_CALL=268;
	public static final int PROPERTY_LIST=269;
	public static final int Q=270;
	public static final int QQ=271;
	public static final int QUESTION=272;
	public static final int RASS=273;
	public static final int RATIONAL=274;
	public static final int RBRACKET=275;
	public static final int RCON=276;
	public static final int RCURLY=277;
	public static final int REAL_LIT=278;
	public static final int RECORD_TERM=279;
	public static final int RPAREN=280;
	public static final int S=281;
	public static final int SEMICOLON=282;
	public static final int SLCOMMENT=283;
	public static final int SOURCE=284;
	public static final int START=285;
	public static final int START_ASSERTION_PROPERTY=286;
	public static final int STOP=287;
	public static final int SUBCOMPONENT=288;
	public static final int SUBPROGRAM_ANNEX=289;
	public static final int THREAD_ANNEX=290;
	public static final int THREAD_GROUP=291;
	public static final int TICK=292;
	public static final int TILDE=293;
	public static final int TIMES=294;
	public static final int TOP=295;
	public static final int TRANSITION=296;
	public static final int TYPE=297;
	public static final int TYPE_OPERATOR=298;
	public static final int TYPE_OPERATOR_INVOCATION=299;
	public static final int UNARY_MINUS=300;
	public static final int VALUE=301;
	public static final int WP=302;
	public static final int WS=303;

	// delegates
	public Parser[] getDelegates() {
		return new Parser[] {};
	}

	// delegators


	public BLESStoASTParser(TokenStream input) {
		this(input, new RecognizerSharedState());
	}
	public BLESStoASTParser(TokenStream input, RecognizerSharedState state) {
		super(input, state);
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return BLESStoASTParser.tokenNames; }
	@Override public String getGrammarFileName() { return "/Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g"; }


	/** Map variable name to Integer object holding value */
	HashMap memory = new HashMap();
	Token tok = null;
	public boolean recognitionErrorOccurred = false;    //did a parse error occur?
	public static int countRecognitionErrors = 1; //accumulates count of recognition errors
	public static Vector<String> error_messages = new Vector<String>();

	//MUST SET currentPackageRecord BEFORE USE
	public PackageRecord currentPackageRecord = null;  //created by package_spec
	public PropertySetRecord currentPropertySetRecord = null;  //created by property_set
	public ParseRecord currentParseRecord = null;  //either currentPackageRecord or currentPropertySetRecord
	//public boolean putAssertionsIntoMap = true;  //put Assertions with labels into Proof.label_assertion_map?
	boolean saidTypeError = false;  //has a type exception already happened
	public String fileName = null;

	int startingLine = 0; //starting line of sublanguage in AADL file
	static int staticLine=0;  //used by BAST constructor

	  public void 
	setStartingLine(int line) //sets starting line
	  {
	  startingLine = line;
	  staticLine = line;
	  }

	  public int
	getStartingLine()
	  {
	  return startingLine;
	  }

	  public static int
	getStaticStartingLine()
	  {
	  return staticLine;
	  }
	  
	 
	public void reportError(RecognitionException ex, BAST start)
	  {
	  if (start!=null)
	    if (start.getParent()!=null)
	      ((BAST)start.getParent()).showParseTree("parent of "+start.getText());
	    else
	      start.showParseTree(start.getText());
	  reportError(ex);     
	  }  //end of reportError(RecognitionException ex, BAST start)

	public void reportError(RecognitionException ex)
	  {
	  if ((currentPackageRecord != null) && (currentPackageRecord.packageID != null))
	    Dump.it("In Package "+currentPackageRecord.packageID);
	  if ((currentPackageRecord != null) && (currentPackageRecord.file != null))
	    Dump.it("In File "+currentPackageRecord.file.getName());
	  else if (fileName != null)
	    Dump.it("In File "+fileName);
	  Dump.it("\nBLESS Syntax Error #"+
	    Integer.toString(countRecognitionErrors)+"\n");
	  error_messages.add(getErrorHeader(ex));  
	  Dump.it("\nSome "+Global.dope+", made another "+
	     (Global.kindMessages?"unfortunate":"stupid")+" grammatical mistake. \n"+
	      "We know this because the token we\'re trying to parse has token-type \""+
	      ((ex.getUnexpectedType()>0)&&(ex.getUnexpectedType()<tokenNames.length)?tokenNames[ex.getUnexpectedType()]:Integer.toString(ex.getUnexpectedType()))+
	      "\" "+
	      (ex.token!=null?"having text \""+ex.token.getText()+"\"":"")+"\n"+
	      "  which is not among the permitted token types here on line "+
	      (ex.token!=null?ex.token.getLine():"null ex.token"));
	//  Dump.it("This "+Global.dope+" may not be you, but you must fix it.");
	  if ((ex.node!=null)&&(ex.node instanceof BAST))
	    ((BAST)ex.node).showParseTree(((BAST)ex.node).getText());
	  int x=5;
	  if (ex instanceof UnwantedTokenException)
	    {
	    UnwantedTokenException ute = (UnwantedTokenException)ex;
	    Dump.it("Expecting:  "+tokenNames[ute.expecting]);
	    Dump.it("\nHint: Don\'t include units for numeric literals in BLESS::Assertion property strings.\n");
	    }
	  if (countRecognitionErrors<Global.YouIdiotReportLimit)
	    {
	    recognitionErrorOccurred = true;
	    ex.line = ex.line+startingLine;
	    Dump.it("offending text = \""+input.toString()+"\"");
	    Dump.it(getErrorHeader(ex));
	//    super.reportError(ex);
	  ex.printStackTrace();
	//    StackTraceElement[] ste = ex.getStackTrace(); 
	//    for (int k=0;k<ste.length;k++)
	//      Dump.it("   "+ste[k].toString());     
	//    HelpfulHints.giveHint();
	    }
	  else
	    {
	    Dump.it(countRecognitionErrors+" recognition errors occurred; divide by zero to stop runaway parser");
	    x=(x+x)/(x-5);
	    }
	  countRecognitionErrors++;
	//  // Global.stopProof = true; 
	  } //end of reportError

	public int errorCount = 0;
	public final int errorLimit=3;

	//REPLACE THIS WITH LOOK-UP OF OSATE RENAMES CLAUSE
	public String timeAlias = "T";

	//public void emitErrorMessage(String msg) 
	//  {
	//  System.err.println(msg);
	//  Dump.it(msg);
	//  }

	public void recover(IntStream input, RecognitionException re) {}
	 

	//tell user of BNF when they make a mistake 
	public boolean toldBNF=false;         
	public void tellBNF(String s, RecognitionException re)
	  {
	  if (!toldBNF)
	    {
	    Dump.it("BNF reminder:\n"+s);
	    toldBNF=true;
	    }
	  } //end of tellBNF(String s, RecognitionException re)
	  
	public void tellBNF(String s, RecognitionException re, BAST errorTree)
	  {
	  if (errorTree!=null)
	    {
	    errorTree.showParseTree(errorTree.getText()!=null?errorTree.getText():"error");
	    Dump.it("error on line "+Integer.toString(errorTree.getLine()+startingLine)+": "+
	      (errorTree.getText()!=null?errorTree.getText():""));
	    }
	  else Dump.it("error tree is null");
	  tellBNF(s,re);
	  }  //end of tellBNF(String s, RecognitionException re, BAST errorTree)
	  
	  


	public static class rational_literal_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "rational_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:722:1: rational_literal : LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) ) -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor) -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) ) -> ^( RATIONAL $dividend $divisor) ;
	public final BLESStoASTParser.rational_literal_return rational_literal() throws RecognitionException {
		BLESStoASTParser.rational_literal_return retval = new BLESStoASTParser.rational_literal_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token up=null;
		Token dividend=null;
		Token down=null;
		Token divisor=null;
		Token LBRACKET1=null;
		Token char_literal2=null;
		Token RBRACKET3=null;

		BAST up_tree=null;
		BAST dividend_tree=null;
		BAST down_tree=null;
		BAST divisor_tree=null;
		BAST LBRACKET1_tree=null;
		BAST char_literal2_tree=null;
		BAST RBRACKET3_tree=null;
		RewriteRuleTokenStream stream_INTEGER_LIT=new RewriteRuleTokenStream(adaptor,"token INTEGER_LIT");
		RewriteRuleTokenStream stream_304=new RewriteRuleTokenStream(adaptor,"token 304");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:723:3: ( LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) ) -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor) -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) ) -> ^( RATIONAL $dividend $divisor) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:3: LBRACKET (up= MINUS )? dividend= INTEGER_LIT '|' (down= MINUS )? divisor= INTEGER_LIT RBRACKET
			{
			LBRACKET1=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_rational_literal2632); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET1);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:14: (up= MINUS )?
			int alt1=2;
			int LA1_0 = input.LA(1);
			if ( (LA1_0==MINUS) ) {
				alt1=1;
			}
			switch (alt1) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:14: up= MINUS
					{
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2636); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(up);

					}
					break;

			}

			dividend=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2641); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(dividend);

			char_literal2=(Token)match(input,304,FOLLOW_304_in_rational_literal2643); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_304.add(char_literal2);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:51: (down= MINUS )?
			int alt2=2;
			int LA2_0 = input.LA(1);
			if ( (LA2_0==MINUS) ) {
				alt2=1;
			}
			switch (alt2) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:724:51: down= MINUS
					{
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_rational_literal2647); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(down);

					}
					break;

			}

			divisor=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal2652); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_INTEGER_LIT.add(divisor);

			RBRACKET3=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_rational_literal2654); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET3);

			// AST REWRITE
			// elements: divisor, down, divisor, dividend, divisor, dividend, divisor, dividend, dividend, down, up, up
			// token labels: divisor, dividend, up, down
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_divisor=new RewriteRuleTokenStream(adaptor,"token divisor",divisor);
			RewriteRuleTokenStream stream_dividend=new RewriteRuleTokenStream(adaptor,"token dividend",dividend);
			RewriteRuleTokenStream stream_up=new RewriteRuleTokenStream(adaptor,"token up",up);
			RewriteRuleTokenStream stream_down=new RewriteRuleTokenStream(adaptor,"token down",down);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 725:3: -> {(up!=null)&&(down!=null)}? ^( RATIONAL ^( $up $dividend) ^( $down $divisor) )
			if ((up!=null)&&(down!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:34: ^( RATIONAL ^( $up $dividend) ^( $down $divisor) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:45: ^( $up $dividend)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_dividend.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:725:62: ^( $down $divisor)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_divisor.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 726:3: -> {up!=null}? ^( RATIONAL ^( $up $dividend) $divisor)
			if (up!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:726:18: ^( RATIONAL ^( $up $dividend) $divisor)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:726:29: ^( $up $dividend)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_dividend.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_divisor.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 727:3: -> {down!=null}? ^( RATIONAL $dividend ^( $down $divisor) )
			if (down!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:727:20: ^( RATIONAL $dividend ^( $down $divisor) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				adaptor.addChild(root_1, stream_dividend.nextNode());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:727:41: ^( $down $divisor)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_divisor.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 728:3: -> ^( RATIONAL $dividend $divisor)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:728:6: ^( RATIONAL $dividend $divisor)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RATIONAL, "RATIONAL"), root_1);
				adaptor.addChild(root_1, stream_dividend.nextNode());
				adaptor.addChild(root_1, stream_divisor.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rational_literal"


	public static class complex_literal_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "complex_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:731:1: complex_literal : LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) ) -> {up!=null}? ^( COMPLEX ^( $up $real) $im) -> {down!=null}? ^( COMPLEX $real ^( $down $im) ) -> ^( COMPLEX $real $im) ;
	public final BLESStoASTParser.complex_literal_return complex_literal() throws RecognitionException {
		BLESStoASTParser.complex_literal_return retval = new BLESStoASTParser.complex_literal_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token up=null;
		Token real=null;
		Token down=null;
		Token im=null;
		Token LBRACKET4=null;
		Token COLON5=null;
		Token RBRACKET6=null;

		BAST up_tree=null;
		BAST real_tree=null;
		BAST down_tree=null;
		BAST im_tree=null;
		BAST LBRACKET4_tree=null;
		BAST COLON5_tree=null;
		BAST RBRACKET6_tree=null;
		RewriteRuleTokenStream stream_REAL_LIT=new RewriteRuleTokenStream(adaptor,"token REAL_LIT");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:732:3: ( LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) ) -> {up!=null}? ^( COMPLEX ^( $up $real) $im) -> {down!=null}? ^( COMPLEX $real ^( $down $im) ) -> ^( COMPLEX $real $im) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:3: LBRACKET (up= MINUS )? real= REAL_LIT COLON (down= MINUS )? im= REAL_LIT RBRACKET
			{
			LBRACKET4=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_complex_literal2751); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET4);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:14: (up= MINUS )?
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==MINUS) ) {
				alt3=1;
			}
			switch (alt3) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:14: up= MINUS
					{
					up=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2755); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(up);

					}
					break;

			}

			real=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2760); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(real);

			COLON5=(Token)match(input,COLON,FOLLOW_COLON_in_complex_literal2762); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON5);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:46: (down= MINUS )?
			int alt4=2;
			int LA4_0 = input.LA(1);
			if ( (LA4_0==MINUS) ) {
				alt4=1;
			}
			switch (alt4) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:733:46: down= MINUS
					{
					down=(Token)match(input,MINUS,FOLLOW_MINUS_in_complex_literal2766); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(down);

					}
					break;

			}

			im=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal2771); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL_LIT.add(im);

			RBRACKET6=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_complex_literal2773); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET6);

			// AST REWRITE
			// elements: im, real, up, real, real, down, up, im, down, real, im, im
			// token labels: im, real, up, down
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_im=new RewriteRuleTokenStream(adaptor,"token im",im);
			RewriteRuleTokenStream stream_real=new RewriteRuleTokenStream(adaptor,"token real",real);
			RewriteRuleTokenStream stream_up=new RewriteRuleTokenStream(adaptor,"token up",up);
			RewriteRuleTokenStream stream_down=new RewriteRuleTokenStream(adaptor,"token down",down);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 734:3: -> {(up!=null)&&(down!=null)}? ^( COMPLEX ^( $up $real) ^( $down $im) )
			if ((up!=null)&&(down!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:34: ^( COMPLEX ^( $up $real) ^( $down $im) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:44: ^( $up $real)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_real.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:734:57: ^( $down $im)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_im.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 735:3: -> {up!=null}? ^( COMPLEX ^( $up $real) $im)
			if (up!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:735:18: ^( COMPLEX ^( $up $real) $im)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:735:28: ^( $up $real)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_up.nextNode(), root_2);
				adaptor.addChild(root_2, stream_real.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_im.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 736:3: -> {down!=null}? ^( COMPLEX $real ^( $down $im) )
			if (down!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:736:20: ^( COMPLEX $real ^( $down $im) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				adaptor.addChild(root_1, stream_real.nextNode());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:736:36: ^( $down $im)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_down.nextNode(), root_2);
				adaptor.addChild(root_2, stream_im.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 737:3: -> ^( COMPLEX $real $im)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:737:6: ^( COMPLEX $real $im)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(COMPLEX, "COMPLEX"), root_1);
				adaptor.addChild(root_1, stream_real.nextNode());
				adaptor.addChild(root_1, stream_im.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "complex_literal"


	public static class relation_symbol_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "relation_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:740:1: relation_symbol : ( EQ | NEQ | LT | AM | AL | GT );
	public final BLESStoASTParser.relation_symbol_return relation_symbol() throws RecognitionException {
		BLESStoASTParser.relation_symbol_return retval = new BLESStoASTParser.relation_symbol_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set7=null;

		BAST set7_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:741:3: ( EQ | NEQ | LT | AM | AL | GT )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set7=input.LT(1);
			if ( (input.LA(1) >= AL && input.LA(1) <= AM)||input.LA(1)==EQ||input.LA(1)==GT||input.LA(1)==LT||input.LA(1)==NEQ ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set7));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relation_symbol"


	public static class range_symbol_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "range_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:746:1: range_symbol : ( DOTDOT | COMMADOT | DOTCOMMA | COMMACOMMA );
	public final BLESStoASTParser.range_symbol_return range_symbol() throws RecognitionException {
		BLESStoASTParser.range_symbol_return retval = new BLESStoASTParser.range_symbol_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set8=null;

		BAST set8_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:746:14: ( DOTDOT | COMMADOT | DOTCOMMA | COMMACOMMA )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set8=input.LT(1);
			if ( (input.LA(1) >= COMMACOMMA && input.LA(1) <= COMMADOT)||(input.LA(1) >= DOTCOMMA && input.LA(1) <= DOTDOT) ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set8));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range_symbol"


	public static class identifier_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "identifier"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:748:1: identifier : ID ;
	public final BLESStoASTParser.identifier_return identifier() throws RecognitionException {
		BLESStoASTParser.identifier_return retval = new BLESStoASTParser.identifier_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID9=null;

		BAST ID9_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:749:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:749:5: ID
			{
			root_0 = (BAST)adaptor.nil();


			ID9=(Token)match(input,ID,FOLLOW_ID_in_identifier2927); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID9_tree = (BAST)adaptor.create(ID9);
			adaptor.addChild(root_0, ID9_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re,(BAST)retval.getTree()); Dump.it("\nYou may be using a reserved word inappropriately.\n");throw(re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "identifier"


	public static class annex_library_assertions_return extends ParserRuleReturnScope {
		public BAST newRoot;
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "annex_library_assertions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1083:1: annex_library_assertions[HashMap<String,BAST> assertions_in_library] returns [BAST newRoot] : ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )? ;
	public final BLESStoASTParser.annex_library_assertions_return annex_library_assertions(HashMap<String,BAST> assertions_in_library) throws RecognitionException {
		BLESStoASTParser.annex_library_assertions_return retval = new BLESStoASTParser.annex_library_assertions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START10=null;
		Token ANNEX_END11=null;
		ParserRuleReturnScope ala =null;

		BAST ANNEX_START10_tree=null;
		BAST ANNEX_END11_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1085:3: ( ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1086:3: ( ANNEX_START )? (ala= assertion )+ ( ANNEX_END )?
			{
			root_0 = (BAST)adaptor.nil();


			if ( state.backtracking==0 ) {retval.newRoot = new BAST("ASSERTION_ANNEX",BLESStoASTLexer.ASSERTION_ANNEX,getStartingLine());}
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1087:3: ( ANNEX_START )?
			int alt5=2;
			int LA5_0 = input.LA(1);
			if ( (LA5_0==ANNEX_START) ) {
				alt5=1;
			}
			switch (alt5) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1087:3: ANNEX_START
					{
					ANNEX_START10=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_annex_library_assertions3302); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ANNEX_START10_tree = (BAST)adaptor.create(ANNEX_START10);
					adaptor.addChild(root_0, ANNEX_START10_tree);
					}

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1088:5: (ala= assertion )+
			int cnt6=0;
			loop6:
			while (true) {
				int alt6=2;
				int LA6_0 = input.LA(1);
				if ( (LA6_0==LASS) ) {
					alt6=1;
				}

				switch (alt6) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1088:6: ala= assertion
					{
					pushFollow(FOLLOW_assertion_in_annex_library_assertions3312);
					ala=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, ala.getTree());

					if ( state.backtracking==0 ) {if ((assertions_in_library!=null)&&
					      ((ala!=null?((BAST)ala.getTree()):null)!=null)&&((ala!=null?((BAST)ala.getTree()):null).getChild(0)!=null)&&
					      ((ala!=null?((BAST)ala.getTree()):null).getChild(0).getChild(0)!=null)&&
					      ((BAST)(ala!=null?((BAST)ala.getTree()):null).getChild(0)).hasType(BLESStoASTLexer.LABEL)) 
					      assertions_in_library.put(((BAST)(ala!=null?((BAST)ala.getTree()):null).getChild(0).getChild(0)).getText(),(ala!=null?((BAST)ala.getTree()):null));
					      retval.newRoot.addChild((BAST)(ala!=null?((BAST)ala.getTree()):null));}
					}
					break;

				default :
					if ( cnt6 >= 1 ) break loop6;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(6, input);
					throw eee;
				}
				cnt6++;
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1096:3: ( ANNEX_END )?
			int alt7=2;
			int LA7_0 = input.LA(1);
			if ( (LA7_0==ANNEX_END) ) {
				alt7=1;
			}
			switch (alt7) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1096:3: ANNEX_END
					{
					ANNEX_END11=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_annex_library_assertions3332); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ANNEX_END11_tree = (BAST)adaptor.create(ANNEX_END11);
					adaptor.addChild(root_0, ANNEX_END11_tree);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "annex_library_assertions"


	public static class thread_behavior_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "thread_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1676:1: thread_behavior : ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )? -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP ) ;
	public final BLESStoASTParser.thread_behavior_return thread_behavior() throws RecognitionException {
		BLESStoASTParser.thread_behavior_return retval = new BLESStoASTParser.thread_behavior_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token no_proof=null;
		Token s=null;
		Token ANNEX_START12=null;
		Token ANNEX_END13=null;
		List<Object> list_bs=null;
		ParserRuleReturnScope av =null;
		ParserRuleReturnScope ac =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope sv =null;
		ParserRuleReturnScope tran =null;
		RuleReturnScope bs = null;
		BAST no_proof_tree=null;
		BAST s_tree=null;
		BAST ANNEX_START12_tree=null;
		BAST ANNEX_END13_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_LITERAL_states=new RewriteRuleTokenStream(adaptor,"token LITERAL_states");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleTokenStream stream_DO_NOT_PROVE=new RewriteRuleTokenStream(adaptor,"token DO_NOT_PROVE");
		RewriteRuleSubtreeStream stream_assert_clause=new RewriteRuleSubtreeStream(adaptor,"rule assert_clause");
		RewriteRuleSubtreeStream stream_variables=new RewriteRuleSubtreeStream(adaptor,"rule variables");
		RewriteRuleSubtreeStream stream_behavior_state=new RewriteRuleSubtreeStream(adaptor,"rule behavior_state");
		RewriteRuleSubtreeStream stream_invariant_clause=new RewriteRuleSubtreeStream(adaptor,"rule invariant_clause");
		RewriteRuleSubtreeStream stream_availability=new RewriteRuleSubtreeStream(adaptor,"rule availability");
		RewriteRuleSubtreeStream stream_transitions=new RewriteRuleSubtreeStream(adaptor,"rule transitions");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1677:3: ( ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )? -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:3: ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (av= availability )? (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? s= LITERAL_states (bs+= behavior_state )+ tran= transitions ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:3: ( ANNEX_START )?
			int alt8=2;
			int LA8_0 = input.LA(1);
			if ( (LA8_0==ANNEX_START) ) {
				alt8=1;
			}
			switch (alt8) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1678:3: ANNEX_START
					{
					ANNEX_START12=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_thread_behavior4007); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START12);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1679:11: (no_proof= DO_NOT_PROVE )?
			int alt9=2;
			int LA9_0 = input.LA(1);
			if ( (LA9_0==DO_NOT_PROVE) ) {
				alt9=1;
			}
			switch (alt9) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1679:11: no_proof= DO_NOT_PROVE
					{
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_thread_behavior4014); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DO_NOT_PROVE.add(no_proof);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1680:5: (av= availability )?
			int alt10=2;
			int LA10_0 = input.LA(1);
			if ( (LA10_0==LITERAL_availability) ) {
				alt10=1;
			}
			switch (alt10) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1680:5: av= availability
					{
					pushFollow(FOLLOW_availability_in_thread_behavior4021);
					av=availability();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_availability.add(av.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1681:5: (ac= assert_clause )?
			int alt11=2;
			int LA11_0 = input.LA(1);
			if ( (LA11_0==LITERAL_assert) ) {
				alt11=1;
			}
			switch (alt11) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1681:5: ac= assert_clause
					{
					pushFollow(FOLLOW_assert_clause_in_thread_behavior4028);
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assert_clause.add(ac.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1682:6: (inv= invariant_clause )?
			int alt12=2;
			int LA12_0 = input.LA(1);
			if ( (LA12_0==LITERAL_invariant) ) {
				alt12=1;
			}
			switch (alt12) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1682:6: inv= invariant_clause
					{
					pushFollow(FOLLOW_invariant_clause_in_thread_behavior4035);
					inv=invariant_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_invariant_clause.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1683:5: (sv= variables )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==LITERAL_variables) ) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1683:5: sv= variables
					{
					pushFollow(FOLLOW_variables_in_thread_behavior4042);
					sv=variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_variables.add(sv.getTree());
					}
					break;

			}

			s=(Token)match(input,LITERAL_states,FOLLOW_LITERAL_states_in_thread_behavior4049); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_states.add(s);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1684:20: (bs+= behavior_state )+
			int cnt14=0;
			loop14:
			while (true) {
				int alt14=2;
				int LA14_0 = input.LA(1);
				if ( (LA14_0==ID) ) {
					alt14=1;
				}

				switch (alt14) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1684:22: bs+= behavior_state
					{
					pushFollow(FOLLOW_behavior_state_in_thread_behavior4055);
					bs=behavior_state();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_state.add(bs.getTree());
					if (list_bs==null) list_bs=new ArrayList<Object>();
					list_bs.add(bs.getTree());
					}
					break;

				default :
					if ( cnt14 >= 1 ) break loop14;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(14, input);
					throw eee;
				}
				cnt14++;
			}

			pushFollow(FOLLOW_transitions_in_thread_behavior4064);
			tran=transitions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_transitions.add(tran.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1686:3: ( ANNEX_END )?
			int alt15=2;
			int LA15_0 = input.LA(1);
			if ( (LA15_0==ANNEX_END) ) {
				alt15=1;
			}
			switch (alt15) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1686:3: ANNEX_END
					{
					ANNEX_END13=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_thread_behavior4068); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END13);

					}
					break;

			}

			// AST REWRITE
			// elements: LITERAL_states, bs, inv, sv, no_proof, ac, tran
			// token labels: no_proof
			// rule labels: inv, ac, sv, tran, retval
			// token list labels: 
			// rule list labels: bs
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_no_proof=new RewriteRuleTokenStream(adaptor,"token no_proof",no_proof);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"rule ac",ac!=null?ac.getTree():null);
			RewriteRuleSubtreeStream stream_sv=new RewriteRuleSubtreeStream(adaptor,"rule sv",sv!=null?sv.getTree():null);
			RewriteRuleSubtreeStream stream_tran=new RewriteRuleSubtreeStream(adaptor,"rule tran",tran!=null?tran.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bs=new RewriteRuleSubtreeStream(adaptor,"token bs",list_bs);
			root_0 = (BAST)adaptor.nil();
			// 1687:5: -> ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1687:8: ^( THREAD_ANNEX[$s,\"THREAD_ANNEX\"+(startingLine>0?\"[\"+startingLine+\"]\":\"\")] ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ ) ( $ac)? ( $inv)? ( $sv)? $tran ( $no_proof)? STOP )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(THREAD_ANNEX, s, "THREAD_ANNEX"+(startingLine>0?"["+startingLine+"]":"")), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1688:9: ^( LITERAL_states[$s,\"states[\"+Integer.toString($s.getLine()+startingLine)+\"]\"] ( $bs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_states, s, "states["+Integer.toString(s.getLine()+startingLine)+"]"), root_2);
				if ( !(stream_bs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bs.hasNext() ) {
					adaptor.addChild(root_2, stream_bs.nextTree());
				}
				stream_bs.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:10: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:15: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_1, stream_inv.nextTree());
				}
				stream_inv.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:21: ( $sv)?
				if ( stream_sv.hasNext() ) {
					adaptor.addChild(root_1, stream_sv.nextTree());
				}
				stream_sv.reset();

				adaptor.addChild(root_1, stream_tran.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1689:32: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_1, (BAST)adaptor.create(STOP, "STOP"));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
			    Dump.it("RecognitionException in BLESStoAST.thread_behavior");
			     if (re instanceof MismatchedTokenException)
			       Dump.it("\nHey "+HelpfulHints.getIdiot()+"!\n\nDid you put the semicolon *after* "+
			        "the Assertion?\n"+
			        "You must have \"states\" and at least one behvior state:  PowerOn: initial state;\n");
			     tellBNF(GrammarStrings.threadBehavior,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "thread_behavior"


	public static class assert_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assert_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1700:1: assert_clause : la= LITERAL_assert (ass+= assertion )+ -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ ) ;
	public final BLESStoASTParser.assert_clause_return assert_clause() throws RecognitionException {
		BLESStoASTParser.assert_clause_return retval = new BLESStoASTParser.assert_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token la=null;
		List<Object> list_ass=null;
		RuleReturnScope ass = null;
		BAST la_tree=null;
		RewriteRuleTokenStream stream_LITERAL_assert=new RewriteRuleTokenStream(adaptor,"token LITERAL_assert");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1701:3: (la= LITERAL_assert (ass+= assertion )+ -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1702:3: la= LITERAL_assert (ass+= assertion )+
			{
			la=(Token)match(input,LITERAL_assert,FOLLOW_LITERAL_assert_in_assert_clause4157); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_assert.add(la);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1702:24: (ass+= assertion )+
			int cnt16=0;
			loop16:
			while (true) {
				int alt16=2;
				int LA16_0 = input.LA(1);
				if ( (LA16_0==LASS) ) {
					alt16=1;
				}

				switch (alt16) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1702:24: ass+= assertion
					{
					pushFollow(FOLLOW_assertion_in_assert_clause4161);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(ass.getTree());
					if (list_ass==null) list_ass=new ArrayList<Object>();
					list_ass.add(ass.getTree());
					}
					break;

				default :
					if ( cnt16 >= 1 ) break loop16;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(16, input);
					throw eee;
				}
				cnt16++;
			}

			// AST REWRITE
			// elements: LITERAL_assert, ass
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: ass
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ass=new RewriteRuleSubtreeStream(adaptor,"token ass",list_ass);
			root_0 = (BAST)adaptor.nil();
			// 1703:5: -> ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1703:8: ^( LITERAL_assert[$la,\"assert[\"+Integer.toString($la.getLine()+startingLine)+\"]\"] ( $ass)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_assert, la, "assert["+Integer.toString(la.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_ass.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.assertClause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assert_clause"


	public static class invariant_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "invariant_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1708:1: invariant_clause : li= LITERAL_invariant inv= assertion -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv) ;
	public final BLESStoASTParser.invariant_clause_return invariant_clause() throws RecognitionException {
		BLESStoASTParser.invariant_clause_return retval = new BLESStoASTParser.invariant_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token li=null;
		ParserRuleReturnScope inv =null;

		BAST li_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1709:3: (li= LITERAL_invariant inv= assertion -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1710:3: li= LITERAL_invariant inv= assertion
			{
			li=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_invariant_clause4205); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_invariant.add(li);

			pushFollow(FOLLOW_assertion_in_invariant_clause4209);
			inv=assertion();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
			// AST REWRITE
			// elements: inv, LITERAL_invariant
			// token labels: 
			// rule labels: inv, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1711:5: -> ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1711:8: ^( LITERAL_invariant[$li,\"invariant[\"+Integer.toString($li.getLine()+startingLine)+\"]\"] $inv)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_invariant, li, "invariant["+Integer.toString(li.getLine()+startingLine)+"]"), root_1);
				adaptor.addChild(root_1, stream_inv.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.invariantClause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "invariant_clause"


	public static class variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1716:1: variables : v= LITERAL_variables (bv+= behavior_variable )+ -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* ) ;
	public final BLESStoASTParser.variables_return variables() throws RecognitionException {
		BLESStoASTParser.variables_return retval = new BLESStoASTParser.variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		BAST v_tree=null;
		RewriteRuleTokenStream stream_LITERAL_variables=new RewriteRuleTokenStream(adaptor,"token LITERAL_variables");
		RewriteRuleSubtreeStream stream_behavior_variable=new RewriteRuleSubtreeStream(adaptor,"rule behavior_variable");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1717:3: (v= LITERAL_variables (bv+= behavior_variable )+ -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1718:3: v= LITERAL_variables (bv+= behavior_variable )+
			{
			v=(Token)match(input,LITERAL_variables,FOLLOW_LITERAL_variables_in_variables4252); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_variables.add(v);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1718:23: (bv+= behavior_variable )+
			int cnt17=0;
			loop17:
			while (true) {
				int alt17=2;
				int LA17_0 = input.LA(1);
				if ( (LA17_0==ID) ) {
					alt17=1;
				}

				switch (alt17) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1718:25: bv+= behavior_variable
					{
					pushFollow(FOLLOW_behavior_variable_in_variables4258);
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_variable.add(bv.getTree());
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTree());
					}
					break;

				default :
					if ( cnt17 >= 1 ) break loop17;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(17, input);
					throw eee;
				}
				cnt17++;
			}

			// AST REWRITE
			// elements: LITERAL_variables, bv
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bv=new RewriteRuleSubtreeStream(adaptor,"token bv",list_bv);
			root_0 = (BAST)adaptor.nil();
			// 1719:5: -> ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1719:8: ^( LITERAL_variables[$v,\"variables[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)* )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_variables, v, "variables["+Integer.toString(v.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1719:95: ( $bv)*
				while ( stream_bv.hasNext() ) {
					adaptor.addChild(root_1, stream_bv.nextTree());
				}
				stream_bv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.variables,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variables"


	public static class quantified_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "quantified_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1726:1: quantified_variables : v= LITERAL_declare (bv+= behavior_variable )+ -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ ) ;
	public final BLESStoASTParser.quantified_variables_return quantified_variables() throws RecognitionException {
		BLESStoASTParser.quantified_variables_return retval = new BLESStoASTParser.quantified_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		BAST v_tree=null;
		RewriteRuleTokenStream stream_LITERAL_declare=new RewriteRuleTokenStream(adaptor,"token LITERAL_declare");
		RewriteRuleSubtreeStream stream_behavior_variable=new RewriteRuleSubtreeStream(adaptor,"rule behavior_variable");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1727:3: (v= LITERAL_declare (bv+= behavior_variable )+ -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1728:3: v= LITERAL_declare (bv+= behavior_variable )+
			{
			v=(Token)match(input,LITERAL_declare,FOLLOW_LITERAL_declare_in_quantified_variables4310); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_declare.add(v);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1728:21: (bv+= behavior_variable )+
			int cnt18=0;
			loop18:
			while (true) {
				int alt18=2;
				int LA18_0 = input.LA(1);
				if ( (LA18_0==ID) ) {
					alt18=1;
				}

				switch (alt18) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1728:23: bv+= behavior_variable
					{
					pushFollow(FOLLOW_behavior_variable_in_quantified_variables4316);
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_variable.add(bv.getTree());
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTree());
					}
					break;

				default :
					if ( cnt18 >= 1 ) break loop18;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(18, input);
					throw eee;
				}
				cnt18++;
			}

			// AST REWRITE
			// elements: LITERAL_declare, bv
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bv=new RewriteRuleSubtreeStream(adaptor,"token bv",list_bv);
			root_0 = (BAST)adaptor.nil();
			// 1729:5: -> ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1729:8: ^( LITERAL_declare[$v,\"declare[\"+Integer.toString($v.getLine()+startingLine)+\"]\"] ( $bv)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_declare, v, "declare["+Integer.toString(v.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_bv.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bv.hasNext() ) {
					adaptor.addChild(root_1, stream_bv.nextTree());
				}
				stream_bv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.quantifiedVariables,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "quantified_variables"


	public static class behavior_variable_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_variable"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1744:1: behavior_variable : dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) ;
	public final BLESStoASTParser.behavior_variable_return behavior_variable() throws RecognitionException {
		BLESStoASTParser.behavior_variable_return retval = new BLESStoASTParser.behavior_variable_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token p=null;
		Token s=null;
		Token con=null;
		Token sp=null;
		Token finl=null;
		Token agn=null;
		Token semi=null;
		ParserRuleReturnScope dec =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope ass =null;

		BAST c_tree=null;
		BAST p_tree=null;
		BAST s_tree=null;
		BAST con_tree=null;
		BAST sp_tree=null;
		BAST finl_tree=null;
		BAST agn_tree=null;
		BAST semi_tree=null;
		RewriteRuleTokenStream stream_LITERAL_shared=new RewriteRuleTokenStream(adaptor,"token LITERAL_shared");
		RewriteRuleTokenStream stream_LITERAL_final=new RewriteRuleTokenStream(adaptor,"token LITERAL_final");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_LITERAL_nonvolatile=new RewriteRuleTokenStream(adaptor,"token LITERAL_nonvolatile");
		RewriteRuleTokenStream stream_LITERAL_spread=new RewriteRuleTokenStream(adaptor,"token LITERAL_spread");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleTokenStream stream_LITERAL_constant=new RewriteRuleTokenStream(adaptor,"token LITERAL_constant");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_declarators=new RewriteRuleSubtreeStream(adaptor,"rule declarators");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1745:3: (dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1746:3: dec= declarators c= COLON (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )? t= type (agn= ASSIGN e= expression )? (ass= assertion )? semi= SEMICOLON
			{
			pushFollow(FOLLOW_declarators_in_behavior_variable4376);
			dec=declarators();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_declarators.add(dec.getTree());
			c=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_variable4380); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:3: (p= LITERAL_nonvolatile |s= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )?
			int alt19=6;
			switch ( input.LA(1) ) {
				case LITERAL_nonvolatile:
					{
					alt19=1;
					}
					break;
				case LITERAL_shared:
					{
					alt19=2;
					}
					break;
				case LITERAL_constant:
					{
					alt19=3;
					}
					break;
				case LITERAL_spread:
					{
					alt19=4;
					}
					break;
				case LITERAL_final:
					{
					alt19=5;
					}
					break;
			}
			switch (alt19) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:5: p= LITERAL_nonvolatile
					{
					p=(Token)match(input,LITERAL_nonvolatile,FOLLOW_LITERAL_nonvolatile_in_behavior_variable4389); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_nonvolatile.add(p);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:29: s= LITERAL_shared
					{
					s=(Token)match(input,LITERAL_shared,FOLLOW_LITERAL_shared_in_behavior_variable4395); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_shared.add(s);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:48: con= LITERAL_constant
					{
					con=(Token)match(input,LITERAL_constant,FOLLOW_LITERAL_constant_in_behavior_variable4401); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_constant.add(con);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1747:71: sp= LITERAL_spread
					{
					sp=(Token)match(input,LITERAL_spread,FOLLOW_LITERAL_spread_in_behavior_variable4407); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_spread.add(sp);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1748:5: finl= LITERAL_final
					{
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_variable4415); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_final.add(finl);

					}
					break;

			}

			pushFollow(FOLLOW_type_in_behavior_variable4425);
			t=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_type.add(t.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1749:10: (agn= ASSIGN e= expression )?
			int alt20=2;
			int LA20_0 = input.LA(1);
			if ( (LA20_0==ASSIGN) ) {
				alt20=1;
			}
			switch (alt20) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1749:12: agn= ASSIGN e= expression
					{
					agn=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_behavior_variable4431); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(agn);

					pushFollow(FOLLOW_expression_in_behavior_variable4435);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:6: (ass= assertion )?
			int alt21=2;
			int LA21_0 = input.LA(1);
			if ( (LA21_0==LASS) ) {
				alt21=1;
			}
			switch (alt21) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1750:6: ass= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_variable4445);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(ass.getTree());
					}
					break;

			}

			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_variable4454); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: ass, semi, e, s, t, dec, con, p, s, t, p, sp, agn, ass, finl, semi, con, c, sp, finl, c, dec
			// token labels: p, s, con, c, agn, semi, sp, finl
			// rule labels: ass, dec, t, e, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_p=new RewriteRuleTokenStream(adaptor,"token p",p);
			RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
			RewriteRuleTokenStream stream_con=new RewriteRuleTokenStream(adaptor,"token con",con);
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_agn=new RewriteRuleTokenStream(adaptor,"token agn",agn);
			RewriteRuleTokenStream stream_semi=new RewriteRuleTokenStream(adaptor,"token semi",semi);
			RewriteRuleTokenStream stream_sp=new RewriteRuleTokenStream(adaptor,"token sp",sp);
			RewriteRuleTokenStream stream_finl=new RewriteRuleTokenStream(adaptor,"token finl",finl);
			RewriteRuleSubtreeStream stream_ass=new RewriteRuleSubtreeStream(adaptor,"rule ass",ass!=null?ass.getTree():null);
			RewriteRuleSubtreeStream stream_dec=new RewriteRuleSubtreeStream(adaptor,"rule dec",dec!=null?dec.getTree():null);
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1752:5: -> {e!=null}? ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
			if (e!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:19: ^( $c $dec ^( TYPE[\"TYPE\"] $t) ^( $agn $e) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dec.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:29: ^( TYPE[\"TYPE\"] $t)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TYPE, "TYPE"), root_2);
				adaptor.addChild(root_2, stream_t.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:48: ^( $agn $e)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_agn.nextNode(), root_2);
				adaptor.addChild(root_2, stream_e.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:62: ( $ass)?
				if ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:68: ( $p)?
				if ( stream_p.hasNext() ) {
					adaptor.addChild(root_1, stream_p.nextNode());
				}
				stream_p.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:72: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_1, stream_s.nextNode());
				}
				stream_s.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:76: ( $con)?
				if ( stream_con.hasNext() ) {
					adaptor.addChild(root_1, stream_con.nextNode());
				}
				stream_con.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:82: ( $sp)?
				if ( stream_sp.hasNext() ) {
					adaptor.addChild(root_1, stream_sp.nextNode());
				}
				stream_sp.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1752:87: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_semi.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1753:5: -> ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:8: ^( $c $dec ^( TYPE[\"TYPE\"] $t) ( $ass)? ( $p)? ( $s)? ( $con)? ( $sp)? ( $finl)? $semi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dec.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:18: ^( TYPE[\"TYPE\"] $t)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TYPE, "TYPE"), root_2);
				adaptor.addChild(root_2, stream_t.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:38: ( $ass)?
				if ( stream_ass.hasNext() ) {
					adaptor.addChild(root_1, stream_ass.nextTree());
				}
				stream_ass.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:44: ( $p)?
				if ( stream_p.hasNext() ) {
					adaptor.addChild(root_1, stream_p.nextNode());
				}
				stream_p.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:48: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_1, stream_s.nextNode());
				}
				stream_s.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:52: ( $con)?
				if ( stream_con.hasNext() ) {
					adaptor.addChild(root_1, stream_con.nextNode());
				}
				stream_con.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:58: ( $sp)?
				if ( stream_sp.hasNext() ) {
					adaptor.addChild(root_1, stream_sp.nextNode());
				}
				stream_sp.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1753:63: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_semi.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());tellBNF(GrammarStrings.behaviorVariable,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_variable"


	public static class declarators_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "declarators"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1758:1: declarators : d= ID (c= COMMA ds+= ID )* -> {ds!=null}? ^( $c $d ( $ds)+ ) -> $d;
	public final BLESStoASTParser.declarators_return declarators() throws RecognitionException {
		BLESStoASTParser.declarators_return retval = new BLESStoASTParser.declarators_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token d=null;
		Token c=null;
		Token ds=null;
		List<Object> list_ds=null;

		BAST d_tree=null;
		BAST c_tree=null;
		BAST ds_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1759:3: (d= ID (c= COMMA ds+= ID )* -> {ds!=null}? ^( $c $d ( $ds)+ ) -> $d)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1760:24: d= ID (c= COMMA ds+= ID )*
			{
			d=(Token)match(input,ID,FOLLOW_ID_in_declarators4591); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(d);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1760:29: (c= COMMA ds+= ID )*
			loop22:
			while (true) {
				int alt22=2;
				int LA22_0 = input.LA(1);
				if ( (LA22_0==COMMA) ) {
					alt22=1;
				}

				switch (alt22) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1760:30: c= COMMA ds+= ID
					{
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_declarators4596); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					ds=(Token)match(input,ID,FOLLOW_ID_in_declarators4601); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ds);

					if (list_ds==null) list_ds=new ArrayList<Object>();
					list_ds.add(ds);
					}
					break;

				default :
					break loop22;
				}
			}

			// AST REWRITE
			// elements: ds, c, d, d
			// token labels: c, d
			// rule labels: retval
			// token list labels: ds
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
			RewriteRuleTokenStream stream_ds=new RewriteRuleTokenStream(adaptor,"token ds", list_ds);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1761:5: -> {ds!=null}? ^( $c $d ( $ds)+ )
			if (ds!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1761:20: ^( $c $d ( $ds)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_d.nextNode());
				if ( !(stream_ds.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ds.hasNext() ) {
					adaptor.addChild(root_1, stream_ds.nextNode());
				}
				stream_ds.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1762:5: -> $d
			{
				adaptor.addChild(root_0, stream_d.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "declarators"


	public static class behavior_state_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_state"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1792:1: behavior_state : i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? ) ;
	public final BLESStoASTParser.behavior_state_return behavior_state() throws RecognitionException {
		BLESStoASTParser.behavior_state_return retval = new BLESStoASTParser.behavior_state_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token init=null;
		Token com=null;
		Token finl=null;
		Token st=null;
		Token COLON14=null;
		Token SEMICOLON15=null;
		ParserRuleReturnScope i =null;
		ParserRuleReturnScope a =null;

		BAST init_tree=null;
		BAST com_tree=null;
		BAST finl_tree=null;
		BAST st_tree=null;
		BAST COLON14_tree=null;
		BAST SEMICOLON15_tree=null;
		RewriteRuleTokenStream stream_LITERAL_final=new RewriteRuleTokenStream(adaptor,"token LITERAL_final");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_LITERAL_state=new RewriteRuleTokenStream(adaptor,"token LITERAL_state");
		RewriteRuleTokenStream stream_LITERAL_initial=new RewriteRuleTokenStream(adaptor,"token LITERAL_initial");
		RewriteRuleTokenStream stream_LITERAL_complete=new RewriteRuleTokenStream(adaptor,"token LITERAL_complete");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1793:3: (i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1794:3: i= identifier COLON (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )? st= LITERAL_state (a= assertion )? SEMICOLON
			{
			pushFollow(FOLLOW_identifier_in_behavior_state4685);
			i=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
			COLON14=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_state4690); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON14);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:9: (init= LITERAL_initial |com= LITERAL_complete |finl= LITERAL_final )?
			int alt23=4;
			switch ( input.LA(1) ) {
				case LITERAL_initial:
					{
					alt23=1;
					}
					break;
				case LITERAL_complete:
					{
					alt23=2;
					}
					break;
				case LITERAL_final:
					{
					alt23=3;
					}
					break;
			}
			switch (alt23) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:10: init= LITERAL_initial
					{
					init=(Token)match(input,LITERAL_initial,FOLLOW_LITERAL_initial_in_behavior_state4695); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_initial.add(init);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:33: com= LITERAL_complete
					{
					com=(Token)match(input,LITERAL_complete,FOLLOW_LITERAL_complete_in_behavior_state4701); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complete.add(com);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:56: finl= LITERAL_final
					{
					finl=(Token)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_state4707); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_final.add(finl);

					}
					break;

			}

			st=(Token)match(input,LITERAL_state,FOLLOW_LITERAL_state_in_behavior_state4713); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_state.add(st);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:95: (a= assertion )?
			int alt24=2;
			int LA24_0 = input.LA(1);
			if ( (LA24_0==LASS) ) {
				alt24=1;
			}
			switch (alt24) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1795:95: a= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_state4717);
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
					}
					break;

			}

			SEMICOLON15=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_state4720); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON15);

			// AST REWRITE
			// elements: a, init, finl, com, i, LITERAL_state
			// token labels: com, init, finl
			// rule labels: a, i, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_com=new RewriteRuleTokenStream(adaptor,"token com",com);
			RewriteRuleTokenStream stream_init=new RewriteRuleTokenStream(adaptor,"token init",init);
			RewriteRuleTokenStream stream_finl=new RewriteRuleTokenStream(adaptor,"token finl",finl);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1796:5: -> ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:8: ^( LITERAL_state[$st,\"state[\"+Integer.toString($st.getLine()+startingLine)+\"]\"] ( $init)? ( $com)? ( $finl)? $i ( $a)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_state, st, "state["+Integer.toString(st.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:89: ( $init)?
				if ( stream_init.hasNext() ) {
					adaptor.addChild(root_1, stream_init.nextNode());
				}
				stream_init.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:96: ( $com)?
				if ( stream_com.hasNext() ) {
					adaptor.addChild(root_1, stream_com.nextNode());
				}
				stream_com.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:102: ( $finl)?
				if ( stream_finl.hasNext() ) {
					adaptor.addChild(root_1, stream_finl.nextNode());
				}
				stream_finl.reset();

				adaptor.addChild(root_1, stream_i.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1796:112: ( $a)?
				if ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.behaviorState,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_state"


	public static class transitions_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "transitions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1801:1: transitions : t= LITERAL_transitions (bt+= behavior_transition )+ -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ ) ;
	public final BLESStoASTParser.transitions_return transitions() throws RecognitionException {
		BLESStoASTParser.transitions_return retval = new BLESStoASTParser.transitions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token t=null;
		List<Object> list_bt=null;
		RuleReturnScope bt = null;
		BAST t_tree=null;
		RewriteRuleTokenStream stream_LITERAL_transitions=new RewriteRuleTokenStream(adaptor,"token LITERAL_transitions");
		RewriteRuleSubtreeStream stream_behavior_transition=new RewriteRuleSubtreeStream(adaptor,"rule behavior_transition");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1802:3: (t= LITERAL_transitions (bt+= behavior_transition )+ -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1803:3: t= LITERAL_transitions (bt+= behavior_transition )+
			{
			t=(Token)match(input,LITERAL_transitions,FOLLOW_LITERAL_transitions_in_transitions4780); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_transitions.add(t);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1803:27: (bt+= behavior_transition )+
			int cnt25=0;
			loop25:
			while (true) {
				int alt25=2;
				int LA25_0 = input.LA(1);
				if ( (LA25_0==ID) ) {
					alt25=1;
				}

				switch (alt25) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1803:27: bt+= behavior_transition
					{
					pushFollow(FOLLOW_behavior_transition_in_transitions4784);
					bt=behavior_transition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_transition.add(bt.getTree());
					if (list_bt==null) list_bt=new ArrayList<Object>();
					list_bt.add(bt.getTree());
					}
					break;

				default :
					if ( cnt25 >= 1 ) break loop25;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(25, input);
					throw eee;
				}
				cnt25++;
			}

			// AST REWRITE
			// elements: bt, LITERAL_transitions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: bt
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_bt=new RewriteRuleSubtreeStream(adaptor,"token bt",list_bt);
			root_0 = (BAST)adaptor.nil();
			// 1804:5: -> ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1804:8: ^( LITERAL_transitions[$t,\"transitions[\"+Integer.toString($t.getLine()+startingLine)+\"]\"] ( $bt)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LITERAL_transitions, t, "transitions["+Integer.toString(t.getLine()+startingLine)+"]"), root_1);
				if ( !(stream_bt.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_bt.hasNext() ) {
					adaptor.addChild(root_1, stream_bt.nextTree());
				}
				stream_bt.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("If you get \"mismatched input"+
			      " '<<' expecting 'transitions'\" then you might have put a semicolon "+
			      "between an action and a Assertion, instead of afterwards.");
			    tellBNF(GrammarStrings.transitions,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "transitions"


	public static class behavior_transition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_transition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1812:1: behavior_transition : (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) ) ;
	public final BLESStoASTParser.behavior_transition_return behavior_transition() throws RecognitionException {
		BLESStoASTParser.behavior_transition_return retval = new BLESStoASTParser.behavior_transition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token x=null;
		Token semi=null;
		Token COLON16=null;
		Token COMMA17=null;
		Token RCON18=null;
		Token LCURLY19=null;
		Token RCURLY20=null;
		Token EMPTY_CURLY21=null;
		List<Object> list_ssi=null;
		ParserRuleReturnScope btl =null;
		ParserRuleReturnScope bc =null;
		ParserRuleReturnScope dsi =null;
		ParserRuleReturnScope s =null;
		ParserRuleReturnScope q =null;
		RuleReturnScope ssi = null;
		BAST x_tree=null;
		BAST semi_tree=null;
		BAST COLON16_tree=null;
		BAST COMMA17_tree=null;
		BAST RCON18_tree=null;
		BAST LCURLY19_tree=null;
		BAST RCURLY20_tree=null;
		BAST EMPTY_CURLY21_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EMPTY_CURLY=new RewriteRuleTokenStream(adaptor,"token EMPTY_CURLY");
		RewriteRuleTokenStream stream_LCON=new RewriteRuleTokenStream(adaptor,"token LCON");
		RewriteRuleTokenStream stream_RCON=new RewriteRuleTokenStream(adaptor,"token RCON");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_behavior_transition_label=new RewriteRuleSubtreeStream(adaptor,"rule behavior_transition_label");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_behavior_condition=new RewriteRuleSubtreeStream(adaptor,"rule behavior_condition");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1813:3: ( (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:3: (btl= behavior_transition_label COLON )? ssi+= identifier ( COMMA ssi+= identifier )* x= LCON (bc= behavior_condition )? RCON dsi= identifier ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY ) (q= assertion )? semi= SEMICOLON
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:3: (btl= behavior_transition_label COLON )?
			int alt26=2;
			int LA26_0 = input.LA(1);
			if ( (LA26_0==ID) ) {
				int LA26_1 = input.LA(2);
				if ( (LA26_1==COLON||LA26_1==LBRACKET) ) {
					alt26=1;
				}
			}
			switch (alt26) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1814:5: btl= behavior_transition_label COLON
					{
					pushFollow(FOLLOW_behavior_transition_label_in_behavior_transition4831);
					btl=behavior_transition_label();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_transition_label.add(btl.getTree());
					COLON16=(Token)match(input,COLON,FOLLOW_COLON_in_behavior_transition4833); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON16);

					}
					break;

			}

			pushFollow(FOLLOW_identifier_in_behavior_transition4843);
			ssi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(ssi.getTree());
			if (list_ssi==null) list_ssi=new ArrayList<Object>();
			list_ssi.add(ssi.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1815:36: ( COMMA ssi+= identifier )*
			loop27:
			while (true) {
				int alt27=2;
				int LA27_0 = input.LA(1);
				if ( (LA27_0==COMMA) ) {
					alt27=1;
				}

				switch (alt27) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1815:38: COMMA ssi+= identifier
					{
					COMMA17=(Token)match(input,COMMA,FOLLOW_COMMA_in_behavior_transition4847); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA17);

					pushFollow(FOLLOW_identifier_in_behavior_transition4852);
					ssi=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(ssi.getTree());
					if (list_ssi==null) list_ssi=new ArrayList<Object>();
					list_ssi.add(ssi.getTree());
					}
					break;

				default :
					break loop27;
				}
			}

			x=(Token)match(input,LCON,FOLLOW_LCON_in_behavior_transition4861); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCON.add(x);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:12: (bc= behavior_condition )?
			int alt28=2;
			int LA28_0 = input.LA(1);
			if ( (LA28_0==AADL_STRING_LITERAL||LA28_0==ID||LA28_0==INTEGER_LIT||LA28_0==LBRACKET||LA28_0==LITERAL_complex||LA28_0==LITERAL_false||LA28_0==LITERAL_in||LA28_0==LITERAL_integer||LA28_0==LITERAL_natural||(LA28_0 >= LITERAL_not && LA28_0 <= LITERAL_now)||LA28_0==LITERAL_null||LA28_0==LITERAL_on||(LA28_0 >= LITERAL_rational && LA28_0 <= LITERAL_real)||LA28_0==LITERAL_self||(LA28_0 >= LITERAL_time && LA28_0 <= LITERAL_timeout)||LA28_0==LITERAL_tops||LA28_0==LITERAL_true||LA28_0==LPAREN||LA28_0==MINUS||LA28_0==OCTOTHORPE||LA28_0==REAL_LIT) ) {
				alt28=1;
			}
			switch (alt28) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1816:12: bc= behavior_condition
					{
					pushFollow(FOLLOW_behavior_condition_in_behavior_transition4865);
					bc=behavior_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_condition.add(bc.getTree());
					}
					break;

			}

			RCON18=(Token)match(input,RCON,FOLLOW_RCON_in_behavior_transition4868); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCON.add(RCON18);

			pushFollow(FOLLOW_identifier_in_behavior_transition4875);
			dsi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(dsi.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1818:3: ( LCURLY s= behavior_actions RCURLY | EMPTY_CURLY )
			int alt29=2;
			int LA29_0 = input.LA(1);
			if ( (LA29_0==LCURLY) ) {
				alt29=1;
			}
			else if ( (LA29_0==EMPTY_CURLY) ) {
				alt29=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 29, 0, input);
				throw nvae;
			}

			switch (alt29) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1818:5: LCURLY s= behavior_actions RCURLY
					{
					LCURLY19=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_behavior_transition4882); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY19);

					pushFollow(FOLLOW_behavior_actions_in_behavior_transition4886);
					s=behavior_actions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_behavior_actions.add(s.getTree());
					RCURLY20=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_behavior_transition4888); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY20);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1818:40: EMPTY_CURLY
					{
					EMPTY_CURLY21=(Token)match(input,EMPTY_CURLY,FOLLOW_EMPTY_CURLY_in_behavior_transition4892); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EMPTY_CURLY.add(EMPTY_CURLY21);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1819:4: (q= assertion )?
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==LASS) ) {
				alt30=1;
			}
			switch (alt30) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1819:4: q= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_transition4900);
					q=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(q.getTree());
					}
					break;

			}

			semi=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_transition4905); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SEMICOLON.add(semi);

			// AST REWRITE
			// elements: s, dsi, q, btl, bc, ssi
			// token labels: 
			// rule labels: q, bc, s, dsi, btl, retval
			// token list labels: 
			// rule list labels: ssi
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.getTree():null);
			RewriteRuleSubtreeStream stream_bc=new RewriteRuleSubtreeStream(adaptor,"rule bc",bc!=null?bc.getTree():null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.getTree():null);
			RewriteRuleSubtreeStream stream_dsi=new RewriteRuleSubtreeStream(adaptor,"rule dsi",dsi!=null?dsi.getTree():null);
			RewriteRuleSubtreeStream stream_btl=new RewriteRuleSubtreeStream(adaptor,"rule btl",btl!=null?btl.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ssi=new RewriteRuleSubtreeStream(adaptor,"token ssi",list_ssi);
			root_0 = (BAST)adaptor.nil();
			// 1820:5: -> ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1821:7: ^( TRANSITION[$x,\"TRANSITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? ) ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ ) ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? ) ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi) ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? ) ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(TRANSITION, x, "TRANSITION["+Integer.toString(x.getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1822:7: ^( LABEL[$x,\"LABEL[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $btl)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, x, "LABEL["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1822:78: ( $btl)?
				if ( stream_btl.hasNext() ) {
					adaptor.addChild(root_2, stream_btl.nextTree());
				}
				stream_btl.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1823:7: ^( SOURCE[$x,\"SOURCE[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $ssi)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SOURCE, x, "SOURCE["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				if ( !(stream_ssi.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ssi.hasNext() ) {
					adaptor.addChild(root_2, stream_ssi.nextTree());
				}
				stream_ssi.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1824:7: ^( CONDITION[$x,\"CONDITION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $bc)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITION, x, "CONDITION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1824:86: ( $bc)?
				if ( stream_bc.hasNext() ) {
					adaptor.addChild(root_2, stream_bc.nextTree());
				}
				stream_bc.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1825:7: ^( DESTINATION[$x,\"DESTINATION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] $dsi)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(DESTINATION, x, "DESTINATION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				adaptor.addChild(root_2, stream_dsi.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1826:7: ^( ACTION[$x,\"ACTION[\"+Integer.toString($x.getLine()+startingLine)+\"]\"] ( $s)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ACTION, x, "ACTION["+Integer.toString(x.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1826:80: ( $s)?
				if ( stream_s.hasNext() ) {
					adaptor.addChild(root_2, stream_s.nextTree());
				}
				stream_s.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1827:7: ^( Q[$semi,\"Q[\"+Integer.toString($semi.getLine()+startingLine)+\"]\"] ( $q)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(Q, semi, "Q["+Integer.toString(semi.getLine()+startingLine)+"]"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1827:76: ( $q)?
				if ( stream_q.hasNext() ) {
					adaptor.addChild(root_2, stream_q.nextTree());
				}
				stream_q.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nDo you have either behavior actions or empty curly brackets?");
			    Dump.it("Is there a space between your empty curly brackets?\nYou stink!  Take a bath.\n");
			    Dump.it("Is your execute condition grammatically-correct? ");
			    tellBNF(GrammarStrings.behaviorTransition,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition"


	public static class behavior_transition_label_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_transition_label"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1839:1: behavior_transition_label : id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )? -> ^( $id ( $lit)? ) ;
	public final BLESStoASTParser.behavior_transition_label_return behavior_transition_label() throws RecognitionException {
		BLESStoASTParser.behavior_transition_label_return retval = new BLESStoASTParser.behavior_transition_label_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lit=null;
		Token LBRACKET22=null;
		Token RBRACKET23=null;
		ParserRuleReturnScope id =null;

		BAST lit_tree=null;
		BAST LBRACKET22_tree=null;
		BAST RBRACKET23_tree=null;
		RewriteRuleTokenStream stream_INTEGER_LIT=new RewriteRuleTokenStream(adaptor,"token INTEGER_LIT");
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1840:3: (id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )? -> ^( $id ( $lit)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1841:3: id= identifier ( LBRACKET lit= INTEGER_LIT RBRACKET )?
			{
			pushFollow(FOLLOW_identifier_in_behavior_transition_label5069);
			id=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1841:17: ( LBRACKET lit= INTEGER_LIT RBRACKET )?
			int alt31=2;
			int LA31_0 = input.LA(1);
			if ( (LA31_0==LBRACKET) ) {
				alt31=1;
			}
			switch (alt31) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1841:19: LBRACKET lit= INTEGER_LIT RBRACKET
					{
					LBRACKET22=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_behavior_transition_label5073); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET22);

					lit=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_behavior_transition_label5077); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_INTEGER_LIT.add(lit);

					RBRACKET23=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_behavior_transition_label5079); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET23);

					}
					break;

			}

			// AST REWRITE
			// elements: lit, id
			// token labels: lit
			// rule labels: id, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lit=new RewriteRuleTokenStream(adaptor,"token lit",lit);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1842:5: -> ^( $id ( $lit)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1842:8: ^( $id ( $lit)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_id.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1842:16: ( $lit)?
				if ( stream_lit.hasNext() ) {
					adaptor.addChild(root_1, stream_lit.nextNode());
				}
				stream_lit.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition_label"


	public static class behavior_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1845:1: behavior_condition : ( dispatch_condition | execute_condition | mode_condition );
	public final BLESStoASTParser.behavior_condition_return behavior_condition() throws RecognitionException {
		BLESStoASTParser.behavior_condition_return retval = new BLESStoASTParser.behavior_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope dispatch_condition24 =null;
		ParserRuleReturnScope execute_condition25 =null;
		ParserRuleReturnScope mode_condition26 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1846:3: ( dispatch_condition | execute_condition | mode_condition )
			int alt32=3;
			int LA32_0 = input.LA(1);
			if ( (LA32_0==LITERAL_on) ) {
				int LA32_1 = input.LA(2);
				if ( (LA32_1==LITERAL_dispatch) ) {
					alt32=1;
				}
				else if ( (LA32_1==ID||LA32_1==LPAREN) ) {
					alt32=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 32, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA32_0==AADL_STRING_LITERAL||LA32_0==ID||LA32_0==INTEGER_LIT||LA32_0==LBRACKET||LA32_0==LITERAL_complex||LA32_0==LITERAL_false||LA32_0==LITERAL_in||LA32_0==LITERAL_integer||LA32_0==LITERAL_natural||(LA32_0 >= LITERAL_not && LA32_0 <= LITERAL_now)||LA32_0==LITERAL_null||(LA32_0 >= LITERAL_rational && LA32_0 <= LITERAL_real)||LA32_0==LITERAL_self||(LA32_0 >= LITERAL_time && LA32_0 <= LITERAL_timeout)||LA32_0==LITERAL_tops||LA32_0==LITERAL_true||LA32_0==LPAREN||LA32_0==MINUS||LA32_0==OCTOTHORPE||LA32_0==REAL_LIT) ) {
				alt32=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 32, 0, input);
				throw nvae;
			}

			switch (alt32) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1847:3: dispatch_condition
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_dispatch_condition_in_behavior_condition5117);
					dispatch_condition24=dispatch_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dispatch_condition24.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1847:24: execute_condition
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_execute_condition_in_behavior_condition5121);
					execute_condition25=execute_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, execute_condition25.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1847:44: mode_condition
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_mode_condition_in_behavior_condition5125);
					mode_condition26=mode_condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, mode_condition26.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_condition"


	public static class execute_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "execute_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1850:1: execute_condition : expression_or_relation ;
	public final BLESStoASTParser.execute_condition_return execute_condition() throws RecognitionException {
		BLESStoASTParser.execute_condition_return retval = new BLESStoASTParser.execute_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope expression_or_relation27 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1851:3: ( expression_or_relation )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1852:15: expression_or_relation
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_expression_or_relation_in_execute_condition5143);
			expression_or_relation27=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_relation27.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "execute_condition"


	public static class mode_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "mode_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1855:1: mode_condition : LITERAL_on ^ trigger_logical_expression ;
	public final BLESStoASTParser.mode_condition_return mode_condition() throws RecognitionException {
		BLESStoASTParser.mode_condition_return retval = new BLESStoASTParser.mode_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_on28=null;
		ParserRuleReturnScope trigger_logical_expression29 =null;

		BAST LITERAL_on28_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1856:3: ( LITERAL_on ^ trigger_logical_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1857:3: LITERAL_on ^ trigger_logical_expression
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_on28=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_mode_condition5159); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_on28_tree = (BAST)adaptor.create(LITERAL_on28);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_on28_tree, root_0);
			}

			pushFollow(FOLLOW_trigger_logical_expression_in_mode_condition5162);
			trigger_logical_expression29=trigger_logical_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, trigger_logical_expression29.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mode_condition"


	public static class trigger_logical_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "trigger_logical_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1861:1: trigger_logical_expression : first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )? -> {op1!=null}? ^( $op1 $first ( $et)+ ) -> $first;
	public final BLESStoASTParser.trigger_logical_expression_return trigger_logical_expression() throws RecognitionException {
		BLESStoASTParser.trigger_logical_expression_return retval = new BLESStoASTParser.trigger_logical_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		List<Object> list_et=null;
		ParserRuleReturnScope first =null;
		ParserRuleReturnScope op1 =null;
		ParserRuleReturnScope op2 =null;
		RuleReturnScope et = null;
		RewriteRuleSubtreeStream stream_event_trigger=new RewriteRuleSubtreeStream(adaptor,"rule event_trigger");
		RewriteRuleSubtreeStream stream_logical_operator=new RewriteRuleSubtreeStream(adaptor,"rule logical_operator");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1862:3: (first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )? -> {op1!=null}? ^( $op1 $first ( $et)+ ) -> $first)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:3: first= event_trigger (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )?
			{
			pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5180);
			first=event_trigger();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_event_trigger.add(first.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:23: (op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)* )?
			int alt34=2;
			int LA34_0 = input.LA(1);
			if ( (LA34_0==LITERAL_and||LA34_0==LITERAL_cand||LA34_0==LITERAL_cor||LA34_0==LITERAL_or||LA34_0==LITERAL_xor) ) {
				alt34=1;
			}
			switch (alt34) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1863:25: op1= logical_operator et+= event_trigger (op2= logical_operator et+= event_trigger {...}?)*
					{
					pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5186);
					op1=logical_operator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logical_operator.add(op1.getTree());
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5190);
					et=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_event_trigger.add(et.getTree());
					if (list_et==null) list_et=new ArrayList<Object>();
					list_et.add(et.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1864:5: (op2= logical_operator et+= event_trigger {...}?)*
					loop33:
					while (true) {
						int alt33=2;
						int LA33_0 = input.LA(1);
						if ( (LA33_0==LITERAL_and||LA33_0==LITERAL_cand||LA33_0==LITERAL_cor||LA33_0==LITERAL_or||LA33_0==LITERAL_xor) ) {
							alt33=1;
						}

						switch (alt33) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1864:6: op2= logical_operator et+= event_trigger {...}?
							{
							pushFollow(FOLLOW_logical_operator_in_trigger_logical_expression5200);
							op2=logical_operator();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logical_operator.add(op2.getTree());
							pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression5204);
							et=event_trigger();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_event_trigger.add(et.getTree());
							if (list_et==null) list_et=new ArrayList<Object>();
							list_et.add(et.getTree());
							if ( !((op1==op2)) ) {
								if (state.backtracking>0) {state.failed=true; return retval;}
								throw new FailedPredicateException(input, "trigger_logical_expression", "op1==op2");
							}
							}
							break;

						default :
							break loop33;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: op1, first, first, et
			// token labels: 
			// rule labels: op1, first, retval
			// token list labels: 
			// rule list labels: et
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_op1=new RewriteRuleSubtreeStream(adaptor,"rule op1",op1!=null?op1.getTree():null);
			RewriteRuleSubtreeStream stream_first=new RewriteRuleSubtreeStream(adaptor,"rule first",first!=null?first.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_et=new RewriteRuleSubtreeStream(adaptor,"token et",list_et);
			root_0 = (BAST)adaptor.nil();
			// 1865:5: -> {op1!=null}? ^( $op1 $first ( $et)+ )
			if (op1!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1865:21: ^( $op1 $first ( $et)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_op1.nextNode(), root_1);
				adaptor.addChild(root_1, stream_first.nextTree());
				if ( !(stream_et.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_et.hasNext() ) {
					adaptor.addChild(root_1, stream_et.nextTree());
				}
				stream_et.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1866:5: -> $first
			{
				adaptor.addChild(root_0, stream_first.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nAll operators in trigger_logical_expression must be the same.");
			    reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trigger_logical_expression"


	public static class event_trigger_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "event_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1873:1: event_trigger : ( (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID | LPAREN ^ trigger_logical_expression RPAREN );
	public final BLESStoASTParser.event_trigger_return event_trigger() throws RecognitionException {
		BLESStoASTParser.event_trigger_return retval = new BLESStoASTParser.event_trigger_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token port=null;
		Token PERIOD30=null;
		Token PERIOD31=null;
		Token LPAREN32=null;
		Token RPAREN34=null;
		Token sub=null;
		List<Object> list_sub=null;
		ParserRuleReturnScope trigger_logical_expression33 =null;

		BAST port_tree=null;
		BAST PERIOD30_tree=null;
		BAST PERIOD31_tree=null;
		BAST LPAREN32_tree=null;
		BAST RPAREN34_tree=null;
		BAST sub_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1874:3: ( (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID | LPAREN ^ trigger_logical_expression RPAREN )
			int alt37=2;
			int LA37_0 = input.LA(1);
			if ( (LA37_0==ID) ) {
				alt37=1;
			}
			else if ( (LA37_0==LPAREN) ) {
				alt37=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 37, 0, input);
				throw nvae;
			}

			switch (alt37) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:3: (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )? port= ID
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:3: (sub+= ID PERIOD ^ (sub+= ID PERIOD )* )?
					int alt36=2;
					int LA36_0 = input.LA(1);
					if ( (LA36_0==ID) ) {
						int LA36_1 = input.LA(2);
						if ( (LA36_1==PERIOD) ) {
							alt36=1;
						}
					}
					switch (alt36) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:5: sub+= ID PERIOD ^ (sub+= ID PERIOD )*
							{
							sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5275); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							sub_tree = (BAST)adaptor.create(sub);
							adaptor.addChild(root_0, sub_tree);
							}

							if (list_sub==null) list_sub=new ArrayList<Object>();
							list_sub.add(sub);
							PERIOD30=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5277); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD30_tree = (BAST)adaptor.create(PERIOD30);
							root_0 = (BAST)adaptor.becomeRoot(PERIOD30_tree, root_0);
							}

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:21: (sub+= ID PERIOD )*
							loop35:
							while (true) {
								int alt35=2;
								int LA35_0 = input.LA(1);
								if ( (LA35_0==ID) ) {
									int LA35_1 = input.LA(2);
									if ( (LA35_1==PERIOD) ) {
										alt35=1;
									}

								}

								switch (alt35) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1875:23: sub+= ID PERIOD
									{
									sub=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5284); if (state.failed) return retval;
									if ( state.backtracking==0 ) {
									sub_tree = (BAST)adaptor.create(sub);
									adaptor.addChild(root_0, sub_tree);
									}

									if (list_sub==null) list_sub=new ArrayList<Object>();
									list_sub.add(sub);
									PERIOD31=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger5286); if (state.failed) return retval;
									if ( state.backtracking==0 ) {
									PERIOD31_tree = (BAST)adaptor.create(PERIOD31);
									adaptor.addChild(root_0, PERIOD31_tree);
									}

									}
									break;

								default :
									break loop35;
								}
							}

							}
							break;

					}

					port=(Token)match(input,ID,FOLLOW_ID_in_event_trigger5296); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					port_tree = (BAST)adaptor.create(port);
					adaptor.addChild(root_0, port_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1876:5: LPAREN ^ trigger_logical_expression RPAREN
					{
					root_0 = (BAST)adaptor.nil();


					LPAREN32=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_trigger5302); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LPAREN32_tree = (BAST)adaptor.create(LPAREN32);
					root_0 = (BAST)adaptor.becomeRoot(LPAREN32_tree, root_0);
					}

					pushFollow(FOLLOW_trigger_logical_expression_in_event_trigger5305);
					trigger_logical_expression33=trigger_logical_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, trigger_logical_expression33.getTree());

					RPAREN34=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_trigger5307); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RPAREN34_tree = (BAST)adaptor.create(RPAREN34);
					adaptor.addChild(root_0, RPAREN34_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "event_trigger"


	public static class logical_operator_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logical_operator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1879:1: logical_operator : ( LITERAL_and | LITERAL_or | LITERAL_xor | LITERAL_cand | LITERAL_cor );
	public final BLESStoASTParser.logical_operator_return logical_operator() throws RecognitionException {
		BLESStoASTParser.logical_operator_return retval = new BLESStoASTParser.logical_operator_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set35=null;

		BAST set35_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1880:3: ( LITERAL_and | LITERAL_or | LITERAL_xor | LITERAL_cand | LITERAL_cor )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set35=input.LT(1);
			if ( input.LA(1)==LITERAL_and||input.LA(1)==LITERAL_cand||input.LA(1)==LITERAL_cor||input.LA(1)==LITERAL_or||input.LA(1)==LITERAL_xor ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set35));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logical_operator"


	public static class subprogram_behavior_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subprogram_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1890:1: subprogram_behavior : ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )? -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? ) -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? ) -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? ) -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? ) ;
	public final BLESStoASTParser.subprogram_behavior_return subprogram_behavior() throws RecognitionException {
		BLESStoASTParser.subprogram_behavior_return retval = new BLESStoASTParser.subprogram_behavior_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token no_proof=null;
		Token pr=null;
		Token po=null;
		Token ANNEX_START36=null;
		Token ANNEX_END37=null;
		ParserRuleReturnScope ac =null;
		ParserRuleReturnScope p1 =null;
		ParserRuleReturnScope p2 =null;
		ParserRuleReturnScope elq =null;

		BAST no_proof_tree=null;
		BAST pr_tree=null;
		BAST po_tree=null;
		BAST ANNEX_START36_tree=null;
		BAST ANNEX_END37_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_LITERAL_pre=new RewriteRuleTokenStream(adaptor,"token LITERAL_pre");
		RewriteRuleTokenStream stream_LITERAL_post=new RewriteRuleTokenStream(adaptor,"token LITERAL_post");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleTokenStream stream_DO_NOT_PROVE=new RewriteRuleTokenStream(adaptor,"token DO_NOT_PROVE");
		RewriteRuleSubtreeStream stream_assert_clause=new RewriteRuleSubtreeStream(adaptor,"rule assert_clause");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1891:3: ( ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )? -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? ) -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? ) -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? ) -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1892:3: ( ANNEX_START )? (no_proof= DO_NOT_PROVE )? (ac= assert_clause )? (pr= LITERAL_pre p1= assertion )? (po= LITERAL_post p2= assertion )? elq= existential_lattice_quantification ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1892:3: ( ANNEX_START )?
			int alt38=2;
			int LA38_0 = input.LA(1);
			if ( (LA38_0==ANNEX_START) ) {
				alt38=1;
			}
			switch (alt38) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1892:3: ANNEX_START
					{
					ANNEX_START36=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_subprogram_behavior5369); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START36);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1893:11: (no_proof= DO_NOT_PROVE )?
			int alt39=2;
			int LA39_0 = input.LA(1);
			if ( (LA39_0==DO_NOT_PROVE) ) {
				alt39=1;
			}
			switch (alt39) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1893:11: no_proof= DO_NOT_PROVE
					{
					no_proof=(Token)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5376); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DO_NOT_PROVE.add(no_proof);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1895:5: (ac= assert_clause )?
			int alt40=2;
			int LA40_0 = input.LA(1);
			if ( (LA40_0==LITERAL_assert) ) {
				alt40=1;
			}
			switch (alt40) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1895:5: ac= assert_clause
					{
					pushFollow(FOLLOW_assert_clause_in_subprogram_behavior5384);
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assert_clause.add(ac.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1896:3: (pr= LITERAL_pre p1= assertion )?
			int alt41=2;
			int LA41_0 = input.LA(1);
			if ( (LA41_0==LITERAL_pre) ) {
				alt41=1;
			}
			switch (alt41) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1896:5: pr= LITERAL_pre p1= assertion
					{
					pr=(Token)match(input,LITERAL_pre,FOLLOW_LITERAL_pre_in_subprogram_behavior5393); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_pre.add(pr);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5397);
					p1=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(p1.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1897:3: (po= LITERAL_post p2= assertion )?
			int alt42=2;
			int LA42_0 = input.LA(1);
			if ( (LA42_0==LITERAL_post) ) {
				alt42=1;
			}
			switch (alt42) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1897:5: po= LITERAL_post p2= assertion
					{
					po=(Token)match(input,LITERAL_post,FOLLOW_LITERAL_post_in_subprogram_behavior5408); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_post.add(po);

					pushFollow(FOLLOW_assertion_in_subprogram_behavior5412);
					p2=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(p2.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_existential_lattice_quantification_in_subprogram_behavior5421);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:3: ( ANNEX_END )?
			int alt43=2;
			int LA43_0 = input.LA(1);
			if ( (LA43_0==ANNEX_END) ) {
				alt43=1;
			}
			switch (alt43) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1899:3: ANNEX_END
					{
					ANNEX_END37=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_subprogram_behavior5425); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END37);

					}
					break;

			}

			// AST REWRITE
			// elements: elq, p2, no_proof, p1, elq, no_proof, no_proof, pr, pr, p1, ac, ac, po, ac, elq, elq, p2, ac, po, no_proof
			// token labels: pr, no_proof, po
			// rule labels: p1, p2, ac, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_pr=new RewriteRuleTokenStream(adaptor,"token pr",pr);
			RewriteRuleTokenStream stream_no_proof=new RewriteRuleTokenStream(adaptor,"token no_proof",no_proof);
			RewriteRuleTokenStream stream_po=new RewriteRuleTokenStream(adaptor,"token po",po);
			RewriteRuleSubtreeStream stream_p1=new RewriteRuleSubtreeStream(adaptor,"rule p1",p1!=null?p1.getTree():null);
			RewriteRuleSubtreeStream stream_p2=new RewriteRuleSubtreeStream(adaptor,"rule p2",p2!=null?p2.getTree():null);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"rule ac",ac!=null?ac.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1901:5: -> {pr==null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? )
			if (pr==null & po==null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:31: ^( SUBPROGRAM_ANNEX ( $ac)? $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1901:61: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1902:5: -> {pr!=null & po==null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? )
			if (pr!=null & po==null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:31: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:55: ^( $pr $p1)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_pr.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1902:73: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1903:5: -> {pr==null & po!=null}? ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? )
			if (pr==null & po!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:31: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $po $p2) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:51: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:55: ^( $po $p2)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_po.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p2.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1903:72: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1904:5: -> ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:8: ^( SUBPROGRAM_ANNEX ( $ac)? ^( $pr $p1) ^( $po $p2) $elq ( $no_proof)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(SUBPROGRAM_ANNEX, "SUBPROGRAM_ANNEX"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:28: ( $ac)?
				if ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:32: ^( $pr $p1)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_pr.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:43: ^( $po $p2)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_po.nextNode(), root_2);
				adaptor.addChild(root_2, stream_p2.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1904:60: ( $no_proof)?
				if ( stream_no_proof.hasNext() ) {
					adaptor.addChild(root_1, stream_no_proof.nextNode());
				}
				stream_no_proof.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subprogramBehavior,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subprogram_behavior"


	public static class asserted_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "asserted_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1909:1: asserted_action : (pre= assertion )? s= action (post= assertion )? -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) ) ;
	public final BLESStoASTParser.asserted_action_return asserted_action() throws RecognitionException {
		BLESStoASTParser.asserted_action_return retval = new BLESStoASTParser.asserted_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope pre =null;
		ParserRuleReturnScope s =null;
		ParserRuleReturnScope post =null;

		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1911:3: ( (pre= assertion )? s= action (post= assertion )? -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:3: (pre= assertion )? s= action (post= assertion )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:6: (pre= assertion )?
			int alt44=2;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==LASS) ) {
				alt44=1;
			}
			switch (alt44) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1912:6: pre= assertion
					{
					pushFollow(FOLLOW_assertion_in_asserted_action5585);
					pre=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(pre.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_action_in_asserted_action5594);
			s=action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_action.add(s.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1914:7: (post= assertion )?
			int alt45=2;
			int LA45_0 = input.LA(1);
			if ( (LA45_0==LASS) ) {
				alt45=1;
			}
			switch (alt45) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1914:7: post= assertion
					{
					pushFollow(FOLLOW_assertion_in_asserted_action5600);
					post=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(post.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: pre, post, s
			// token labels: 
			// rule labels: pre, s, post, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_pre=new RewriteRuleSubtreeStream(adaptor,"rule pre",pre!=null?pre.getTree():null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.getTree():null);
			RewriteRuleSubtreeStream stream_post=new RewriteRuleSubtreeStream(adaptor,"rule post",post!=null?post.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1915:5: -> ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1916:5: ^( ACTION[$s.tree.getToken(),\"ACTION[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] ^( P[\"P\"] ( $pre)? ) ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s) ^( Q[\"Q\"] ( $post)? ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ACTION, (s!=null?((BAST)s.getTree()):null).getToken(), "ACTION["+Integer.toString((s!=null?((BAST)s.getTree()):null).getLine()+startingLine)+"]"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1917:9: ^( P[\"P\"] ( $pre)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(P, "P"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1917:20: ( $pre)?
				if ( stream_pre.hasNext() ) {
					adaptor.addChild(root_2, stream_pre.nextTree());
				}
				stream_pre.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1918:9: ^( S[$s.tree.getToken(),\"S[\"+Integer.toString($s.tree.getLine()+startingLine)+\"]\"] $s)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(S, (s!=null?((BAST)s.getTree()):null).getToken(), "S["+Integer.toString((s!=null?((BAST)s.getTree()):null).getLine()+startingLine)+"]"), root_2);
				adaptor.addChild(root_2, stream_s.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1919:9: ^( Q[\"Q\"] ( $post)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(Q, "Q"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1919:20: ( $post)?
				if ( stream_post.hasNext() ) {
					adaptor.addChild(root_2, stream_post.nextTree());
				}
				stream_post.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(s!=null?((BAST)s.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertedAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "asserted_action"


	public static class action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1925:1: action : ( basic_action | alternative | while_loop | for_loop | do_until_loop | existential_lattice_quantification | universal_lattice_quantification );
	public final BLESStoASTParser.action_return action() throws RecognitionException {
		BLESStoASTParser.action_return retval = new BLESStoASTParser.action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope basic_action38 =null;
		ParserRuleReturnScope alternative39 =null;
		ParserRuleReturnScope while_loop40 =null;
		ParserRuleReturnScope for_loop41 =null;
		ParserRuleReturnScope do_until_loop42 =null;
		ParserRuleReturnScope existential_lattice_quantification43 =null;
		ParserRuleReturnScope universal_lattice_quantification44 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1926:3: ( basic_action | alternative | while_loop | for_loop | do_until_loop | existential_lattice_quantification | universal_lattice_quantification )
			int alt46=7;
			switch ( input.LA(1) ) {
			case ID:
			case LITERAL_computation:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_pause:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_when:
			case LPAREN:
				{
				alt46=1;
				}
				break;
			case LITERAL_if:
				{
				alt46=2;
				}
				break;
			case LITERAL_while:
				{
				alt46=3;
				}
				break;
			case LITERAL_for:
				{
				alt46=4;
				}
				break;
			case LITERAL_do:
				{
				alt46=5;
				}
				break;
			case LCURLY:
			case LITERAL_declare:
				{
				alt46=6;
				}
				break;
			case LITERAL_forall:
				{
				alt46=7;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 46, 0, input);
				throw nvae;
			}
			switch (alt46) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1927:3: basic_action
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_basic_action_in_action5721);
					basic_action38=basic_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, basic_action38.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1928:5: alternative
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_alternative_in_action5727);
					alternative39=alternative();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, alternative39.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1929:5: while_loop
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_while_loop_in_action5733);
					while_loop40=while_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, while_loop40.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1930:5: for_loop
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_for_loop_in_action5739);
					for_loop41=for_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, for_loop41.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1931:5: do_until_loop
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_do_until_loop_in_action5745);
					do_until_loop42=do_until_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, do_until_loop42.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1932:5: existential_lattice_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_existential_lattice_quantification_in_action5751);
					existential_lattice_quantification43=existential_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, existential_lattice_quantification43.getTree());

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1933:5: universal_lattice_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_universal_lattice_quantification_in_action5757);
					universal_lattice_quantification44=universal_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, universal_lattice_quantification44.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.action,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "action"


	public static class alternative_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "alternative"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1938:1: alternative : lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi -> ^( $lif ( $alt)+ ) ;
	public final BLESStoASTParser.alternative_return alternative() throws RecognitionException {
		BLESStoASTParser.alternative_return retval = new BLESStoASTParser.alternative_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lif=null;
		Token string_literal45=null;
		Token LITERAL_fi46=null;
		List<Object> list_alt=null;
		RuleReturnScope alt = null;
		BAST lif_tree=null;
		BAST string_literal45_tree=null;
		BAST LITERAL_fi46_tree=null;
		RewriteRuleTokenStream stream_LITERAL_fi=new RewriteRuleTokenStream(adaptor,"token LITERAL_fi");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_BOX=new RewriteRuleTokenStream(adaptor,"token BOX");
		RewriteRuleSubtreeStream stream_guarded_action=new RewriteRuleSubtreeStream(adaptor,"rule guarded_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1939:3: (lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi -> ^( $lif ( $alt)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1940:3: lif= LITERAL_if alt+= guarded_action ( '[]' alt+= guarded_action )+ LITERAL_fi
			{
			lif=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_alternative5784); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_if.add(lif);

			pushFollow(FOLLOW_guarded_action_in_alternative5792);
			alt=guarded_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_guarded_action.add(alt.getTree());
			if (list_alt==null) list_alt=new ArrayList<Object>();
			list_alt.add(alt.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1943:3: ( '[]' alt+= guarded_action )+
			int cnt47=0;
			loop47:
			while (true) {
				int alt47=2;
				int LA47_0 = input.LA(1);
				if ( (LA47_0==BOX) ) {
					alt47=1;
				}

				switch (alt47) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1943:5: '[]' alt+= guarded_action
					{
					string_literal45=(Token)match(input,BOX,FOLLOW_BOX_in_alternative5798); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_BOX.add(string_literal45);

					pushFollow(FOLLOW_guarded_action_in_alternative5802);
					alt=guarded_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_guarded_action.add(alt.getTree());
					if (list_alt==null) list_alt=new ArrayList<Object>();
					list_alt.add(alt.getTree());
					}
					break;

				default :
					if ( cnt47 >= 1 ) break loop47;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(47, input);
					throw eee;
				}
				cnt47++;
			}

			LITERAL_fi46=(Token)match(input,LITERAL_fi,FOLLOW_LITERAL_fi_in_alternative5810); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_fi.add(LITERAL_fi46);

			// AST REWRITE
			// elements: lif, alt
			// token labels: lif
			// rule labels: retval
			// token list labels: 
			// rule list labels: alt
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lif=new RewriteRuleTokenStream(adaptor,"token lif",lif);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_alt=new RewriteRuleSubtreeStream(adaptor,"token alt",list_alt);
			root_0 = (BAST)adaptor.nil();
			// 1945:5: -> ^( $lif ( $alt)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1945:8: ^( $lif ( $alt)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lif.nextNode(), root_1);
				if ( !(stream_alt.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_alt.hasNext() ) {
					adaptor.addChild(root_1, stream_alt.nextTree());
				}
				stream_alt.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.alternative,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "alternative"


	public static class guarded_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "guarded_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1951:1: guarded_action : LPAREN ! expression_or_relation GUARD ^ asserted_action ;
	public final BLESStoASTParser.guarded_action_return guarded_action() throws RecognitionException {
		BLESStoASTParser.guarded_action_return retval = new BLESStoASTParser.guarded_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN47=null;
		Token GUARD49=null;
		ParserRuleReturnScope expression_or_relation48 =null;
		ParserRuleReturnScope asserted_action50 =null;

		BAST LPAREN47_tree=null;
		BAST GUARD49_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1952:3: ( LPAREN ! expression_or_relation GUARD ^ asserted_action )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1953:3: LPAREN ! expression_or_relation GUARD ^ asserted_action
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN47=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_guarded_action5853); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_guarded_action5857);
			expression_or_relation48=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_relation48.getTree());

			GUARD49=(Token)match(input,GUARD,FOLLOW_GUARD_in_guarded_action5859); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			GUARD49_tree = (BAST)adaptor.create(GUARD49);
			root_0 = (BAST)adaptor.becomeRoot(GUARD49_tree, root_0);
			}

			pushFollow(FOLLOW_asserted_action_in_guarded_action5862);
			asserted_action50=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, asserted_action50.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.guardedAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "guarded_action"


	public static class universal_lattice_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "universal_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1958:1: universal_lattice_quantification : lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification -> ^( $lf $lv ^( $li $r) $elq) ;
	public final BLESStoASTParser.universal_lattice_quantification_return universal_lattice_quantification() throws RecognitionException {
		BLESStoASTParser.universal_lattice_quantification_return retval = new BLESStoASTParser.universal_lattice_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lf=null;
		Token li=null;
		ParserRuleReturnScope lv =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope elq =null;

		BAST lf_tree=null;
		BAST li_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_forall=new RewriteRuleTokenStream(adaptor,"token LITERAL_forall");
		RewriteRuleSubtreeStream stream_lattice_variables=new RewriteRuleSubtreeStream(adaptor,"rule lattice_variables");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_range=new RewriteRuleSubtreeStream(adaptor,"rule range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1959:3: (lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification -> ^( $lf $lv ^( $li $r) $elq) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1960:3: lf= LITERAL_forall lv= lattice_variables li= LITERAL_in r= range elq= existential_lattice_quantification
			{
			lf=(Token)match(input,LITERAL_forall,FOLLOW_LITERAL_forall_in_universal_lattice_quantification5889); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_forall.add(lf);

			pushFollow(FOLLOW_lattice_variables_in_universal_lattice_quantification5898);
			lv=lattice_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_lattice_variables.add(lv.getTree());
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_universal_lattice_quantification5902); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_range_in_universal_lattice_quantification5906);
			r=range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_range.add(r.getTree());
			pushFollow(FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5915);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// AST REWRITE
			// elements: li, elq, lv, lf, r
			// token labels: lf, li
			// rule labels: r, lv, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lf=new RewriteRuleTokenStream(adaptor,"token lf",lf);
			RewriteRuleTokenStream stream_li=new RewriteRuleTokenStream(adaptor,"token li",li);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
			RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1964:5: -> ^( $lf $lv ^( $li $r) $elq)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1964:8: ^( $lf $lv ^( $li $r) $elq)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lf.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lv.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1964:18: ^( $li $r)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_li.nextNode(), root_2);
				adaptor.addChild(root_2, stream_r.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.ulq,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_lattice_quantification"


	public static class lattice_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "lattice_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1969:1: lattice_variables : i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )? -> {com!=null}? ^( $com $i1 ( $i)+ ) -> $i1;
	public final BLESStoASTParser.lattice_variables_return lattice_variables() throws RecognitionException {
		BLESStoASTParser.lattice_variables_return retval = new BLESStoASTParser.lattice_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token com=null;
		Token COMMA51=null;
		List<Object> list_i=null;
		ParserRuleReturnScope i1 =null;
		RuleReturnScope i = null;
		BAST com_tree=null;
		BAST COMMA51_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1970:3: (i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )? -> {com!=null}? ^( $com $i1 ( $i)+ ) -> $i1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:3: i1= identifier (com= COMMA i+= identifier ( COMMA i+= identifier )* )?
			{
			pushFollow(FOLLOW_identifier_in_lattice_variables5966);
			i1=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:17: (com= COMMA i+= identifier ( COMMA i+= identifier )* )?
			int alt49=2;
			int LA49_0 = input.LA(1);
			if ( (LA49_0==COMMA) ) {
				alt49=1;
			}
			switch (alt49) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:18: com= COMMA i+= identifier ( COMMA i+= identifier )*
					{
					com=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5971); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(com);

					pushFollow(FOLLOW_identifier_in_lattice_variables5975);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:42: ( COMMA i+= identifier )*
					loop48:
					while (true) {
						int alt48=2;
						int LA48_0 = input.LA(1);
						if ( (LA48_0==COMMA) ) {
							alt48=1;
						}

						switch (alt48) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1971:43: COMMA i+= identifier
							{
							COMMA51=(Token)match(input,COMMA,FOLLOW_COMMA_in_lattice_variables5978); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA51);

							pushFollow(FOLLOW_identifier_in_lattice_variables5982);
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							break loop48;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: i1, i1, i, com
			// token labels: com
			// rule labels: i1, retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_com=new RewriteRuleTokenStream(adaptor,"token com",com);
			RewriteRuleSubtreeStream stream_i1=new RewriteRuleSubtreeStream(adaptor,"rule i1",i1!=null?i1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (BAST)adaptor.nil();
			// 1972:5: -> {com!=null}? ^( $com $i1 ( $i)+ )
			if (com!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1972:20: ^( $com $i1 ( $i)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_com.nextNode(), root_1);
				adaptor.addChild(root_1, stream_i1.nextTree());
				if ( !(stream_i.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_i.hasNext() ) {
					adaptor.addChild(root_1, stream_i.nextTree());
				}
				stream_i.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1973:5: -> $i1
			{
				adaptor.addChild(root_0, stream_i1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lattice_variables"


	public static class while_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "while_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1978:1: while_loop : lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq) ;
	public final BLESStoASTParser.while_loop_return while_loop() throws RecognitionException {
		BLESStoASTParser.while_loop_return retval = new BLESStoASTParser.while_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lw=null;
		Token LPAREN52=null;
		Token RPAREN53=null;
		Token LITERAL_invariant54=null;
		Token LITERAL_bound55=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope bd =null;
		ParserRuleReturnScope elq =null;

		BAST lw_tree=null;
		BAST LPAREN52_tree=null;
		BAST RPAREN53_tree=null;
		BAST LITERAL_invariant54_tree=null;
		BAST LITERAL_bound55_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_bound=new RewriteRuleTokenStream(adaptor,"token LITERAL_bound");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_LITERAL_while=new RewriteRuleTokenStream(adaptor,"token LITERAL_while");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_existential_lattice_quantification=new RewriteRuleSubtreeStream(adaptor,"rule existential_lattice_quantification");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1979:3: (lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1980:3: lw= LITERAL_while LPAREN be= expression_or_relation RPAREN ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? elq= existential_lattice_quantification
			{
			lw=(Token)match(input,LITERAL_while,FOLLOW_LITERAL_while_in_while_loop6044); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_while.add(lw);

			LPAREN52=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_while_loop6050); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN52);

			pushFollow(FOLLOW_expression_or_relation_in_while_loop6055);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
			RPAREN53=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_while_loop6057); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN53);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1983:3: ( LITERAL_invariant inv= assertion )?
			int alt50=2;
			int LA50_0 = input.LA(1);
			if ( (LA50_0==LITERAL_invariant) ) {
				alt50=1;
			}
			switch (alt50) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1983:5: LITERAL_invariant inv= assertion
					{
					LITERAL_invariant54=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_while_loop6064); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant54);

					pushFollow(FOLLOW_assertion_in_while_loop6068);
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:3: ( LITERAL_bound bd= expression )?
			int alt51=2;
			int LA51_0 = input.LA(1);
			if ( (LA51_0==LITERAL_bound) ) {
				alt51=1;
			}
			switch (alt51) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1984:5: LITERAL_bound bd= expression
					{
					LITERAL_bound55=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_while_loop6077); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound55);

					pushFollow(FOLLOW_expression_in_while_loop6082);
					bd=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(bd.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_existential_lattice_quantification_in_while_loop6093);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_existential_lattice_quantification.add(elq.getTree());
			// AST REWRITE
			// elements: inv, elq, lw, be, bd
			// token labels: lw
			// rule labels: inv, bd, be, elq, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lw=new RewriteRuleTokenStream(adaptor,"token lw",lw);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_bd=new RewriteRuleSubtreeStream(adaptor,"rule bd",bd!=null?bd.getTree():null);
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_elq=new RewriteRuleSubtreeStream(adaptor,"rule elq",elq!=null?elq.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 1986:5: -> ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:8: ^( $lw $be ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$lw,\"BOUND\"] ( $bd)? ) $elq)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lw.nextNode(), root_1);
				adaptor.addChild(root_1, stream_be.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:18: ^( INVARIANT[$lw,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, lw, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:48: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:54: ^( BOUND[$lw,\"BOUND\"] ( $bd)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BOUND, lw, "BOUND"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1986:76: ( $bd)?
				if ( stream_bd.hasNext() ) {
					adaptor.addChild(root_2, stream_bd.nextTree());
				}
				stream_bd.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_elq.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.whileLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "while_loop"


	public static class for_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "for_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1991:1: for_loop : lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act) ;
	public final BLESStoASTParser.for_loop_return for_loop() throws RecognitionException {
		BLESStoASTParser.for_loop_return retval = new BLESStoASTParser.for_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lf=null;
		Token li=null;
		Token DOTDOT56=null;
		Token LITERAL_invariant57=null;
		Token LCURLY58=null;
		Token RCURLY59=null;
		ParserRuleReturnScope a =null;
		ParserRuleReturnScope lb =null;
		ParserRuleReturnScope ub =null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope act =null;

		BAST lf_tree=null;
		BAST li_tree=null;
		BAST DOTDOT56_tree=null;
		BAST LITERAL_invariant57_tree=null;
		BAST LCURLY58_tree=null;
		BAST RCURLY59_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_for=new RewriteRuleTokenStream(adaptor,"token LITERAL_for");
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1992:3: (lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1993:3: lf= LITERAL_for a= identifier li= LITERAL_in lb= expression DOTDOT ub= expression ( LITERAL_invariant inv= assertion )? LCURLY act= behavior_actions RCURLY
			{
			lf=(Token)match(input,LITERAL_for,FOLLOW_LITERAL_for_in_for_loop6158); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_for.add(lf);

			pushFollow(FOLLOW_identifier_in_for_loop6166);
			a=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
			li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_for_loop6171); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

			pushFollow(FOLLOW_expression_in_for_loop6176);
			lb=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(lb.getTree());
			DOTDOT56=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_for_loop6178); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT56);

			pushFollow(FOLLOW_expression_in_for_loop6183);
			ub=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(ub.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1998:3: ( LITERAL_invariant inv= assertion )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==LITERAL_invariant) ) {
				alt52=1;
			}
			switch (alt52) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:1998:5: LITERAL_invariant inv= assertion
					{
					LITERAL_invariant57=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_for_loop6192); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant57);

					pushFollow(FOLLOW_assertion_in_for_loop6196);
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			LCURLY58=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_for_loop6203); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY58);

			pushFollow(FOLLOW_behavior_actions_in_for_loop6208);
			act=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_behavior_actions.add(act.getTree());
			RCURLY59=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_for_loop6210); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY59);

			// AST REWRITE
			// elements: act, a, ub, li, lb, inv, lf
			// token labels: lf, li
			// rule labels: inv, a, act, lb, ub, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lf=new RewriteRuleTokenStream(adaptor,"token lf",lf);
			RewriteRuleTokenStream stream_li=new RewriteRuleTokenStream(adaptor,"token li",li);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
			RewriteRuleSubtreeStream stream_act=new RewriteRuleSubtreeStream(adaptor,"rule act",act!=null?act.getTree():null);
			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,"rule lb",lb!=null?lb.getTree():null);
			RewriteRuleSubtreeStream stream_ub=new RewriteRuleSubtreeStream(adaptor,"rule ub",ub!=null?ub.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2001:5: -> ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:7: ^( $lf $a ^( $li $lb $ub) ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? ) $act)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lf.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:16: ^( $li $lb $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_li.nextNode(), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:31: ^( INVARIANT[$lf,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, lf, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2001:61: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_act.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.forLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_loop"


	public static class do_until_loop_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "do_until_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2006:1: do_until_loop : ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba) ;
	public final BLESStoASTParser.do_until_loop_return do_until_loop() throws RecognitionException {
		BLESStoASTParser.do_until_loop_return retval = new BLESStoASTParser.do_until_loop_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ld=null;
		Token lu=null;
		Token LITERAL_invariant60=null;
		Token LITERAL_bound61=null;
		Token LPAREN62=null;
		Token RPAREN63=null;
		ParserRuleReturnScope inv =null;
		ParserRuleReturnScope bd =null;
		ParserRuleReturnScope ba =null;
		ParserRuleReturnScope be =null;

		BAST ld_tree=null;
		BAST lu_tree=null;
		BAST LITERAL_invariant60_tree=null;
		BAST LITERAL_bound61_tree=null;
		BAST LPAREN62_tree=null;
		BAST RPAREN63_tree=null;
		RewriteRuleTokenStream stream_LITERAL_invariant=new RewriteRuleTokenStream(adaptor,"token LITERAL_invariant");
		RewriteRuleTokenStream stream_LITERAL_bound=new RewriteRuleTokenStream(adaptor,"token LITERAL_bound");
		RewriteRuleTokenStream stream_LITERAL_until=new RewriteRuleTokenStream(adaptor,"token LITERAL_until");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_LITERAL_do=new RewriteRuleTokenStream(adaptor,"token LITERAL_do");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_behavior_actions=new RewriteRuleSubtreeStream(adaptor,"rule behavior_actions");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2007:3: (ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2008:3: ld= LITERAL_do ( LITERAL_invariant inv= assertion )? ( LITERAL_bound bd= expression )? ba= behavior_actions lu= LITERAL_until LPAREN be= expression_or_relation RPAREN
			{
			ld=(Token)match(input,LITERAL_do,FOLLOW_LITERAL_do_in_do_until_loop6280); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_do.add(ld);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2010:3: ( LITERAL_invariant inv= assertion )?
			int alt53=2;
			int LA53_0 = input.LA(1);
			if ( (LA53_0==LITERAL_invariant) ) {
				alt53=1;
			}
			switch (alt53) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2010:5: LITERAL_invariant inv= assertion
					{
					LITERAL_invariant60=(Token)match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_do_until_loop6288); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_invariant.add(LITERAL_invariant60);

					pushFollow(FOLLOW_assertion_in_do_until_loop6292);
					inv=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(inv.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2011:3: ( LITERAL_bound bd= expression )?
			int alt54=2;
			int LA54_0 = input.LA(1);
			if ( (LA54_0==LITERAL_bound) ) {
				alt54=1;
			}
			switch (alt54) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2011:5: LITERAL_bound bd= expression
					{
					LITERAL_bound61=(Token)match(input,LITERAL_bound,FOLLOW_LITERAL_bound_in_do_until_loop6301); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_bound.add(LITERAL_bound61);

					pushFollow(FOLLOW_expression_in_do_until_loop6306);
					bd=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(bd.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_behavior_actions_in_do_until_loop6317);
			ba=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_behavior_actions.add(ba.getTree());
			lu=(Token)match(input,LITERAL_until,FOLLOW_LITERAL_until_in_do_until_loop6323); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_until.add(lu);

			LPAREN62=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_do_until_loop6325); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN62);

			pushFollow(FOLLOW_expression_or_relation_in_do_until_loop6330);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
			RPAREN63=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_do_until_loop6332); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN63);

			// AST REWRITE
			// elements: bd, ba, ld, be, inv, lu
			// token labels: ld, lu
			// rule labels: inv, bd, be, retval, ba
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_ld=new RewriteRuleTokenStream(adaptor,"token ld",ld);
			RewriteRuleTokenStream stream_lu=new RewriteRuleTokenStream(adaptor,"token lu",lu);
			RewriteRuleSubtreeStream stream_inv=new RewriteRuleSubtreeStream(adaptor,"rule inv",inv!=null?inv.getTree():null);
			RewriteRuleSubtreeStream stream_bd=new RewriteRuleSubtreeStream(adaptor,"rule bd",bd!=null?bd.getTree():null);
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ba=new RewriteRuleSubtreeStream(adaptor,"rule ba",ba!=null?ba.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2014:5: -> ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:7: ^( $ld ^( $lu $be) ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? ) ^( BOUND[$ld,\"BOUND\"] ( $bd)? ) $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_ld.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:13: ^( $lu $be)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_lu.nextNode(), root_2);
				adaptor.addChild(root_2, stream_be.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:24: ^( INVARIANT[$ld,\"INVARIANT\"] ( $inv)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVARIANT, ld, "INVARIANT"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:54: ( $inv)?
				if ( stream_inv.hasNext() ) {
					adaptor.addChild(root_2, stream_inv.nextTree());
				}
				stream_inv.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:60: ^( BOUND[$ld,\"BOUND\"] ( $bd)? )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BOUND, ld, "BOUND"), root_2);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2014:82: ( $bd)?
				if ( stream_bd.hasNext() ) {
					adaptor.addChild(root_2, stream_bd.nextTree());
				}
				stream_bd.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.doUntilLoop,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "do_until_loop"


	public static class basic_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "basic_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2019:1: basic_action : ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception );
	public final BLESStoASTParser.basic_action_return basic_action() throws RecognitionException {
		BLESStoASTParser.basic_action_return retval = new BLESStoASTParser.basic_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_skip64=null;
		Token LITERAL_setmode68=null;
		ParserRuleReturnScope assignment65 =null;
		ParserRuleReturnScope communication_action66 =null;
		ParserRuleReturnScope computation_action67 =null;
		ParserRuleReturnScope identifier69 =null;
		ParserRuleReturnScope when_throw70 =null;
		ParserRuleReturnScope combinable_operation71 =null;
		ParserRuleReturnScope simultaneous_assignment72 =null;
		ParserRuleReturnScope issue_exception73 =null;

		BAST LITERAL_skip64_tree=null;
		BAST LITERAL_setmode68_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2020:3: ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception )
			int alt55=9;
			alt55 = dfa55.predict(input);
			switch (alt55) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2021:3: LITERAL_skip
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_skip64=(Token)match(input,LITERAL_skip,FOLLOW_LITERAL_skip_in_basic_action6402); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_skip64_tree = (BAST)adaptor.create(LITERAL_skip64);
					adaptor.addChild(root_0, LITERAL_skip64_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2022:5: assignment
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_assignment_in_basic_action6408);
					assignment65=assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assignment65.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2024:5: communication_action
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_communication_action_in_basic_action6415);
					communication_action66=communication_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, communication_action66.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2025:5: computation_action
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_computation_action_in_basic_action6422);
					computation_action67=computation_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, computation_action67.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2026:5: LITERAL_setmode identifier
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_setmode68=(Token)match(input,LITERAL_setmode,FOLLOW_LITERAL_setmode_in_basic_action6428); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_setmode68_tree = (BAST)adaptor.create(LITERAL_setmode68);
					adaptor.addChild(root_0, LITERAL_setmode68_tree);
					}

					pushFollow(FOLLOW_identifier_in_basic_action6431);
					identifier69=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier69.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2027:5: when_throw
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_when_throw_in_basic_action6437);
					when_throw70=when_throw();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, when_throw70.getTree());

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2028:5: combinable_operation
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_combinable_operation_in_basic_action6443);
					combinable_operation71=combinable_operation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, combinable_operation71.getTree());

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2029:5: simultaneous_assignment
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_simultaneous_assignment_in_basic_action6449);
					simultaneous_assignment72=simultaneous_assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, simultaneous_assignment72.getTree());

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2030:5: issue_exception
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_issue_exception_in_basic_action6455);
					issue_exception73=issue_exception();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, issue_exception73.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.basicAction,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "basic_action"


	public static class assignment_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2035:1: assignment : nt= name_tick a= ASSIGN eort= expression_or_record_term -> ^( $a $nt $eort) ;
	public final BLESStoASTParser.assignment_return assignment() throws RecognitionException {
		BLESStoASTParser.assignment_return retval = new BLESStoASTParser.assignment_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		ParserRuleReturnScope nt =null;
		ParserRuleReturnScope eort =null;

		BAST a_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression_or_record_term=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_record_term");
		RewriteRuleSubtreeStream stream_name_tick=new RewriteRuleSubtreeStream(adaptor,"rule name_tick");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2036:3: (nt= name_tick a= ASSIGN eort= expression_or_record_term -> ^( $a $nt $eort) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2037:2: nt= name_tick a= ASSIGN eort= expression_or_record_term
			{
			pushFollow(FOLLOW_name_tick_in_assignment6482);
			nt=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name_tick.add(nt.getTree());
			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignment6486); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_assignment6490);
			eort=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_record_term.add(eort.getTree());
			// AST REWRITE
			// elements: eort, a, nt
			// token labels: a
			// rule labels: eort, nt, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_eort=new RewriteRuleSubtreeStream(adaptor,"rule eort",eort!=null?eort.getTree():null);
			RewriteRuleSubtreeStream stream_nt=new RewriteRuleSubtreeStream(adaptor,"rule nt",nt!=null?nt.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2038:5: -> ^( $a $nt $eort)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2038:8: ^( $a $nt $eort)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				adaptor.addChild(root_1, stream_nt.nextTree());
				adaptor.addChild(root_1, stream_eort.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignment"


	public static class name_tick_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "name_tick"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2046:1: name_tick : name ( TICK ^)? ;
	public final BLESStoASTParser.name_tick_return name_tick() throws RecognitionException {
		BLESStoASTParser.name_tick_return retval = new BLESStoASTParser.name_tick_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK75=null;
		ParserRuleReturnScope name74 =null;

		BAST TICK75_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2047:3: ( name ( TICK ^)? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2048:17: name ( TICK ^)?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_name_in_name_tick6534);
			name74=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, name74.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2048:22: ( TICK ^)?
			int alt56=2;
			int LA56_0 = input.LA(1);
			if ( (LA56_0==TICK) ) {
				alt56=1;
			}
			switch (alt56) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2048:24: TICK ^
					{
					TICK75=(Token)match(input,TICK,FOLLOW_TICK_in_name_tick6538); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TICK75_tree = (BAST)adaptor.create(TICK75);
					root_0 = (BAST)adaptor.becomeRoot(TICK75_tree, root_0);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name_tick"


	public static class expression_or_record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2051:1: expression_or_record_term : ( ( LBRACKET ID COLON )=>rt= record_term |e= expression |any= LITERAL_any );
	public final BLESStoASTParser.expression_or_record_term_return expression_or_record_term() throws RecognitionException {
		BLESStoASTParser.expression_or_record_term_return retval = new BLESStoASTParser.expression_or_record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token any=null;
		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope e =null;

		BAST any_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2052:3: ( ( LBRACKET ID COLON )=>rt= record_term |e= expression |any= LITERAL_any )
			int alt57=3;
			switch ( input.LA(1) ) {
			case LBRACKET:
				{
				int LA57_1 = input.LA(2);
				if ( (synpred1_BLESStoAST()) ) {
					alt57=1;
				}
				else if ( (true) ) {
					alt57=2;
				}

				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt57=2;
				}
				break;
			case LITERAL_any:
				{
				alt57=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 57, 0, input);
				throw nvae;
			}
			switch (alt57) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2053:3: ( LBRACKET ID COLON )=>rt= record_term
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_record_term_in_expression_or_record_term6572);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rt.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2054:3: e= expression
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_expression_in_expression_or_record_term6580);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, e.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2054:19: any= LITERAL_any
					{
					root_0 = (BAST)adaptor.nil();


					any=(Token)match(input,LITERAL_any,FOLLOW_LITERAL_any_in_expression_or_record_term6587); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					any_tree = (BAST)adaptor.create(any);
					adaptor.addChild(root_0, any_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_record_term"


	public static class record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2057:1: record_term : LBRACKET typeid= ID COLON (prv+= record_value )+ RBRACKET -> ^( RECORD_TERM[\"RECORD_TERM\"] $typeid ( $prv)+ ) ;
	public final BLESStoASTParser.record_term_return record_term() throws RecognitionException {
		BLESStoASTParser.record_term_return retval = new BLESStoASTParser.record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token typeid=null;
		Token LBRACKET76=null;
		Token COLON77=null;
		Token RBRACKET78=null;
		List<Object> list_prv=null;
		RuleReturnScope prv = null;
		BAST typeid_tree=null;
		BAST LBRACKET76_tree=null;
		BAST COLON77_tree=null;
		BAST RBRACKET78_tree=null;
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_record_value=new RewriteRuleSubtreeStream(adaptor,"rule record_value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2058:3: ( LBRACKET typeid= ID COLON (prv+= record_value )+ RBRACKET -> ^( RECORD_TERM[\"RECORD_TERM\"] $typeid ( $prv)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2059:3: LBRACKET typeid= ID COLON (prv+= record_value )+ RBRACKET
			{
			LBRACKET76=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_record_term6602); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET76);

			typeid=(Token)match(input,ID,FOLLOW_ID_in_record_term6606); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(typeid);

			COLON77=(Token)match(input,COLON,FOLLOW_COLON_in_record_term6608); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON77);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2059:31: (prv+= record_value )+
			int cnt58=0;
			loop58:
			while (true) {
				int alt58=2;
				int LA58_0 = input.LA(1);
				if ( (LA58_0==ID) ) {
					alt58=1;
				}

				switch (alt58) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2059:31: prv+= record_value
					{
					pushFollow(FOLLOW_record_value_in_record_term6612);
					prv=record_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_value.add(prv.getTree());
					if (list_prv==null) list_prv=new ArrayList<Object>();
					list_prv.add(prv.getTree());
					}
					break;

				default :
					if ( cnt58 >= 1 ) break loop58;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(58, input);
					throw eee;
				}
				cnt58++;
			}

			RBRACKET78=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_record_term6615); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET78);

			// AST REWRITE
			// elements: prv, typeid
			// token labels: typeid
			// rule labels: retval
			// token list labels: 
			// rule list labels: prv
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_typeid=new RewriteRuleTokenStream(adaptor,"token typeid",typeid);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_prv=new RewriteRuleSubtreeStream(adaptor,"token prv",list_prv);
			root_0 = (BAST)adaptor.nil();
			// 2060:5: -> ^( RECORD_TERM[\"RECORD_TERM\"] $typeid ( $prv)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2060:8: ^( RECORD_TERM[\"RECORD_TERM\"] $typeid ( $prv)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(RECORD_TERM, "RECORD_TERM"), root_1);
				adaptor.addChild(root_1, stream_typeid.nextNode());
				if ( !(stream_prv.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_prv.hasNext() ) {
					adaptor.addChild(root_1, stream_prv.nextTree());
				}
				stream_prv.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_term"


	public static class record_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2063:1: record_value : identifier ARROW ^ value SEMICOLON !;
	public final BLESStoASTParser.record_value_return record_value() throws RecognitionException {
		BLESStoASTParser.record_value_return retval = new BLESStoASTParser.record_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ARROW80=null;
		Token SEMICOLON82=null;
		ParserRuleReturnScope identifier79 =null;
		ParserRuleReturnScope value81 =null;

		BAST ARROW80_tree=null;
		BAST SEMICOLON82_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2064:3: ( identifier ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2065:20: identifier ARROW ^ value SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_identifier_in_record_value6652);
			identifier79=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier79.getTree());

			ARROW80=(Token)match(input,ARROW,FOLLOW_ARROW_in_record_value6654); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ARROW80_tree = (BAST)adaptor.create(ARROW80);
			root_0 = (BAST)adaptor.becomeRoot(ARROW80_tree, root_0);
			}

			pushFollow(FOLLOW_value_in_record_value6657);
			value81=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value81.getTree());

			SEMICOLON82=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_value6659); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_value"


	public static class simultaneous_assignment_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "simultaneous_assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2068:1: simultaneous_assignment : LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) ) ;
	public final BLESStoASTParser.simultaneous_assignment_return simultaneous_assignment() throws RecognitionException {
		BLESStoASTParser.simultaneous_assignment_return retval = new BLESStoASTParser.simultaneous_assignment_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token left_comma=null;
		Token a=null;
		Token right_comma=null;
		Token LPAREN83=null;
		Token RPAREN84=null;
		List<Object> list_lhs=null;
		List<Object> list_rhs=null;
		RuleReturnScope lhs = null;
		RuleReturnScope rhs = null;
		BAST left_comma_tree=null;
		BAST a_tree=null;
		BAST right_comma_tree=null;
		BAST LPAREN83_tree=null;
		BAST RPAREN84_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression_or_record_term=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_record_term");
		RewriteRuleSubtreeStream stream_name_tick=new RewriteRuleSubtreeStream(adaptor,"rule name_tick");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2087:3: ( LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2088:3: LPAREN lhs+= name_tick (left_comma= COMMA lhs+= name_tick )+ a= ASSIGN rhs+= expression_or_record_term (right_comma= COMMA rhs+= expression_or_record_term )+ RPAREN
			{
			LPAREN83=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_simultaneous_assignment6685); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN83);

			pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6689);
			lhs=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name_tick.add(lhs.getTree());
			if (list_lhs==null) list_lhs=new ArrayList<Object>();
			list_lhs.add(lhs.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2088:25: (left_comma= COMMA lhs+= name_tick )+
			int cnt59=0;
			loop59:
			while (true) {
				int alt59=2;
				int LA59_0 = input.LA(1);
				if ( (LA59_0==COMMA) ) {
					alt59=1;
				}

				switch (alt59) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2088:27: left_comma= COMMA lhs+= name_tick
					{
					left_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6695); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(left_comma);

					pushFollow(FOLLOW_name_tick_in_simultaneous_assignment6699);
					lhs=name_tick();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name_tick.add(lhs.getTree());
					if (list_lhs==null) list_lhs=new ArrayList<Object>();
					list_lhs.add(lhs.getTree());
					}
					break;

				default :
					if ( cnt59 >= 1 ) break loop59;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(59, input);
					throw eee;
				}
				cnt59++;
			}

			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_simultaneous_assignment6709); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASSIGN.add(a);

			pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6713);
			rhs=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_record_term.add(rhs.getTree());
			if (list_rhs==null) list_rhs=new ArrayList<Object>();
			list_rhs.add(rhs.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2089:43: (right_comma= COMMA rhs+= expression_or_record_term )+
			int cnt60=0;
			loop60:
			while (true) {
				int alt60=2;
				int LA60_0 = input.LA(1);
				if ( (LA60_0==COMMA) ) {
					alt60=1;
				}

				switch (alt60) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2089:45: right_comma= COMMA rhs+= expression_or_record_term
					{
					right_comma=(Token)match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment6719); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(right_comma);

					pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment6723);
					rhs=expression_or_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_record_term.add(rhs.getTree());
					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}
					break;

				default :
					if ( cnt60 >= 1 ) break loop60;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(60, input);
					throw eee;
				}
				cnt60++;
			}

			RPAREN84=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_simultaneous_assignment6728); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN84);

			// AST REWRITE
			// elements: lhs, rhs, right_comma, a, left_comma
			// token labels: a, right_comma, left_comma
			// rule labels: retval
			// token list labels: 
			// rule list labels: lhs, rhs
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleTokenStream stream_right_comma=new RewriteRuleTokenStream(adaptor,"token right_comma",right_comma);
			RewriteRuleTokenStream stream_left_comma=new RewriteRuleTokenStream(adaptor,"token left_comma",left_comma);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"token lhs",list_lhs);
			RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"token rhs",list_rhs);
			root_0 = (BAST)adaptor.nil();
			// 2090:5: -> ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2090:8: ^( $a ^( $left_comma ( $lhs)+ ) ^( $right_comma ( $rhs)+ ) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2090:13: ^( $left_comma ( $lhs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_left_comma.nextNode(), root_2);
				if ( !(stream_lhs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_lhs.hasNext() ) {
					adaptor.addChild(root_2, stream_lhs.nextTree());
				}
				stream_lhs.reset();

				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2090:36: ^( $right_comma ( $rhs)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_right_comma.nextNode(), root_2);
				if ( !(stream_rhs.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_rhs.hasNext() ) {
					adaptor.addChild(root_2, stream_rhs.nextTree());
				}
				stream_rhs.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {
			    if (retval.tree==null) throw new YouIdiot("No retval.tree in simultaneous_assignment");
			    if (!retval.tree.hasType(BLESStoASTLexer.ASSIGN)) throw new YouIdiot(
			      "retval.tree must be := for simulatneous assignmen",retval.tree);
			    if (retval.tree.getChildCount()!=2) throw new YouIdiot(" := must have two children",retval.tree);
			    BAST lhc=(BAST)retval.tree.getChild(0); 
			    BAST rhc=(BAST)retval.tree.getChild(1); 
			    if (!lhc.hasType(BLESStoASTLexer.COMMA) || !rhc.hasType(BLESStoASTLexer.COMMA))
			      throw new YouIdiot(" children of := must be ,",retval.tree);
			    if (lhc.getChildCount()!=rhc.getChildCount())
			      {
			      Dump.it("\n\nBoth sides of simulatneous assignment must have equal number of terms:  "+
			          lhc.getChildCount()+" is not "+rhc.getChildCount());
			      throw new YouIdiot("simultaneous assignment "+
			      (lhc.getChildCount()>rhc.getChildCount()?"more variables than expressions":"more expressions than variables")
			      ,retval.tree);
			      }
			  }
		}
		catch (YouIdiot yi) {
			yi.handleException();
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simultaneous_assignment"


	public static class issue_exception_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "issue_exception"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2094:1: issue_exception : LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !;
	public final BLESStoASTParser.issue_exception_return issue_exception() throws RecognitionException {
		BLESStoASTParser.issue_exception_return retval = new BLESStoASTParser.issue_exception_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token message=null;
		Token LITERAL_exception85=null;
		Token LPAREN86=null;
		Token COMMA87=null;
		Token RPAREN88=null;
		ParserRuleReturnScope exception_state =null;

		BAST message_tree=null;
		BAST LITERAL_exception85_tree=null;
		BAST LPAREN86_tree=null;
		BAST COMMA87_tree=null;
		BAST RPAREN88_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2095:3: ( LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2096:3: LITERAL_exception ^ LPAREN ! (exception_state= identifier COMMA !)? message= AADL_STRING_LITERAL RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_exception85=(Token)match(input,LITERAL_exception,FOLLOW_LITERAL_exception_in_issue_exception6790); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_exception85_tree = (BAST)adaptor.create(LITERAL_exception85);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_exception85_tree, root_0);
			}

			LPAREN86=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_issue_exception6793); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2097:3: (exception_state= identifier COMMA !)?
			int alt61=2;
			int LA61_0 = input.LA(1);
			if ( (LA61_0==ID) ) {
				alt61=1;
			}
			switch (alt61) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2097:5: exception_state= identifier COMMA !
					{
					pushFollow(FOLLOW_identifier_in_issue_exception6803);
					exception_state=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exception_state.getTree());

					COMMA87=(Token)match(input,COMMA,FOLLOW_COMMA_in_issue_exception6805); if (state.failed) return retval;
					}
					break;

			}

			message=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_issue_exception6813); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			message_tree = (BAST)adaptor.create(message);
			adaptor.addChild(root_0, message_tree);
			}

			RPAREN88=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_issue_exception6815); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "issue_exception"


	public static class computation_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "computation_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2101:1: computation_action : LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !;
	public final BLESStoASTParser.computation_action_return computation_action() throws RecognitionException {
		BLESStoASTParser.computation_action_return retval = new BLESStoASTParser.computation_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_computation89=null;
		Token LPAREN90=null;
		Token COMMA92=null;
		Token RPAREN94=null;
		ParserRuleReturnScope behavior_time91 =null;
		ParserRuleReturnScope behavior_time93 =null;

		BAST LITERAL_computation89_tree=null;
		BAST LPAREN90_tree=null;
		BAST COMMA92_tree=null;
		BAST RPAREN94_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2102:3: ( LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2103:3: LITERAL_computation ^ LPAREN ! behavior_time ( COMMA ! behavior_time )? RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_computation89=(Token)match(input,LITERAL_computation,FOLLOW_LITERAL_computation_in_computation_action6844); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_computation89_tree = (BAST)adaptor.create(LITERAL_computation89);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_computation89_tree, root_0);
			}

			LPAREN90=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_computation_action6851); if (state.failed) return retval;
			pushFollow(FOLLOW_behavior_time_in_computation_action6854);
			behavior_time91=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time91.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2105:25: ( COMMA ! behavior_time )?
			int alt62=2;
			int LA62_0 = input.LA(1);
			if ( (LA62_0==COMMA) ) {
				alt62=1;
			}
			switch (alt62) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2105:27: COMMA ! behavior_time
					{
					COMMA92=(Token)match(input,COMMA,FOLLOW_COMMA_in_computation_action6858); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_time_in_computation_action6861);
					behavior_time93=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time93.getTree());

					}
					break;

			}

			RPAREN94=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_computation_action6869); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "computation_action"


	public static class behavior_time_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_time"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2113:1: behavior_time : duration= expression u= time_unit -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u) ;
	public final BLESStoASTParser.behavior_time_return behavior_time() throws RecognitionException {
		BLESStoASTParser.behavior_time_return retval = new BLESStoASTParser.behavior_time_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope duration =null;
		ParserRuleReturnScope u =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_time_unit=new RewriteRuleSubtreeStream(adaptor,"rule time_unit");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2115:3: (duration= expression u= time_unit -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2116:3: duration= expression u= time_unit
			{
			pushFollow(FOLLOW_expression_in_behavior_time6900);
			duration=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(duration.getTree());
			pushFollow(FOLLOW_time_unit_in_behavior_time6905);
			u=time_unit();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_time_unit.add(u.getTree());
			// AST REWRITE
			// elements: u, duration
			// token labels: 
			// rule labels: duration, u, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_duration=new RewriteRuleSubtreeStream(adaptor,"rule duration",duration!=null?duration.getTree():null);
			RewriteRuleSubtreeStream stream_u=new RewriteRuleSubtreeStream(adaptor,"rule u",u!=null?u.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2117:5: -> ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2117:8: ^( BEHAVIOR_TIME[\"BEHAVIOR_TIME\"] $duration $u)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(BEHAVIOR_TIME, "BEHAVIOR_TIME"), root_1);
				adaptor.addChild(root_1, stream_duration.nextTree());
				adaptor.addChild(root_1, stream_u.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(duration!=null?((BAST)duration.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_time"


	public static class time_unit_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_unit"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2122:1: time_unit : ( LITERAL_ps | LITERAL_ns | LITERAL_us | LITERAL_ms | LITERAL_sec | LITERAL_min | LITERAL_hr );
	public final BLESStoASTParser.time_unit_return time_unit() throws RecognitionException {
		BLESStoASTParser.time_unit_return retval = new BLESStoASTParser.time_unit_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token set95=null;

		BAST set95_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2123:3: ( LITERAL_ps | LITERAL_ns | LITERAL_us | LITERAL_ms | LITERAL_sec | LITERAL_min | LITERAL_hr )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:
			{
			root_0 = (BAST)adaptor.nil();


			set95=input.LT(1);
			if ( input.LA(1)==LITERAL_hr||input.LA(1)==LITERAL_min||input.LA(1)==LITERAL_ms||input.LA(1)==LITERAL_ns||input.LA(1)==LITERAL_ps||input.LA(1)==LITERAL_sec||input.LA(1)==LITERAL_us ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set95));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_unit"


	public static class communication_action_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "communication_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2127:1: communication_action : (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause);
	public final BLESStoASTParser.communication_action_return communication_action() throws RecognitionException {
		BLESStoASTParser.communication_action_return retval = new BLESStoASTParser.communication_action_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token pause=null;
		ParserRuleReturnScope pc =null;
		ParserRuleReturnScope po =null;
		ParserRuleReturnScope pi =null;

		BAST pause_tree=null;
		RewriteRuleTokenStream stream_LITERAL_pause=new RewriteRuleTokenStream(adaptor,"token LITERAL_pause");
		RewriteRuleSubtreeStream stream_port_input=new RewriteRuleSubtreeStream(adaptor,"rule port_input");
		RewriteRuleSubtreeStream stream_port_output=new RewriteRuleSubtreeStream(adaptor,"rule port_output");
		RewriteRuleSubtreeStream stream_procedure_call=new RewriteRuleSubtreeStream(adaptor,"rule procedure_call");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2128:3: (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause)
			int alt63=4;
			alt63 = dfa63.predict(input);
			switch (alt63) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2129:3: pc= procedure_call
					{
					pushFollow(FOLLOW_procedure_call_in_communication_action6995);
					pc=procedure_call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_procedure_call.add(pc.getTree());
					// AST REWRITE
					// elements: pc
					// token labels: 
					// rule labels: pc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_pc=new RewriteRuleSubtreeStream(adaptor,"rule pc",pc!=null?pc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2130:5: -> $pc
					{
						adaptor.addChild(root_0, stream_pc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2132:3: po= port_output
					{
					pushFollow(FOLLOW_port_output_in_communication_action7013);
					po=port_output();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_output.add(po.getTree());
					// AST REWRITE
					// elements: po
					// token labels: 
					// rule labels: retval, po
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_po=new RewriteRuleSubtreeStream(adaptor,"rule po",po!=null?po.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2133:5: -> $po
					{
						adaptor.addChild(root_0, stream_po.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2135:3: pi= port_input
					{
					pushFollow(FOLLOW_port_input_in_communication_action7031);
					pi=port_input();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_input.add(pi.getTree());
					// AST REWRITE
					// elements: pi
					// token labels: 
					// rule labels: pi, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_pi=new RewriteRuleSubtreeStream(adaptor,"rule pi",pi!=null?pi.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2136:5: -> $pi
					{
						adaptor.addChild(root_0, stream_pi.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2138:3: pause= LITERAL_pause
					{
					pause=(Token)match(input,LITERAL_pause,FOLLOW_LITERAL_pause_in_communication_action7049); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_pause.add(pause);

					// AST REWRITE
					// elements: pause
					// token labels: pause
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_pause=new RewriteRuleTokenStream(adaptor,"token pause",pause);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2139:5: -> $pause
					{
						adaptor.addChild(root_0, stream_pause.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "communication_action"


	public static class procedure_call_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "procedure_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2142:1: procedure_call : p= identifier LPAREN (spb= formal_actual_list )? RPAREN -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? ) ;
	public final BLESStoASTParser.procedure_call_return procedure_call() throws RecognitionException {
		BLESStoASTParser.procedure_call_return retval = new BLESStoASTParser.procedure_call_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN96=null;
		Token RPAREN97=null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope spb =null;

		BAST LPAREN96_tree=null;
		BAST RPAREN97_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_formal_actual_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_actual_list");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2144:3: (p= identifier LPAREN (spb= formal_actual_list )? RPAREN -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2145:27: p= identifier LPAREN (spb= formal_actual_list )? RPAREN
			{
			pushFollow(FOLLOW_identifier_in_procedure_call7086);
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
			LPAREN96=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_procedure_call7090); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN96);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2145:61: (spb= formal_actual_list )?
			int alt64=2;
			int LA64_0 = input.LA(1);
			if ( (LA64_0==AADL_STRING_LITERAL||LA64_0==ID||LA64_0==INTEGER_LIT||LA64_0==LBRACKET||LA64_0==LITERAL_false||LA64_0==LITERAL_self||LA64_0==LITERAL_true||LA64_0==LPAREN||LA64_0==OCTOTHORPE||LA64_0==REAL_LIT) ) {
				alt64=1;
			}
			switch (alt64) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2145:61: spb= formal_actual_list
					{
					pushFollow(FOLLOW_formal_actual_list_in_procedure_call7094);
					spb=formal_actual_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_formal_actual_list.add(spb.getTree());
					}
					break;

			}

			RPAREN97=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_procedure_call7097); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN97);

			// AST REWRITE
			// elements: spb, p
			// token labels: 
			// rule labels: p, spb, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
			RewriteRuleSubtreeStream stream_spb=new RewriteRuleSubtreeStream(adaptor,"rule spb",spb!=null?spb.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2146:5: -> ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2146:8: ^( PROCEDURE_CALL[$p.tree.getToken(),\n \"PROCEDURE_CALL[\"+Integer.toString($p.tree.getLine() //+startingLine\n )+\"]\"] $p ( $spb)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PROCEDURE_CALL, (p!=null?((BAST)p.getTree()):null).getToken(), "PROCEDURE_CALL["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_p.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2148:18: ( $spb)?
				if ( stream_spb.hasNext() ) {
					adaptor.addChild(root_1, stream_spb.nextTree());
				}
				stream_spb.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(p!=null?((BAST)p.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  Dump.it("RecognitionException caught by BLESStoAST.procedure_call");
			  Dump.it("Did you forget \"formal:actual\" in your subprogram invocation, "+HelpfulHints.getIdiot()+"?");
			//    tellBNF(GrammarStrings.procedureCall,re,retval.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "procedure_call"


	public static class port_output_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_output"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2157:1: port_output : pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )? -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? ) ;
	public final BLESStoASTParser.port_output_return port_output() throws RecognitionException {
		BLESStoASTParser.port_output_return retval = new BLESStoASTParser.port_output_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token EXCLAMATION98=null;
		Token LPAREN99=null;
		Token RPAREN100=null;
		ParserRuleReturnScope pn =null;
		ParserRuleReturnScope be =null;

		BAST EXCLAMATION98_tree=null;
		BAST LPAREN99_tree=null;
		BAST RPAREN100_tree=null;
		RewriteRuleTokenStream stream_EXCLAMATION=new RewriteRuleTokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2159:3: (pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )? -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2160:5: pn= port_name EXCLAMATION ( LPAREN be= expression_or_relation RPAREN )?
			{
			pushFollow(FOLLOW_port_name_in_port_output7154);
			pn=port_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_port_name.add(pn.getTree());
			EXCLAMATION98=(Token)match(input,EXCLAMATION,FOLLOW_EXCLAMATION_in_port_output7156); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EXCLAMATION.add(EXCLAMATION98);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2160:30: ( LPAREN be= expression_or_relation RPAREN )?
			int alt65=2;
			int LA65_0 = input.LA(1);
			if ( (LA65_0==LPAREN) ) {
				alt65=1;
			}
			switch (alt65) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2160:32: LPAREN be= expression_or_relation RPAREN
					{
					LPAREN99=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_output7160); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN99);

					pushFollow(FOLLOW_expression_or_relation_in_port_output7164);
					be=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_relation.add(be.getTree());
					RPAREN100=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_output7166); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN100);

					}
					break;

			}

			// AST REWRITE
			// elements: be, pn
			// token labels: 
			// rule labels: be, pn, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
			RewriteRuleSubtreeStream stream_pn=new RewriteRuleSubtreeStream(adaptor,"rule pn",pn!=null?pn.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2161:5: -> ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2161:8: ^( PORT_OUTPUT[$pn.tree.getToken(),\n \"PORT_OUTPUT[\"+Integer.toString($pn.tree.getLine() //+startingLine\n )+\"]\"] $pn ( $be)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PORT_OUTPUT, (pn!=null?((BAST)pn.getTree()):null).getToken(), "PORT_OUTPUT["+Integer.toString((pn!=null?((BAST)pn.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_pn.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2163:19: ( $be)?
				if ( stream_be.hasNext() ) {
					adaptor.addChild(root_1, stream_be.nextTree());
				}
				stream_be.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(pn!=null?((BAST)pn.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_output"


	public static class port_input_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_input"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2167:1: port_input : pn2= port_name QUESTION LPAREN n= name RPAREN -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n) ;
	public final BLESStoASTParser.port_input_return port_input() throws RecognitionException {
		BLESStoASTParser.port_input_return retval = new BLESStoASTParser.port_input_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token QUESTION101=null;
		Token LPAREN102=null;
		Token RPAREN103=null;
		ParserRuleReturnScope pn2 =null;
		ParserRuleReturnScope n =null;

		BAST QUESTION101_tree=null;
		BAST LPAREN102_tree=null;
		BAST RPAREN103_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2169:3: (pn2= port_name QUESTION LPAREN n= name RPAREN -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2170:5: pn2= port_name QUESTION LPAREN n= name RPAREN
			{
			pushFollow(FOLLOW_port_name_in_port_input7224);
			pn2=port_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_port_name.add(pn2.getTree());
			QUESTION101=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_port_input7226); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION101);

			LPAREN102=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_port_input7228); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN102);

			pushFollow(FOLLOW_name_in_port_input7233);
			n=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(n.getTree());
			RPAREN103=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_port_input7235); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN103);

			// AST REWRITE
			// elements: n, pn2
			// token labels: 
			// rule labels: pn2, n, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_pn2=new RewriteRuleSubtreeStream(adaptor,"rule pn2",pn2!=null?pn2.getTree():null);
			RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,"rule n",n!=null?n.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2171:6: -> ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2171:9: ^( PORT_INPUT[$pn2.tree.getToken(),\n \"PORT_INPUT[\"+Integer.toString($pn2.tree.getLine() //+startingLine\n )+\"]\"] $pn2 $n)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PORT_INPUT, (pn2!=null?((BAST)pn2.getTree()):null).getToken(), "PORT_INPUT["+Integer.toString((pn2!=null?((BAST)pn2.getTree()):null).getLine()       )+"]"), root_1);
				adaptor.addChild(root_1, stream_pn2.nextTree());
				adaptor.addChild(root_1, stream_n.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(pn2!=null?((BAST)pn2.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_input"


	public static class port_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "port_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2178:1: port_name : ( identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )? | identifier LBRACKET ^ INTEGER_LIT RBRACKET );
	public final BLESStoASTParser.port_name_return port_name() throws RecognitionException {
		BLESStoASTParser.port_name_return retval = new BLESStoASTParser.port_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token PERIOD105=null;
		Token PERIOD107=null;
		Token LBRACKET110=null;
		Token INTEGER_LIT111=null;
		Token RBRACKET112=null;
		ParserRuleReturnScope identifier104 =null;
		ParserRuleReturnScope identifier106 =null;
		ParserRuleReturnScope identifier108 =null;
		ParserRuleReturnScope identifier109 =null;

		BAST PERIOD105_tree=null;
		BAST PERIOD107_tree=null;
		BAST LBRACKET110_tree=null;
		BAST INTEGER_LIT111_tree=null;
		BAST RBRACKET112_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2179:3: ( identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )? | identifier LBRACKET ^ INTEGER_LIT RBRACKET )
			int alt68=2;
			int LA68_0 = input.LA(1);
			if ( (LA68_0==ID) ) {
				int LA68_1 = input.LA(2);
				if ( (LA68_1==EXCLAMATION||LA68_1==PERIOD||LA68_1==QUESTION||LA68_1==TICK) ) {
					alt68=1;
				}
				else if ( (LA68_1==LBRACKET) ) {
					alt68=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 68, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 68, 0, input);
				throw nvae;
			}

			switch (alt68) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2180:12: identifier ( PERIOD ^ identifier ( PERIOD ! identifier )* )?
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_port_name7278);
					identifier104=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier104.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2180:23: ( PERIOD ^ identifier ( PERIOD ! identifier )* )?
					int alt67=2;
					int LA67_0 = input.LA(1);
					if ( (LA67_0==PERIOD) ) {
						alt67=1;
					}
					switch (alt67) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2180:24: PERIOD ^ identifier ( PERIOD ! identifier )*
							{
							PERIOD105=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7281); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD105_tree = (BAST)adaptor.create(PERIOD105);
							root_0 = (BAST)adaptor.becomeRoot(PERIOD105_tree, root_0);
							}

							pushFollow(FOLLOW_identifier_in_port_name7284);
							identifier106=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier106.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2180:43: ( PERIOD ! identifier )*
							loop66:
							while (true) {
								int alt66=2;
								int LA66_0 = input.LA(1);
								if ( (LA66_0==PERIOD) ) {
									alt66=1;
								}

								switch (alt66) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2180:44: PERIOD ! identifier
									{
									PERIOD107=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_port_name7287); if (state.failed) return retval;
									pushFollow(FOLLOW_identifier_in_port_name7290);
									identifier108=identifier();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier108.getTree());

									}
									break;

								default :
									break loop66;
								}
							}

							}
							break;

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2182:12: identifier LBRACKET ^ INTEGER_LIT RBRACKET
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_port_name7304);
					identifier109=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier109.getTree());

					LBRACKET110=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_port_name7306); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LBRACKET110_tree = (BAST)adaptor.create(LBRACKET110);
					root_0 = (BAST)adaptor.becomeRoot(LBRACKET110_tree, root_0);
					}

					INTEGER_LIT111=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_port_name7310); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					INTEGER_LIT111_tree = (BAST)adaptor.create(INTEGER_LIT111);
					adaptor.addChild(root_0, INTEGER_LIT111_tree);
					}

					RBRACKET112=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_port_name7312); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RBRACKET112_tree = (BAST)adaptor.create(RBRACKET112);
					adaptor.addChild(root_0, RBRACKET112_tree);
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_name"


	public static class formal_actual_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_actual_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2185:1: formal_actual_list : fa= formal_actual (c= COMMA fa2+= formal_actual )* -> {c!=null}? ^( $c $fa ( $fa2)+ ) -> $fa;
	public final BLESStoASTParser.formal_actual_list_return formal_actual_list() throws RecognitionException {
		BLESStoASTParser.formal_actual_list_return retval = new BLESStoASTParser.formal_actual_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		List<Object> list_fa2=null;
		ParserRuleReturnScope fa =null;
		RuleReturnScope fa2 = null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal_actual=new RewriteRuleSubtreeStream(adaptor,"rule formal_actual");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2186:3: (fa= formal_actual (c= COMMA fa2+= formal_actual )* -> {c!=null}? ^( $c $fa ( $fa2)+ ) -> $fa)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2187:3: fa= formal_actual (c= COMMA fa2+= formal_actual )*
			{
			pushFollow(FOLLOW_formal_actual_in_formal_actual_list7331);
			fa=formal_actual();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_formal_actual.add(fa.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2187:20: (c= COMMA fa2+= formal_actual )*
			loop69:
			while (true) {
				int alt69=2;
				int LA69_0 = input.LA(1);
				if ( (LA69_0==COMMA) ) {
					alt69=1;
				}

				switch (alt69) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2187:22: c= COMMA fa2+= formal_actual
					{
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_actual_list7337); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_formal_actual_in_formal_actual_list7341);
					fa2=formal_actual();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_formal_actual.add(fa2.getTree());
					if (list_fa2==null) list_fa2=new ArrayList<Object>();
					list_fa2.add(fa2.getTree());
					}
					break;

				default :
					break loop69;
				}
			}

			// AST REWRITE
			// elements: fa, fa2, c, fa
			// token labels: c
			// rule labels: fa, retval
			// token list labels: 
			// rule list labels: fa2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_fa=new RewriteRuleSubtreeStream(adaptor,"rule fa",fa!=null?fa.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_fa2=new RewriteRuleSubtreeStream(adaptor,"token fa2",list_fa2);
			root_0 = (BAST)adaptor.nil();
			// 2188:5: -> {c!=null}? ^( $c $fa ( $fa2)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2188:19: ^( $c $fa ( $fa2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_fa.nextTree());
				if ( !(stream_fa2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_fa2.hasNext() ) {
					adaptor.addChild(root_1, stream_fa2.nextTree());
				}
				stream_fa2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2189:5: -> $fa
			{
				adaptor.addChild(root_0, stream_fa.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual_list"


	public static class formal_actual_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_actual"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2192:1: formal_actual : ( identifier COLON ^)? actual_parameter ;
	public final BLESStoASTParser.formal_actual_return formal_actual() throws RecognitionException {
		BLESStoASTParser.formal_actual_return retval = new BLESStoASTParser.formal_actual_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COLON114=null;
		ParserRuleReturnScope identifier113 =null;
		ParserRuleReturnScope actual_parameter115 =null;

		BAST COLON114_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2193:3: ( ( identifier COLON ^)? actual_parameter )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2194:3: ( identifier COLON ^)? actual_parameter
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2194:3: ( identifier COLON ^)?
			int alt70=2;
			int LA70_0 = input.LA(1);
			if ( (LA70_0==ID) ) {
				int LA70_1 = input.LA(2);
				if ( (LA70_1==COLON) ) {
					alt70=1;
				}
			}
			switch (alt70) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2194:26: identifier COLON ^
					{
					pushFollow(FOLLOW_identifier_in_formal_actual7396);
					identifier113=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier113.getTree());

					COLON114=(Token)match(input,COLON,FOLLOW_COLON_in_formal_actual7398); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COLON114_tree = (BAST)adaptor.create(COLON114);
					root_0 = (BAST)adaptor.becomeRoot(COLON114_tree, root_0);
					}

					}
					break;

			}

			pushFollow(FOLLOW_actual_parameter_in_formal_actual7404);
			actual_parameter115=actual_parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, actual_parameter115.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual"


	public static class actual_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "actual_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2197:1: actual_parameter : ( name | value_constant | parenthesized_subexpression );
	public final BLESStoASTParser.actual_parameter_return actual_parameter() throws RecognitionException {
		BLESStoASTParser.actual_parameter_return retval = new BLESStoASTParser.actual_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope name116 =null;
		ParserRuleReturnScope value_constant117 =null;
		ParserRuleReturnScope parenthesized_subexpression118 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2198:3: ( name | value_constant | parenthesized_subexpression )
			int alt71=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				switch ( input.LA(2) ) {
				case COMMA:
				case LBRACKET:
				case RPAREN:
					{
					alt71=1;
					}
					break;
				case PERIOD:
					{
					int LA71_5 = input.LA(3);
					if ( (LA71_5==ID) ) {
						int LA71_6 = input.LA(4);
						if ( (LA71_6==COMMA||LA71_6==LBRACKET||LA71_6==PERIOD||LA71_6==RPAREN) ) {
							alt71=1;
						}
						else if ( (LA71_6==OCTOTHORPE) ) {
							alt71=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 71, 6, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 71, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

					}
					break;
				case DOUBLE_COLON:
				case OCTOTHORPE:
				case TICK:
					{
					alt71=2;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 71, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
				}
				break;
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_self:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt71=2;
				}
				break;
			case LPAREN:
				{
				alt71=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 71, 0, input);
				throw nvae;
			}
			switch (alt71) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2199:17: name
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_name_in_actual_parameter7423);
					name116=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, name116.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2200:6: value_constant
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_value_constant_in_actual_parameter7431);
					value_constant117=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, value_constant117.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2201:6: parenthesized_subexpression
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_parenthesized_subexpression_in_actual_parameter7439);
					parenthesized_subexpression118=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_subexpression118.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_parameter"


	public static class existential_lattice_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "existential_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2204:1: existential_lattice_quantification : ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )? ;
	public final BLESStoASTParser.existential_lattice_quantification_return existential_lattice_quantification() throws RecognitionException {
		BLESStoASTParser.existential_lattice_quantification_return retval = new BLESStoASTParser.existential_lattice_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LCURLY120=null;
		Token RCURLY122=null;
		ParserRuleReturnScope quantified_variables119 =null;
		ParserRuleReturnScope behavior_actions121 =null;
		ParserRuleReturnScope timeout_clause123 =null;
		ParserRuleReturnScope catch_clause124 =null;

		BAST LCURLY120_tree=null;
		BAST RCURLY122_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2205:3: ( ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2206:3: ( quantified_variables )? LCURLY ^ behavior_actions RCURLY ( timeout_clause )? ( catch_clause )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2206:3: ( quantified_variables )?
			int alt72=2;
			int LA72_0 = input.LA(1);
			if ( (LA72_0==LITERAL_declare) ) {
				alt72=1;
			}
			switch (alt72) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2206:3: quantified_variables
					{
					pushFollow(FOLLOW_quantified_variables_in_existential_lattice_quantification7465);
					quantified_variables119=quantified_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, quantified_variables119.getTree());

					}
					break;

			}

			LCURLY120=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_existential_lattice_quantification7470); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LCURLY120_tree = (BAST)adaptor.create(LCURLY120);
			root_0 = (BAST)adaptor.becomeRoot(LCURLY120_tree, root_0);
			}

			pushFollow(FOLLOW_behavior_actions_in_existential_lattice_quantification7474);
			behavior_actions121=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_actions121.getTree());

			RCURLY122=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_existential_lattice_quantification7476); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RCURLY122_tree = (BAST)adaptor.create(RCURLY122);
			adaptor.addChild(root_0, RCURLY122_tree);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2208:3: ( timeout_clause )?
			int alt73=2;
			int LA73_0 = input.LA(1);
			if ( (LA73_0==LITERAL_timeout) ) {
				alt73=1;
			}
			switch (alt73) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2208:3: timeout_clause
					{
					pushFollow(FOLLOW_timeout_clause_in_existential_lattice_quantification7482);
					timeout_clause123=timeout_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, timeout_clause123.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2209:3: ( catch_clause )?
			int alt74=2;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==LITERAL_catch) ) {
				alt74=1;
			}
			switch (alt74) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2209:3: catch_clause
					{
					pushFollow(FOLLOW_catch_clause_in_existential_lattice_quantification7487);
					catch_clause124=catch_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clause124.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.elq,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_lattice_quantification"


	public static class catch_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "catch_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2214:1: catch_clause : LITERAL_catch ^ ( catch_clause_term )+ ;
	public final BLESStoASTParser.catch_clause_return catch_clause() throws RecognitionException {
		BLESStoASTParser.catch_clause_return retval = new BLESStoASTParser.catch_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_catch125=null;
		ParserRuleReturnScope catch_clause_term126 =null;

		BAST LITERAL_catch125_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2215:3: ( LITERAL_catch ^ ( catch_clause_term )+ )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2216:3: LITERAL_catch ^ ( catch_clause_term )+
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_catch125=(Token)match(input,LITERAL_catch,FOLLOW_LITERAL_catch_in_catch_clause7511); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_catch125_tree = (BAST)adaptor.create(LITERAL_catch125);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_catch125_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2216:18: ( catch_clause_term )+
			int cnt75=0;
			loop75:
			while (true) {
				int alt75=2;
				int LA75_0 = input.LA(1);
				if ( (LA75_0==LPAREN) ) {
					alt75=1;
				}

				switch (alt75) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2216:18: catch_clause_term
					{
					pushFollow(FOLLOW_catch_clause_term_in_catch_clause7514);
					catch_clause_term126=catch_clause_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clause_term126.getTree());

					}
					break;

				default :
					if ( cnt75 >= 1 ) break loop75;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(75, input);
					throw eee;
				}
				cnt75++;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause"


	public static class timeout_clause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timeout_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2219:1: timeout_clause : LITERAL_timeout ^ behavior_time ;
	public final BLESStoASTParser.timeout_clause_return timeout_clause() throws RecognitionException {
		BLESStoASTParser.timeout_clause_return retval = new BLESStoASTParser.timeout_clause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_timeout127=null;
		ParserRuleReturnScope behavior_time128 =null;

		BAST LITERAL_timeout127_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2220:3: ( LITERAL_timeout ^ behavior_time )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2221:3: LITERAL_timeout ^ behavior_time
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_timeout127=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_timeout_clause7530); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_timeout127_tree = (BAST)adaptor.create(LITERAL_timeout127);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout127_tree, root_0);
			}

			pushFollow(FOLLOW_behavior_time_in_timeout_clause7533);
			behavior_time128=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time128.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timeout_clause"


	public static class catch_clause_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "catch_clause_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2224:1: catch_clause_term : LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN -> {a!=null}? ^( $c $a $ba) -> ^( $c ( $ei)+ $ba) ;
	public final BLESStoASTParser.catch_clause_term_return catch_clause_term() throws RecognitionException {
		BLESStoASTParser.catch_clause_term_return retval = new BLESStoASTParser.catch_clause_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		Token c=null;
		Token LPAREN129=null;
		Token RPAREN130=null;
		List<Object> list_ei=null;
		ParserRuleReturnScope ba =null;
		RuleReturnScope ei = null;
		BAST a_tree=null;
		BAST c_tree=null;
		BAST LPAREN129_tree=null;
		BAST RPAREN130_tree=null;
		RewriteRuleTokenStream stream_LITERAL_all=new RewriteRuleTokenStream(adaptor,"token LITERAL_all");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_basic_action=new RewriteRuleSubtreeStream(adaptor,"rule basic_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2225:3: ( LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN -> {a!=null}? ^( $c $a $ba) -> ^( $c ( $ei)+ $ba) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:3: LPAREN ( (ei+= identifier )+ |a= LITERAL_all ) c= COLON ba= basic_action RPAREN
			{
			LPAREN129=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_catch_clause_term7554); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN129);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:10: ( (ei+= identifier )+ |a= LITERAL_all )
			int alt77=2;
			int LA77_0 = input.LA(1);
			if ( (LA77_0==ID) ) {
				alt77=1;
			}
			else if ( (LA77_0==LITERAL_all) ) {
				alt77=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 77, 0, input);
				throw nvae;
			}

			switch (alt77) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:12: (ei+= identifier )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:14: (ei+= identifier )+
					int cnt76=0;
					loop76:
					while (true) {
						int alt76=2;
						int LA76_0 = input.LA(1);
						if ( (LA76_0==ID) ) {
							alt76=1;
						}

						switch (alt76) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:14: ei+= identifier
							{
							pushFollow(FOLLOW_identifier_in_catch_clause_term7561);
							ei=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ei.getTree());
							if (list_ei==null) list_ei=new ArrayList<Object>();
							list_ei.add(ei.getTree());
							}
							break;

						default :
							if ( cnt76 >= 1 ) break loop76;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(76, input);
							throw eee;
						}
						cnt76++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2226:44: a= LITERAL_all
					{
					a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_catch_clause_term7568); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_all.add(a);

					}
					break;

			}

			c=(Token)match(input,COLON,FOLLOW_COLON_in_catch_clause_term7574); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(c);

			pushFollow(FOLLOW_basic_action_in_catch_clause_term7578);
			ba=basic_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_basic_action.add(ba.getTree());
			RPAREN130=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_catch_clause_term7580); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN130);

			// AST REWRITE
			// elements: a, ei, ba, ba, c, c
			// token labels: a, c
			// rule labels: retval, ba
			// token list labels: 
			// rule list labels: ei
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ba=new RewriteRuleSubtreeStream(adaptor,"rule ba",ba!=null?ba.getTree():null);
			RewriteRuleSubtreeStream stream_ei=new RewriteRuleSubtreeStream(adaptor,"token ei",list_ei);
			root_0 = (BAST)adaptor.nil();
			// 2227:5: -> {a!=null}? ^( $c $a $ba)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2227:19: ^( $c $a $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a.nextNode());
				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2228:5: -> ^( $c ( $ei)+ $ba)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2228:8: ^( $c ( $ei)+ $ba)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				if ( !(stream_ei.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ei.hasNext() ) {
					adaptor.addChild(root_1, stream_ei.nextTree());
				}
				stream_ei.reset();

				adaptor.addChild(root_1, stream_ba.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause_term"


	public static class when_throw_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "when_throw"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2231:1: when_throw : LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier ;
	public final BLESStoASTParser.when_throw_return when_throw() throws RecognitionException {
		BLESStoASTParser.when_throw_return retval = new BLESStoASTParser.when_throw_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_when131=null;
		Token LPAREN132=null;
		Token RPAREN134=null;
		Token LITERAL_throw135=null;
		ParserRuleReturnScope expression133 =null;
		ParserRuleReturnScope identifier136 =null;

		BAST LITERAL_when131_tree=null;
		BAST LPAREN132_tree=null;
		BAST RPAREN134_tree=null;
		BAST LITERAL_throw135_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2232:3: ( LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2233:3: LITERAL_when ^ LPAREN ! expression RPAREN ! LITERAL_throw identifier
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_when131=(Token)match(input,LITERAL_when,FOLLOW_LITERAL_when_in_when_throw7636); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_when131_tree = (BAST)adaptor.create(LITERAL_when131);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_when131_tree, root_0);
			}

			LPAREN132=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_when_throw7639); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_when_throw7643);
			expression133=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression133.getTree());

			RPAREN134=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_when_throw7645); if (state.failed) return retval;
			LITERAL_throw135=(Token)match(input,LITERAL_throw,FOLLOW_LITERAL_throw_in_when_throw7648); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_throw135_tree = (BAST)adaptor.create(LITERAL_throw135);
			adaptor.addChild(root_0, LITERAL_throw135_tree);
			}

			pushFollow(FOLLOW_identifier_in_when_throw7651);
			identifier136=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier136.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "when_throw"


	public static class combinable_operation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "combinable_operation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2236:1: combinable_operation : ( LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !);
	public final BLESStoASTParser.combinable_operation_return combinable_operation() throws RecognitionException {
		BLESStoASTParser.combinable_operation_return retval = new BLESStoASTParser.combinable_operation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_fetchadd137=null;
		Token LPAREN138=null;
		Token COMMA140=null;
		Token COMMA142=null;
		Token RPAREN144=null;
		Token LITERAL_fetchor145=null;
		Token LPAREN146=null;
		Token COMMA148=null;
		Token COMMA150=null;
		Token RPAREN152=null;
		Token LITERAL_fetchand153=null;
		Token LPAREN154=null;
		Token COMMA156=null;
		Token COMMA158=null;
		Token RPAREN160=null;
		Token LITERAL_fetchxor161=null;
		Token LPAREN162=null;
		Token COMMA164=null;
		Token COMMA166=null;
		Token RPAREN168=null;
		Token LITERAL_swap169=null;
		Token LPAREN170=null;
		Token COMMA172=null;
		Token COMMA174=null;
		Token RPAREN176=null;
		ParserRuleReturnScope variable_name139 =null;
		ParserRuleReturnScope expression141 =null;
		ParserRuleReturnScope identifier143 =null;
		ParserRuleReturnScope variable_name147 =null;
		ParserRuleReturnScope expression149 =null;
		ParserRuleReturnScope identifier151 =null;
		ParserRuleReturnScope variable_name155 =null;
		ParserRuleReturnScope expression157 =null;
		ParserRuleReturnScope identifier159 =null;
		ParserRuleReturnScope variable_name163 =null;
		ParserRuleReturnScope expression165 =null;
		ParserRuleReturnScope identifier167 =null;
		ParserRuleReturnScope variable_name171 =null;
		ParserRuleReturnScope variable_name173 =null;
		ParserRuleReturnScope identifier175 =null;

		BAST LITERAL_fetchadd137_tree=null;
		BAST LPAREN138_tree=null;
		BAST COMMA140_tree=null;
		BAST COMMA142_tree=null;
		BAST RPAREN144_tree=null;
		BAST LITERAL_fetchor145_tree=null;
		BAST LPAREN146_tree=null;
		BAST COMMA148_tree=null;
		BAST COMMA150_tree=null;
		BAST RPAREN152_tree=null;
		BAST LITERAL_fetchand153_tree=null;
		BAST LPAREN154_tree=null;
		BAST COMMA156_tree=null;
		BAST COMMA158_tree=null;
		BAST RPAREN160_tree=null;
		BAST LITERAL_fetchxor161_tree=null;
		BAST LPAREN162_tree=null;
		BAST COMMA164_tree=null;
		BAST COMMA166_tree=null;
		BAST RPAREN168_tree=null;
		BAST LITERAL_swap169_tree=null;
		BAST LPAREN170_tree=null;
		BAST COMMA172_tree=null;
		BAST COMMA174_tree=null;
		BAST RPAREN176_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2237:3: ( LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !| LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !)
			int alt83=5;
			switch ( input.LA(1) ) {
			case LITERAL_fetchadd:
				{
				alt83=1;
				}
				break;
			case LITERAL_fetchor:
				{
				alt83=2;
				}
				break;
			case LITERAL_fetchand:
				{
				alt83=3;
				}
				break;
			case LITERAL_fetchxor:
				{
				alt83=4;
				}
				break;
			case LITERAL_swap:
				{
				alt83=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 83, 0, input);
				throw nvae;
			}
			switch (alt83) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2238:3: LITERAL_fetchadd ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchadd137=(Token)match(input,LITERAL_fetchadd,FOLLOW_LITERAL_fetchadd_in_combinable_operation7666); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchadd137_tree = (BAST)adaptor.create(LITERAL_fetchadd137);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchadd137_tree, root_0);
					}

					LPAREN138=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7669); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7673);
					variable_name139=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name139.getTree());

					COMMA140=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7675); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7686);
					expression141=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression141.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2239:32: ( COMMA ! identifier )?
					int alt78=2;
					int LA78_0 = input.LA(1);
					if ( (LA78_0==COMMA) ) {
						alt78=1;
					}
					switch (alt78) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2239:34: COMMA ! identifier
							{
							COMMA142=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7690); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7694);
							identifier143=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier143.getTree());

							}
							break;

					}

					RPAREN144=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7699); if (state.failed) return retval;
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2241:3: LITERAL_fetchor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchor145=(Token)match(input,LITERAL_fetchor,FOLLOW_LITERAL_fetchor_in_combinable_operation7708); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchor145_tree = (BAST)adaptor.create(LITERAL_fetchor145);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchor145_tree, root_0);
					}

					LPAREN146=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7711); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7715);
					variable_name147=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name147.getTree());

					COMMA148=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7717); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7728);
					expression149=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression149.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2242:30: ( COMMA ! identifier )?
					int alt79=2;
					int LA79_0 = input.LA(1);
					if ( (LA79_0==COMMA) ) {
						alt79=1;
					}
					switch (alt79) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2242:32: COMMA ! identifier
							{
							COMMA150=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7732); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7736);
							identifier151=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier151.getTree());

							}
							break;

					}

					RPAREN152=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7741); if (state.failed) return retval;
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2244:3: LITERAL_fetchand ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchand153=(Token)match(input,LITERAL_fetchand,FOLLOW_LITERAL_fetchand_in_combinable_operation7750); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchand153_tree = (BAST)adaptor.create(LITERAL_fetchand153);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchand153_tree, root_0);
					}

					LPAREN154=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7753); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7757);
					variable_name155=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name155.getTree());

					COMMA156=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7759); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7770);
					expression157=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression157.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2245:30: ( COMMA ! identifier )?
					int alt80=2;
					int LA80_0 = input.LA(1);
					if ( (LA80_0==COMMA) ) {
						alt80=1;
					}
					switch (alt80) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2245:32: COMMA ! identifier
							{
							COMMA158=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7774); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7778);
							identifier159=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier159.getTree());

							}
							break;

					}

					RPAREN160=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7783); if (state.failed) return retval;
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2247:3: LITERAL_fetchxor ^ LPAREN ! variable_name COMMA ! expression ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_fetchxor161=(Token)match(input,LITERAL_fetchxor,FOLLOW_LITERAL_fetchxor_in_combinable_operation7792); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_fetchxor161_tree = (BAST)adaptor.create(LITERAL_fetchxor161);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_fetchxor161_tree, root_0);
					}

					LPAREN162=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7795); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7799);
					variable_name163=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name163.getTree());

					COMMA164=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7801); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation7812);
					expression165=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression165.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2248:30: ( COMMA ! identifier )?
					int alt81=2;
					int LA81_0 = input.LA(1);
					if ( (LA81_0==COMMA) ) {
						alt81=1;
					}
					switch (alt81) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2248:32: COMMA ! identifier
							{
							COMMA166=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7816); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7820);
							identifier167=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier167.getTree());

							}
							break;

					}

					RPAREN168=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7825); if (state.failed) return retval;
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2250:3: LITERAL_swap ^ LPAREN ! variable_name COMMA ! variable_name ( COMMA ! identifier )? RPAREN !
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_swap169=(Token)match(input,LITERAL_swap,FOLLOW_LITERAL_swap_in_combinable_operation7834); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_swap169_tree = (BAST)adaptor.create(LITERAL_swap169);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_swap169_tree, root_0);
					}

					LPAREN170=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_combinable_operation7838); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7842);
					variable_name171=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name171.getTree());

					COMMA172=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7844); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation7855);
					variable_name173=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_name173.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2251:35: ( COMMA ! identifier )?
					int alt82=2;
					int LA82_0 = input.LA(1);
					if ( (LA82_0==COMMA) ) {
						alt82=1;
					}
					switch (alt82) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2251:37: COMMA ! identifier
							{
							COMMA174=(Token)match(input,COMMA,FOLLOW_COMMA_in_combinable_operation7859); if (state.failed) return retval;
							pushFollow(FOLLOW_identifier_in_combinable_operation7863);
							identifier175=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier175.getTree());

							}
							break;

					}

					RPAREN176=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_combinable_operation7868); if (state.failed) return retval;
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "combinable_operation"


	public static class behavior_actions_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "behavior_actions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2254:1: behavior_actions : aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )? -> {c!=null}? ^( $c $aa ( $as)+ ) -> {amp!=null}? ^( $amp $aa ( $ac)+ ) -> $aa;
	public final BLESStoASTParser.behavior_actions_return behavior_actions() throws RecognitionException {
		BLESStoASTParser.behavior_actions_return retval = new BLESStoASTParser.behavior_actions_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token amp=null;
		Token SEMICOLON177=null;
		Token AMPERSAND178=null;
		List<Object> list_as=null;
		List<Object> list_ac=null;
		ParserRuleReturnScope aa =null;
		RuleReturnScope as = null;
		RuleReturnScope ac = null;
		BAST c_tree=null;
		BAST amp_tree=null;
		BAST SEMICOLON177_tree=null;
		BAST AMPERSAND178_tree=null;
		RewriteRuleTokenStream stream_AMPERSAND=new RewriteRuleTokenStream(adaptor,"token AMPERSAND");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_asserted_action=new RewriteRuleSubtreeStream(adaptor,"rule asserted_action");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2255:3: (aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )? -> {c!=null}? ^( $c $aa ( $as)+ ) -> {amp!=null}? ^( $amp $aa ( $ac)+ ) -> $aa)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2256:3: aa= asserted_action ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )?
			{
			pushFollow(FOLLOW_asserted_action_in_behavior_actions7891);
			aa=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_asserted_action.add(aa.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2257:5: ( (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* ) | (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* ) )?
			int alt86=3;
			int LA86_0 = input.LA(1);
			if ( (LA86_0==SEMICOLON) ) {
				alt86=1;
			}
			else if ( (LA86_0==AMPERSAND) ) {
				alt86=2;
			}
			switch (alt86) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:5: (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:5: (c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:7: c= SEMICOLON as+= asserted_action ( SEMICOLON as+= asserted_action )*
					{
					c=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7907); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SEMICOLON.add(c);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7911);
					as=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asserted_action.add(as.getTree());
					if (list_as==null) list_as=new ArrayList<Object>();
					list_as.add(as.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:39: ( SEMICOLON as+= asserted_action )*
					loop84:
					while (true) {
						int alt84=2;
						int LA84_0 = input.LA(1);
						if ( (LA84_0==SEMICOLON) ) {
							alt84=1;
						}

						switch (alt84) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2258:41: SEMICOLON as+= asserted_action
							{
							SEMICOLON177=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions7915); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON177);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7919);
							as=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_asserted_action.add(as.getTree());
							if (list_as==null) list_as=new ArrayList<Object>();
							list_as.add(as.getTree());
							}
							break;

						default :
							break loop84;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2260:5: (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2260:5: (amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2260:7: amp= AMPERSAND ac+= asserted_action ( AMPERSAND ac+= asserted_action )*
					{
					amp=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7940); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AMPERSAND.add(amp);

					pushFollow(FOLLOW_asserted_action_in_behavior_actions7944);
					ac=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asserted_action.add(ac.getTree());
					if (list_ac==null) list_ac=new ArrayList<Object>();
					list_ac.add(ac.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2260:41: ( AMPERSAND ac+= asserted_action )*
					loop85:
					while (true) {
						int alt85=2;
						int LA85_0 = input.LA(1);
						if ( (LA85_0==AMPERSAND) ) {
							alt85=1;
						}

						switch (alt85) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2260:43: AMPERSAND ac+= asserted_action
							{
							AMPERSAND178=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions7948); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_AMPERSAND.add(AMPERSAND178);

							pushFollow(FOLLOW_asserted_action_in_behavior_actions7952);
							ac=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_asserted_action.add(ac.getTree());
							if (list_ac==null) list_ac=new ArrayList<Object>();
							list_ac.add(ac.getTree());
							}
							break;

						default :
							break loop85;
						}
					}

					}

					}
					break;

			}

			// AST REWRITE
			// elements: as, aa, ac, amp, aa, c, aa
			// token labels: c, amp
			// rule labels: aa, retval
			// token list labels: 
			// rule list labels: as, ac
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleTokenStream stream_amp=new RewriteRuleTokenStream(adaptor,"token amp",amp);
			RewriteRuleSubtreeStream stream_aa=new RewriteRuleSubtreeStream(adaptor,"rule aa",aa!=null?aa.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_as=new RewriteRuleSubtreeStream(adaptor,"token as",list_as);
			RewriteRuleSubtreeStream stream_ac=new RewriteRuleSubtreeStream(adaptor,"token ac",list_ac);
			root_0 = (BAST)adaptor.nil();
			// 2262:5: -> {c!=null}? ^( $c $aa ( $as)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2262:19: ^( $c $aa ( $as)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aa.nextTree());
				if ( !(stream_as.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_as.hasNext() ) {
					adaptor.addChild(root_1, stream_as.nextTree());
				}
				stream_as.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2263:5: -> {amp!=null}? ^( $amp $aa ( $ac)+ )
			if (amp!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2263:21: ^( $amp $aa ( $ac)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_amp.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aa.nextTree());
				if ( !(stream_ac.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ac.hasNext() ) {
					adaptor.addChild(root_1, stream_ac.nextTree());
				}
				stream_ac.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2264:5: -> $aa
			{
				adaptor.addChild(root_0, stream_aa.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.behaviorActions,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_actions"


	public static class name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2273:1: name : pn1= partial_name (d= PERIOD pn2+= partial_name )* -> {d!=null}? ^( $d $pn1 ( $pn2)+ ) -> $pn1;
	public final BLESStoASTParser.name_return name() throws RecognitionException {
		BLESStoASTParser.name_return retval = new BLESStoASTParser.name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token d=null;
		List<Object> list_pn2=null;
		ParserRuleReturnScope pn1 =null;
		RuleReturnScope pn2 = null;
		BAST d_tree=null;
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleSubtreeStream stream_partial_name=new RewriteRuleSubtreeStream(adaptor,"rule partial_name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2274:3: (pn1= partial_name (d= PERIOD pn2+= partial_name )* -> {d!=null}? ^( $d $pn1 ( $pn2)+ ) -> $pn1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2274:5: pn1= partial_name (d= PERIOD pn2+= partial_name )*
			{
			pushFollow(FOLLOW_partial_name_in_name8047);
			pn1=partial_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_partial_name.add(pn1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2274:22: (d= PERIOD pn2+= partial_name )*
			loop87:
			while (true) {
				int alt87=2;
				int LA87_0 = input.LA(1);
				if ( (LA87_0==PERIOD) ) {
					alt87=1;
				}

				switch (alt87) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2274:24: d= PERIOD pn2+= partial_name
					{
					d=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_name8053); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERIOD.add(d);

					pushFollow(FOLLOW_partial_name_in_name8057);
					pn2=partial_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_partial_name.add(pn2.getTree());
					if (list_pn2==null) list_pn2=new ArrayList<Object>();
					list_pn2.add(pn2.getTree());
					}
					break;

				default :
					break loop87;
				}
			}

			// AST REWRITE
			// elements: d, pn2, pn1, pn1
			// token labels: d
			// rule labels: pn1, retval
			// token list labels: 
			// rule list labels: pn2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
			RewriteRuleSubtreeStream stream_pn1=new RewriteRuleSubtreeStream(adaptor,"rule pn1",pn1!=null?pn1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_pn2=new RewriteRuleSubtreeStream(adaptor,"token pn2",list_pn2);
			root_0 = (BAST)adaptor.nil();
			// 2276:5: -> {d!=null}? ^( $d $pn1 ( $pn2)+ )
			if (d!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2276:19: ^( $d $pn1 ( $pn2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_d.nextNode(), root_1);
				adaptor.addChild(root_1, stream_pn1.nextTree());
				if ( !(stream_pn2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_pn2.hasNext() ) {
					adaptor.addChild(root_1, stream_pn2.nextTree());
				}
				stream_pn2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2277:5: -> $pn1
			{
				adaptor.addChild(root_0, stream_pn1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.name,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name"


	public static class partial_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "partial_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2282:1: partial_name : identifier ( LBRACKET index+= expression_or_range RBRACKET )* -> {index!=null}? ^( identifier ( $index)+ ) -> identifier ;
	public final BLESStoASTParser.partial_name_return partial_name() throws RecognitionException {
		BLESStoASTParser.partial_name_return retval = new BLESStoASTParser.partial_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET180=null;
		Token RBRACKET181=null;
		List<Object> list_index=null;
		ParserRuleReturnScope identifier179 =null;
		RuleReturnScope index = null;
		BAST LBRACKET180_tree=null;
		BAST RBRACKET181_tree=null;
		RewriteRuleTokenStream stream_LBRACKET=new RewriteRuleTokenStream(adaptor,"token LBRACKET");
		RewriteRuleTokenStream stream_RBRACKET=new RewriteRuleTokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_expression_or_range=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2283:3: ( identifier ( LBRACKET index+= expression_or_range RBRACKET )* -> {index!=null}? ^( identifier ( $index)+ ) -> identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2284:3: identifier ( LBRACKET index+= expression_or_range RBRACKET )*
			{
			pushFollow(FOLLOW_identifier_in_partial_name8124);
			identifier179=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(identifier179.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2285:3: ( LBRACKET index+= expression_or_range RBRACKET )*
			loop88:
			while (true) {
				int alt88=2;
				int LA88_0 = input.LA(1);
				if ( (LA88_0==LBRACKET) ) {
					alt88=1;
				}

				switch (alt88) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2285:5: LBRACKET index+= expression_or_range RBRACKET
					{
					LBRACKET180=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_partial_name8133); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LBRACKET.add(LBRACKET180);

					pushFollow(FOLLOW_expression_or_range_in_partial_name8137);
					index=expression_or_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_range.add(index.getTree());
					if (list_index==null) list_index=new ArrayList<Object>();
					list_index.add(index.getTree());
					RBRACKET181=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_partial_name8139); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RBRACKET.add(RBRACKET181);

					}
					break;

				default :
					break loop88;
				}
			}

			// AST REWRITE
			// elements: identifier, index, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: index
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"token index",list_index);
			root_0 = (BAST)adaptor.nil();
			// 2286:3: -> {index!=null}? ^( identifier ( $index)+ )
			if (index!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2286:21: ^( identifier ( $index)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_identifier.nextNode(), root_1);
				if ( !(stream_index.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_index.hasNext() ) {
					adaptor.addChild(root_1, stream_index.nextTree());
				}
				stream_index.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2287:3: -> identifier
			{
				adaptor.addChild(root_0, stream_identifier.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "partial_name"


	public static class parameter_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2290:1: parameter_list : e1= expression_or_range (c= COMMA e2+= expression_or_range )* -> {c!=null}? ^( $c $e1 ( $e2)+ ) -> $e1;
	public final BLESStoASTParser.parameter_list_return parameter_list() throws RecognitionException {
		BLESStoASTParser.parameter_list_return retval = new BLESStoASTParser.parameter_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		List<Object> list_e2=null;
		ParserRuleReturnScope e1 =null;
		RuleReturnScope e2 = null;
		BAST c_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression_or_range=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_range");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2291:3: (e1= expression_or_range (c= COMMA e2+= expression_or_range )* -> {c!=null}? ^( $c $e1 ( $e2)+ ) -> $e1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2292:3: e1= expression_or_range (c= COMMA e2+= expression_or_range )*
			{
			pushFollow(FOLLOW_expression_or_range_in_parameter_list8188);
			e1=expression_or_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_or_range.add(e1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2293:3: (c= COMMA e2+= expression_or_range )*
			loop89:
			while (true) {
				int alt89=2;
				int LA89_0 = input.LA(1);
				if ( (LA89_0==COMMA) ) {
					alt89=1;
				}

				switch (alt89) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2293:5: c= COMMA e2+= expression_or_range
					{
					c=(Token)match(input,COMMA,FOLLOW_COMMA_in_parameter_list8197); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(c);

					pushFollow(FOLLOW_expression_or_range_in_parameter_list8201);
					e2=expression_or_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_range.add(e2.getTree());
					if (list_e2==null) list_e2=new ArrayList<Object>();
					list_e2.add(e2.getTree());
					}
					break;

				default :
					break loop89;
				}
			}

			// AST REWRITE
			// elements: e1, e1, e2, c
			// token labels: c
			// rule labels: e1, retval
			// token list labels: 
			// rule list labels: e2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"token e2",list_e2);
			root_0 = (BAST)adaptor.nil();
			// 2294:5: -> {c!=null}? ^( $c $e1 ( $e2)+ )
			if (c!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2294:19: ^( $c $e1 ( $e2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_c.nextNode(), root_1);
				adaptor.addChild(root_1, stream_e1.nextTree());
				if ( !(stream_e2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_e2.hasNext() ) {
					adaptor.addChild(root_1, stream_e2.nextTree());
				}
				stream_e2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2295:5: -> $e1
			{
				adaptor.addChild(root_0, stream_e1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.parameterList,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameter_list"


	public static class expression_or_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2300:1: expression_or_range : expression ( range_symbol ^ expression )? ;
	public final BLESStoASTParser.expression_or_range_return expression_or_range() throws RecognitionException {
		BLESStoASTParser.expression_or_range_return retval = new BLESStoASTParser.expression_or_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope expression182 =null;
		ParserRuleReturnScope range_symbol183 =null;
		ParserRuleReturnScope expression184 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2301:3: ( expression ( range_symbol ^ expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2302:3: expression ( range_symbol ^ expression )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_expression_in_expression_or_range8263);
			expression182=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression182.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2302:14: ( range_symbol ^ expression )?
			int alt90=2;
			int LA90_0 = input.LA(1);
			if ( ((LA90_0 >= COMMACOMMA && LA90_0 <= COMMADOT)||(LA90_0 >= DOTCOMMA && LA90_0 <= DOTDOT)) ) {
				alt90=1;
			}
			switch (alt90) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2302:16: range_symbol ^ expression
					{
					pushFollow(FOLLOW_range_symbol_in_expression_or_range8267);
					range_symbol183=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol183.getTree(), root_0);
					pushFollow(FOLLOW_expression_in_expression_or_range8270);
					expression184=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression184.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expressionOrRange,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_range"


	public static class variable_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variable_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2307:1: variable_name : name ;
	public final BLESStoASTParser.variable_name_return variable_name() throws RecognitionException {
		BLESStoASTParser.variable_name_return retval = new BLESStoASTParser.variable_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope name185 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2308:3: ( name )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2308:5: name
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_name_in_variable_name8297);
			name185=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, name185.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variable_name"


	public static class expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2316:1: expression : a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.expression_return expression() throws RecognitionException {
		BLESStoASTParser.expression_return retval = new BLESStoASTParser.expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_cor=new RewriteRuleTokenStream(adaptor,"token LITERAL_cor");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleTokenStream stream_LITERAL_cand=new RewriteRuleTokenStream(adaptor,"token LITERAL_cand");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2318:3: (a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2319:3: a1= subexpression ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |)
			{
			pushFollow(FOLLOW_subexpression_in_expression8323);
			a1=subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2320:3: ( (o= PLUS a+= subexpression )+ | (o= TIMES a+= subexpression )+ |o= MINUS a+= subexpression |o= DIVIDE a+= subexpression |o= LITERAL_mod a+= subexpression |o= LITERAL_rem a+= subexpression |o= EXP a+= subexpression | (o= LITERAL_and a+= subexpression )+ | (o= LITERAL_or a+= subexpression )+ | (o= LITERAL_xor a+= subexpression )+ |o= LITERAL_cand a+= subexpression |o= LITERAL_cor a+= subexpression |)
			int alt96=13;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt96=1;
				}
				break;
			case TIMES:
				{
				alt96=2;
				}
				break;
			case MINUS:
				{
				alt96=3;
				}
				break;
			case DIVIDE:
				{
				alt96=4;
				}
				break;
			case LITERAL_mod:
				{
				alt96=5;
				}
				break;
			case LITERAL_rem:
				{
				alt96=6;
				}
				break;
			case EXP:
				{
				alt96=7;
				}
				break;
			case LITERAL_and:
				{
				alt96=8;
				}
				break;
			case LITERAL_or:
				{
				alt96=9;
				}
				break;
			case LITERAL_xor:
				{
				alt96=10;
				}
				break;
			case LITERAL_cand:
				{
				alt96=11;
				}
				break;
			case LITERAL_cor:
				{
				alt96=12;
				}
				break;
			case EOF:
			case AMPERSAND:
			case BOX:
			case COLON:
			case COMMA:
			case COMMACOMMA:
			case COMMADOT:
			case DOTCOMMA:
			case DOTDOT:
			case GUARD:
			case ID:
			case LASS:
			case LCURLY:
			case LITERAL_computation:
			case LITERAL_declare:
			case LITERAL_do:
			case LITERAL_else:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_fi:
			case LITERAL_for:
			case LITERAL_forall:
			case LITERAL_hr:
			case LITERAL_if:
			case LITERAL_invariant:
			case LITERAL_min:
			case LITERAL_ms:
			case LITERAL_ns:
			case LITERAL_pause:
			case LITERAL_ps:
			case LITERAL_sec:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_until:
			case LITERAL_us:
			case LITERAL_when:
			case LITERAL_while:
			case LPAREN:
			case RBRACKET:
			case RCON:
			case RCURLY:
			case RPAREN:
			case SEMICOLON:
				{
				alt96=13;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 96, 0, input);
				throw nvae;
			}
			switch (alt96) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:3: (o= PLUS a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:3: (o= PLUS a+= subexpression )+
					int cnt91=0;
					loop91:
					while (true) {
						int alt91=2;
						int LA91_0 = input.LA(1);
						if ( (LA91_0==PLUS) ) {
							alt91=1;
						}

						switch (alt91) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2322:5: o= PLUS a+= subexpression
							{
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_expression8339); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8343);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt91 >= 1 ) break loop91;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(91, input);
							throw eee;
						}
						cnt91++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2324:3: (o= TIMES a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2324:3: (o= TIMES a+= subexpression )+
					int cnt92=0;
					loop92:
					while (true) {
						int alt92=2;
						int LA92_0 = input.LA(1);
						if ( (LA92_0==TIMES) ) {
							alt92=1;
						}

						switch (alt92) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2324:5: o= TIMES a+= subexpression
							{
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_expression8359); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8363);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt92 >= 1 ) break loop92;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(92, input);
							throw eee;
						}
						cnt92++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2326:3: o= MINUS a+= subexpression
					{
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_expression8377); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8381);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2328:3: o= DIVIDE a+= subexpression
					{
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_expression8392); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8396);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2330:3: o= LITERAL_mod a+= subexpression
					{
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_expression8407); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8411);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2332:3: o= LITERAL_rem a+= subexpression
					{
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_expression8422); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8426);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2334:3: o= EXP a+= subexpression
					{
					o=(Token)match(input,EXP,FOLLOW_EXP_in_expression8437); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8441);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:3: (o= LITERAL_and a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:3: (o= LITERAL_and a+= subexpression )+
					int cnt93=0;
					loop93:
					while (true) {
						int alt93=2;
						int LA93_0 = input.LA(1);
						if ( (LA93_0==LITERAL_and) ) {
							alt93=1;
						}

						switch (alt93) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2336:5: o= LITERAL_and a+= subexpression
							{
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_expression8454); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8458);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt93 >= 1 ) break loop93;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(93, input);
							throw eee;
						}
						cnt93++;
					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:3: (o= LITERAL_or a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:3: (o= LITERAL_or a+= subexpression )+
					int cnt94=0;
					loop94:
					while (true) {
						int alt94=2;
						int LA94_0 = input.LA(1);
						if ( (LA94_0==LITERAL_or) ) {
							alt94=1;
						}

						switch (alt94) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2338:5: o= LITERAL_or a+= subexpression
							{
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_expression8474); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8478);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt94 >= 1 ) break loop94;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(94, input);
							throw eee;
						}
						cnt94++;
					}

					}
					break;
				case 10 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2340:3: (o= LITERAL_xor a+= subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2340:3: (o= LITERAL_xor a+= subexpression )+
					int cnt95=0;
					loop95:
					while (true) {
						int alt95=2;
						int LA95_0 = input.LA(1);
						if ( (LA95_0==LITERAL_xor) ) {
							alt95=1;
						}

						switch (alt95) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2340:5: o= LITERAL_xor a+= subexpression
							{
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_expression8494); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_subexpression_in_expression8498);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt95 >= 1 ) break loop95;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(95, input);
							throw eee;
						}
						cnt95++;
					}

					}
					break;
				case 11 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2342:3: o= LITERAL_cand a+= subexpression
					{
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_expression8512); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8516);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 12 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2344:3: o= LITERAL_cor a+= subexpression
					{
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_expression8527); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_subexpression_in_expression8531);
					a=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 13 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2346:3: 
					{
					}
					break;

			}

			// AST REWRITE
			// elements: a1, a1, o, a
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2348:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2348:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2350:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2355:1: subexpression : ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc);
	public final BLESStoASTParser.subexpression_return subexpression() throws RecognitionException {
		BLESStoASTParser.subexpression_return retval = new BLESStoASTParser.subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		Token n=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope tc =null;
		ParserRuleReturnScope fc =null;

		BAST m_tree=null;
		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_function_call=new RewriteRuleSubtreeStream(adaptor,"rule function_call");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_type_conversion=new RewriteRuleSubtreeStream(adaptor,"rule type_conversion");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2357:3: ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc)
			int alt99=3;
			alt99 = dfa99.predict(input);
			switch (alt99) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2358:3: (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2358:3: (m= MINUS |n= LITERAL_not )?
					int alt97=3;
					int LA97_0 = input.LA(1);
					if ( (LA97_0==MINUS) ) {
						alt97=1;
					}
					else if ( (LA97_0==LITERAL_not) ) {
						alt97=2;
					}
					switch (alt97) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2358:5: m= MINUS
							{
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_subexpression8603); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(m);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2358:15: n= LITERAL_not
							{
							n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subexpression8609); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

							}
							break;

					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2359:3: (v= value |ps= parenthesized_subexpression )
					int alt98=2;
					int LA98_0 = input.LA(1);
					if ( (LA98_0==AADL_STRING_LITERAL||LA98_0==ID||LA98_0==INTEGER_LIT||LA98_0==LBRACKET||LA98_0==LITERAL_false||LA98_0==LITERAL_in||LA98_0==LITERAL_now||LA98_0==LITERAL_null||LA98_0==LITERAL_self||LA98_0==LITERAL_timeout||LA98_0==LITERAL_tops||LA98_0==LITERAL_true||LA98_0==OCTOTHORPE||LA98_0==REAL_LIT) ) {
						alt98=1;
					}
					else if ( (LA98_0==LPAREN) ) {
						alt98=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 98, 0, input);
						throw nvae;
					}

					switch (alt98) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2359:5: v= value
							{
							pushFollow(FOLLOW_value_in_subexpression8621);
							v=value();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_value.add(v.getTree());
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2359:15: ps= parenthesized_subexpression
							{
							pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression8627);
							ps=parenthesized_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: n, ps, v, n, ps, v, v, ps
					// token labels: n
					// rule labels: ps, v, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
					RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2360:5: -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v)
					if (m!=null&&v!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2360:28: ^( UNARY_MINUS[$m] $v)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_v.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2361:5: -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps)
					if (m!=null&&ps!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2361:29: ^( UNARY_MINUS[$m] $ps)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_ps.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2362:5: -> {n!=null&&v!=null}? ^( $n $v)
					if (n!=null&&v!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2362:28: ^( $n $v)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_v.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2363:5: -> {n!=null&&ps!=null}? ^( $n $ps)
					if (n!=null&&ps!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2363:29: ^( $n $ps)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ps.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2364:5: -> {v!=null}? $v
					if (v!=null) {
						adaptor.addChild(root_0, stream_v.nextTree());
					}

					else // 2365:5: -> $ps
					{
						adaptor.addChild(root_0, stream_ps.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2366:5: tc= type_conversion
					{
					pushFollow(FOLLOW_type_conversion_in_subexpression8727);
					tc=type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_conversion.add(tc.getTree());
					// AST REWRITE
					// elements: tc
					// token labels: 
					// rule labels: retval, tc
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_tc=new RewriteRuleSubtreeStream(adaptor,"rule tc",tc!=null?tc.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2367:5: -> $tc
					{
						adaptor.addChild(root_0, stream_tc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2369:3: fc= function_call
					{
					pushFollow(FOLLOW_function_call_in_subexpression8747);
					fc=function_call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_function_call.add(fc.getTree());
					// AST REWRITE
					// elements: fc
					// token labels: 
					// rule labels: fc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_fc=new RewriteRuleSubtreeStream(adaptor,"rule fc",fc!=null?fc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2369:20: -> $fc
					{
						adaptor.addChild(root_0, stream_fc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subexpression"


	public static class type_conversion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2374:1: type_conversion : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression -> ^( $n $ps) ;
	public final BLESStoASTParser.type_conversion_return type_conversion() throws RecognitionException {
		BLESStoASTParser.type_conversion_return retval = new BLESStoASTParser.type_conversion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2375:2: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression -> ^( $n $ps) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2376:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_subexpression
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2376:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt100=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt100=1;
				}
				break;
			case LITERAL_integer:
				{
				alt100=2;
				}
				break;
			case LITERAL_rational:
				{
				alt100=3;
				}
				break;
			case LITERAL_real:
				{
				alt100=4;
				}
				break;
			case LITERAL_complex:
				{
				alt100=5;
				}
				break;
			case LITERAL_time:
				{
				alt100=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 100, 0, input);
				throw nvae;
			}
			switch (alt100) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2376:4: n= LITERAL_natural
					{
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_type_conversion8777); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2377:3: n= LITERAL_integer
					{
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_type_conversion8786); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2378:3: n= LITERAL_rational
					{
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_type_conversion8795); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2379:3: n= LITERAL_real
					{
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_type_conversion8804); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2380:3: n= LITERAL_complex
					{
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_type_conversion8813); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2381:3: n= LITERAL_time
					{
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_type_conversion8821); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion8830);
			ps=parenthesized_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
			// AST REWRITE
			// elements: n, ps
			// token labels: n
			// rule labels: ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2383:5: -> ^( $n $ps)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2383:8: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_conversion"


	public static class assertion_type_conversion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2387:1: assertion_type_conversion : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression -> ^( $n $ps) ;
	public final BLESStoASTParser.assertion_type_conversion_return assertion_type_conversion() throws RecognitionException {
		BLESStoASTParser.assertion_type_conversion_return retval = new BLESStoASTParser.assertion_type_conversion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_parenthesized_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2388:2: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression -> ^( $n $ps) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2389:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) ps= parenthesized_assertion_expression
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2389:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt101=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt101=1;
				}
				break;
			case LITERAL_integer:
				{
				alt101=2;
				}
				break;
			case LITERAL_rational:
				{
				alt101=3;
				}
				break;
			case LITERAL_real:
				{
				alt101=4;
				}
				break;
			case LITERAL_complex:
				{
				alt101=5;
				}
				break;
			case LITERAL_time:
				{
				alt101=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 101, 0, input);
				throw nvae;
			}
			switch (alt101) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2389:4: n= LITERAL_natural
					{
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type_conversion8861); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2390:3: n= LITERAL_integer
					{
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type_conversion8870); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2391:3: n= LITERAL_rational
					{
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type_conversion8879); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2392:3: n= LITERAL_real
					{
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type_conversion8888); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2393:3: n= LITERAL_complex
					{
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type_conversion8897); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2394:3: n= LITERAL_time
					{
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type_conversion8905); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8914);
			ps=parenthesized_assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parenthesized_assertion_expression.add(ps.getTree());
			// AST REWRITE
			// elements: ps, n
			// token labels: n
			// rule labels: ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2396:5: -> ^( $n $ps)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2396:8: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type_conversion"


	public static class boolean_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2400:1: boolean_expression : a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.boolean_expression_return boolean_expression() throws RecognitionException {
		BLESStoASTParser.boolean_expression_return retval = new BLESStoASTParser.boolean_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_cor=new RewriteRuleTokenStream(adaptor,"token LITERAL_cor");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleTokenStream stream_LITERAL_cand=new RewriteRuleTokenStream(adaptor,"token LITERAL_cand");
		RewriteRuleSubtreeStream stream_boolean_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2402:3: (a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2403:3: a1= boolean_subexpression ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |)
			{
			pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8949);
			a1=boolean_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_boolean_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2404:3: ( (o= LITERAL_and a+= boolean_subexpression )+ | (o= LITERAL_or a+= boolean_subexpression )+ | (o= LITERAL_xor a+= boolean_subexpression )+ |o= LITERAL_cand a+= boolean_subexpression |o= LITERAL_cor a+= boolean_subexpression |)
			int alt105=6;
			switch ( input.LA(1) ) {
			case LITERAL_and:
				{
				alt105=1;
				}
				break;
			case LITERAL_or:
				{
				alt105=2;
				}
				break;
			case LITERAL_xor:
				{
				alt105=3;
				}
				break;
			case LITERAL_cand:
				{
				alt105=4;
				}
				break;
			case LITERAL_cor:
				{
				alt105=5;
				}
				break;
			case LITERAL_then:
			case QQ:
			case RPAREN:
				{
				alt105=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 105, 0, input);
				throw nvae;
			}
			switch (alt105) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:3: (o= LITERAL_and a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:3: (o= LITERAL_and a+= boolean_subexpression )+
					int cnt102=0;
					loop102:
					while (true) {
						int alt102=2;
						int LA102_0 = input.LA(1);
						if ( (LA102_0==LITERAL_and) ) {
							alt102=1;
						}

						switch (alt102) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2406:5: o= LITERAL_and a+= boolean_subexpression
							{
							o=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_boolean_expression8965); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8969);
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt102 >= 1 ) break loop102;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(102, input);
							throw eee;
						}
						cnt102++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:3: (o= LITERAL_or a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:3: (o= LITERAL_or a+= boolean_subexpression )+
					int cnt103=0;
					loop103:
					while (true) {
						int alt103=2;
						int LA103_0 = input.LA(1);
						if ( (LA103_0==LITERAL_or) ) {
							alt103=1;
						}

						switch (alt103) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2408:5: o= LITERAL_or a+= boolean_subexpression
							{
							o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_boolean_expression8985); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression8989);
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt103 >= 1 ) break loop103;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(103, input);
							throw eee;
						}
						cnt103++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2410:3: (o= LITERAL_xor a+= boolean_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2410:3: (o= LITERAL_xor a+= boolean_subexpression )+
					int cnt104=0;
					loop104:
					while (true) {
						int alt104=2;
						int LA104_0 = input.LA(1);
						if ( (LA104_0==LITERAL_xor) ) {
							alt104=1;
						}

						switch (alt104) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2410:5: o= LITERAL_xor a+= boolean_subexpression
							{
							o=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_boolean_expression9005); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(o);

							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression9009);
							a=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt104 >= 1 ) break loop104;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(104, input);
							throw eee;
						}
						cnt104++;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2412:3: o= LITERAL_cand a+= boolean_subexpression
					{
					o=(Token)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_boolean_expression9023); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cand.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression9027);
					a=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2414:3: o= LITERAL_cor a+= boolean_subexpression
					{
					o=(Token)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_boolean_expression9038); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_cor.add(o);

					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression9042);
					a=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2416:3: 
					{
					}
					break;

			}

			// AST REWRITE
			// elements: o, a1, a, a1
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2418:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2418:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2420:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression"


	public static class boolean_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2425:1: boolean_subexpression : (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps;
	public final BLESStoASTParser.boolean_subexpression_return boolean_subexpression() throws RecognitionException {
		BLESStoASTParser.boolean_subexpression_return retval = new BLESStoASTParser.boolean_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;

		BAST n_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2427:3: ( (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2428:3: (n= LITERAL_not )? (v= value |ps= parenthesized_subexpression )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2428:3: (n= LITERAL_not )?
			int alt106=2;
			int LA106_0 = input.LA(1);
			if ( (LA106_0==LITERAL_not) ) {
				alt106=1;
			}
			switch (alt106) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2428:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_boolean_subexpression9114); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2429:3: (v= value |ps= parenthesized_subexpression )
			int alt107=2;
			int LA107_0 = input.LA(1);
			if ( (LA107_0==AADL_STRING_LITERAL||LA107_0==ID||LA107_0==INTEGER_LIT||LA107_0==LBRACKET||LA107_0==LITERAL_false||LA107_0==LITERAL_in||LA107_0==LITERAL_now||LA107_0==LITERAL_null||LA107_0==LITERAL_self||LA107_0==LITERAL_timeout||LA107_0==LITERAL_tops||LA107_0==LITERAL_true||LA107_0==OCTOTHORPE||LA107_0==REAL_LIT) ) {
				alt107=1;
			}
			else if ( (LA107_0==LPAREN) ) {
				alt107=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 107, 0, input);
				throw nvae;
			}

			switch (alt107) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2429:5: v= value
					{
					pushFollow(FOLLOW_value_in_boolean_subexpression9126);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2429:15: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_boolean_subexpression9132);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: ps, v, n, v, n, ps
			// token labels: n
			// rule labels: ps, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2430:5: -> {n!=null&&v!=null}? ^( $n $v)
			if (n!=null&&v!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2430:28: ^( $n $v)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_v.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2431:5: -> {n!=null&&ps!=null}? ^( $n $ps)
			if (n!=null&&ps!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2431:29: ^( $n $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2432:5: -> {v!=null}? $v
			if (v!=null) {
				adaptor.addChild(root_0, stream_v.nextTree());
			}

			else // 2433:5: -> $ps
			{
				adaptor.addChild(root_0, stream_ps.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_subexpression"


	public static class numeric_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2438:1: numeric_expression : a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1;
	public final BLESStoASTParser.numeric_expression_return numeric_expression() throws RecognitionException {
		BLESStoASTParser.numeric_expression_return retval = new BLESStoASTParser.numeric_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_a=null;
		ParserRuleReturnScope a1 =null;
		RuleReturnScope a = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_numeric_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule numeric_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2440:3: (a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |) -> {$o!=null}? ^( $o $a1 ( $a)+ ) -> $a1)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2441:3: a1= numeric_subexpression ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |)
			{
			pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9217);
			a1=numeric_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_subexpression.add(a1.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2442:3: ( (o= PLUS a+= numeric_subexpression )+ | (o= TIMES a+= numeric_subexpression )+ |o= MINUS a+= numeric_subexpression |o= DIVIDE a+= numeric_subexpression |o= LITERAL_mod a+= numeric_subexpression |o= LITERAL_rem a+= numeric_subexpression |o= EXP a+= numeric_subexpression |)
			int alt110=8;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt110=1;
				}
				break;
			case TIMES:
				{
				alt110=2;
				}
				break;
			case MINUS:
				{
				alt110=3;
				}
				break;
			case DIVIDE:
				{
				alt110=4;
				}
				break;
			case LITERAL_mod:
				{
				alt110=5;
				}
				break;
			case LITERAL_rem:
				{
				alt110=6;
				}
				break;
			case EXP:
				{
				alt110=7;
				}
				break;
			case COMMACOMMA:
			case COMMADOT:
			case DOTCOMMA:
			case DOTDOT:
			case LCURLY:
			case LITERAL_declare:
				{
				alt110=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 110, 0, input);
				throw nvae;
			}
			switch (alt110) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:3: (o= PLUS a+= numeric_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:3: (o= PLUS a+= numeric_subexpression )+
					int cnt108=0;
					loop108:
					while (true) {
						int alt108=2;
						int LA108_0 = input.LA(1);
						if ( (LA108_0==PLUS) ) {
							alt108=1;
						}

						switch (alt108) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2444:5: o= PLUS a+= numeric_subexpression
							{
							o=(Token)match(input,PLUS,FOLLOW_PLUS_in_numeric_expression9233); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9237);
							a=numeric_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt108 >= 1 ) break loop108;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(108, input);
							throw eee;
						}
						cnt108++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2446:3: (o= TIMES a+= numeric_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2446:3: (o= TIMES a+= numeric_subexpression )+
					int cnt109=0;
					loop109:
					while (true) {
						int alt109=2;
						int LA109_0 = input.LA(1);
						if ( (LA109_0==TIMES) ) {
							alt109=1;
						}

						switch (alt109) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2446:5: o= TIMES a+= numeric_subexpression
							{
							o=(Token)match(input,TIMES,FOLLOW_TIMES_in_numeric_expression9253); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(o);

							pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9257);
							a=numeric_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt109 >= 1 ) break loop109;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(109, input);
							throw eee;
						}
						cnt109++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2448:3: o= MINUS a+= numeric_subexpression
					{
					o=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_expression9271); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9275);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2450:3: o= DIVIDE a+= numeric_subexpression
					{
					o=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_numeric_expression9286); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DIVIDE.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9290);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2452:3: o= LITERAL_mod a+= numeric_subexpression
					{
					o=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_numeric_expression9301); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mod.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9305);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2454:3: o= LITERAL_rem a+= numeric_subexpression
					{
					o=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_numeric_expression9316); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rem.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9320);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2456:3: o= EXP a+= numeric_subexpression
					{
					o=(Token)match(input,EXP,FOLLOW_EXP_in_numeric_expression9331); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EXP.add(o);

					pushFollow(FOLLOW_numeric_subexpression_in_numeric_expression9335);
					a=numeric_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_numeric_subexpression.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2458:3: 
					{
					}
					break;

			}

			// AST REWRITE
			// elements: a1, a1, o, a
			// token labels: o
			// rule labels: a1, retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2460:3: -> {$o!=null}? ^( $o $a1 ( $a)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2460:18: ^( $o $a1 ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_a1.nextTree());
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2462:3: -> $a1
			{
				adaptor.addChild(root_0, stream_a1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			     tellBNF(GrammarStrings.expression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_expression"


	public static class numeric_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2468:1: numeric_subexpression : (m= MINUS )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {v!=null}? $v -> $ps;
	public final BLESStoASTParser.numeric_subexpression_return numeric_subexpression() throws RecognitionException {
		BLESStoASTParser.numeric_subexpression_return retval = new BLESStoASTParser.numeric_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope ps =null;

		BAST m_tree=null;
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_parenthesized_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized_subexpression");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2470:3: ( (m= MINUS )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {v!=null}? $v -> $ps)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2471:3: (m= MINUS )? (v= value |ps= parenthesized_subexpression )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2471:3: (m= MINUS )?
			int alt111=2;
			int LA111_0 = input.LA(1);
			if ( (LA111_0==MINUS) ) {
				alt111=1;
			}
			switch (alt111) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2471:5: m= MINUS
					{
					m=(Token)match(input,MINUS,FOLLOW_MINUS_in_numeric_subexpression9407); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(m);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2472:3: (v= value |ps= parenthesized_subexpression )
			int alt112=2;
			int LA112_0 = input.LA(1);
			if ( (LA112_0==AADL_STRING_LITERAL||LA112_0==ID||LA112_0==INTEGER_LIT||LA112_0==LBRACKET||LA112_0==LITERAL_false||LA112_0==LITERAL_in||LA112_0==LITERAL_now||LA112_0==LITERAL_null||LA112_0==LITERAL_self||LA112_0==LITERAL_timeout||LA112_0==LITERAL_tops||LA112_0==LITERAL_true||LA112_0==OCTOTHORPE||LA112_0==REAL_LIT) ) {
				alt112=1;
			}
			else if ( (LA112_0==LPAREN) ) {
				alt112=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 112, 0, input);
				throw nvae;
			}

			switch (alt112) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2472:5: v= value
					{
					pushFollow(FOLLOW_value_in_numeric_subexpression9419);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2472:15: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_numeric_subexpression9425);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized_subexpression.add(ps.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: ps, ps, v, v
			// token labels: 
			// rule labels: ps, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2473:5: -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v)
			if (m!=null&&v!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2473:28: ^( UNARY_MINUS[$m] $v)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
				adaptor.addChild(root_1, stream_v.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2474:5: -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps)
			if (m!=null&&ps!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2474:29: ^( UNARY_MINUS[$m] $ps)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2475:5: -> {v!=null}? $v
			if (v!=null) {
				adaptor.addChild(root_0, stream_v.nextTree());
			}

			else // 2476:5: -> $ps
			{
				adaptor.addChild(root_0, stream_ps.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    tellBNF(GrammarStrings.subexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_subexpression"


	public static class parenthesized_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2482:1: parenthesized_subexpression : ( ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression -> $ce| ( LPAREN case_choice )=>ce= case_expression -> $ce|lp= LPAREN eor= expression_or_relation rp= RPAREN -> ^( $lp $eor $rp) );
	public final BLESStoASTParser.parenthesized_subexpression_return parenthesized_subexpression() throws RecognitionException {
		BLESStoASTParser.parenthesized_subexpression_return retval = new BLESStoASTParser.parenthesized_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope ce =null;
		ParserRuleReturnScope eor =null;

		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_conditional_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_expression");
		RewriteRuleSubtreeStream stream_case_expression=new RewriteRuleSubtreeStream(adaptor,"rule case_expression");
		RewriteRuleSubtreeStream stream_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2484:3: ( ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression -> $ce| ( LPAREN case_choice )=>ce= case_expression -> $ce|lp= LPAREN eor= expression_or_relation rp= RPAREN -> ^( $lp $eor $rp) )
			int alt113=3;
			int LA113_0 = input.LA(1);
			if ( (LA113_0==LPAREN) ) {
				int LA113_1 = input.LA(2);
				if ( (synpred2_BLESStoAST()) ) {
					alt113=1;
				}
				else if ( (synpred3_BLESStoAST()) ) {
					alt113=2;
				}
				else if ( (true) ) {
					alt113=3;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 113, 0, input);
				throw nvae;
			}

			switch (alt113) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )=>ce= conditional_expression
					{
					pushFollow(FOLLOW_conditional_expression_in_parenthesized_subexpression9527);
					ce=conditional_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_expression.add(ce.getTree());
					// AST REWRITE
					// elements: ce
					// token labels: 
					// rule labels: ce, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ce=new RewriteRuleSubtreeStream(adaptor,"rule ce",ce!=null?ce.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2487:5: -> $ce
					{
						adaptor.addChild(root_0, stream_ce.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2489:3: ( LPAREN case_choice )=>ce= case_expression
					{
					pushFollow(FOLLOW_case_expression_in_parenthesized_subexpression9557);
					ce=case_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_expression.add(ce.getTree());
					// AST REWRITE
					// elements: ce
					// token labels: 
					// rule labels: ce, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ce=new RewriteRuleSubtreeStream(adaptor,"rule ce",ce!=null?ce.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2491:5: -> $ce
					{
						adaptor.addChild(root_0, stream_ce.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2493:3: lp= LPAREN eor= expression_or_relation rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_subexpression9576); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_expression_or_relation_in_parenthesized_subexpression9580);
					eor=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_or_relation.add(eor.getTree());
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_subexpression9584); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: rp, lp, eor
					// token labels: lp, rp
					// rule labels: eor, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_eor=new RewriteRuleSubtreeStream(adaptor,"rule eor",eor!=null?eor.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2494:5: -> ^( $lp $eor $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2494:8: ^( $lp $eor $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_eor.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_subexpression"


	public static class case_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "case_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2497:1: case_expression : lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN -> ^( CASE_EXPRESSION ( $cc)+ ) ;
	public final BLESStoASTParser.case_expression_return case_expression() throws RecognitionException {
		BLESStoASTParser.case_expression_return retval = new BLESStoASTParser.case_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token c=null;
		Token COMMA186=null;
		Token RPAREN187=null;
		List<Object> list_cc=null;
		RuleReturnScope cc = null;
		BAST lp_tree=null;
		BAST c_tree=null;
		BAST COMMA186_tree=null;
		BAST RPAREN187_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_case_choice=new RewriteRuleSubtreeStream(adaptor,"rule case_choice");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2498:3: (lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN -> ^( CASE_EXPRESSION ( $cc)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2499:3: lp= LPAREN cc+= case_choice (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* ) RPAREN
			{
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_expression9621); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			pushFollow(FOLLOW_case_choice_in_case_expression9625);
			cc=case_choice();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
			if (list_cc==null) list_cc=new ArrayList<Object>();
			list_cc.add(cc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2499:29: (c= COMMA cc+= case_choice ( COMMA cc+= case_choice )* )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2499:31: c= COMMA cc+= case_choice ( COMMA cc+= case_choice )*
			{
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9631); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_case_choice_in_case_expression9635);
			cc=case_choice();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
			if (list_cc==null) list_cc=new ArrayList<Object>();
			list_cc.add(cc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2499:55: ( COMMA cc+= case_choice )*
			loop114:
			while (true) {
				int alt114=2;
				int LA114_0 = input.LA(1);
				if ( (LA114_0==COMMA) ) {
					alt114=1;
				}

				switch (alt114) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2499:57: COMMA cc+= case_choice
					{
					COMMA186=(Token)match(input,COMMA,FOLLOW_COMMA_in_case_expression9639); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA186);

					pushFollow(FOLLOW_case_choice_in_case_expression9643);
					cc=case_choice();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_choice.add(cc.getTree());
					if (list_cc==null) list_cc=new ArrayList<Object>();
					list_cc.add(cc.getTree());
					}
					break;

				default :
					break loop114;
				}
			}

			}

			RPAREN187=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_expression9650); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN187);

			// AST REWRITE
			// elements: cc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: cc
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_cc=new RewriteRuleSubtreeStream(adaptor,"token cc",list_cc);
			root_0 = (BAST)adaptor.nil();
			// 2500:5: -> ^( CASE_EXPRESSION ( $cc)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2500:8: ^( CASE_EXPRESSION ( $cc)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CASE_EXPRESSION, "CASE_EXPRESSION"), root_1);
				if ( !(stream_cc.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_cc.hasNext() ) {
					adaptor.addChild(root_1, stream_cc.nextTree());
				}
				stream_cc.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_expression"


	public static class case_choice_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "case_choice"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2504:1: case_choice : LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression ;
	public final BLESStoASTParser.case_choice_return case_choice() throws RecognitionException {
		BLESStoASTParser.case_choice_return retval = new BLESStoASTParser.case_choice_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN188=null;
		Token RPAREN189=null;
		Token IMP190=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope exp =null;

		BAST LPAREN188_tree=null;
		BAST RPAREN189_tree=null;
		BAST IMP190_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2505:3: ( LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2506:3: LPAREN !be= boolean_expression_or_relation RPAREN ! IMP ^exp= expression
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN188=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_case_choice9687); if (state.failed) return retval;
			pushFollow(FOLLOW_boolean_expression_or_relation_in_case_choice9692);
			be=boolean_expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, be.getTree());

			RPAREN189=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_case_choice9694); if (state.failed) return retval;
			IMP190=(Token)match(input,IMP,FOLLOW_IMP_in_case_choice9697); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			IMP190_tree = (BAST)adaptor.create(IMP190);
			root_0 = (BAST)adaptor.becomeRoot(IMP190_tree, root_0);
			}

			pushFollow(FOLLOW_expression_in_case_choice9702);
			exp=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, exp.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_choice"


	public static class conditional_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2509:1: conditional_expression : ( LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN -> ^( CONDITIONAL[$then] $be $t $f) | LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN -> ^( CONDITIONAL[$q] $be $t $f) );
	public final BLESStoASTParser.conditional_expression_return conditional_expression() throws RecognitionException {
		BLESStoASTParser.conditional_expression_return retval = new BLESStoASTParser.conditional_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token then=null;
		Token q=null;
		Token LPAREN191=null;
		Token LITERAL_if192=null;
		Token LITERAL_else193=null;
		Token RPAREN194=null;
		Token LPAREN195=null;
		Token COLON196=null;
		Token RPAREN197=null;
		ParserRuleReturnScope be =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope f =null;

		BAST then_tree=null;
		BAST q_tree=null;
		BAST LPAREN191_tree=null;
		BAST LITERAL_if192_tree=null;
		BAST LITERAL_else193_tree=null;
		BAST RPAREN194_tree=null;
		BAST LPAREN195_tree=null;
		BAST COLON196_tree=null;
		BAST RPAREN197_tree=null;
		RewriteRuleTokenStream stream_QQ=new RewriteRuleTokenStream(adaptor,"token QQ");
		RewriteRuleTokenStream stream_LITERAL_else=new RewriteRuleTokenStream(adaptor,"token LITERAL_else");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_then=new RewriteRuleTokenStream(adaptor,"token LITERAL_then");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_boolean_expression_or_relation=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression_or_relation");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2510:3: ( LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN -> ^( CONDITIONAL[$then] $be $t $f) | LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN -> ^( CONDITIONAL[$q] $be $t $f) )
			int alt115=2;
			int LA115_0 = input.LA(1);
			if ( (LA115_0==LPAREN) ) {
				int LA115_1 = input.LA(2);
				if ( (LA115_1==LITERAL_if) ) {
					alt115=1;
				}
				else if ( (LA115_1==AADL_STRING_LITERAL||LA115_1==ID||LA115_1==INTEGER_LIT||LA115_1==LBRACKET||LA115_1==LITERAL_complex||LA115_1==LITERAL_false||LA115_1==LITERAL_in||LA115_1==LITERAL_integer||LA115_1==LITERAL_natural||(LA115_1 >= LITERAL_not && LA115_1 <= LITERAL_now)||LA115_1==LITERAL_null||(LA115_1 >= LITERAL_rational && LA115_1 <= LITERAL_real)||LA115_1==LITERAL_self||(LA115_1 >= LITERAL_time && LA115_1 <= LITERAL_timeout)||LA115_1==LITERAL_tops||LA115_1==LITERAL_true||LA115_1==LPAREN||LA115_1==MINUS||LA115_1==OCTOTHORPE||LA115_1==REAL_LIT) ) {
					alt115=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 115, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 115, 0, input);
				throw nvae;
			}

			switch (alt115) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2511:3: LPAREN LITERAL_if be= boolean_expression_or_relation then= LITERAL_then t= expression LITERAL_else f= expression RPAREN
					{
					LPAREN191=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9717); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN191);

					LITERAL_if192=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_expression9719); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if192);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9723);
					be=boolean_expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression_or_relation.add(be.getTree());
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_expression9727); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_expression_in_conditional_expression9732);
					t=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(t.getTree());
					LITERAL_else193=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_expression9734); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else193);

					pushFollow(FOLLOW_expression_in_conditional_expression9739);
					f=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(f.getTree());
					RPAREN194=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9741); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN194);

					// AST REWRITE
					// elements: f, be, t
					// token labels: 
					// rule labels: be, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2512:5: -> ^( CONDITIONAL[$then] $be $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2512:8: ^( CONDITIONAL[$then] $be $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, then), root_1);
						adaptor.addChild(root_1, stream_be.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2514:3: LPAREN be= boolean_expression_or_relation q= QQ t= expression COLON f= expression RPAREN
					{
					LPAREN195=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_expression9771); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN195);

					pushFollow(FOLLOW_boolean_expression_or_relation_in_conditional_expression9775);
					be=boolean_expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression_or_relation.add(be.getTree());
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_expression9779); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_expression_in_conditional_expression9784);
					t=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(t.getTree());
					COLON196=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_expression9786); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON196);

					pushFollow(FOLLOW_expression_in_conditional_expression9791);
					f=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(f.getTree());
					RPAREN197=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_expression9793); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN197);

					// AST REWRITE
					// elements: f, t, be
					// token labels: 
					// rule labels: be, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2515:5: -> ^( CONDITIONAL[$q] $be $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2515:8: ^( CONDITIONAL[$q] $be $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, q), root_1);
						adaptor.addChild(root_1, stream_be.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_expression"


	public static class value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2518:1: value : (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops);
	public final BLESStoASTParser.value_return value() throws RecognitionException {
		BLESStoASTParser.value_return retval = new BLESStoASTParser.value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token q=null;
		Token tf=null;
		Token f=null;
		Token tc=null;
		Token c=null;
		Token u=null;
		Token li=null;
		Token timeout=null;
		Token nu=null;
		Token now=null;
		Token tops=null;
		Token string_literal198=null;
		Token LPAREN199=null;
		Token RPAREN200=null;
		List<Object> list_i=null;
		ParserRuleReturnScope vc =null;
		ParserRuleReturnScope pn =null;
		ParserRuleReturnScope nam =null;
		RuleReturnScope i = null;
		BAST q_tree=null;
		BAST tf_tree=null;
		BAST f_tree=null;
		BAST tc_tree=null;
		BAST c_tree=null;
		BAST u_tree=null;
		BAST li_tree=null;
		BAST timeout_tree=null;
		BAST nu_tree=null;
		BAST now_tree=null;
		BAST tops_tree=null;
		BAST string_literal198_tree=null;
		BAST LPAREN199_tree=null;
		BAST RPAREN200_tree=null;
		RewriteRuleTokenStream stream_LITERAL_mode=new RewriteRuleTokenStream(adaptor,"token LITERAL_mode");
		RewriteRuleTokenStream stream_LITERAL_null=new RewriteRuleTokenStream(adaptor,"token LITERAL_null");
		RewriteRuleTokenStream stream_LITERAL_count=new RewriteRuleTokenStream(adaptor,"token LITERAL_count");
		RewriteRuleTokenStream stream_LITERAL_now=new RewriteRuleTokenStream(adaptor,"token LITERAL_now");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_timeout=new RewriteRuleTokenStream(adaptor,"token LITERAL_timeout");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_TICK=new RewriteRuleTokenStream(adaptor,"token TICK");
		RewriteRuleTokenStream stream_LITERAL_fresh=new RewriteRuleTokenStream(adaptor,"token LITERAL_fresh");
		RewriteRuleTokenStream stream_LITERAL_updated=new RewriteRuleTokenStream(adaptor,"token LITERAL_updated");
		RewriteRuleTokenStream stream_LITERAL_tops=new RewriteRuleTokenStream(adaptor,"token LITERAL_tops");
		RewriteRuleSubtreeStream stream_port_name=new RewriteRuleSubtreeStream(adaptor,"rule port_name");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_value_constant=new RewriteRuleSubtreeStream(adaptor,"rule value_constant");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2519:3: (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops)
			int alt118=8;
			alt118 = dfa118.predict(input);
			switch (alt118) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2520:3: vc= value_constant
					{
					pushFollow(FOLLOW_value_constant_in_value9833);
					vc=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value_constant.add(vc.getTree());
					// AST REWRITE
					// elements: vc
					// token labels: 
					// rule labels: vc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_vc=new RewriteRuleSubtreeStream(adaptor,"rule vc",vc!=null?vc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2520:21: -> $vc
					{
						adaptor.addChild(root_0, stream_vc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated )
					{
					pushFollow(FOLLOW_port_name_in_value9885);
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_port_name.add(pn.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:16: (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated )
					int alt116=4;
					int LA116_0 = input.LA(1);
					if ( (LA116_0==QUESTION) ) {
						alt116=1;
					}
					else if ( (LA116_0==TICK) ) {
						switch ( input.LA(2) ) {
						case LITERAL_fresh:
							{
							alt116=2;
							}
							break;
						case LITERAL_count:
							{
							alt116=3;
							}
							break;
						case LITERAL_updated:
							{
							alt116=4;
							}
							break;
						default:
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 116, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 116, 0, input);
						throw nvae;
					}

					switch (alt116) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:18: q= QUESTION
							{
							q=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_value9891); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_QUESTION.add(q);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:31: tf= TICK f= LITERAL_fresh
							{
							tf=(Token)match(input,TICK,FOLLOW_TICK_in_value9897); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tf);

							f=(Token)match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_value9901); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_fresh.add(f);

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:57: tc= TICK c= LITERAL_count
							{
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9907); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							c=(Token)match(input,LITERAL_count,FOLLOW_LITERAL_count_in_value9911); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_count.add(c);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2525:84: tc= TICK u= LITERAL_updated
							{
							tc=(Token)match(input,TICK,FOLLOW_TICK_in_value9918); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TICK.add(tc);

							u=(Token)match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_value9922); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_updated.add(u);

							}
							break;

					}

					// AST REWRITE
					// elements: c, tc, pn, pn, f, q, tc, pn, pn, u, tf
					// token labels: q, tf, c, u, f, tc
					// rule labels: pn, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_q=new RewriteRuleTokenStream(adaptor,"token q",q);
					RewriteRuleTokenStream stream_tf=new RewriteRuleTokenStream(adaptor,"token tf",tf);
					RewriteRuleTokenStream stream_c=new RewriteRuleTokenStream(adaptor,"token c",c);
					RewriteRuleTokenStream stream_u=new RewriteRuleTokenStream(adaptor,"token u",u);
					RewriteRuleTokenStream stream_f=new RewriteRuleTokenStream(adaptor,"token f",f);
					RewriteRuleTokenStream stream_tc=new RewriteRuleTokenStream(adaptor,"token tc",tc);
					RewriteRuleSubtreeStream stream_pn=new RewriteRuleSubtreeStream(adaptor,"rule pn",pn!=null?pn.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2526:5: -> {$f!=null}? ^( $tf $pn $f)
					if (f!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2526:20: ^( $tf $pn $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tf.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_f.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2527:5: -> {$c!=null}? ^( $tc $pn $c)
					if (c!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2527:20: ^( $tc $pn $c)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_c.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2528:5: -> {$u!=null}? ^( $tc $pn $u)
					if (u!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2528:20: ^( $tc $pn $u)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_tc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_1, stream_u.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2529:5: -> ^( $q $pn)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2529:8: ^( $q $pn)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_q.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pn.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2534:3: nam= name
					{
					pushFollow(FOLLOW_name_in_value10017);
					nam=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(nam.getTree());
					// AST REWRITE
					// elements: nam
					// token labels: 
					// rule labels: nam, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_nam=new RewriteRuleSubtreeStream(adaptor,"rule nam",nam!=null?nam.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2534:12: -> $nam
					{
						adaptor.addChild(root_0, stream_nam.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2536:3: li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN
					{
					li=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_value10032); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(li);

					string_literal198=(Token)match(input,LITERAL_mode,FOLLOW_LITERAL_mode_in_value10034); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_mode.add(string_literal198);

					LPAREN199=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_value10036); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN199);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2536:41: (i+= identifier )+
					int cnt117=0;
					loop117:
					while (true) {
						int alt117=2;
						int LA117_0 = input.LA(1);
						if ( (LA117_0==ID) ) {
							alt117=1;
						}

						switch (alt117) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2536:41: i+= identifier
							{
							pushFollow(FOLLOW_identifier_in_value10041);
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTree());
							}
							break;

						default :
							if ( cnt117 >= 1 ) break loop117;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(117, input);
							throw eee;
						}
						cnt117++;
					}

					RPAREN200=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_value10044); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN200);

					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: i
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
					root_0 = (BAST)adaptor.nil();
					// 2537:5: -> ^( INMODE[$li,\"in mode\"] ( $i)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2537:8: ^( INMODE[$li,\"in mode\"] ( $i)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INMODE, li, "in mode"), root_1);
						if ( !(stream_i.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_i.hasNext() ) {
							adaptor.addChild(root_1, stream_i.nextTree());
						}
						stream_i.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2539:3: timeout= LITERAL_timeout
					{
					timeout=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_value10070); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_timeout.add(timeout);

					// AST REWRITE
					// elements: timeout
					// token labels: timeout
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_timeout=new RewriteRuleTokenStream(adaptor,"token timeout",timeout);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2539:27: -> $timeout
					{
						adaptor.addChild(root_0, stream_timeout.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2541:3: nu= LITERAL_null
					{
					nu=(Token)match(input,LITERAL_null,FOLLOW_LITERAL_null_in_value10085); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_null.add(nu);

					// AST REWRITE
					// elements: nu
					// token labels: nu
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_nu=new RewriteRuleTokenStream(adaptor,"token nu",nu);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2541:19: -> $nu
					{
						adaptor.addChild(root_0, stream_nu.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2543:3: now= LITERAL_now
					{
					now=(Token)match(input,LITERAL_now,FOLLOW_LITERAL_now_in_value10100); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_now.add(now);

					// AST REWRITE
					// elements: now
					// token labels: now
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_now=new RewriteRuleTokenStream(adaptor,"token now",now);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2543:19: -> $now
					{
						adaptor.addChild(root_0, stream_now.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2545:3: tops= LITERAL_tops
					{
					tops=(Token)match(input,LITERAL_tops,FOLLOW_LITERAL_tops_in_value10115); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_tops.add(tops);

					// AST REWRITE
					// elements: tops
					// token labels: tops
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_tops=new RewriteRuleTokenStream(adaptor,"token tops",tops);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2545:21: -> $tops
					{
						adaptor.addChild(root_0, stream_tops.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.value,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value"


	public static class value_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "value_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2550:1: value_constant : ( LITERAL_true | LITERAL_false | numeric_constant | AADL_STRING_LITERAL | enumeration_value | record_term );
	public final BLESStoASTParser.value_constant_return value_constant() throws RecognitionException {
		BLESStoASTParser.value_constant_return retval = new BLESStoASTParser.value_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_true201=null;
		Token LITERAL_false202=null;
		Token AADL_STRING_LITERAL204=null;
		ParserRuleReturnScope numeric_constant203 =null;
		ParserRuleReturnScope enumeration_value205 =null;
		ParserRuleReturnScope record_term206 =null;

		BAST LITERAL_true201_tree=null;
		BAST LITERAL_false202_tree=null;
		BAST AADL_STRING_LITERAL204_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2551:3: ( LITERAL_true | LITERAL_false | numeric_constant | AADL_STRING_LITERAL | enumeration_value | record_term )
			int alt119=6;
			switch ( input.LA(1) ) {
			case LITERAL_true:
				{
				alt119=1;
				}
				break;
			case LITERAL_false:
				{
				alt119=2;
				}
				break;
			case INTEGER_LIT:
			case LITERAL_self:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt119=3;
				}
				break;
			case LBRACKET:
				{
				int LA119_4 = input.LA(2);
				if ( (LA119_4==ID) ) {
					alt119=6;
				}
				else if ( (LA119_4==INTEGER_LIT||LA119_4==MINUS||LA119_4==REAL_LIT) ) {
					alt119=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 119, 4, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				int LA119_5 = input.LA(2);
				if ( (LA119_5==DOUBLE_COLON||LA119_5==OCTOTHORPE||LA119_5==PERIOD) ) {
					alt119=3;
				}
				else if ( (LA119_5==TICK) ) {
					alt119=5;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 119, 5, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				alt119=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 119, 0, input);
				throw nvae;
			}
			switch (alt119) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2552:3: LITERAL_true
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_true201=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_value_constant10143); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_true201_tree = (BAST)adaptor.create(LITERAL_true201);
					adaptor.addChild(root_0, LITERAL_true201_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2552:18: LITERAL_false
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_false202=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_value_constant10147); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_false202_tree = (BAST)adaptor.create(LITERAL_false202);
					adaptor.addChild(root_0, LITERAL_false202_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2553:5: numeric_constant
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_numeric_constant_in_value_constant10153);
					numeric_constant203=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_constant203.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2554:5: AADL_STRING_LITERAL
					{
					root_0 = (BAST)adaptor.nil();


					AADL_STRING_LITERAL204=(Token)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_value_constant10159); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AADL_STRING_LITERAL204_tree = (BAST)adaptor.create(AADL_STRING_LITERAL204);
					adaptor.addChild(root_0, AADL_STRING_LITERAL204_tree);
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2555:5: enumeration_value
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_enumeration_value_in_value_constant10165);
					enumeration_value205=enumeration_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_value205.getTree());

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2556:5: record_term
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_record_term_in_value_constant10171);
					record_term206=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_term206.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.value,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value_constant"


	public static class enumeration_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2562:1: enumeration_value : enum_type= identifier tick= TICK enum_value= identifier -> ^( $tick $enum_type $enum_value) ;
	public final BLESStoASTParser.enumeration_value_return enumeration_value() throws RecognitionException {
		BLESStoASTParser.enumeration_value_return retval = new BLESStoASTParser.enumeration_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token tick=null;
		ParserRuleReturnScope enum_type =null;
		ParserRuleReturnScope enum_value =null;

		BAST tick_tree=null;
		RewriteRuleTokenStream stream_TICK=new RewriteRuleTokenStream(adaptor,"token TICK");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2563:3: (enum_type= identifier tick= TICK enum_value= identifier -> ^( $tick $enum_type $enum_value) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2564:3: enum_type= identifier tick= TICK enum_value= identifier
			{
			pushFollow(FOLLOW_identifier_in_enumeration_value10202);
			enum_type=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(enum_type.getTree());
			tick=(Token)match(input,TICK,FOLLOW_TICK_in_enumeration_value10206); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TICK.add(tick);

			pushFollow(FOLLOW_identifier_in_enumeration_value10210);
			enum_value=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(enum_value.getTree());
			// AST REWRITE
			// elements: enum_type, enum_value, tick
			// token labels: tick
			// rule labels: enum_type, enum_value, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_tick=new RewriteRuleTokenStream(adaptor,"token tick",tick);
			RewriteRuleSubtreeStream stream_enum_type=new RewriteRuleSubtreeStream(adaptor,"rule enum_type",enum_type!=null?enum_type.getTree():null);
			RewriteRuleSubtreeStream stream_enum_value=new RewriteRuleSubtreeStream(adaptor,"rule enum_value",enum_value!=null?enum_value.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2565:5: -> ^( $tick $enum_type $enum_value)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2565:8: ^( $tick $enum_type $enum_value)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_tick.nextNode(), root_1);
				adaptor.addChild(root_1, stream_enum_type.nextTree());
				adaptor.addChild(root_1, stream_enum_value.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_value"


	public static class property_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2568:1: property : ( property_constant | property_reference );
	public final BLESStoASTParser.property_return property() throws RecognitionException {
		BLESStoASTParser.property_return retval = new BLESStoASTParser.property_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope property_constant207 =null;
		ParserRuleReturnScope property_reference208 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2569:3: ( property_constant | property_reference )
			int alt120=2;
			int LA120_0 = input.LA(1);
			if ( (LA120_0==ID) ) {
				int LA120_1 = input.LA(2);
				if ( (LA120_1==DOUBLE_COLON) ) {
					int LA120_3 = input.LA(3);
					if ( (LA120_3==ID) ) {
						int LA120_4 = input.LA(4);
						if ( (LA120_4==EOF||(LA120_4 >= AL && LA120_4 <= ANNEX_END)||LA120_4==AT_SIGN||(LA120_4 >= BOX && LA120_4 <= CARET)||LA120_4==COLON||(LA120_4 >= COMMA && LA120_4 <= COMMADOT)||LA120_4==DIVIDE||(LA120_4 >= DOTCOMMA && LA120_4 <= DOTDOT)||LA120_4==EQ||LA120_4==EXP||(LA120_4 >= GT && LA120_4 <= GUARD)||(LA120_4 >= ID && LA120_4 <= IMP)||LA120_4==LASS||LA120_4==LCURLY||LA120_4==LITERAL_and||LA120_4==LITERAL_are||LA120_4==LITERAL_cand||LA120_4==LITERAL_computation||LA120_4==LITERAL_cor||LA120_4==LITERAL_declare||(LA120_4 >= LITERAL_do && LA120_4 <= LITERAL_else)||LA120_4==LITERAL_exception||(LA120_4 >= LITERAL_fetchadd && LA120_4 <= LITERAL_fi)||(LA120_4 >= LITERAL_for && LA120_4 <= LITERAL_forall)||(LA120_4 >= LITERAL_hr && LA120_4 <= LITERAL_iff)||(LA120_4 >= LITERAL_implies && LA120_4 <= LITERAL_in)||LA120_4==LITERAL_invariant||(LA120_4 >= LITERAL_min && LA120_4 <= LITERAL_mod)||LA120_4==LITERAL_ms||LA120_4==LITERAL_ns||LA120_4==LITERAL_of||LA120_4==LITERAL_or||LA120_4==LITERAL_pause||LA120_4==LITERAL_ps||LA120_4==LITERAL_rem||LA120_4==LITERAL_sec||LA120_4==LITERAL_setmode||LA120_4==LITERAL_skip||LA120_4==LITERAL_swap||(LA120_4 >= LITERAL_that && LA120_4 <= LITERAL_then)||LA120_4==LITERAL_until||LA120_4==LITERAL_us||(LA120_4 >= LITERAL_when && LA120_4 <= LITERAL_while)||(LA120_4 >= LITERAL_xor && LA120_4 <= LT)||LA120_4==MINUS||LA120_4==NEQ||LA120_4==PLUS||LA120_4==QQ||LA120_4==RASS||(LA120_4 >= RBRACKET && LA120_4 <= RCURLY)||LA120_4==RPAREN||LA120_4==SEMICOLON||LA120_4==TICK||LA120_4==TIMES) ) {
							alt120=1;
						}
						else if ( (LA120_4==DOUBLE_COLON||LA120_4==OCTOTHORPE||LA120_4==PERIOD) ) {
							alt120=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 120, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 120, 3, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}
				else if ( (LA120_1==OCTOTHORPE||LA120_1==PERIOD) ) {
					alt120=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 120, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA120_0==LITERAL_self||LA120_0==OCTOTHORPE) ) {
				alt120=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 120, 0, input);
				throw nvae;
			}

			switch (alt120) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2570:3: property_constant
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_property_constant_in_property10246);
					property_constant207=property_constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property_constant207.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2570:23: property_reference
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_property_reference_in_property10250);
					property_reference208=property_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property_reference208.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property"


	public static class property_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2573:1: property_constant : ps= identifier dc= DOUBLE_COLON ^p= identifier ;
	public final BLESStoASTParser.property_constant_return property_constant() throws RecognitionException {
		BLESStoASTParser.property_constant_return retval = new BLESStoASTParser.property_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dc=null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope p =null;

		BAST dc_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2574:3: (ps= identifier dc= DOUBLE_COLON ^p= identifier )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2575:3: ps= identifier dc= DOUBLE_COLON ^p= identifier
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_identifier_in_property_constant10268);
			ps=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ps.getTree());

			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_constant10272); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			dc_tree = (BAST)adaptor.create(dc);
			root_0 = (BAST)adaptor.becomeRoot(dc_tree, root_0);
			}

			pushFollow(FOLLOW_identifier_in_property_constant10278);
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, p.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_constant"


	public static class property_reference_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2578:1: property_reference : (oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $pname ( $field)* ) |self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $self $pname ( $field)* ) |component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $component $pname ( $field)* ) );
	public final BLESStoASTParser.property_reference_return property_reference() throws RecognitionException {
		BLESStoASTParser.property_reference_return retval = new BLESStoASTParser.property_reference_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token oc=null;
		Token self=null;
		List<Object> list_field=null;
		ParserRuleReturnScope pname =null;
		ParserRuleReturnScope component =null;
		RuleReturnScope field = null;
		BAST oc_tree=null;
		BAST self_tree=null;
		RewriteRuleTokenStream stream_LITERAL_self=new RewriteRuleTokenStream(adaptor,"token LITERAL_self");
		RewriteRuleTokenStream stream_OCTOTHORPE=new RewriteRuleTokenStream(adaptor,"token OCTOTHORPE");
		RewriteRuleSubtreeStream stream_unique_component_classifier_reference=new RewriteRuleSubtreeStream(adaptor,"rule unique_component_classifier_reference");
		RewriteRuleSubtreeStream stream_property_field=new RewriteRuleSubtreeStream(adaptor,"rule property_field");
		RewriteRuleSubtreeStream stream_property_name=new RewriteRuleSubtreeStream(adaptor,"rule property_name");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2579:3: (oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $pname ( $field)* ) |self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $self $pname ( $field)* ) |component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )* -> ^( $oc $component $pname ( $field)* ) )
			int alt124=3;
			switch ( input.LA(1) ) {
			case OCTOTHORPE:
				{
				alt124=1;
				}
				break;
			case LITERAL_self:
				{
				alt124=2;
				}
				break;
			case ID:
				{
				alt124=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 124, 0, input);
				throw nvae;
			}
			switch (alt124) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2580:3: oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10295); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10299);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2582:5: (field+= property_field )*
					loop121:
					while (true) {
						int alt121=2;
						int LA121_0 = input.LA(1);
						if ( (LA121_0==LBRACKET||LA121_0==PERIOD) ) {
							alt121=1;
						}

						switch (alt121) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2582:7: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference10314);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop121;
						}
					}

					// AST REWRITE
					// elements: field, oc, pname
					// token labels: oc
					// rule labels: pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2583:5: -> ^( $oc $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2583:8: ^( $oc $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2583:22: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2585:5: self= LITERAL_self oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
					self=(Token)match(input,LITERAL_self,FOLLOW_LITERAL_self_in_property_reference10344); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_self.add(self);

					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10348); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10352);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2585:57: (field+= property_field )*
					loop122:
					while (true) {
						int alt122=2;
						int LA122_0 = input.LA(1);
						if ( (LA122_0==LBRACKET||LA122_0==PERIOD) ) {
							alt122=1;
						}

						switch (alt122) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2585:59: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference10358);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop122;
						}
					}

					// AST REWRITE
					// elements: oc, self, pname, field
					// token labels: oc, self
					// rule labels: pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleTokenStream stream_self=new RewriteRuleTokenStream(adaptor,"token self",self);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2586:5: -> ^( $oc $self $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2586:8: ^( $oc $self $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_self.nextNode());
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2586:28: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2589:5: component= unique_component_classifier_reference oc= OCTOTHORPE pname= property_name (field+= property_field )*
					{
					pushFollow(FOLLOW_unique_component_classifier_reference_in_property_reference10392);
					component=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unique_component_classifier_reference.add(component.getTree());
					oc=(Token)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference10396); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OCTOTHORPE.add(oc);

					pushFollow(FOLLOW_property_name_in_property_reference10400);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property_name.add(pname.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2590:5: (field+= property_field )*
					loop123:
					while (true) {
						int alt123=2;
						int LA123_0 = input.LA(1);
						if ( (LA123_0==LBRACKET||LA123_0==PERIOD) ) {
							alt123=1;
						}

						switch (alt123) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2590:7: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference10410);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_property_field.add(field.getTree());
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTree());
							}
							break;

						default :
							break loop123;
						}
					}

					// AST REWRITE
					// elements: field, component, pname, oc
					// token labels: oc
					// rule labels: component, pname, retval
					// token list labels: 
					// rule list labels: field
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_oc=new RewriteRuleTokenStream(adaptor,"token oc",oc);
					RewriteRuleSubtreeStream stream_component=new RewriteRuleSubtreeStream(adaptor,"rule component",component!=null?component.getTree():null);
					RewriteRuleSubtreeStream stream_pname=new RewriteRuleSubtreeStream(adaptor,"rule pname",pname!=null?pname.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"token field",list_field);
					root_0 = (BAST)adaptor.nil();
					// 2591:5: -> ^( $oc $component $pname ( $field)* )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2591:8: ^( $oc $component $pname ( $field)* )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_oc.nextNode(), root_1);
						adaptor.addChild(root_1, stream_component.nextTree());
						adaptor.addChild(root_1, stream_pname.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2591:33: ( $field)*
						while ( stream_field.hasNext() ) {
							adaptor.addChild(root_1, stream_field.nextTree());
						}
						stream_field.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_reference"


	public static class property_field_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2594:1: property_field : ( LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET | PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound ) );
	public final BLESStoASTParser.property_field_return property_field() throws RecognitionException {
		BLESStoASTParser.property_field_return retval = new BLESStoASTParser.property_field_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET209=null;
		Token set210=null;
		Token RBRACKET211=null;
		Token PERIOD212=null;
		Token set213=null;

		BAST LBRACKET209_tree=null;
		BAST set210_tree=null;
		BAST RBRACKET211_tree=null;
		BAST PERIOD212_tree=null;
		BAST set213_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2595:3: ( LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET | PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound ) )
			int alt125=2;
			int LA125_0 = input.LA(1);
			if ( (LA125_0==LBRACKET) ) {
				alt125=1;
			}
			else if ( (LA125_0==PERIOD) ) {
				alt125=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 125, 0, input);
				throw nvae;
			}

			switch (alt125) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2596:3: LBRACKET ^ ( INTEGER_LIT | ID ) RBRACKET
					{
					root_0 = (BAST)adaptor.nil();


					LBRACKET209=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_property_field10450); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LBRACKET209_tree = (BAST)adaptor.create(LBRACKET209);
					root_0 = (BAST)adaptor.becomeRoot(LBRACKET209_tree, root_0);
					}

					set210=input.LT(1);
					if ( input.LA(1)==ID||input.LA(1)==INTEGER_LIT ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set210));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					RBRACKET211=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_property_field10461); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RBRACKET211_tree = (BAST)adaptor.create(RBRACKET211);
					adaptor.addChild(root_0, RBRACKET211_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2598:3: PERIOD ^ ( ID | LITERAL_upper_bound | LITERAL_lower_bound )
					{
					root_0 = (BAST)adaptor.nil();


					PERIOD212=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_property_field10469); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					PERIOD212_tree = (BAST)adaptor.create(PERIOD212);
					root_0 = (BAST)adaptor.becomeRoot(PERIOD212_tree, root_0);
					}

					set213=input.LT(1);
					if ( input.LA(1)==ID||input.LA(1)==LITERAL_lower_bound||input.LA(1)==LITERAL_upper_bound ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (BAST)adaptor.create(set213));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_field"


	public static class property_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "property_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2601:1: property_name : ps= identifier dc= DOUBLE_COLON p= identifier -> ^( $dc $ps $p) ;
	public final BLESStoASTParser.property_name_return property_name() throws RecognitionException {
		BLESStoASTParser.property_name_return retval = new BLESStoASTParser.property_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dc=null;
		ParserRuleReturnScope ps =null;
		ParserRuleReturnScope p =null;

		BAST dc_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2602:3: (ps= identifier dc= DOUBLE_COLON p= identifier -> ^( $dc $ps $p) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2603:3: ps= identifier dc= DOUBLE_COLON p= identifier
			{
			pushFollow(FOLLOW_identifier_in_property_name10498);
			ps=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(ps.getTree());
			dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_name10502); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(dc);

			pushFollow(FOLLOW_identifier_in_property_name10507);
			p=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
			// AST REWRITE
			// elements: p, ps, dc
			// token labels: dc
			// rule labels: p, ps, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dc=new RewriteRuleTokenStream(adaptor,"token dc",dc);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
			RewriteRuleSubtreeStream stream_ps=new RewriteRuleSubtreeStream(adaptor,"rule ps",ps!=null?ps.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2604:5: -> ^( $dc $ps $p)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2604:8: ^( $dc $ps $p)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dc.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ps.nextTree());
				adaptor.addChild(root_1, stream_p.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_name"


	public static class numeric_constant_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "numeric_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2608:1: numeric_constant : ( INTEGER_LIT | REAL_LIT | rational_literal | complex_literal | property );
	public final BLESStoASTParser.numeric_constant_return numeric_constant() throws RecognitionException {
		BLESStoASTParser.numeric_constant_return retval = new BLESStoASTParser.numeric_constant_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token INTEGER_LIT214=null;
		Token REAL_LIT215=null;
		ParserRuleReturnScope rational_literal216 =null;
		ParserRuleReturnScope complex_literal217 =null;
		ParserRuleReturnScope property218 =null;

		BAST INTEGER_LIT214_tree=null;
		BAST REAL_LIT215_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2609:3: ( INTEGER_LIT | REAL_LIT | rational_literal | complex_literal | property )
			int alt126=5;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt126=1;
				}
				break;
			case REAL_LIT:
				{
				alt126=2;
				}
				break;
			case LBRACKET:
				{
				switch ( input.LA(2) ) {
				case MINUS:
					{
					int LA126_5 = input.LA(3);
					if ( (LA126_5==INTEGER_LIT) ) {
						alt126=3;
					}
					else if ( (LA126_5==REAL_LIT) ) {
						alt126=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 126, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

					}
					break;
				case INTEGER_LIT:
					{
					alt126=3;
					}
					break;
				case REAL_LIT:
					{
					alt126=4;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 126, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
				}
				break;
			case ID:
			case LITERAL_self:
			case OCTOTHORPE:
				{
				alt126=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 126, 0, input);
				throw nvae;
			}
			switch (alt126) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2610:3: INTEGER_LIT
					{
					root_0 = (BAST)adaptor.nil();


					INTEGER_LIT214=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_numeric_constant10545); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					INTEGER_LIT214_tree = (BAST)adaptor.create(INTEGER_LIT214);
					adaptor.addChild(root_0, INTEGER_LIT214_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2611:5: REAL_LIT
					{
					root_0 = (BAST)adaptor.nil();


					REAL_LIT215=(Token)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_numeric_constant10552); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					REAL_LIT215_tree = (BAST)adaptor.create(REAL_LIT215);
					adaptor.addChild(root_0, REAL_LIT215_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2613:3: rational_literal
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_rational_literal_in_numeric_constant10561);
					rational_literal216=rational_literal();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rational_literal216.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2613:22: complex_literal
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_complex_literal_in_numeric_constant10565);
					complex_literal217=complex_literal();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, complex_literal217.getTree());

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2614:5: property
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_property_in_numeric_constant10571);
					property218=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, property218.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_constant"


	public static class expression_or_relation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2617:1: expression_or_relation : ( ( LPAREN ID ARROW )=>rt= record_term -> $rt| ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= expression -> $e);
	public final BLESStoASTParser.expression_or_relation_return expression_or_relation() throws RecognitionException {
		BLESStoASTParser.expression_or_relation_return retval = new BLESStoASTParser.expression_or_relation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_record_term=new RewriteRuleSubtreeStream(adaptor,"rule record_term");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2619:3: ( ( LPAREN ID ARROW )=>rt= record_term -> $rt| ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= expression -> $e)
			int alt127=3;
			switch ( input.LA(1) ) {
			case LBRACKET:
				{
				int LA127_1 = input.LA(2);
				if ( (synpred5_BLESStoAST()) ) {
					alt127=1;
				}
				else if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case MINUS:
				{
				int LA127_2 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_not:
				{
				int LA127_3 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_true:
				{
				int LA127_4 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_false:
				{
				int LA127_5 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case INTEGER_LIT:
				{
				int LA127_6 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case REAL_LIT:
				{
				int LA127_7 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case ID:
				{
				int LA127_8 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case OCTOTHORPE:
				{
				int LA127_9 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_self:
				{
				int LA127_10 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				int LA127_11 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_in:
				{
				int LA127_12 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_timeout:
				{
				int LA127_13 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_null:
				{
				int LA127_14 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_now:
				{
				int LA127_15 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_tops:
				{
				int LA127_16 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LPAREN:
				{
				int LA127_17 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_natural:
				{
				int LA127_18 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA127_19 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA127_20 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_real:
				{
				int LA127_21 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA127_22 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			case LITERAL_time:
				{
				int LA127_23 = input.LA(2);
				if ( (synpred6_BLESStoAST()) ) {
					alt127=2;
				}
				else if ( (true) ) {
					alt127=3;
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 127, 0, input);
				throw nvae;
			}
			switch (alt127) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2620:3: ( LPAREN ID ARROW )=>rt= record_term
					{
					pushFollow(FOLLOW_record_term_in_expression_or_relation10603);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_term.add(rt.getTree());
					// AST REWRITE
					// elements: rt
					// token labels: 
					// rule labels: rt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rt=new RewriteRuleSubtreeStream(adaptor,"rule rt",rt!=null?rt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2622:5: -> $rt
					{
						adaptor.addChild(root_0, stream_rt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2624:3: ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression
					{
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10633);
					e1=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e1.getTree());
					pushFollow(FOLLOW_relation_symbol_in_expression_or_relation10642);
					rs=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(rs.getTree());
					pushFollow(FOLLOW_subexpression_in_expression_or_relation10646);
					e2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e2.getTree());
					// AST REWRITE
					// elements: e2, rs, e1
					// token labels: 
					// rule labels: rs, e1, e2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
					RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2627:5: -> ^( $rs $e1 $e2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2627:8: ^( $rs $e1 $e2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_e1.nextTree());
						adaptor.addChild(root_1, stream_e2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2629:3: e= expression
					{
					pushFollow(FOLLOW_expression_in_expression_or_relation10674);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2630:3: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.expressionOrRelation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_relation"


	public static class boolean_expression_or_relation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "boolean_expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2636:1: boolean_expression_or_relation : ( ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= boolean_expression -> $e);
	public final BLESStoASTParser.boolean_expression_or_relation_return boolean_expression_or_relation() throws RecognitionException {
		BLESStoASTParser.boolean_expression_or_relation_return retval = new BLESStoASTParser.boolean_expression_or_relation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_boolean_expression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression");
		RewriteRuleSubtreeStream stream_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2638:3: ( ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression -> ^( $rs $e1 $e2) |e= boolean_expression -> $e)
			int alt128=2;
			int LA128_0 = input.LA(1);
			if ( (LA128_0==MINUS) && (synpred7_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_not) ) {
				int LA128_2 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_true) ) {
				int LA128_3 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_false) ) {
				int LA128_4 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==INTEGER_LIT) ) {
				int LA128_5 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==REAL_LIT) ) {
				int LA128_6 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LBRACKET) ) {
				int LA128_7 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==ID) ) {
				int LA128_8 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==OCTOTHORPE) ) {
				int LA128_9 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_self) ) {
				int LA128_10 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==AADL_STRING_LITERAL) ) {
				int LA128_11 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_in) ) {
				int LA128_12 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_timeout) ) {
				int LA128_13 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_null) ) {
				int LA128_14 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_now) ) {
				int LA128_15 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_tops) ) {
				int LA128_16 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LPAREN) ) {
				int LA128_17 = input.LA(2);
				if ( (synpred7_BLESStoAST()) ) {
					alt128=1;
				}
				else if ( (true) ) {
					alt128=2;
				}

			}
			else if ( (LA128_0==LITERAL_natural) && (synpred7_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_integer) && (synpred7_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_rational) && (synpred7_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_real) && (synpred7_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_complex) && (synpred7_BLESStoAST())) {
				alt128=1;
			}
			else if ( (LA128_0==LITERAL_time) && (synpred7_BLESStoAST())) {
				alt128=1;
			}

			switch (alt128) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2639:3: ( subexpression relation_symbol )=>e1= subexpression rs= relation_symbol e2= subexpression
					{
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10723);
					e1=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e1.getTree());
					pushFollow(FOLLOW_relation_symbol_in_boolean_expression_or_relation10733);
					rs=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(rs.getTree());
					pushFollow(FOLLOW_subexpression_in_boolean_expression_or_relation10737);
					e2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subexpression.add(e2.getTree());
					// AST REWRITE
					// elements: rs, e2, e1
					// token labels: 
					// rule labels: rs, e1, e2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
					RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2644:3: -> ^( $rs $e1 $e2)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2644:6: ^( $rs $e1 $e2)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_e1.nextTree());
						adaptor.addChild(root_1, stream_e2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2646:3: e= boolean_expression
					{
					pushFollow(FOLLOW_boolean_expression_in_boolean_expression_or_relation10764);
					e=boolean_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_boolean_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2647:3: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			      tellBNF(GrammarStrings.expressionOrRelation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression_or_relation"


	public static class function_call_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "function_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2654:1: function_call : (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? ) ;
	public final BLESStoASTParser.function_call_return function_call() throws RecognitionException {
		BLESStoASTParser.function_call_return retval = new BLESStoASTParser.function_call_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token DOUBLE_COLON219=null;
		Token RPAREN220=null;
		List<Object> list_p=null;
		ParserRuleReturnScope id =null;
		ParserRuleReturnScope fp =null;
		RuleReturnScope p = null;
		BAST lp_tree=null;
		BAST DOUBLE_COLON219_tree=null;
		BAST RPAREN220_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_function_parameters=new RewriteRuleSubtreeStream(adaptor,"rule function_parameters");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2656:3: ( (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2657:3: (p+= identifier DOUBLE_COLON )+ id= identifier lp= LPAREN (fp= function_parameters )? RPAREN
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2657:3: (p+= identifier DOUBLE_COLON )+
			int cnt129=0;
			loop129:
			while (true) {
				int alt129=2;
				int LA129_0 = input.LA(1);
				if ( (LA129_0==ID) ) {
					int LA129_1 = input.LA(2);
					if ( (LA129_1==DOUBLE_COLON) ) {
						alt129=1;
					}

				}

				switch (alt129) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2657:17: p+= identifier DOUBLE_COLON
					{
					pushFollow(FOLLOW_identifier_in_function_call10813);
					p=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
					if (list_p==null) list_p=new ArrayList<Object>();
					list_p.add(p.getTree());
					DOUBLE_COLON219=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_function_call10815); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON219);

					}
					break;

				default :
					if ( cnt129 >= 1 ) break loop129;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(129, input);
					throw eee;
				}
				cnt129++;
			}

			pushFollow(FOLLOW_identifier_in_function_call10825);
			id=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_function_call10829); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(lp);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2658:42: (fp= function_parameters )?
			int alt130=2;
			int LA130_0 = input.LA(1);
			if ( (LA130_0==ID) ) {
				alt130=1;
			}
			switch (alt130) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2658:42: fp= function_parameters
					{
					pushFollow(FOLLOW_function_parameters_in_function_call10833);
					fp=function_parameters();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_function_parameters.add(fp.getTree());
					}
					break;

			}

			RPAREN220=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_function_call10836); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN220);

			// AST REWRITE
			// elements: fp, DOUBLE_COLON, p, id
			// token labels: 
			// rule labels: fp, id, retval
			// token list labels: 
			// rule list labels: p
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_fp=new RewriteRuleSubtreeStream(adaptor,"rule fp",fp!=null?fp.getTree():null);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"token p",list_p);
			root_0 = (BAST)adaptor.nil();
			// 2659:3: -> ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2659:6: ^( FUNCTION_CALL[$lp,\"FUNCTION_CALL\"] ^( DOUBLE_COLON ( $p)+ ) $id ( $fp)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(FUNCTION_CALL, lp, "FUNCTION_CALL"), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2659:43: ^( DOUBLE_COLON ( $p)+ )
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_2);
				if ( !(stream_p.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_p.hasNext() ) {
					adaptor.addChild(root_2, stream_p.nextTree());
				}
				stream_p.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_id.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2659:68: ( $fp)?
				if ( stream_fp.hasNext() ) {
					adaptor.addChild(root_1, stream_fp.nextTree());
				}
				stream_fp.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(id!=null?((BAST)id.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.functionCall,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_call"


	public static class function_parameters_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "function_parameters"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2668:1: function_parameters :param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )? ;
	public final BLESStoASTParser.function_parameters_return function_parameters() throws RecognitionException {
		BLESStoASTParser.function_parameters_return retval = new BLESStoASTParser.function_parameters_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA221=null;
		Token COMMA222=null;
		List<Object> list_param=null;
		RuleReturnScope param = null;
		BAST COMMA221_tree=null;
		BAST COMMA222_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2669:3: (param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2670:3: param+= formal_expression_pair ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10895);
			param=formal_expression_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

			if (list_param==null) list_param=new ArrayList<Object>();
			list_param.add(param.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2670:33: ( COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )* )?
			int alt132=2;
			int LA132_0 = input.LA(1);
			if ( (LA132_0==COMMA) ) {
				alt132=1;
			}
			switch (alt132) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2670:35: COMMA ^param+= formal_expression_pair ( COMMA param+= formal_expression_pair )*
					{
					COMMA221=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10899); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA221_tree = (BAST)adaptor.create(COMMA221);
					root_0 = (BAST)adaptor.becomeRoot(COMMA221_tree, root_0);
					}

					pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10905);
					param=formal_expression_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

					if (list_param==null) list_param=new ArrayList<Object>();
					list_param.add(param.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2671:5: ( COMMA param+= formal_expression_pair )*
					loop131:
					while (true) {
						int alt131=2;
						int LA131_0 = input.LA(1);
						if ( (LA131_0==COMMA) ) {
							alt131=1;
						}

						switch (alt131) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2671:7: COMMA param+= formal_expression_pair
							{
							COMMA222=(Token)match(input,COMMA,FOLLOW_COMMA_in_function_parameters10915); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							COMMA222_tree = (BAST)adaptor.create(COMMA222);
							adaptor.addChild(root_0, COMMA222_tree);
							}

							pushFollow(FOLLOW_formal_expression_pair_in_function_parameters10920);
							param=formal_expression_pair();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, param.getTree());

							if (list_param==null) list_param=new ArrayList<Object>();
							list_param.add(param.getTree());
							}
							break;

						default :
							break loop131;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_parameters"


	public static class formal_expression_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_expression_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2674:1: formal_expression_pair : formal= ID COLON ^actual= expression ;
	public final BLESStoASTParser.formal_expression_pair_return formal_expression_pair() throws RecognitionException {
		BLESStoASTParser.formal_expression_pair_return retval = new BLESStoASTParser.formal_expression_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token formal=null;
		Token COLON223=null;
		ParserRuleReturnScope actual =null;

		BAST formal_tree=null;
		BAST COLON223_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2675:3: (formal= ID COLON ^actual= expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2676:3: formal= ID COLON ^actual= expression
			{
			root_0 = (BAST)adaptor.nil();


			formal=(Token)match(input,ID,FOLLOW_ID_in_formal_expression_pair10942); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			formal_tree = (BAST)adaptor.create(formal);
			adaptor.addChild(root_0, formal_tree);
			}

			COLON223=(Token)match(input,COLON,FOLLOW_COLON_in_formal_expression_pair10944); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			COLON223_tree = (BAST)adaptor.create(COLON223);
			root_0 = (BAST)adaptor.becomeRoot(COLON223_tree, root_0);
			}

			pushFollow(FOLLOW_expression_in_formal_expression_pair10949);
			actual=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, actual.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_expression_pair"


	public static class type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2681:1: type : (tn= type_name -> $tn|et= enumeration_type -> $et|nt= number_type -> $nt|at= array_type -> $at|rt= record_type -> $rt|vt= variant_type -> $vt|b= LITERAL_boolean -> $b|s= LITERAL_string -> $s);
	public final BLESStoASTParser.type_return type() throws RecognitionException {
		BLESStoASTParser.type_return retval = new BLESStoASTParser.type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token b=null;
		Token s=null;
		ParserRuleReturnScope tn =null;
		ParserRuleReturnScope et =null;
		ParserRuleReturnScope nt =null;
		ParserRuleReturnScope at =null;
		ParserRuleReturnScope rt =null;
		ParserRuleReturnScope vt =null;

		BAST b_tree=null;
		BAST s_tree=null;
		RewriteRuleTokenStream stream_LITERAL_string=new RewriteRuleTokenStream(adaptor,"token LITERAL_string");
		RewriteRuleTokenStream stream_LITERAL_boolean=new RewriteRuleTokenStream(adaptor,"token LITERAL_boolean");
		RewriteRuleSubtreeStream stream_type_name=new RewriteRuleSubtreeStream(adaptor,"rule type_name");
		RewriteRuleSubtreeStream stream_enumeration_type=new RewriteRuleSubtreeStream(adaptor,"rule enumeration_type");
		RewriteRuleSubtreeStream stream_variant_type=new RewriteRuleSubtreeStream(adaptor,"rule variant_type");
		RewriteRuleSubtreeStream stream_number_type=new RewriteRuleSubtreeStream(adaptor,"rule number_type");
		RewriteRuleSubtreeStream stream_array_type=new RewriteRuleSubtreeStream(adaptor,"rule array_type");
		RewriteRuleSubtreeStream stream_record_type=new RewriteRuleSubtreeStream(adaptor,"rule record_type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2682:3: (tn= type_name -> $tn|et= enumeration_type -> $et|nt= number_type -> $nt|at= array_type -> $at|rt= record_type -> $rt|vt= variant_type -> $vt|b= LITERAL_boolean -> $b|s= LITERAL_string -> $s)
			int alt133=8;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt133=1;
				}
				break;
			case LITERAL_enumeration:
				{
				alt133=2;
				}
				break;
			case LITERAL_complex:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
				{
				alt133=3;
				}
				break;
			case LITERAL_array:
				{
				alt133=4;
				}
				break;
			case LITERAL_record:
				{
				alt133=5;
				}
				break;
			case LITERAL_variant:
				{
				alt133=6;
				}
				break;
			case LITERAL_boolean:
				{
				alt133=7;
				}
				break;
			case LITERAL_string:
				{
				alt133=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 133, 0, input);
				throw nvae;
			}
			switch (alt133) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2684:3: tn= type_name
					{
					pushFollow(FOLLOW_type_name_in_type10974);
					tn=type_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_name.add(tn.getTree());
					// AST REWRITE
					// elements: tn
					// token labels: 
					// rule labels: tn, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_tn=new RewriteRuleSubtreeStream(adaptor,"rule tn",tn!=null?tn.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2685:5: -> $tn
					{
						adaptor.addChild(root_0, stream_tn.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2687:3: et= enumeration_type
					{
					pushFollow(FOLLOW_enumeration_type_in_type10993);
					et=enumeration_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumeration_type.add(et.getTree());
					// AST REWRITE
					// elements: et
					// token labels: 
					// rule labels: retval, et
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_et=new RewriteRuleSubtreeStream(adaptor,"rule et",et!=null?et.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2688:5: -> $et
					{
						adaptor.addChild(root_0, stream_et.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2690:3: nt= number_type
					{
					pushFollow(FOLLOW_number_type_in_type11012);
					nt=number_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_number_type.add(nt.getTree());
					// AST REWRITE
					// elements: nt
					// token labels: 
					// rule labels: nt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_nt=new RewriteRuleSubtreeStream(adaptor,"rule nt",nt!=null?nt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2691:5: -> $nt
					{
						adaptor.addChild(root_0, stream_nt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2693:3: at= array_type
					{
					pushFollow(FOLLOW_array_type_in_type11031);
					at=array_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_array_type.add(at.getTree());
					// AST REWRITE
					// elements: at
					// token labels: 
					// rule labels: at, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_at=new RewriteRuleSubtreeStream(adaptor,"rule at",at!=null?at.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2694:5: -> $at
					{
						adaptor.addChild(root_0, stream_at.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2696:3: rt= record_type
					{
					pushFollow(FOLLOW_record_type_in_type11050);
					rt=record_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_record_type.add(rt.getTree());
					// AST REWRITE
					// elements: rt
					// token labels: 
					// rule labels: rt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_rt=new RewriteRuleSubtreeStream(adaptor,"rule rt",rt!=null?rt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2697:5: -> $rt
					{
						adaptor.addChild(root_0, stream_rt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2699:3: vt= variant_type
					{
					pushFollow(FOLLOW_variant_type_in_type11069);
					vt=variant_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_variant_type.add(vt.getTree());
					// AST REWRITE
					// elements: vt
					// token labels: 
					// rule labels: vt, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_vt=new RewriteRuleSubtreeStream(adaptor,"rule vt",vt!=null?vt.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2700:5: -> $vt
					{
						adaptor.addChild(root_0, stream_vt.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2705:3: b= LITERAL_boolean
					{
					b=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_type11091); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_boolean.add(b);

					// AST REWRITE
					// elements: b
					// token labels: b
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_b=new RewriteRuleTokenStream(adaptor,"token b",b);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2705:21: -> $b
					{
						adaptor.addChild(root_0, stream_b.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2707:3: s= LITERAL_string
					{
					s=(Token)match(input,LITERAL_string,FOLLOW_LITERAL_string_in_type11106); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_string.add(s);

					// AST REWRITE
					// elements: s
					// token labels: s
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_s=new RewriteRuleTokenStream(adaptor,"token s",s);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2707:20: -> $s
					{
						adaptor.addChild(root_0, stream_s.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			  Dump.it("\n"+(saidTypeError?"That ":"Some ")+Global.dope+
			  " made "+(saidTypeError?"another":"an")+" error in grammar of a \"type\".\n");
			  Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  tellBNF(GrammarStrings.type,re,retval.tree);
			//  Dump.it("RecognitionException suppressed ");
			//  if ((retval!=null)&&(retval.getTree()!=null))
			//    Dump.it(((BAST)retval.getTree()).toStringTree());
			  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type"


	public static class enumeration_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2720:1: enumeration_type : LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
	public final BLESStoASTParser.enumeration_type_return enumeration_type() throws RecognitionException {
		BLESStoASTParser.enumeration_type_return retval = new BLESStoASTParser.enumeration_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_enumeration224=null;
		Token LPAREN225=null;
		Token COMMA227=null;
		Token RPAREN229=null;
		ParserRuleReturnScope identifier226 =null;
		ParserRuleReturnScope identifier228 =null;

		BAST LITERAL_enumeration224_tree=null;
		BAST LPAREN225_tree=null;
		BAST COMMA227_tree=null;
		BAST RPAREN229_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2721:3: ( LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2722:2: LITERAL_enumeration ^ LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_enumeration224=(Token)match(input,LITERAL_enumeration,FOLLOW_LITERAL_enumeration_in_enumeration_type11135); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_enumeration224_tree = (BAST)adaptor.create(LITERAL_enumeration224);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_enumeration224_tree, root_0);
			}

			LPAREN225=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_enumeration_type11138); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_enumeration_type11143);
			identifier226=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier226.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2723:4: ( COMMA ! identifier )*
			loop134:
			while (true) {
				int alt134=2;
				int LA134_0 = input.LA(1);
				if ( (LA134_0==COMMA) ) {
					alt134=1;
				}

				switch (alt134) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2723:5: COMMA ! identifier
					{
					COMMA227=(Token)match(input,COMMA,FOLLOW_COMMA_in_enumeration_type11149); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_enumeration_type11152);
					identifier228=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier228.getTree());

					}
					break;

				default :
					break loop134;
				}
			}

			RPAREN229=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_enumeration_type11156); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			 Dump.it("Did you forget commas between your enumeration literals?");
			  Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.enumerationType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_type"


	public static class number_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "number_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2753:1: number_type : (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )? -> {u!=null}? ^( $n ^( $u $ud) ( $r)? ) -> ^( $n ( $r)? ) ;
	public final BLESStoASTParser.number_type_return number_type() throws RecognitionException {
		BLESStoASTParser.number_type_return retval = new BLESStoASTParser.number_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token u=null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope ud =null;

		BAST n_tree=null;
		BAST u_tree=null;
		RewriteRuleTokenStream stream_LITERAL_integer=new RewriteRuleTokenStream(adaptor,"token LITERAL_integer");
		RewriteRuleTokenStream stream_LITERAL_complex=new RewriteRuleTokenStream(adaptor,"token LITERAL_complex");
		RewriteRuleTokenStream stream_LITERAL_time=new RewriteRuleTokenStream(adaptor,"token LITERAL_time");
		RewriteRuleTokenStream stream_LITERAL_units=new RewriteRuleTokenStream(adaptor,"token LITERAL_units");
		RewriteRuleTokenStream stream_LITERAL_real=new RewriteRuleTokenStream(adaptor,"token LITERAL_real");
		RewriteRuleTokenStream stream_LITERAL_natural=new RewriteRuleTokenStream(adaptor,"token LITERAL_natural");
		RewriteRuleTokenStream stream_LITERAL_rational=new RewriteRuleTokenStream(adaptor,"token LITERAL_rational");
		RewriteRuleSubtreeStream stream_number_range=new RewriteRuleSubtreeStream(adaptor,"rule number_range");
		RewriteRuleSubtreeStream stream_units_designator=new RewriteRuleSubtreeStream(adaptor,"rule units_designator");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2754:3: ( (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )? -> {u!=null}? ^( $n ^( $u $ud) ( $r)? ) -> ^( $n ( $r)? ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2755:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time ) (r= number_range )? (u= LITERAL_units ud= units_designator )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2755:3: (n= LITERAL_natural |n= LITERAL_integer |n= LITERAL_rational |n= LITERAL_real |n= LITERAL_complex |n= LITERAL_time )
			int alt135=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt135=1;
				}
				break;
			case LITERAL_integer:
				{
				alt135=2;
				}
				break;
			case LITERAL_rational:
				{
				alt135=3;
				}
				break;
			case LITERAL_real:
				{
				alt135=4;
				}
				break;
			case LITERAL_complex:
				{
				alt135=5;
				}
				break;
			case LITERAL_time:
				{
				alt135=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 135, 0, input);
				throw nvae;
			}
			switch (alt135) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2755:4: n= LITERAL_natural
					{
					n=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_number_type11211); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_natural.add(n);

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2756:3: n= LITERAL_integer
					{
					n=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_number_type11220); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_integer.add(n);

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2757:3: n= LITERAL_rational
					{
					n=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_number_type11229); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_rational.add(n);

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2758:3: n= LITERAL_real
					{
					n=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_number_type11238); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_real.add(n);

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2759:3: n= LITERAL_complex
					{
					n=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_number_type11247); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_complex.add(n);

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2760:3: n= LITERAL_time
					{
					n=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_number_type11255); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_time.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2761:4: (r= number_range )?
			int alt136=2;
			int LA136_0 = input.LA(1);
			if ( (LA136_0==LBRACKET) ) {
				alt136=1;
			}
			switch (alt136) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2761:4: r= number_range
					{
					pushFollow(FOLLOW_number_range_in_number_type11263);
					r=number_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_number_range.add(r.getTree());
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2761:19: (u= LITERAL_units ud= units_designator )?
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==LITERAL_units) ) {
				alt137=1;
			}
			switch (alt137) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2761:21: u= LITERAL_units ud= units_designator
					{
					u=(Token)match(input,LITERAL_units,FOLLOW_LITERAL_units_in_number_type11270); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_units.add(u);

					pushFollow(FOLLOW_units_designator_in_number_type11274);
					ud=units_designator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_units_designator.add(ud.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: u, n, ud, r, r, n
			// token labels: u, n
			// rule labels: r, retval, ud
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_u=new RewriteRuleTokenStream(adaptor,"token u",u);
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ud=new RewriteRuleSubtreeStream(adaptor,"rule ud",ud!=null?ud.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2762:4: -> {u!=null}? ^( $n ^( $u $ud) ( $r)? )
			if (u!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2762:18: ^( $n ^( $u $ud) ( $r)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2762:23: ^( $u $ud)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_u.nextNode(), root_2);
				adaptor.addChild(root_2, stream_ud.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2762:34: ( $r)?
				if ( stream_r.hasNext() ) {
					adaptor.addChild(root_1, stream_r.nextTree());
				}
				stream_r.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2763:4: -> ^( $n ( $r)? )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2763:7: ^( $n ( $r)? )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2763:13: ( $r)?
				if ( stream_r.hasNext() ) {
					adaptor.addChild(root_1, stream_r.nextTree());
				}
				stream_r.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.numberType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_type"


	public static class number_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2768:1: number_range : LBRACKET ! constant_number_range RBRACKET !;
	public final BLESStoASTParser.number_range_return number_range() throws RecognitionException {
		BLESStoASTParser.number_range_return retval = new BLESStoASTParser.number_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LBRACKET230=null;
		Token RBRACKET232=null;
		ParserRuleReturnScope constant_number_range231 =null;

		BAST LBRACKET230_tree=null;
		BAST RBRACKET232_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2769:3: ( LBRACKET ! constant_number_range RBRACKET !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2770:3: LBRACKET ! constant_number_range RBRACKET !
			{
			root_0 = (BAST)adaptor.nil();


			LBRACKET230=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_number_range11339); if (state.failed) return retval;
			pushFollow(FOLLOW_constant_number_range_in_number_range11342);
			constant_number_range231=constant_number_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_number_range231.getTree());

			RBRACKET232=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_number_range11344); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_range"


	public static class constant_number_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "constant_number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2773:1: constant_number_range : (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) ) -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub) -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) ) -> ^( $dd $lb $ub) ;
	public final BLESStoASTParser.constant_number_range_return constant_number_range() throws RecognitionException {
		BLESStoASTParser.constant_number_range_return retval = new BLESStoASTParser.constant_number_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lb_um=null;
		Token dd=null;
		Token ub_um=null;
		ParserRuleReturnScope lb =null;
		ParserRuleReturnScope ub =null;

		BAST lb_um_tree=null;
		BAST dd_tree=null;
		BAST ub_um_tree=null;
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_numeric_constant=new RewriteRuleSubtreeStream(adaptor,"rule numeric_constant");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2774:3: ( (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) ) -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub) -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) ) -> ^( $dd $lb $ub) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:3: (lb_um= MINUS )? lb= numeric_constant dd= DOTDOT (ub_um= MINUS )? ub= numeric_constant
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:8: (lb_um= MINUS )?
			int alt138=2;
			int LA138_0 = input.LA(1);
			if ( (LA138_0==MINUS) ) {
				alt138=1;
			}
			switch (alt138) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:8: lb_um= MINUS
					{
					lb_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11362); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(lb_um);

					}
					break;

			}

			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11367);
			lb=numeric_constant();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_constant.add(lb.getTree());
			dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range11371); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(dd);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:51: (ub_um= MINUS )?
			int alt139=2;
			int LA139_0 = input.LA(1);
			if ( (LA139_0==MINUS) ) {
				alt139=1;
			}
			switch (alt139) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2775:51: ub_um= MINUS
					{
					ub_um=(Token)match(input,MINUS,FOLLOW_MINUS_in_constant_number_range11375); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(ub_um);

					}
					break;

			}

			pushFollow(FOLLOW_numeric_constant_in_constant_number_range11380);
			ub=numeric_constant();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_numeric_constant.add(ub.getTree());
			// AST REWRITE
			// elements: dd, ub, lb, ub, lb, dd, dd, lb, ub, ub, lb, dd
			// token labels: dd
			// rule labels: lb, ub, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dd=new RewriteRuleTokenStream(adaptor,"token dd",dd);
			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,"rule lb",lb!=null?lb.getTree():null);
			RewriteRuleSubtreeStream stream_ub=new RewriteRuleSubtreeStream(adaptor,"rule ub",ub!=null?ub.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 2776:3: -> {(lb_um!=null)&&(ub_um!=null)}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) )
			if ((lb_um!=null)&&(ub_um!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2776:38: ^( $dd ^( UNARY_MINUS[$lb_um] $lb) ^( UNARY_MINUS[$ub_um] $ub) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2776:44: ^( UNARY_MINUS[$lb_um] $lb)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, lb_um), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2776:71: ^( UNARY_MINUS[$ub_um] $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, ub_um), root_2);
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2777:3: -> {lb_um!=null}? ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub)
			if (lb_um!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2777:21: ^( $dd ^( UNARY_MINUS[$lb_um] $lb) $ub)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2777:27: ^( UNARY_MINUS[$lb_um] $lb)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, lb_um), root_2);
				adaptor.addChild(root_2, stream_lb.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_ub.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2778:3: -> {ub_um!=null}? ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) )
			if (ub_um!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2778:21: ^( $dd $lb ^( UNARY_MINUS[$ub_um] $ub) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lb.nextTree());
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2778:31: ^( UNARY_MINUS[$ub_um] $ub)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, ub_um), root_2);
				adaptor.addChild(root_2, stream_ub.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 2779:3: -> ^( $dd $lb $ub)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2779:6: ^( $dd $lb $ub)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dd.nextNode(), root_1);
				adaptor.addChild(root_1, stream_lb.nextTree());
				adaptor.addChild(root_1, stream_ub.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constant_number_range"


	public static class units_designator_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "units_designator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2782:1: units_designator : ( identifier | time_unit );
	public final BLESStoASTParser.units_designator_return units_designator() throws RecognitionException {
		BLESStoASTParser.units_designator_return retval = new BLESStoASTParser.units_designator_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope identifier233 =null;
		ParserRuleReturnScope time_unit234 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2783:3: ( identifier | time_unit )
			int alt140=2;
			int LA140_0 = input.LA(1);
			if ( (LA140_0==ID) ) {
				alt140=1;
			}
			else if ( (LA140_0==LITERAL_hr||LA140_0==LITERAL_min||LA140_0==LITERAL_ms||LA140_0==LITERAL_ns||LA140_0==LITERAL_ps||LA140_0==LITERAL_sec||LA140_0==LITERAL_us) ) {
				alt140=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 140, 0, input);
				throw nvae;
			}

			switch (alt140) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2784:34: identifier
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_units_designator11494);
					identifier233=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier233.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2785:5: time_unit
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_time_unit_in_units_designator11500);
					time_unit234=time_unit();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_unit234.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.unitsDesignator,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "units_designator"


	public static class unique_component_classifier_reference_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "unique_component_classifier_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2800:1: unique_component_classifier_reference : (p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )? -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) ) -> ^( DOUBLE_COLON ( $p)+ ) |dci= identifier ( PERIOD ii= identifier )? -> {ii!=null}? ^( PERIOD $dci $ii) -> $dci);
	public final BLESStoASTParser.unique_component_classifier_reference_return unique_component_classifier_reference() throws RecognitionException {
		BLESStoASTParser.unique_component_classifier_reference_return retval = new BLESStoASTParser.unique_component_classifier_reference_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token DOUBLE_COLON235=null;
		Token PERIOD236=null;
		Token PERIOD237=null;
		List<Object> list_p=null;
		ParserRuleReturnScope ii =null;
		ParserRuleReturnScope dci =null;
		RuleReturnScope p = null;
		BAST DOUBLE_COLON235_tree=null;
		BAST PERIOD236_tree=null;
		BAST PERIOD237_tree=null;
		RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2801:3: (p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )? -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) ) -> ^( DOUBLE_COLON ( $p)+ ) |dci= identifier ( PERIOD ii= identifier )? -> {ii!=null}? ^( PERIOD $dci $ii) -> $dci)
			int alt144=2;
			int LA144_0 = input.LA(1);
			if ( (LA144_0==ID) ) {
				int LA144_1 = input.LA(2);
				if ( (LA144_1==DOUBLE_COLON) ) {
					alt144=1;
				}
				else if ( (LA144_1==LITERAL_in||LA144_1==LITERAL_of||LA144_1==LITERAL_that||LA144_1==OCTOTHORPE||LA144_1==PERIOD) ) {
					alt144=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 144, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 144, 0, input);
				throw nvae;
			}

			switch (alt144) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2802:3: p+= identifier ( DOUBLE_COLON p+= identifier )+ ( PERIOD ii= identifier )?
					{
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11540);
					p=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
					if (list_p==null) list_p=new ArrayList<Object>();
					list_p.add(p.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2802:29: ( DOUBLE_COLON p+= identifier )+
					int cnt141=0;
					loop141:
					while (true) {
						int alt141=2;
						int LA141_0 = input.LA(1);
						if ( (LA141_0==DOUBLE_COLON) ) {
							alt141=1;
						}

						switch (alt141) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2802:31: DOUBLE_COLON p+= identifier
							{
							DOUBLE_COLON235=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11544); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON235);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11549);
							p=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(p.getTree());
							if (list_p==null) list_p=new ArrayList<Object>();
							list_p.add(p.getTree());
							}
							break;

						default :
							if ( cnt141 >= 1 ) break loop141;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(141, input);
							throw eee;
						}
						cnt141++;
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2803:5: ( PERIOD ii= identifier )?
					int alt142=2;
					int LA142_0 = input.LA(1);
					if ( (LA142_0==PERIOD) ) {
						alt142=1;
					}
					switch (alt142) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2803:7: PERIOD ii= identifier
							{
							PERIOD236=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11561); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD236);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11566);
							ii=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ii.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: p, DOUBLE_COLON, p, PERIOD, ii, DOUBLE_COLON
					// token labels: 
					// rule labels: ii, retval
					// token list labels: 
					// rule list labels: p
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ii=new RewriteRuleSubtreeStream(adaptor,"rule ii",ii!=null?ii.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"token p",list_p);
					root_0 = (BAST)adaptor.nil();
					// 2804:5: -> {ii!=null}? ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) )
					if (ii!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2804:20: ^( DOUBLE_COLON ( $p)+ ^( PERIOD $ii) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_1);
						if ( !(stream_p.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_p.hasNext() ) {
							adaptor.addChild(root_1, stream_p.nextTree());
						}
						stream_p.reset();

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2804:40: ^( PERIOD $ii)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_PERIOD.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ii.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2805:5: -> ^( DOUBLE_COLON ( $p)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2805:8: ^( DOUBLE_COLON ( $p)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_DOUBLE_COLON.nextNode(), root_1);
						if ( !(stream_p.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_p.hasNext() ) {
							adaptor.addChild(root_1, stream_p.nextTree());
						}
						stream_p.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2810:3: dci= identifier ( PERIOD ii= identifier )?
					{
					pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11624);
					dci=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(dci.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2811:5: ( PERIOD ii= identifier )?
					int alt143=2;
					int LA143_0 = input.LA(1);
					if ( (LA143_0==PERIOD) ) {
						alt143=1;
					}
					switch (alt143) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2811:7: PERIOD ii= identifier
							{
							PERIOD237=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference11632); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD237);

							pushFollow(FOLLOW_identifier_in_unique_component_classifier_reference11637);
							ii=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_identifier.add(ii.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: PERIOD, dci, dci, ii
					// token labels: 
					// rule labels: ii, dci, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ii=new RewriteRuleSubtreeStream(adaptor,"rule ii",ii!=null?ii.getTree():null);
					RewriteRuleSubtreeStream stream_dci=new RewriteRuleSubtreeStream(adaptor,"rule dci",dci!=null?dci.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2812:5: -> {ii!=null}? ^( PERIOD $dci $ii)
					if (ii!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2812:20: ^( PERIOD $dci $ii)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_PERIOD.nextNode(), root_1);
						adaptor.addChild(root_1, stream_dci.nextTree());
						adaptor.addChild(root_1, stream_ii.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2813:5: -> $dci
					{
						adaptor.addChild(root_0, stream_dci.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("\nIs this a unique_component_classifier_reference?\n");
			//    tellBNF(GrammarStrings.subcomponent,re,$subcomponent.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unique_component_classifier_reference"


	public static class type_name_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "type_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2821:1: type_name : p= ID (dc= DOUBLE_COLON ^x= ID )? ;
	public final BLESStoASTParser.type_name_return type_name() throws RecognitionException {
		BLESStoASTParser.type_name_return retval = new BLESStoASTParser.type_name_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token p=null;
		Token dc=null;
		Token x=null;

		BAST p_tree=null;
		BAST dc_tree=null;
		BAST x_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2822:3: (p= ID (dc= DOUBLE_COLON ^x= ID )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2824:3: p= ID (dc= DOUBLE_COLON ^x= ID )?
			{
			root_0 = (BAST)adaptor.nil();


			p=(Token)match(input,ID,FOLLOW_ID_in_type_name11713); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			p_tree = (BAST)adaptor.create(p);
			adaptor.addChild(root_0, p_tree);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2824:8: (dc= DOUBLE_COLON ^x= ID )?
			int alt145=2;
			int LA145_0 = input.LA(1);
			if ( (LA145_0==DOUBLE_COLON) ) {
				alt145=1;
			}
			switch (alt145) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2824:9: dc= DOUBLE_COLON ^x= ID
					{
					dc=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_type_name11718); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					dc_tree = (BAST)adaptor.create(dc);
					root_0 = (BAST)adaptor.becomeRoot(dc_tree, root_0);
					}

					x=(Token)match(input,ID,FOLLOW_ID_in_type_name11723); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x_tree = (BAST)adaptor.create(x);
					adaptor.addChild(root_0, x_tree);
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.typeName,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_name"


	public static class array_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "array_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2829:1: array_type : LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type ;
	public final BLESStoASTParser.array_type_return array_type() throws RecognitionException {
		BLESStoASTParser.array_type_return retval = new BLESStoASTParser.array_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_array238=null;
		Token LBRACKET239=null;
		Token RBRACKET241=null;
		Token LITERAL_of242=null;
		ParserRuleReturnScope array_range_list240 =null;
		ParserRuleReturnScope type243 =null;

		BAST LITERAL_array238_tree=null;
		BAST LBRACKET239_tree=null;
		BAST RBRACKET241_tree=null;
		BAST LITERAL_of242_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2830:3: ( LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2831:3: LITERAL_array ^ LBRACKET ! array_range_list RBRACKET ! LITERAL_of type
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_array238=(Token)match(input,LITERAL_array,FOLLOW_LITERAL_array_in_array_type11750); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_array238_tree = (BAST)adaptor.create(LITERAL_array238);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_array238_tree, root_0);
			}

			LBRACKET239=(Token)match(input,LBRACKET,FOLLOW_LBRACKET_in_array_type11753); if (state.failed) return retval;
			pushFollow(FOLLOW_array_range_list_in_array_type11756);
			array_range_list240=array_range_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, array_range_list240.getTree());

			RBRACKET241=(Token)match(input,RBRACKET,FOLLOW_RBRACKET_in_array_type11758); if (state.failed) return retval;
			LITERAL_of242=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_array_type11761); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_of242_tree = (BAST)adaptor.create(LITERAL_of242);
			adaptor.addChild(root_0, LITERAL_of242_tree);
			}

			pushFollow(FOLLOW_type_in_array_type11763);
			type243=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type243.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.arrayType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_type"


	public static class record_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2837:1: record_type : LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !;
	public final BLESStoASTParser.record_type_return record_type() throws RecognitionException {
		BLESStoASTParser.record_type_return retval = new BLESStoASTParser.record_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_record244=null;
		Token LPAREN245=null;
		Token RPAREN247=null;
		ParserRuleReturnScope record_field246 =null;

		BAST LITERAL_record244_tree=null;
		BAST LPAREN245_tree=null;
		BAST RPAREN247_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2838:3: ( LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2839:3: LITERAL_record ^ LPAREN ! ( record_field )+ RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_record244=(Token)match(input,LITERAL_record,FOLLOW_LITERAL_record_in_record_type11790); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_record244_tree = (BAST)adaptor.create(LITERAL_record244);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_record244_tree, root_0);
			}

			LPAREN245=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_record_type11793); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2839:27: ( record_field )+
			int cnt146=0;
			loop146:
			while (true) {
				int alt146=2;
				int LA146_0 = input.LA(1);
				if ( (LA146_0==ID) ) {
					alt146=1;
				}

				switch (alt146) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2839:27: record_field
					{
					pushFollow(FOLLOW_record_field_in_record_type11796);
					record_field246=record_field();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_field246.getTree());

					}
					break;

				default :
					if ( cnt146 >= 1 ) break loop146;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(146, input);
					throw eee;
				}
				cnt146++;
			}

			RPAREN247=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_record_type11799); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.recordType,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_type"


	public static class record_field_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "record_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2844:1: record_field : identifier COLON ^ type SEMICOLON !;
	public final BLESStoASTParser.record_field_return record_field() throws RecognitionException {
		BLESStoASTParser.record_field_return retval = new BLESStoASTParser.record_field_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COLON249=null;
		Token SEMICOLON251=null;
		ParserRuleReturnScope identifier248 =null;
		ParserRuleReturnScope type250 =null;

		BAST COLON249_tree=null;
		BAST SEMICOLON251_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2845:3: ( identifier COLON ^ type SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2846:22: identifier COLON ^ type SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_identifier_in_record_field11828);
			identifier248=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier248.getTree());

			COLON249=(Token)match(input,COLON,FOLLOW_COLON_in_record_field11830); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			COLON249_tree = (BAST)adaptor.create(COLON249);
			root_0 = (BAST)adaptor.becomeRoot(COLON249_tree, root_0);
			}

			pushFollow(FOLLOW_type_in_record_field11833);
			type250=type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type250.getTree());

			SEMICOLON251=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_record_field11835); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("\nDid you forget a ; after a record or variant field?\n");
			    tellBNF(GrammarStrings.recordField,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_field"


	public static class array_range_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "array_range_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2856:1: array_range_list : natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )? ;
	public final BLESStoASTParser.array_range_list_return array_range_list() throws RecognitionException {
		BLESStoASTParser.array_range_list_return retval = new BLESStoASTParser.array_range_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA253=null;
		Token COMMA255=null;
		ParserRuleReturnScope natural_range252 =null;
		ParserRuleReturnScope natural_range254 =null;
		ParserRuleReturnScope natural_range256 =null;

		BAST COMMA253_tree=null;
		BAST COMMA255_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2857:3: ( natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2858:3: natural_range ( COMMA ^ natural_range ( COMMA ! natural_range )* )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_natural_range_in_array_range_list11865);
			natural_range252=natural_range();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range252.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2858:17: ( COMMA ^ natural_range ( COMMA ! natural_range )* )?
			int alt148=2;
			int LA148_0 = input.LA(1);
			if ( (LA148_0==COMMA) ) {
				alt148=1;
			}
			switch (alt148) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2858:19: COMMA ^ natural_range ( COMMA ! natural_range )*
					{
					COMMA253=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11869); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA253_tree = (BAST)adaptor.create(COMMA253);
					root_0 = (BAST)adaptor.becomeRoot(COMMA253_tree, root_0);
					}

					pushFollow(FOLLOW_natural_range_in_array_range_list11872);
					natural_range254=natural_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range254.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2858:40: ( COMMA ! natural_range )*
					loop147:
					while (true) {
						int alt147=2;
						int LA147_0 = input.LA(1);
						if ( (LA147_0==COMMA) ) {
							alt147=1;
						}

						switch (alt147) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2858:42: COMMA ! natural_range
							{
							COMMA255=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_range_list11876); if (state.failed) return retval;
							pushFollow(FOLLOW_natural_range_in_array_range_list11879);
							natural_range256=natural_range();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, natural_range256.getTree());

							}
							break;

						default :
							break loop147;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.arrayRangeList,re);
			      tellBNF(GrammarStrings.arrayRangeList,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_range_list"


	public static class natural_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "natural_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2865:1: natural_range : (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )? ;
	public final BLESStoASTParser.natural_range_return natural_range() throws RecognitionException {
		BLESStoASTParser.natural_range_return retval = new BLESStoASTParser.natural_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ilb=null;
		Token dd=null;
		Token iub=null;
		ParserRuleReturnScope elb =null;
		ParserRuleReturnScope pnlb =null;
		ParserRuleReturnScope eub =null;
		ParserRuleReturnScope pnub =null;

		BAST ilb_tree=null;
		BAST dd_tree=null;
		BAST iub_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2866:3: ( (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2867:3: (ilb= INTEGER_LIT |elb= identifier |pnlb= property ) (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2867:3: (ilb= INTEGER_LIT |elb= identifier |pnlb= property )
			int alt149=3;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt149=1;
				}
				break;
			case ID:
				{
				int LA149_2 = input.LA(2);
				if ( (LA149_2==COMMA||LA149_2==DOTDOT||LA149_2==RBRACKET) ) {
					alt149=2;
				}
				else if ( (LA149_2==DOUBLE_COLON||LA149_2==OCTOTHORPE||LA149_2==PERIOD) ) {
					alt149=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 149, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_self:
			case OCTOTHORPE:
				{
				alt149=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 149, 0, input);
				throw nvae;
			}
			switch (alt149) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2867:5: ilb= INTEGER_LIT
					{
					ilb=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11916); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ilb_tree = (BAST)adaptor.create(ilb);
					adaptor.addChild(root_0, ilb_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2867:23: elb= identifier
					{
					pushFollow(FOLLOW_identifier_in_natural_range11922);
					elb=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, elb.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2867:40: pnlb= property
					{
					pushFollow(FOLLOW_property_in_natural_range11928);
					pnlb=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, pnlb.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2868:3: (dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property ) )?
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==DOTDOT) ) {
				alt151=1;
			}
			switch (alt151) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2868:5: dd= DOTDOT ^ (iub= INTEGER_LIT |eub= identifier |pnub= property )
					{
					dd=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_natural_range11938); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					dd_tree = (BAST)adaptor.create(dd);
					root_0 = (BAST)adaptor.becomeRoot(dd_tree, root_0);
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2868:16: (iub= INTEGER_LIT |eub= identifier |pnub= property )
					int alt150=3;
					switch ( input.LA(1) ) {
					case INTEGER_LIT:
						{
						alt150=1;
						}
						break;
					case ID:
						{
						int LA150_2 = input.LA(2);
						if ( (LA150_2==COMMA||LA150_2==RBRACKET) ) {
							alt150=2;
						}
						else if ( (LA150_2==DOUBLE_COLON||LA150_2==OCTOTHORPE||LA150_2==PERIOD) ) {
							alt150=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 150, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					case LITERAL_self:
					case OCTOTHORPE:
						{
						alt150=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 150, 0, input);
						throw nvae;
					}
					switch (alt150) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2868:18: iub= INTEGER_LIT
							{
							iub=(Token)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_natural_range11945); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							iub_tree = (BAST)adaptor.create(iub);
							adaptor.addChild(root_0, iub_tree);
							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2868:36: eub= identifier
							{
							pushFollow(FOLLOW_identifier_in_natural_range11951);
							eub=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, eub.getTree());

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2868:53: pnub= property
							{
							pushFollow(FOLLOW_property_in_natural_range11957);
							pnub=property();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, pnub.getTree());

							}
							break;

					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.naturalRange,re);
			      tellBNF(GrammarStrings.naturalRange,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "natural_range"


	public static class variant_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "variant_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2880:1: variant_type : LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !;
	public final BLESStoASTParser.variant_type_return variant_type() throws RecognitionException {
		BLESStoASTParser.variant_type_return retval = new BLESStoASTParser.variant_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_variant257=null;
		Token LPAREN258=null;
		Token RPAREN260=null;
		ParserRuleReturnScope record_field259 =null;

		BAST LITERAL_variant257_tree=null;
		BAST LPAREN258_tree=null;
		BAST RPAREN260_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2881:3: ( LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2882:3: LITERAL_variant ^ LPAREN ! ( record_field )+ RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_variant257=(Token)match(input,LITERAL_variant,FOLLOW_LITERAL_variant_in_variant_type11994); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_variant257_tree = (BAST)adaptor.create(LITERAL_variant257);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_variant257_tree, root_0);
			}

			LPAREN258=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_variant_type12002); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2883:13: ( record_field )+
			int cnt152=0;
			loop152:
			while (true) {
				int alt152=2;
				int LA152_0 = input.LA(1);
				if ( (LA152_0==ID) ) {
					alt152=1;
				}

				switch (alt152) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2883:13: record_field
					{
					pushFollow(FOLLOW_record_field_in_variant_type12005);
					record_field259=record_field();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, record_field259.getTree());

					}
					break;

				default :
					if ( cnt152 >= 1 ) break loop152;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(152, input);
					throw eee;
				}
				cnt152++;
			}

			RPAREN260=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_variant_type12008); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.variantType,re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variant_type"


	public static class assertion_annex_subclause_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_annex_subclause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2890:1: assertion_annex_subclause : ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )? ;
	public final BLESStoASTParser.assertion_annex_subclause_return assertion_annex_subclause() throws RecognitionException {
		BLESStoASTParser.assertion_annex_subclause_return retval = new BLESStoASTParser.assertion_annex_subclause_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START261=null;
		Token ANNEX_END262=null;
		List<Object> list_a=null;
		ParserRuleReturnScope p =null;
		RuleReturnScope a = null;
		BAST ANNEX_START261_tree=null;
		BAST ANNEX_END262_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2891:3: ( ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2892:3: ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) ) ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2892:3: ( ANNEX_START )?
			int alt153=2;
			int LA153_0 = input.LA(1);
			if ( (LA153_0==ANNEX_START) ) {
				alt153=1;
			}
			switch (alt153) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2892:3: ANNEX_START
					{
					ANNEX_START261=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_subclause12037); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START261);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2893:3: ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) |p= predicate -> ^( ASSERTION_ANNEX $p) )
			int alt155=2;
			int LA155_0 = input.LA(1);
			if ( (LA155_0==LASS) ) {
				alt155=1;
			}
			else if ( (LA155_0==AADL_STRING_LITERAL||LA155_0==ID||LA155_0==INTEGER_LIT||LA155_0==LBRACKET||LA155_0==LITERAL_abs||LA155_0==LITERAL_all||LA155_0==LITERAL_complex||LA155_0==LITERAL_def||LA155_0==LITERAL_exists||LA155_0==LITERAL_false||LA155_0==LITERAL_in||LA155_0==LITERAL_integer||LA155_0==LITERAL_natural||(LA155_0 >= LITERAL_not && LA155_0 <= LITERAL_now)||LA155_0==LITERAL_null||(LA155_0 >= LITERAL_rational && LA155_0 <= LITERAL_real)||LA155_0==LITERAL_self||LA155_0==LITERAL_stop||(LA155_0 >= LITERAL_time && LA155_0 <= LITERAL_timeout)||LA155_0==LITERAL_tops||LA155_0==LITERAL_true||LA155_0==LPAREN||LA155_0==MINUS||LA155_0==OCTOTHORPE||LA155_0==REAL_LIT) ) {
				alt155=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 155, 0, input);
				throw nvae;
			}

			switch (alt155) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2894:3: (a+= assertion )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2894:4: (a+= assertion )+
					int cnt154=0;
					loop154:
					while (true) {
						int alt154=2;
						int LA154_0 = input.LA(1);
						if ( (LA154_0==LASS) ) {
							alt154=1;
						}

						switch (alt154) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2894:4: a+= assertion
							{
							pushFollow(FOLLOW_assertion_in_assertion_annex_subclause12048);
							a=assertion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTree());
							}
							break;

						default :
							if ( cnt154 >= 1 ) break loop154;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(154, input);
							throw eee;
						}
						cnt154++;
					}

					// AST REWRITE
					// elements: a
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: a
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
					root_0 = (BAST)adaptor.nil();
					// 2895:5: -> ^( ASSERTION_ANNEX ( $a)+ )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2895:8: ^( ASSERTION_ANNEX ( $a)+ )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
						if ( !(stream_a.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_a.hasNext() ) {
							adaptor.addChild(root_1, stream_a.nextTree());
						}
						stream_a.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2896:5: p= predicate
					{
					pushFollow(FOLLOW_predicate_in_assertion_annex_subclause12071);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					// AST REWRITE
					// elements: p
					// token labels: 
					// rule labels: p, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2897:5: -> ^( ASSERTION_ANNEX $p)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2897:8: ^( ASSERTION_ANNEX $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2899:3: ( ANNEX_END )?
			int alt156=2;
			int LA156_0 = input.LA(1);
			if ( (LA156_0==ANNEX_END) ) {
				alt156=1;
			}
			switch (alt156) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2899:3: ANNEX_END
					{
					ANNEX_END262=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_subclause12092); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END262);

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertionAnnexSubclause,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_subclause"


	public static class assertion_annex_library_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_annex_library"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2906:1: assertion_annex_library : ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )? ;
	public final BLESStoASTParser.assertion_annex_library_return assertion_annex_library() throws RecognitionException {
		BLESStoASTParser.assertion_annex_library_return retval = new BLESStoASTParser.assertion_annex_library_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ANNEX_START263=null;
		Token ANNEX_END264=null;
		List<Object> list_a=null;
		RuleReturnScope a = null;
		BAST ANNEX_START263_tree=null;
		BAST ANNEX_END264_tree=null;
		RewriteRuleTokenStream stream_ANNEX_START=new RewriteRuleTokenStream(adaptor,"token ANNEX_START");
		RewriteRuleTokenStream stream_ANNEX_END=new RewriteRuleTokenStream(adaptor,"token ANNEX_END");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2907:3: ( ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2908:3: ( ANNEX_START )? ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) ) ( ANNEX_END )?
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2908:3: ( ANNEX_START )?
			int alt157=2;
			int LA157_0 = input.LA(1);
			if ( (LA157_0==ANNEX_START) ) {
				alt157=1;
			}
			switch (alt157) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2908:3: ANNEX_START
					{
					ANNEX_START263=(Token)match(input,ANNEX_START,FOLLOW_ANNEX_START_in_assertion_annex_library12120); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_START.add(ANNEX_START263);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2909:3: ( (a+= assertion )+ -> ^( ASSERTION_ANNEX ( $a)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2910:3: (a+= assertion )+
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2910:4: (a+= assertion )+
			int cnt158=0;
			loop158:
			while (true) {
				int alt158=2;
				int LA158_0 = input.LA(1);
				if ( (LA158_0==LASS) ) {
					alt158=1;
				}

				switch (alt158) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2910:4: a+= assertion
					{
					pushFollow(FOLLOW_assertion_in_assertion_annex_library12131);
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion.add(a.getTree());
					if (list_a==null) list_a=new ArrayList<Object>();
					list_a.add(a.getTree());
					}
					break;

				default :
					if ( cnt158 >= 1 ) break loop158;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(158, input);
					throw eee;
				}
				cnt158++;
			}

			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: a
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"token a",list_a);
			root_0 = (BAST)adaptor.nil();
			// 2911:5: -> ^( ASSERTION_ANNEX ( $a)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2911:8: ^( ASSERTION_ANNEX ( $a)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ANNEX, "ASSERTION_ANNEX"), root_1);
				if ( !(stream_a.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_a.hasNext() ) {
					adaptor.addChild(root_1, stream_a.nextTree());
				}
				stream_a.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2913:3: ( ANNEX_END )?
			int alt159=2;
			int LA159_0 = input.LA(1);
			if ( (LA159_0==ANNEX_END) ) {
				alt159=1;
			}
			switch (alt159) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2913:3: ANNEX_END
					{
					ANNEX_END264=(Token)match(input,ANNEX_END,FOLLOW_ANNEX_END_in_assertion_annex_library12154); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ANNEX_END.add(ANNEX_END264);

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.assertionAnnexLibrary,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_library"


	public static class assertion_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2918:1: assertion : ll= LASS !ab= assertion_body RASS !;
	public final BLESStoASTParser.assertion_return assertion() throws RecognitionException {
		BLESStoASTParser.assertion_return retval = new BLESStoASTParser.assertion_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ll=null;
		Token RASS265=null;
		ParserRuleReturnScope ab =null;

		BAST ll_tree=null;
		BAST RASS265_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2920:3: (ll= LASS !ab= assertion_body RASS !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2921:3: ll= LASS !ab= assertion_body RASS !
			{
			root_0 = (BAST)adaptor.nil();


			ll=(Token)match(input,LASS,FOLLOW_LASS_in_assertion12184); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_body_in_assertion12189);
			ab=assertion_body();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ab.getTree());

			RASS265=(Token)match(input,RASS,FOLLOW_RASS_in_assertion12191); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (MismatchedTokenException mte) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(mte,(BAST)retval.getTree());
			    tellBNF("\ntry using more parentheses near line "+
			      Integer.toString(ll.getLine()+startingLine)+", as if you\'re not parenthetic enough already"+
			      "\n",mte,retval.tree);
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); tellBNF(GrammarStrings.AssertionBNF,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion"


	public static class assertion_body_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_body"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2934:1: assertion_body : ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) );
	public final BLESStoASTParser.assertion_body_return assertion_body() throws RecognitionException {
		BLESStoASTParser.assertion_body_return retval = new BLESStoASTParser.assertion_body_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token cln=null;
		Token COLON266=null;
		Token ASSIGN267=null;
		Token ASSIGN268=null;
		ParserRuleReturnScope a =null;
		ParserRuleReturnScope lv1 =null;
		ParserRuleReturnScope ae =null;
		ParserRuleReturnScope lv =null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope e =null;
		ParserRuleReturnScope p3 =null;

		BAST cln_tree=null;
		BAST COLON266_tree=null;
		BAST ASSIGN267_tree=null;
		BAST ASSIGN268_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion_enumeration=new RewriteRuleSubtreeStream(adaptor,"rule assertion_enumeration");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_formal_assertion_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_assertion_parameter_list");
		RewriteRuleSubtreeStream stream_assertion_function_value=new RewriteRuleSubtreeStream(adaptor,"rule assertion_function_value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2941:3: ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) )
			int alt162=6;
			alt162 = dfa162.predict(input);
			switch (alt162) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2943:3: (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2943:3: (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2943:5: a= identifier cln= COLON lv1= identifier ae= assertion_enumeration
					{
					pushFollow(FOLLOW_identifier_in_assertion_body12246);
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12250); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					pushFollow(FOLLOW_identifier_in_assertion_body12254);
					lv1=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(lv1.getTree());
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12258);
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_enumeration.add(ae.getTree());
					}

					// AST REWRITE
					// elements: a, lv1, ae
					// token labels: 
					// rule labels: a, ae, lv1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
					RewriteRuleSubtreeStream stream_lv1=new RewriteRuleSubtreeStream(adaptor,"rule lv1",lv1!=null?lv1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2944:5: -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2944:8: ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ENUMERATION, (a!=null?((BAST)a.getTree()):null).getToken(), "ASSERTION_ENUMERATION["+Integer.toString((a!=null?((BAST)a.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2946:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2946:22: ^( PARAMETERS $lv1)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv1.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_ae.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2949:3: ae= assertion_enumeration
					{
					pushFollow(FOLLOW_assertion_enumeration_in_assertion_body12314);
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_enumeration.add(ae.getTree());
					// AST REWRITE
					// elements: ae
					// token labels: 
					// rule labels: ae, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2950:5: -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2950:8: ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_ENUMERATION, (ae!=null?((BAST)ae.getTree()):null).getToken(), "ASSERTION_ENUMERATION["+Integer.toString((ae!=null?((BAST)ae.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_ae.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2953:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2953:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2953:5: a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate
					{
					pushFollow(FOLLOW_identifier_in_assertion_body12341);
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12345); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2953:30: (lv= formal_assertion_parameter_list )?
					int alt160=2;
					int LA160_0 = input.LA(1);
					if ( (LA160_0==ID) ) {
						alt160=1;
					}
					switch (alt160) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2953:30: lv= formal_assertion_parameter_list
							{
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12349);
							lv=formal_assertion_parameter_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_formal_assertion_parameter_list.add(lv.getTree());
							}
							break;

					}

					COLON266=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12352); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON266);

					pushFollow(FOLLOW_predicate_in_assertion_body12356);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					}

					// AST REWRITE
					// elements: p, p, a, a, lv
					// token labels: 
					// rule labels: p, a, lv, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2954:5: -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p)
					if (lv!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2954:20: ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p!=null?((BAST)p.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2955:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2955:22: ^( PARAMETERS $lv)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2956:5: -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2956:9: ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p!=null?((BAST)p.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p!=null?((BAST)p.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2957:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:3: (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:5: a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value
					{
					pushFollow(FOLLOW_identifier_in_assertion_body12448);
					a=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(a.getTree());
					cln=(Token)match(input,COLON,FOLLOW_COLON_in_assertion_body12452); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(cln);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:30: (lv= formal_assertion_parameter_list )?
					int alt161=2;
					int LA161_0 = input.LA(1);
					if ( (LA161_0==ID) ) {
						alt161=1;
					}
					switch (alt161) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2959:30: lv= formal_assertion_parameter_list
							{
							pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion_body12456);
							lv=formal_assertion_parameter_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_formal_assertion_parameter_list.add(lv.getTree());
							}
							break;

					}

					ASSIGN267=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12459); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN267);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12463);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_value.add(e.getTree());
					}

					// AST REWRITE
					// elements: e, a, lv, a, e
					// token labels: 
					// rule labels: a, e, lv, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,"rule lv",lv!=null?lv.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2960:5: -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e)
					if (lv!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2960:20: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2962:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2962:22: ^( PARAMETERS $lv)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETERS, "PARAMETERS"), root_2);
						adaptor.addChild(root_2, stream_lv.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 2963:5: -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2963:8: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2965:9: ^( LABEL $a)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(LABEL, "LABEL"), root_2);
						adaptor.addChild(root_2, stream_a.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2970:5: ( ASSIGN e= assertion_function_value )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2970:5: ( ASSIGN e= assertion_function_value )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2970:7: ASSIGN e= assertion_function_value
					{
					ASSIGN268=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assertion_body12554); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN268);

					pushFollow(FOLLOW_assertion_function_value_in_assertion_body12558);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_value.add(e.getTree());
					}

					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2971:5: -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2971:8: ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION_FUNCTION, (e!=null?((BAST)e.getTree()):null).getToken(), "ASSERTION_FUNCTION["+Integer.toString((e!=null?((BAST)e.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_e.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2975:5: p3= predicate
					{
					pushFollow(FOLLOW_predicate_in_assertion_body12594);
					p3=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p3.getTree());
					// AST REWRITE
					// elements: p3
					// token labels: 
					// rule labels: p3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p3=new RewriteRuleSubtreeStream(adaptor,"rule p3",p3!=null?p3.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 2976:5: -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2976:8: ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(ASSERTION, (p3!=null?((BAST)p3.getTree()):null).getToken(), "ASSERTION["+Integer.toString((p3!=null?((BAST)p3.getTree()):null).getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_p3.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (YouIdiot yi) {
			yi.handleException();
		}
		catch (RecognitionException re) {
			 
			    Dump.it("Could you be missing parentheses?");
			    tellBNF(GrammarStrings.assertionBody,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_body"


	public static class formal_assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2985:1: formal_assertion_parameter : ID TILDE ^ type_name ;
	public final BLESStoASTParser.formal_assertion_parameter_return formal_assertion_parameter() throws RecognitionException {
		BLESStoASTParser.formal_assertion_parameter_return retval = new BLESStoASTParser.formal_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID269=null;
		Token TILDE270=null;
		ParserRuleReturnScope type_name271 =null;

		BAST ID269_tree=null;
		BAST TILDE270_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2986:3: ( ID TILDE ^ type_name )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2987:17: ID TILDE ^ type_name
			{
			root_0 = (BAST)adaptor.nil();


			ID269=(Token)match(input,ID,FOLLOW_ID_in_formal_assertion_parameter12645); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID269_tree = (BAST)adaptor.create(ID269);
			adaptor.addChild(root_0, ID269_tree);
			}

			TILDE270=(Token)match(input,TILDE,FOLLOW_TILDE_in_formal_assertion_parameter12647); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			TILDE270_tree = (BAST)adaptor.create(TILDE270);
			root_0 = (BAST)adaptor.becomeRoot(TILDE270_tree, root_0);
			}

			pushFollow(FOLLOW_type_name_in_formal_assertion_parameter12650);
			type_name271=type_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, type_name271.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter"


	public static class formal_assertion_parameter_list_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "formal_assertion_parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2990:1: formal_assertion_parameter_list : formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )? ;
	public final BLESStoASTParser.formal_assertion_parameter_list_return formal_assertion_parameter_list() throws RecognitionException {
		BLESStoASTParser.formal_assertion_parameter_list_return retval = new BLESStoASTParser.formal_assertion_parameter_list_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token COMMA273=null;
		Token COMMA275=null;
		ParserRuleReturnScope formal_assertion_parameter272 =null;
		ParserRuleReturnScope formal_assertion_parameter274 =null;
		ParserRuleReturnScope formal_assertion_parameter276 =null;

		BAST COMMA273_tree=null;
		BAST COMMA275_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2991:3: ( formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2992:3: formal_assertion_parameter ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12666);
			formal_assertion_parameter272=formal_assertion_parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter272.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2992:30: ( COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )* )?
			int alt164=2;
			int LA164_0 = input.LA(1);
			if ( (LA164_0==COMMA) ) {
				alt164=1;
			}
			switch (alt164) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2992:32: COMMA ^ formal_assertion_parameter ( COMMA formal_assertion_parameter )*
					{
					COMMA273=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12670); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA273_tree = (BAST)adaptor.create(COMMA273);
					root_0 = (BAST)adaptor.becomeRoot(COMMA273_tree, root_0);
					}

					pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12673);
					formal_assertion_parameter274=formal_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter274.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2993:6: ( COMMA formal_assertion_parameter )*
					loop163:
					while (true) {
						int alt163=2;
						int LA163_0 = input.LA(1);
						if ( (LA163_0==COMMA) ) {
							alt163=1;
						}

						switch (alt163) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2993:8: COMMA formal_assertion_parameter
							{
							COMMA275=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list12682); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							COMMA275_tree = (BAST)adaptor.create(COMMA275);
							adaptor.addChild(root_0, COMMA275_tree);
							}

							pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12684);
							formal_assertion_parameter276=formal_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_assertion_parameter276.getTree());

							}
							break;

						default :
							break loop163;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter_list"


	public static class assertion_function_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_function_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2996:1: assertion_function_value : ( ( parenthesized_predicate IMP )=>cae= conditional_assertion_function -> $cae|e= assertion_expression -> $e);
	public final BLESStoASTParser.assertion_function_value_return assertion_function_value() throws RecognitionException {
		BLESStoASTParser.assertion_function_value_return retval = new BLESStoASTParser.assertion_function_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope cae =null;
		ParserRuleReturnScope e =null;

		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_conditional_assertion_function=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_function");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2997:3: ( ( parenthesized_predicate IMP )=>cae= conditional_assertion_function -> $cae|e= assertion_expression -> $e)
			int alt165=2;
			int LA165_0 = input.LA(1);
			if ( (LA165_0==LPAREN) ) {
				int LA165_1 = input.LA(2);
				if ( (synpred8_BLESStoAST()) ) {
					alt165=1;
				}
				else if ( (true) ) {
					alt165=2;
				}

			}
			else if ( (LA165_0==AADL_STRING_LITERAL||LA165_0==ID||LA165_0==INTEGER_LIT||LA165_0==LBRACKET||LA165_0==LITERAL_abs||LA165_0==LITERAL_complex||LA165_0==LITERAL_false||LA165_0==LITERAL_in||LA165_0==LITERAL_integer||LA165_0==LITERAL_natural||LA165_0==LITERAL_now||(LA165_0 >= LITERAL_null && LA165_0 <= LITERAL_numberof)||LA165_0==LITERAL_product||(LA165_0 >= LITERAL_rational && LA165_0 <= LITERAL_real)||LA165_0==LITERAL_self||LA165_0==LITERAL_sum||(LA165_0 >= LITERAL_time && LA165_0 <= LITERAL_timeout)||LA165_0==LITERAL_tops||LA165_0==LITERAL_true||LA165_0==MINUS||LA165_0==OCTOTHORPE||LA165_0==REAL_LIT) ) {
				alt165=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 165, 0, input);
				throw nvae;
			}

			switch (alt165) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2998:3: ( parenthesized_predicate IMP )=>cae= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_assertion_function_value12718);
					cae=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_function.add(cae.getTree());
					// AST REWRITE
					// elements: cae
					// token labels: 
					// rule labels: cae, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cae=new RewriteRuleSubtreeStream(adaptor,"rule cae",cae!=null?cae.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3000:5: -> $cae
					{
						adaptor.addChild(root_0, stream_cae.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3002:3: e= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_assertion_function_value12737);
					e=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(e.getTree());
					// AST REWRITE
					// elements: e
					// token labels: 
					// rule labels: e, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3003:5: -> $e
					{
						adaptor.addChild(root_0, stream_e.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_value"


	public static class conditional_assertion_function_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_assertion_function"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3006:1: conditional_assertion_function : ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN ) -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ ) ;
	public final BLESStoASTParser.conditional_assertion_function_return conditional_assertion_function() throws RecognitionException {
		BLESStoASTParser.conditional_assertion_function_return retval = new BLESStoASTParser.conditional_assertion_function_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token c=null;
		Token LPAREN277=null;
		Token COMMA278=null;
		Token RPAREN279=null;
		List<Object> list_cvp=null;
		RuleReturnScope cvp = null;
		BAST c_tree=null;
		BAST LPAREN277_tree=null;
		BAST COMMA278_tree=null;
		BAST RPAREN279_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_condition_value_pair=new RewriteRuleSubtreeStream(adaptor,"rule condition_value_pair");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3007:3: ( ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN ) -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3008:3: ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3008:3: ( LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3008:5: LPAREN cvp+= condition_value_pair (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* ) RPAREN
			{
			LPAREN277=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_function12763); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN277);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12770);
			cvp=condition_value_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
			if (list_cvp==null) list_cvp=new ArrayList<Object>();
			list_cvp.add(cvp.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3009:30: (c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )* )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3009:32: c= COMMA cvp+= condition_value_pair ( COMMA cvp+= condition_value_pair )*
			{
			c=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12776); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(c);

			pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12780);
			cvp=condition_value_pair();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
			if (list_cvp==null) list_cvp=new ArrayList<Object>();
			list_cvp.add(cvp.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3010:4: ( COMMA cvp+= condition_value_pair )*
			loop166:
			while (true) {
				int alt166=2;
				int LA166_0 = input.LA(1);
				if ( (LA166_0==COMMA) ) {
					alt166=1;
				}

				switch (alt166) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3010:5: COMMA cvp+= condition_value_pair
					{
					COMMA278=(Token)match(input,COMMA,FOLLOW_COMMA_in_conditional_assertion_function12787); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA278);

					pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function12791);
					cvp=condition_value_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_condition_value_pair.add(cvp.getTree());
					if (list_cvp==null) list_cvp=new ArrayList<Object>();
					list_cvp.add(cvp.getTree());
					}
					break;

				default :
					break loop166;
				}
			}

			}

			RPAREN279=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_function12801); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN279);

			}

			// AST REWRITE
			// elements: cvp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: cvp
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_cvp=new RewriteRuleSubtreeStream(adaptor,"token cvp",list_cvp);
			root_0 = (BAST)adaptor.nil();
			// 3012:5: -> ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3012:8: ^( CONDITIONAL_FUNCTION[$c] ( $cvp)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL_FUNCTION, c), root_1);
				if ( !(stream_cvp.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_cvp.hasNext() ) {
					adaptor.addChild(root_1, stream_cvp.nextTree());
				}
				stream_cvp.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_function"


	public static class condition_value_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "condition_value_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3016:1: condition_value_pair : parenthesized_predicate IMP ^ assertion_expression ;
	public final BLESStoASTParser.condition_value_pair_return condition_value_pair() throws RecognitionException {
		BLESStoASTParser.condition_value_pair_return retval = new BLESStoASTParser.condition_value_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token IMP281=null;
		ParserRuleReturnScope parenthesized_predicate280 =null;
		ParserRuleReturnScope assertion_expression282 =null;

		BAST IMP281_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3017:3: ( parenthesized_predicate IMP ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3018:3: parenthesized_predicate IMP ^ assertion_expression
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_parenthesized_predicate_in_condition_value_pair12842);
			parenthesized_predicate280=parenthesized_predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_predicate280.getTree());

			IMP281=(Token)match(input,IMP,FOLLOW_IMP_in_condition_value_pair12844); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			IMP281_tree = (BAST)adaptor.create(IMP281);
			root_0 = (BAST)adaptor.becomeRoot(IMP281_tree, root_0);
			}

			pushFollow(FOLLOW_assertion_expression_in_condition_value_pair12847);
			assertion_expression282=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression282.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "condition_value_pair"


	public static class assertion_enumeration_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_enumeration"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3021:1: assertion_enumeration : ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) );
	public final BLESStoASTParser.assertion_enumeration_return assertion_enumeration() throws RecognitionException {
		BLESStoASTParser.assertion_enumeration_return retval = new BLESStoASTParser.assertion_enumeration_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token PLUS_ARROW283=null;
		Token COMMA285=null;
		Token PLUS_ARROW287=null;
		ParserRuleReturnScope enumeration_pair284 =null;
		ParserRuleReturnScope enumeration_pair286 =null;
		ParserRuleReturnScope predicate_invocation288 =null;

		BAST PLUS_ARROW283_tree=null;
		BAST COMMA285_tree=null;
		BAST PLUS_ARROW287_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3022:3: ( ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* ) | ( PLUS_ARROW ^ predicate_invocation ) )
			int alt168=2;
			int LA168_0 = input.LA(1);
			if ( (LA168_0==PLUS_ARROW) ) {
				int LA168_1 = input.LA(2);
				if ( (LA168_1==ID) ) {
					int LA168_2 = input.LA(3);
					if ( (LA168_2==IMP) ) {
						alt168=1;
					}
					else if ( (LA168_2==LPAREN) ) {
						alt168=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 168, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 168, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 168, 0, input);
				throw nvae;
			}

			switch (alt168) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3023:3: ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* )
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3023:3: ( PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3023:4: PLUS_ARROW ^ enumeration_pair ( COMMA ! enumeration_pair )*
					{
					PLUS_ARROW283=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12865); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					PLUS_ARROW283_tree = (BAST)adaptor.create(PLUS_ARROW283);
					root_0 = (BAST)adaptor.becomeRoot(PLUS_ARROW283_tree, root_0);
					}

					pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12868);
					enumeration_pair284=enumeration_pair();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_pair284.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3023:33: ( COMMA ! enumeration_pair )*
					loop167:
					while (true) {
						int alt167=2;
						int LA167_0 = input.LA(1);
						if ( (LA167_0==COMMA) ) {
							alt167=1;
						}

						switch (alt167) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3023:34: COMMA ! enumeration_pair
							{
							COMMA285=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_enumeration12871); if (state.failed) return retval;
							pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration12874);
							enumeration_pair286=enumeration_pair();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, enumeration_pair286.getTree());

							}
							break;

						default :
							break loop167;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3025:3: ( PLUS_ARROW ^ predicate_invocation )
					{
					root_0 = (BAST)adaptor.nil();


					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3025:3: ( PLUS_ARROW ^ predicate_invocation )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3025:4: PLUS_ARROW ^ predicate_invocation
					{
					PLUS_ARROW287=(Token)match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration12889); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					PLUS_ARROW287_tree = (BAST)adaptor.create(PLUS_ARROW287);
					root_0 = (BAST)adaptor.becomeRoot(PLUS_ARROW287_tree, root_0);
					}

					pushFollow(FOLLOW_predicate_invocation_in_assertion_enumeration12892);
					predicate_invocation288=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate_invocation288.getTree());

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_enumeration"


	public static class enumeration_pair_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "enumeration_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3028:1: enumeration_pair : ID ^ IMP ! predicate ;
	public final BLESStoASTParser.enumeration_pair_return enumeration_pair() throws RecognitionException {
		BLESStoASTParser.enumeration_pair_return retval = new BLESStoASTParser.enumeration_pair_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID289=null;
		Token IMP290=null;
		ParserRuleReturnScope predicate291 =null;

		BAST ID289_tree=null;
		BAST IMP290_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3029:3: ( ID ^ IMP ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3030:27: ID ^ IMP ! predicate
			{
			root_0 = (BAST)adaptor.nil();


			ID289=(Token)match(input,ID,FOLLOW_ID_in_enumeration_pair12911); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID289_tree = (BAST)adaptor.create(ID289);
			root_0 = (BAST)adaptor.becomeRoot(ID289_tree, root_0);
			}

			IMP290=(Token)match(input,IMP,FOLLOW_IMP_in_enumeration_pair12914); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_enumeration_pair12917);
			predicate291=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate291.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_pair"


	public static class universal_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "universal_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3033:1: universal_quantification : a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate ;
	public final BLESStoASTParser.universal_quantification_return universal_quantification() throws RecognitionException {
		BLESStoASTParser.universal_quantification_return retval = new BLESStoASTParser.universal_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		Token r=null;
		ParserRuleReturnScope logic_variables292 =null;
		ParserRuleReturnScope logic_variable_domain293 =null;
		ParserRuleReturnScope predicate294 =null;

		BAST a_tree=null;
		BAST r_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3034:3: (a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3035:3: a= LITERAL_all ^ logic_variables logic_variable_domain r= LITERAL_are ! predicate
			{
			root_0 = (BAST)adaptor.nil();


			a=(Token)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_universal_quantification12936); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			a_tree = (BAST)adaptor.create(a);
			root_0 = (BAST)adaptor.becomeRoot(a_tree, root_0);
			}

			pushFollow(FOLLOW_logic_variables_in_universal_quantification12939);
			logic_variables292=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variables292.getTree());

			pushFollow(FOLLOW_logic_variable_domain_in_universal_quantification12941);
			logic_variable_domain293=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variable_domain293.getTree());

			r=(Token)match(input,LITERAL_are,FOLLOW_LITERAL_are_in_universal_quantification12945); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_universal_quantification12948);
			predicate294=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate294.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			   Dump.it("RecognitionException caught by BLESStoAST.universal_quantification");
			   Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree());
			    tellBNF(GrammarStrings.universalQuantification,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_quantification"


	public static class existential_quantification_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "existential_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3043:1: existential_quantification : e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate ;
	public final BLESStoASTParser.existential_quantification_return existential_quantification() throws RecognitionException {
		BLESStoASTParser.existential_quantification_return retval = new BLESStoASTParser.existential_quantification_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token e=null;
		Token t=null;
		ParserRuleReturnScope logic_variables295 =null;
		ParserRuleReturnScope logic_variable_domain296 =null;
		ParserRuleReturnScope predicate297 =null;

		BAST e_tree=null;
		BAST t_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3044:3: (e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3045:3: e= LITERAL_exists ^ logic_variables logic_variable_domain t= LITERAL_that ! predicate
			{
			root_0 = (BAST)adaptor.nil();


			e=(Token)match(input,LITERAL_exists,FOLLOW_LITERAL_exists_in_existential_quantification12974); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			e_tree = (BAST)adaptor.create(e);
			root_0 = (BAST)adaptor.becomeRoot(e_tree, root_0);
			}

			pushFollow(FOLLOW_logic_variables_in_existential_quantification12977);
			logic_variables295=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variables295.getTree());

			pushFollow(FOLLOW_logic_variable_domain_in_existential_quantification12979);
			logic_variable_domain296=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, logic_variable_domain296.getTree());

			t=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_existential_quantification12983); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_existential_quantification12986);
			predicate297=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate297.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("RecognitionException caught by BLESStoAST.existential_quantification");
			    tellBNF(GrammarStrings.existentialQuantification,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_quantification"


	public static class logic_variables_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logic_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3052:1: logic_variables :i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) ;
	public final BLESStoASTParser.logic_variables_return logic_variables() throws RecognitionException {
		BLESStoASTParser.logic_variables_return retval = new BLESStoASTParser.logic_variables_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token coln=null;
		Token COMMA298=null;
		List<Object> list_i=null;
		ParserRuleReturnScope aty =null;
		RuleReturnScope i = null;
		BAST coln_tree=null;
		BAST COMMA298_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_assertion_type=new RewriteRuleSubtreeStream(adaptor,"rule assertion_type");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3053:3: (i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type -> ^( $coln $aty ( $i)+ ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3054:3: i+= identifier ( COMMA i+= identifier )* coln= COLON aty= assertion_type
			{
			pushFollow(FOLLOW_identifier_in_logic_variables13014);
			i=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
			if (list_i==null) list_i=new ArrayList<Object>();
			list_i.add(i.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3054:17: ( COMMA i+= identifier )*
			loop169:
			while (true) {
				int alt169=2;
				int LA169_0 = input.LA(1);
				if ( (LA169_0==COMMA) ) {
					alt169=1;
				}

				switch (alt169) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3054:18: COMMA i+= identifier
					{
					COMMA298=(Token)match(input,COMMA,FOLLOW_COMMA_in_logic_variables13017); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA298);

					pushFollow(FOLLOW_identifier_in_logic_variables13021);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTree());
					}
					break;

				default :
					break loop169;
				}
			}

			coln=(Token)match(input,COLON,FOLLOW_COLON_in_logic_variables13027); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(coln);

			pushFollow(FOLLOW_assertion_type_in_logic_variables13031);
			aty=assertion_type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assertion_type.add(aty.getTree());
			// AST REWRITE
			// elements: coln, i, aty
			// token labels: coln
			// rule labels: aty, retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_coln=new RewriteRuleTokenStream(adaptor,"token coln",coln);
			RewriteRuleSubtreeStream stream_aty=new RewriteRuleSubtreeStream(adaptor,"rule aty",aty!=null?aty.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (BAST)adaptor.nil();
			// 3055:5: -> ^( $coln $aty ( $i)+ )
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3055:8: ^( $coln $aty ( $i)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_coln.nextNode(), root_1);
				adaptor.addChild(root_1, stream_aty.nextTree());
				if ( !(stream_i.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_i.hasNext() ) {
					adaptor.addChild(root_1, stream_i.nextTree());
				}
				stream_i.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("RecognitionException caught by BLESStoAST.logic_variables");
			    tellBNF(GrammarStrings.logicVariables,re,retval.tree);
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variables"


	public static class logic_variable_domain_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "logic_variable_domain"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3063:1: logic_variable_domain : i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) ;
	public final BLESStoASTParser.logic_variable_domain_return logic_variable_domain() throws RecognitionException {
		BLESStoASTParser.logic_variable_domain_return retval = new BLESStoASTParser.logic_variable_domain_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token i=null;
		ParserRuleReturnScope l =null;
		ParserRuleReturnScope rs =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope predicate299 =null;

		BAST i_tree=null;
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleSubtreeStream stream_range_symbol=new RewriteRuleSubtreeStream(adaptor,"rule range_symbol");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3064:3: (i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3065:3: i= LITERAL_in ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			{
			i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_logic_variable_domain13083); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3066:3: ( ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression -> ^( $i ^( $rs $l $r) ) | predicate -> ^( $i predicate ) )
			int alt170=2;
			int LA170_0 = input.LA(1);
			if ( (LA170_0==LITERAL_sum) && (synpred9_BLESStoAST())) {
				alt170=1;
			}
			else if ( (LA170_0==LITERAL_product) && (synpred9_BLESStoAST())) {
				alt170=1;
			}
			else if ( (LA170_0==LITERAL_numberof) && (synpred9_BLESStoAST())) {
				alt170=1;
			}
			else if ( (LA170_0==MINUS) ) {
				int LA170_4 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_abs) ) {
				int LA170_5 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_true) ) {
				int LA170_6 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_false) ) {
				int LA170_7 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==INTEGER_LIT) ) {
				int LA170_8 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==REAL_LIT) ) {
				int LA170_9 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LBRACKET) ) {
				int LA170_10 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==ID) ) {
				int LA170_11 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==OCTOTHORPE) ) {
				int LA170_12 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_self) ) {
				int LA170_13 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==AADL_STRING_LITERAL) ) {
				int LA170_14 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_in) ) {
				int LA170_15 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_timeout) ) {
				int LA170_16 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_null) ) {
				int LA170_17 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_now) ) {
				int LA170_18 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_tops) ) {
				int LA170_19 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LPAREN) ) {
				int LA170_20 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_natural) ) {
				int LA170_21 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_integer) ) {
				int LA170_22 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_rational) ) {
				int LA170_23 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_real) ) {
				int LA170_24 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_complex) ) {
				int LA170_25 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_time) ) {
				int LA170_26 = input.LA(2);
				if ( (synpred9_BLESStoAST()) ) {
					alt170=1;
				}
				else if ( (true) ) {
					alt170=2;
				}

			}
			else if ( (LA170_0==LITERAL_all||LA170_0==LITERAL_def||LA170_0==LITERAL_exists||LA170_0==LITERAL_not||LA170_0==LITERAL_stop) ) {
				alt170=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 170, 0, input);
				throw nvae;
			}

			switch (alt170) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3067:5: ( assertion_expression range_symbol )=>l= assertion_expression rs= range_symbol r= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13112);
					l=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(l.getTree());
					pushFollow(FOLLOW_range_symbol_in_logic_variable_domain13116);
					rs=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_range_symbol.add(rs.getTree());
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain13120);
					r=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(r.getTree());
					// AST REWRITE
					// elements: l, r, rs, i
					// token labels: i
					// rule labels: rs, r, l, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleSubtreeStream stream_rs=new RewriteRuleSubtreeStream(adaptor,"rule rs",rs!=null?rs.getTree():null);
					RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
					RewriteRuleSubtreeStream stream_l=new RewriteRuleSubtreeStream(adaptor,"rule l",l!=null?l.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3069:5: -> ^( $i ^( $rs $l $r) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3069:8: ^( $i ^( $rs $l $r) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3069:13: ^( $rs $l $r)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_rs.nextNode(), root_2);
						adaptor.addChild(root_2, stream_l.nextTree());
						adaptor.addChild(root_2, stream_r.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3071:3: predicate
					{
					pushFollow(FOLLOW_predicate_in_logic_variable_domain13155);
					predicate299=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(predicate299.getTree());
					// AST REWRITE
					// elements: i, predicate
					// token labels: i
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3072:5: -> ^( $i predicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3072:8: ^( $i predicate )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						adaptor.addChild(root_1, stream_predicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (MismatchedTokenException re) {
			Dump.it("MismatchedTokenException caught by BLESStoAST.logic_variable_domain");
			    Dump.it("\ntry bounding your quantification, eat less food too\n");
			    tellBNF(GrammarStrings.logicVariableDomain,re,retval.tree);
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.logic_variable_domain");
			    tellBNF(GrammarStrings.logicVariableDomain,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variable_domain"


	public static class predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3082:1: predicate : ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? );
	public final BLESStoASTParser.predicate_return predicate() throws RecognitionException {
		BLESStoASTParser.predicate_return retval = new BLESStoASTParser.predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token imp=null;
		Token i=null;
		Token a=null;
		Token LITERAL_and303=null;
		Token LITERAL_and305=null;
		Token LITERAL_or307=null;
		Token LITERAL_or309=null;
		Token LITERAL_xor311=null;
		Token LITERAL_xor313=null;
		ParserRuleReturnScope universal_quantification300 =null;
		ParserRuleReturnScope existential_quantification301 =null;
		ParserRuleReturnScope subpredicate302 =null;
		ParserRuleReturnScope subpredicate304 =null;
		ParserRuleReturnScope subpredicate306 =null;
		ParserRuleReturnScope subpredicate308 =null;
		ParserRuleReturnScope subpredicate310 =null;
		ParserRuleReturnScope subpredicate312 =null;
		ParserRuleReturnScope subpredicate314 =null;
		ParserRuleReturnScope subpredicate315 =null;
		ParserRuleReturnScope subpredicate316 =null;
		ParserRuleReturnScope subpredicate317 =null;

		BAST imp_tree=null;
		BAST i_tree=null;
		BAST a_tree=null;
		BAST LITERAL_and303_tree=null;
		BAST LITERAL_and305_tree=null;
		BAST LITERAL_or307_tree=null;
		BAST LITERAL_or309_tree=null;
		BAST LITERAL_xor311_tree=null;
		BAST LITERAL_xor313_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3083:3: ( universal_quantification | existential_quantification | subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )? )
			int alt175=3;
			switch ( input.LA(1) ) {
			case LITERAL_all:
				{
				alt175=1;
				}
				break;
			case LITERAL_exists:
				{
				alt175=2;
				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_def:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_stop:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt175=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 175, 0, input);
				throw nvae;
			}
			switch (alt175) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3084:3: universal_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_universal_quantification_in_predicate13215);
					universal_quantification300=universal_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, universal_quantification300.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3086:3: existential_quantification
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_existential_quantification_in_predicate13223);
					existential_quantification301=existential_quantification();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, existential_quantification301.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3088:3: subpredicate ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_subpredicate_in_predicate13232);
					subpredicate302=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate302.getTree());

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3089:5: ( ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* ) | ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* ) | ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* ) |imp= LITERAL_implies ^ subpredicate |i= LITERAL_iff ^ subpredicate |a= IMP ^ subpredicate )?
					int alt174=7;
					switch ( input.LA(1) ) {
						case LITERAL_and:
							{
							alt174=1;
							}
							break;
						case LITERAL_or:
							{
							alt174=2;
							}
							break;
						case LITERAL_xor:
							{
							alt174=3;
							}
							break;
						case LITERAL_implies:
							{
							alt174=4;
							}
							break;
						case LITERAL_iff:
							{
							alt174=5;
							}
							break;
						case IMP:
							{
							alt174=6;
							}
							break;
					}
					switch (alt174) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:5: ( LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:7: LITERAL_and ^ subpredicate ( LITERAL_and ! subpredicate )*
							{
							LITERAL_and303=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13250); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_and303_tree = (BAST)adaptor.create(LITERAL_and303);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_and303_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13253);
							subpredicate304=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate304.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:33: ( LITERAL_and ! subpredicate )*
							loop171:
							while (true) {
								int alt171=2;
								int LA171_0 = input.LA(1);
								if ( (LA171_0==LITERAL_and) ) {
									alt171=1;
								}

								switch (alt171) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3090:35: LITERAL_and ! subpredicate
									{
									LITERAL_and305=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate13257); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13260);
									subpredicate306=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate306.getTree());

									}
									break;

								default :
									break loop171;
								}
							}

							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:5: ( LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:7: LITERAL_or ^ subpredicate ( LITERAL_or ! subpredicate )*
							{
							LITERAL_or307=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13280); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_or307_tree = (BAST)adaptor.create(LITERAL_or307);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_or307_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13283);
							subpredicate308=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate308.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:32: ( LITERAL_or ! subpredicate )*
							loop172:
							while (true) {
								int alt172=2;
								int LA172_0 = input.LA(1);
								if ( (LA172_0==LITERAL_or) ) {
									alt172=1;
								}

								switch (alt172) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3092:34: LITERAL_or ! subpredicate
									{
									LITERAL_or309=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate13287); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13290);
									subpredicate310=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate310.getTree());

									}
									break;

								default :
									break loop172;
								}
							}

							}

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3094:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3094:5: ( LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )* )
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3094:7: LITERAL_xor ^ subpredicate ( LITERAL_xor ! subpredicate )*
							{
							LITERAL_xor311=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13313); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LITERAL_xor311_tree = (BAST)adaptor.create(LITERAL_xor311);
							root_0 = (BAST)adaptor.becomeRoot(LITERAL_xor311_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13316);
							subpredicate312=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate312.getTree());

							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3094:33: ( LITERAL_xor ! subpredicate )*
							loop173:
							while (true) {
								int alt173=2;
								int LA173_0 = input.LA(1);
								if ( (LA173_0==LITERAL_xor) ) {
									alt173=1;
								}

								switch (alt173) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3094:35: LITERAL_xor ! subpredicate
									{
									LITERAL_xor313=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate13320); if (state.failed) return retval;
									pushFollow(FOLLOW_subpredicate_in_predicate13323);
									subpredicate314=subpredicate();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate314.getTree());

									}
									break;

								default :
									break loop173;
								}
							}

							}

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3096:5: imp= LITERAL_implies ^ subpredicate
							{
							imp=(Token)match(input,LITERAL_implies,FOLLOW_LITERAL_implies_in_predicate13345); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							imp_tree = (BAST)adaptor.create(imp);
							root_0 = (BAST)adaptor.becomeRoot(imp_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13348);
							subpredicate315=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate315.getTree());

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3098:5: i= LITERAL_iff ^ subpredicate
							{
							i=(Token)match(input,LITERAL_iff,FOLLOW_LITERAL_iff_in_predicate13367); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							i_tree = (BAST)adaptor.create(i);
							root_0 = (BAST)adaptor.becomeRoot(i_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13370);
							subpredicate316=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate316.getTree());

							}
							break;
						case 6 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3100:5: a= IMP ^ subpredicate
							{
							a=(Token)match(input,IMP,FOLLOW_IMP_in_predicate13388); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							a_tree = (BAST)adaptor.create(a);
							root_0 = (BAST)adaptor.becomeRoot(a_tree, root_0);
							}

							pushFollow(FOLLOW_subpredicate_in_predicate13391);
							subpredicate317=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subpredicate317.getTree());

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.predicate");
			    tellBNF(GrammarStrings.predicate,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate"


	public static class subpredicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "subpredicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3107:1: subpredicate : (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) ;
	public final BLESStoASTParser.subpredicate_return subpredicate() throws RecognitionException {
		BLESStoASTParser.subpredicate_return retval = new BLESStoASTParser.subpredicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token i=null;
		Token pe=null;
		Token tr=null;
		Token fa=null;
		Token st=null;
		Token d=null;
		ParserRuleReturnScope lhs =null;
		ParserRuleReturnScope r =null;
		ParserRuleReturnScope rhs =null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope ra =null;
		ParserRuleReturnScope target =null;
		ParserRuleReturnScope increment =null;
		ParserRuleReturnScope definedLogicVariable =null;
		ParserRuleReturnScope predicate_invocation318 =null;
		ParserRuleReturnScope timed_predicate319 =null;

		BAST n_tree=null;
		BAST i_tree=null;
		BAST pe_tree=null;
		BAST tr_tree=null;
		BAST fa_tree=null;
		BAST st_tree=null;
		BAST d_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_LITERAL_in=new RewriteRuleTokenStream(adaptor,"token LITERAL_in");
		RewriteRuleTokenStream stream_LITERAL_def=new RewriteRuleTokenStream(adaptor,"token LITERAL_def");
		RewriteRuleTokenStream stream_LITERAL_stop=new RewriteRuleTokenStream(adaptor,"token LITERAL_stop");
		RewriteRuleTokenStream stream_LITERAL_true=new RewriteRuleTokenStream(adaptor,"token LITERAL_true");
		RewriteRuleTokenStream stream_LITERAL_false=new RewriteRuleTokenStream(adaptor,"token LITERAL_false");
		RewriteRuleTokenStream stream_PLUS_EQUALS=new RewriteRuleTokenStream(adaptor,"token PLUS_EQUALS");
		RewriteRuleSubtreeStream stream_assertion_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_subexpression");
		RewriteRuleSubtreeStream stream_assertion_range=new RewriteRuleSubtreeStream(adaptor,"rule assertion_range");
		RewriteRuleSubtreeStream stream_relation_symbol=new RewriteRuleSubtreeStream(adaptor,"rule relation_symbol");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_predicate_invocation=new RewriteRuleSubtreeStream(adaptor,"rule predicate_invocation");
		RewriteRuleSubtreeStream stream_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule assertion_parameter");
		RewriteRuleSubtreeStream stream_timed_predicate=new RewriteRuleSubtreeStream(adaptor,"rule timed_predicate");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3109:3: ( (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:3: (n= LITERAL_not )? ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:3: (n= LITERAL_not )?
			int alt176=2;
			int LA176_0 = input.LA(1);
			if ( (LA176_0==LITERAL_not) ) {
				alt176=1;
			}
			switch (alt176) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3110:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subpredicate13433); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3111:3: ( ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression -> {n!=null}? ^( $n ^( $r $lhs $rhs) ) -> ^( $r $lhs $rhs) | ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range -> {n!=null}? ^( $n ^( $i $p $ra) ) -> ^( $i $p $ra) | ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression -> {n!=null}? -> ^( $pe $target $increment) |tr= LITERAL_true -> {n!=null}? ^( $n $tr) -> $tr|fa= LITERAL_false -> {n!=null}? ^( $n $fa) -> $fa|st= LITERAL_stop -> {n!=null}? ^( $n $st) -> $st| ( ID LPAREN )=> predicate_invocation -> {n!=null}? ^( $n predicate_invocation ) -> predicate_invocation | timed_predicate -> {n!=null}? ^( $n timed_predicate ) -> timed_predicate |d= LITERAL_def definedLogicVariable= assertion_parameter -> ^( $d $definedLogicVariable) )
			int alt177=9;
			switch ( input.LA(1) ) {
			case MINUS:
				{
				int LA177_1 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_abs:
				{
				int LA177_2 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_true:
				{
				int LA177_3 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (true) ) {
					alt177=4;
				}

				}
				break;
			case LITERAL_false:
				{
				int LA177_4 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (true) ) {
					alt177=5;
				}

				}
				break;
			case INTEGER_LIT:
				{
				int LA177_5 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 5, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case REAL_LIT:
				{
				int LA177_6 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 6, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LBRACKET:
				{
				int LA177_7 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 7, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				int LA177_8 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (synpred12_BLESStoAST()) ) {
					alt177=3;
				}
				else if ( (synpred13_BLESStoAST()) ) {
					alt177=7;
				}
				else if ( (true) ) {
					alt177=8;
				}

				}
				break;
			case OCTOTHORPE:
				{
				int LA177_9 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 9, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_self:
				{
				int LA177_10 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 10, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
				{
				int LA177_11 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 11, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_in:
				{
				int LA177_12 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 12, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_timeout:
				{
				int LA177_13 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 13, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_null:
				{
				int LA177_14 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 14, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_now:
				{
				int LA177_15 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 15, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_tops:
				{
				int LA177_16 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 16, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				int LA177_17 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}
				else if ( (true) ) {
					alt177=8;
				}

				}
				break;
			case LITERAL_natural:
				{
				int LA177_18 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 18, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA177_19 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 19, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA177_20 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 20, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_real:
				{
				int LA177_21 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 21, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA177_22 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 22, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_time:
				{
				int LA177_23 = input.LA(2);
				if ( (synpred10_BLESStoAST()) ) {
					alt177=1;
				}
				else if ( (synpred11_BLESStoAST()) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 23, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_stop:
				{
				alt177=6;
				}
				break;
			case LITERAL_def:
				{
				alt177=9;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 177, 0, input);
				throw nvae;
			}
			switch (alt177) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:3: ( assertion_subexpression relation_symbol )=>lhs= assertion_subexpression r= relation_symbol rhs= assertion_subexpression
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13463);
					lhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(lhs.getTree());
					pushFollow(FOLLOW_relation_symbol_in_subpredicate13467);
					r=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_relation_symbol.add(r.getTree());
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13471);
					rhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(rhs.getTree());
					// AST REWRITE
					// elements: lhs, n, lhs, r, rhs, rhs, r
					// token labels: n
					// rule labels: r, lhs, rhs, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
					RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs",lhs!=null?lhs.getTree():null);
					RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"rule rhs",rhs!=null?rhs.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3114:6: -> {n!=null}? ^( $n ^( $r $lhs $rhs) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3114:20: ^( $n ^( $r $lhs $rhs) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3114:26: ^( $r $lhs $rhs)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_r.nextNode(), root_2);
						adaptor.addChild(root_2, stream_lhs.nextTree());
						adaptor.addChild(root_2, stream_rhs.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3115:5: -> ^( $r $lhs $rhs)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3115:8: ^( $r $lhs $rhs)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_r.nextNode(), root_1);
						adaptor.addChild(root_1, stream_lhs.nextTree());
						adaptor.addChild(root_1, stream_rhs.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3117:3: ( assertion_subexpression LITERAL_in )=>p= assertion_subexpression i= LITERAL_in ra= assertion_range
					{
					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13546);
					p=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(p.getTree());
					i=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_subpredicate13550); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_in.add(i);

					pushFollow(FOLLOW_assertion_range_in_subpredicate13554);
					ra=assertion_range();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_range.add(ra.getTree());
					// AST REWRITE
					// elements: ra, n, p, i, i, p, ra
					// token labels: i, n
					// rule labels: p, retval, ra
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,"token i",i);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ra=new RewriteRuleSubtreeStream(adaptor,"rule ra",ra!=null?ra.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3122:6: -> {n!=null}? ^( $n ^( $i $p $ra) )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3122:20: ^( $n ^( $i $p $ra) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3122:26: ^( $i $p $ra)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						adaptor.addChild(root_2, stream_p.nextTree());
						adaptor.addChild(root_2, stream_ra.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3123:5: -> ^( $i $p $ra)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3123:8: ^( $i $p $ra)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_ra.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3125:3: ( name PLUS_EQUALS )=>target= name pe= PLUS_EQUALS increment= assertion_subexpression
					{
					pushFollow(FOLLOW_name_in_subpredicate13622);
					target=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(target.getTree());
					pe=(Token)match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_subpredicate13626); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS_EQUALS.add(pe);

					pushFollow(FOLLOW_assertion_subexpression_in_subpredicate13632);
					increment=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(increment.getTree());
					// AST REWRITE
					// elements: pe, increment, target
					// token labels: pe
					// rule labels: increment, retval, target
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_pe=new RewriteRuleTokenStream(adaptor,"token pe",pe);
					RewriteRuleSubtreeStream stream_increment=new RewriteRuleSubtreeStream(adaptor,"rule increment",increment!=null?increment.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target",target!=null?target.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3127:5: -> {n!=null}?
					if (n!=null) {
						root_0 = null;
					}

					else // 3128:5: -> ^( $pe $target $increment)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3128:8: ^( $pe $target $increment)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_pe.nextNode(), root_1);
						adaptor.addChild(root_1, stream_target.nextTree());
						adaptor.addChild(root_1, stream_increment.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3130:5: tr= LITERAL_true
					{
					tr=(Token)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_subpredicate13674); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_true.add(tr);

					// AST REWRITE
					// elements: tr, tr, n
					// token labels: tr, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_tr=new RewriteRuleTokenStream(adaptor,"token tr",tr);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3131:5: -> {n!=null}? ^( $n $tr)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3131:19: ^( $n $tr)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_tr.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3132:5: -> $tr
					{
						adaptor.addChild(root_0, stream_tr.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3133:5: fa= LITERAL_false
					{
					fa=(Token)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_subpredicate13712); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_false.add(fa);

					// AST REWRITE
					// elements: fa, n, fa
					// token labels: fa, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_fa=new RewriteRuleTokenStream(adaptor,"token fa",fa);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3134:5: -> {n!=null}? ^( $n $fa)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3134:19: ^( $n $fa)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_fa.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3135:5: -> $fa
					{
						adaptor.addChild(root_0, stream_fa.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3136:5: st= LITERAL_stop
					{
					st=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_subpredicate13748); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_stop.add(st);

					// AST REWRITE
					// elements: st, st, n
					// token labels: st, n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_st=new RewriteRuleTokenStream(adaptor,"token st",st);
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3137:5: -> {n!=null}? ^( $n $st)
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3137:19: ^( $n $st)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_st.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3138:5: -> $st
					{
						adaptor.addChild(root_0, stream_st.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3139:5: ( ID LPAREN )=> predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_subpredicate13793);
					predicate_invocation318=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate_invocation.add(predicate_invocation318.getTree());
					// AST REWRITE
					// elements: predicate_invocation, n, predicate_invocation
					// token labels: n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3141:5: -> {n!=null}? ^( $n predicate_invocation )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3141:19: ^( $n predicate_invocation )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_predicate_invocation.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3142:5: -> predicate_invocation
					{
						adaptor.addChild(root_0, stream_predicate_invocation.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3144:3: timed_predicate
					{
					pushFollow(FOLLOW_timed_predicate_in_subpredicate13827);
					timed_predicate319=timed_predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_timed_predicate.add(timed_predicate319.getTree());
					// AST REWRITE
					// elements: timed_predicate, timed_predicate, n
					// token labels: n
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3145:5: -> {n!=null}? ^( $n timed_predicate )
					if (n!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3145:19: ^( $n timed_predicate )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
						adaptor.addChild(root_1, stream_timed_predicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3146:5: -> timed_predicate
					{
						adaptor.addChild(root_0, stream_timed_predicate.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3149:3: d= LITERAL_def definedLogicVariable= assertion_parameter
					{
					d=(Token)match(input,LITERAL_def,FOLLOW_LITERAL_def_in_subpredicate13864); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_def.add(d);

					pushFollow(FOLLOW_assertion_parameter_in_subpredicate13868);
					definedLogicVariable=assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_parameter.add(definedLogicVariable.getTree());
					// AST REWRITE
					// elements: d, definedLogicVariable
					// token labels: d
					// rule labels: definedLogicVariable, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_d=new RewriteRuleTokenStream(adaptor,"token d",d);
					RewriteRuleSubtreeStream stream_definedLogicVariable=new RewriteRuleSubtreeStream(adaptor,"rule definedLogicVariable",definedLogicVariable!=null?definedLogicVariable.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3150:5: -> ^( $d $definedLogicVariable)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3150:8: ^( $d $definedLogicVariable)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_d.nextNode(), root_1);
						adaptor.addChild(root_1, stream_definedLogicVariable.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.subpredicate");
			    tellBNF(GrammarStrings.predicateAtom,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subpredicate"


	public static class timed_predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timed_predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3158:1: timed_predicate : ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
	public final BLESStoASTParser.timed_predicate_return timed_predicate() throws RecognitionException {
		BLESStoASTParser.timed_predicate_return retval = new BLESStoASTParser.timed_predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK323=null;
		Token AT_SIGN324=null;
		Token CARET326=null;
		ParserRuleReturnScope name320 =null;
		ParserRuleReturnScope parenthesized_predicate321 =null;
		ParserRuleReturnScope predicate_invocation322 =null;
		ParserRuleReturnScope time_subexpression325 =null;
		ParserRuleReturnScope period_shift327 =null;

		BAST TICK323_tree=null;
		BAST AT_SIGN324_tree=null;
		BAST CARET326_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3159:3: ( ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:3: ( name | parenthesized_predicate | predicate_invocation ) ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			{
			root_0 = (BAST)adaptor.nil();


			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:3: ( name | parenthesized_predicate | predicate_invocation )
			int alt178=3;
			int LA178_0 = input.LA(1);
			if ( (LA178_0==ID) ) {
				int LA178_1 = input.LA(2);
				if ( (LA178_1==EOF||LA178_1==ANNEX_END||LA178_1==AT_SIGN||LA178_1==CARET||LA178_1==COLON||(LA178_1 >= COMMA && LA178_1 <= COMMADOT)||(LA178_1 >= DOTCOMMA && LA178_1 <= DOTDOT)||LA178_1==IMP||LA178_1==LBRACKET||LA178_1==LITERAL_and||LA178_1==LITERAL_are||LA178_1==LITERAL_else||LA178_1==LITERAL_iff||LA178_1==LITERAL_implies||LA178_1==LITERAL_of||LA178_1==LITERAL_or||(LA178_1 >= LITERAL_that && LA178_1 <= LITERAL_then)||LA178_1==LITERAL_xor||LA178_1==PERIOD||LA178_1==QQ||LA178_1==RASS||LA178_1==RPAREN||LA178_1==TICK) ) {
					alt178=1;
				}
				else if ( (LA178_1==LPAREN) ) {
					alt178=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA178_0==LPAREN) ) {
				alt178=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 178, 0, input);
				throw nvae;
			}

			switch (alt178) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:4: name
					{
					pushFollow(FOLLOW_name_in_timed_predicate13917);
					name320=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, name320.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:11: parenthesized_predicate
					{
					pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate13921);
					parenthesized_predicate321=parenthesized_predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_predicate321.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3160:37: predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_timed_predicate13925);
					predicate_invocation322=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate_invocation322.getTree());

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3161:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			int alt179=4;
			switch ( input.LA(1) ) {
				case TICK:
					{
					alt179=1;
					}
					break;
				case AT_SIGN:
					{
					alt179=2;
					}
					break;
				case CARET:
					{
					alt179=3;
					}
					break;
			}
			switch (alt179) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3161:4: TICK ^
					{
					TICK323=(Token)match(input,TICK,FOLLOW_TICK_in_timed_predicate13931); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TICK323_tree = (BAST)adaptor.create(TICK323);
					root_0 = (BAST)adaptor.becomeRoot(TICK323_tree, root_0);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3162:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN324=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_predicate13939); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AT_SIGN324_tree = (BAST)adaptor.create(AT_SIGN324);
					root_0 = (BAST)adaptor.becomeRoot(AT_SIGN324_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_timed_predicate13942);
					time_subexpression325=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_subexpression325.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3163:6: CARET ^ period_shift
					{
					CARET326=(Token)match(input,CARET,FOLLOW_CARET_in_timed_predicate13951); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					CARET326_tree = (BAST)adaptor.create(CARET326);
					root_0 = (BAST)adaptor.becomeRoot(CARET326_tree, root_0);
					}

					pushFollow(FOLLOW_period_shift_in_timed_predicate13954);
					period_shift327=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, period_shift327.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.timed_predicate");
			    tellBNF(GrammarStrings.timeExpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_predicate"


	public static class parenthesized_predicate_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3170:1: parenthesized_predicate : LPAREN ^ predicate RPAREN ;
	public final BLESStoASTParser.parenthesized_predicate_return parenthesized_predicate() throws RecognitionException {
		BLESStoASTParser.parenthesized_predicate_return retval = new BLESStoASTParser.parenthesized_predicate_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN328=null;
		Token RPAREN330=null;
		ParserRuleReturnScope predicate329 =null;

		BAST LPAREN328_tree=null;
		BAST RPAREN330_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3171:3: ( LPAREN ^ predicate RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3172:3: LPAREN ^ predicate RPAREN
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN328=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_predicate13992); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LPAREN328_tree = (BAST)adaptor.create(LPAREN328);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN328_tree, root_0);
			}

			pushFollow(FOLLOW_predicate_in_parenthesized_predicate13995);
			predicate329=predicate();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, predicate329.getTree());

			RPAREN330=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_predicate13997); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RPAREN330_tree = (BAST)adaptor.create(RPAREN330);
			adaptor.addChild(root_0, RPAREN330_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_predicate"


	public static class floatingAtom_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "floatingAtom"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3175:1: floatingAtom : value ;
	public final BLESStoASTParser.floatingAtom_return floatingAtom() throws RecognitionException {
		BLESStoASTParser.floatingAtom_return retval = new BLESStoASTParser.floatingAtom_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope value331 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3176:3: ( value )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3177:3: value
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_value_in_floatingAtom14017);
			value331=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value331.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "floatingAtom"


	public static class period_shift_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "period_shift"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3180:1: period_shift : (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) );
	public final BLESStoASTParser.period_shift_return period_shift() throws RecognitionException {
		BLESStoASTParser.period_shift_return retval = new BLESStoASTParser.period_shift_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m2=null;
		Token lp=null;
		Token mia=null;
		Token rp=null;
		Token dia=null;
		Token pia=null;
		Token tia=null;
		Token PLUS332=null;
		Token TIMES333=null;
		List<Object> list_ia3=null;
		ParserRuleReturnScope v =null;
		ParserRuleReturnScope x =null;
		ParserRuleReturnScope ia =null;
		ParserRuleReturnScope ia2 =null;
		RuleReturnScope ia3 = null;
		BAST m2_tree=null;
		BAST lp_tree=null;
		BAST mia_tree=null;
		BAST rp_tree=null;
		BAST dia_tree=null;
		BAST pia_tree=null;
		BAST tia_tree=null;
		BAST PLUS332_tree=null;
		BAST TIMES333_tree=null;
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleSubtreeStream stream_period_shift=new RewriteRuleSubtreeStream(adaptor,"rule period_shift");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3182:3: (v= value -> $v|m2= MINUS x= period_shift -> ^( UNARY_MINUS[$m2] $x) |lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN ) -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp) -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp) -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp) -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp) -> ^( $lp $ia $rp) )
			int alt183=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt183=1;
				}
				break;
			case MINUS:
				{
				alt183=2;
				}
				break;
			case LPAREN:
				{
				alt183=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 183, 0, input);
				throw nvae;
			}
			switch (alt183) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3186:3: v= value
					{
					pushFollow(FOLLOW_value_in_period_shift14045);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(v.getTree());
					// AST REWRITE
					// elements: v
					// token labels: 
					// rule labels: v, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3188:3: -> $v
					{
						adaptor.addChild(root_0, stream_v.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3190:3: m2= MINUS x= period_shift
					{
					m2=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14063); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(m2);

					pushFollow(FOLLOW_period_shift_in_period_shift14067);
					x=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_period_shift.add(x.getTree());
					// AST REWRITE
					// elements: x
					// token labels: 
					// rule labels: x, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3191:3: -> ^( UNARY_MINUS[$m2] $x)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3191:6: ^( UNARY_MINUS[$m2] $x)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m2), root_1);
						adaptor.addChild(root_1, stream_x.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3196:3: lp= LPAREN ia= period_shift (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_period_shift14093); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_period_shift_in_period_shift14097);
					ia=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_period_shift.add(ia.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3197:5: (mia= MINUS ia2= period_shift rp= RPAREN |dia= DIVIDE ia2= period_shift rp= RPAREN |pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN |tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN |rp= RPAREN )
					int alt182=5;
					switch ( input.LA(1) ) {
					case MINUS:
						{
						alt182=1;
						}
						break;
					case DIVIDE:
						{
						alt182=2;
						}
						break;
					case PLUS:
						{
						alt182=3;
						}
						break;
					case TIMES:
						{
						alt182=4;
						}
						break;
					case RPAREN:
						{
						alt182=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 182, 0, input);
						throw nvae;
					}
					switch (alt182) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3197:7: mia= MINUS ia2= period_shift rp= RPAREN
							{
							mia=(Token)match(input,MINUS,FOLLOW_MINUS_in_period_shift14108); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(mia);

							pushFollow(FOLLOW_period_shift_in_period_shift14112);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14116); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3199:5: dia= DIVIDE ia2= period_shift rp= RPAREN
							{
							dia=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_period_shift14130); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(dia);

							pushFollow(FOLLOW_period_shift_in_period_shift14134);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14138); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3201:5: pia= PLUS ia2= period_shift ( PLUS ia3+= period_shift )* rp= RPAREN
							{
							pia=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14152); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_PLUS.add(pia);

							pushFollow(FOLLOW_period_shift_in_period_shift14156);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3201:31: ( PLUS ia3+= period_shift )*
							loop180:
							while (true) {
								int alt180=2;
								int LA180_0 = input.LA(1);
								if ( (LA180_0==PLUS) ) {
									alt180=1;
								}

								switch (alt180) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3201:32: PLUS ia3+= period_shift
									{
									PLUS332=(Token)match(input,PLUS,FOLLOW_PLUS_in_period_shift14159); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS332);

									pushFollow(FOLLOW_period_shift_in_period_shift14163);
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop180;
								}
							}

							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14169); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3203:5: tia= TIMES ia2= period_shift ( TIMES ia3+= period_shift )* rp= RPAREN
							{
							tia=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14185); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_TIMES.add(tia);

							pushFollow(FOLLOW_period_shift_in_period_shift14189);
							ia2=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_period_shift.add(ia2.getTree());
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3203:32: ( TIMES ia3+= period_shift )*
							loop181:
							while (true) {
								int alt181=2;
								int LA181_0 = input.LA(1);
								if ( (LA181_0==TIMES) ) {
									alt181=1;
								}

								switch (alt181) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3203:33: TIMES ia3+= period_shift
									{
									TIMES333=(Token)match(input,TIMES,FOLLOW_TIMES_in_period_shift14192); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES333);

									pushFollow(FOLLOW_period_shift_in_period_shift14196);
									ia3=period_shift();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_period_shift.add(ia3.getTree());
									if (list_ia3==null) list_ia3=new ArrayList<Object>();
									list_ia3.add(ia3.getTree());
									}
									break;

								default :
									break loop181;
								}
							}

							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14202); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3205:5: rp= RPAREN
							{
							rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_period_shift14218); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RPAREN.add(rp);

							}
							break;

					}

					// AST REWRITE
					// elements: rp, ia3, rp, lp, ia, ia, ia, lp, lp, ia2, ia2, lp, mia, dia, pia, rp, lp, ia, ia2, ia3, ia2, rp, ia, tia, rp
					// token labels: lp, mia, pia, dia, tia, rp
					// rule labels: ia, ia2, retval
					// token list labels: 
					// rule list labels: ia3
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_mia=new RewriteRuleTokenStream(adaptor,"token mia",mia);
					RewriteRuleTokenStream stream_pia=new RewriteRuleTokenStream(adaptor,"token pia",pia);
					RewriteRuleTokenStream stream_dia=new RewriteRuleTokenStream(adaptor,"token dia",dia);
					RewriteRuleTokenStream stream_tia=new RewriteRuleTokenStream(adaptor,"token tia",tia);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_ia=new RewriteRuleSubtreeStream(adaptor,"rule ia",ia!=null?ia.getTree():null);
					RewriteRuleSubtreeStream stream_ia2=new RewriteRuleSubtreeStream(adaptor,"rule ia2",ia2!=null?ia2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ia3=new RewriteRuleSubtreeStream(adaptor,"token ia3",list_ia3);
					root_0 = (BAST)adaptor.nil();
					// 3207:3: -> {mia!=null}? ^( $lp ^( $mia $ia $ia2) $rp)
					if (mia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:19: ^( $lp ^( $mia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3207:25: ^( $mia $ia $ia2)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_mia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3208:3: -> {dia!=null}? ^( $lp ^( $dia $ia $ia2) $rp)
					if (dia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3208:19: ^( $lp ^( $dia $ia $ia2) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3208:25: ^( $dia $ia $ia2)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_dia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3209:3: -> {pia!=null}? ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
					if (pia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3209:19: ^( $lp ^( $pia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3209:25: ^( $pia $ia $ia2 ( $ia3)* )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_pia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3209:42: ( $ia3)*
						while ( stream_ia3.hasNext() ) {
							adaptor.addChild(root_2, stream_ia3.nextTree());
						}
						stream_ia3.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3210:3: -> {tia!=null}? ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
					if (tia!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3210:19: ^( $lp ^( $tia $ia $ia2 ( $ia3)* ) $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3210:25: ^( $tia $ia $ia2 ( $ia3)* )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_tia.nextNode(), root_2);
						adaptor.addChild(root_2, stream_ia.nextTree());
						adaptor.addChild(root_2, stream_ia2.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3210:42: ( $ia3)*
						while ( stream_ia3.hasNext() ) {
							adaptor.addChild(root_2, stream_ia3.nextTree());
						}
						stream_ia3.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3211:3: -> ^( $lp $ia $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3211:6: ^( $lp $ia $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ia.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    if ((re.getUnexpectedType()==BLESStoASTLexer.TICK)||(re.getUnexpectedType()==BLESStoASTLexer.CARET))
			      Dump.it("^ and ' are not allowed in integer atoms on rhs of ^");
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("RecognitionException caught by BLESStoAST.period_shift");
			//    tellBNF(GrammarStrings.predicateInvocation,re,$predicate_invocation.tree);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "period_shift"


	public static class predicate_invocation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "predicate_invocation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3223:1: predicate_invocation : (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) );
	public final BLESStoASTParser.predicate_invocation_return predicate_invocation() throws RecognitionException {
		BLESStoASTParser.predicate_invocation_return retval = new BLESStoASTParser.predicate_invocation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token RPAREN334=null;
		Token RPAREN335=null;
		Token COMMA336=null;
		Token RPAREN337=null;
		List<Object> list_params=null;
		ParserRuleReturnScope i =null;
		ParserRuleReturnScope exp =null;
		RuleReturnScope params = null;
		BAST lp_tree=null;
		BAST RPAREN334_tree=null;
		BAST RPAREN335_tree=null;
		BAST COMMA336_tree=null;
		BAST RPAREN337_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_actual_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule actual_assertion_parameter");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3225:3: (i= identifier lp= LPAREN RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i) |i= identifier lp= LPAREN exp= assertion_expression RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) ) |i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) ) )
			int alt185=3;
			int LA185_0 = input.LA(1);
			if ( (LA185_0==ID) ) {
				int LA185_1 = input.LA(2);
				if ( (LA185_1==LPAREN) ) {
					switch ( input.LA(3) ) {
					case RPAREN:
						{
						alt185=1;
						}
						break;
					case AADL_STRING_LITERAL:
					case INTEGER_LIT:
					case LBRACKET:
					case LITERAL_abs:
					case LITERAL_complex:
					case LITERAL_false:
					case LITERAL_in:
					case LITERAL_integer:
					case LITERAL_natural:
					case LITERAL_now:
					case LITERAL_null:
					case LITERAL_numberof:
					case LITERAL_product:
					case LITERAL_rational:
					case LITERAL_real:
					case LITERAL_self:
					case LITERAL_sum:
					case LITERAL_time:
					case LITERAL_timeout:
					case LITERAL_tops:
					case LITERAL_true:
					case LPAREN:
					case MINUS:
					case OCTOTHORPE:
					case REAL_LIT:
						{
						alt185=2;
						}
						break;
					case ID:
						{
						int LA185_5 = input.LA(4);
						if ( (LA185_5==AT_SIGN||LA185_5==CARET||LA185_5==DIVIDE||LA185_5==DOUBLE_COLON||LA185_5==EXP||LA185_5==LBRACKET||LA185_5==LITERAL_mod||LA185_5==LITERAL_rem||LA185_5==LPAREN||LA185_5==MINUS||LA185_5==OCTOTHORPE||(LA185_5 >= PERIOD && LA185_5 <= PLUS)||LA185_5==QUESTION||LA185_5==RPAREN||LA185_5==TICK||LA185_5==TIMES) ) {
							alt185=2;
						}
						else if ( ((LA185_5 >= COLON && LA185_5 <= COLON_TILDE)) ) {
							alt185=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 185, 5, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 185, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 185, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 185, 0, input);
				throw nvae;
			}

			switch (alt185) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3226:3: i= identifier lp= LPAREN RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14386);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14390); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					RPAREN334=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14392); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN334);

					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: i, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3227:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3227:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] $i)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						adaptor.addChild(root_1, stream_i.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3230:3: i= identifier lp= LPAREN exp= assertion_expression RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14427);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14431); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_predicate_invocation14435);
					exp=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(exp.getTree());
					RPAREN335=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14437); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN335);

					// AST REWRITE
					// elements: exp, i
					// token labels: 
					// rule labels: i, exp, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp",exp!=null?exp.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3231:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3231:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i $exp) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3232:9: ^( $i $exp)
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						adaptor.addChild(root_2, stream_exp.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3234:3: i= identifier lp= LPAREN params+= actual_assertion_parameter ( COMMA params+= actual_assertion_parameter )* RPAREN
					{
					pushFollow(FOLLOW_identifier_in_predicate_invocation14480);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(i.getTree());
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_predicate_invocation14484); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14488);
					params=actual_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(params.getTree());
					if (list_params==null) list_params=new ArrayList<Object>();
					list_params.add(params.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3234:61: ( COMMA params+= actual_assertion_parameter )*
					loop184:
					while (true) {
						int alt184=2;
						int LA184_0 = input.LA(1);
						if ( (LA184_0==COMMA) ) {
							alt184=1;
						}

						switch (alt184) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3234:63: COMMA params+= actual_assertion_parameter
							{
							COMMA336=(Token)match(input,COMMA,FOLLOW_COMMA_in_predicate_invocation14492); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA336);

							pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation14496);
							params=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(params.getTree());
							if (list_params==null) list_params=new ArrayList<Object>();
							list_params.add(params.getTree());
							}
							break;

						default :
							break loop184;
						}
					}

					RPAREN337=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_predicate_invocation14502); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN337);

					// AST REWRITE
					// elements: i, params
					// token labels: 
					// rule labels: i, retval
					// token list labels: 
					// rule list labels: params
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"rule i",i!=null?i.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"token params",list_params);
					root_0 = (BAST)adaptor.nil();
					// 3235:5: -> ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3235:8: ^( INVOKE[$lp,\"INVOKE[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $i ( $params)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE, lp, "INVOKE["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3236:9: ^( $i ( $params)+ )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_i.nextNode(), root_2);
						if ( !(stream_params.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_params.hasNext() ) {
							adaptor.addChild(root_2, stream_params.nextTree());
						}
						stream_params.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) {((BAST)retval.getTree()).setParseRecord(((BAST)(i!=null?((BAST)i.getTree()):null)).getParseRecord());}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			  Dump.it("RecognitionException caught by BLESStoAST.predicate_invocation"+
			  "\n\nDid you forget that parameters must be of the form \"formal:assertion_expression\"?");
			    tellBNF(GrammarStrings.predicateInvocation,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate_invocation"


	public static class actual_assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "actual_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3244:1: actual_assertion_parameter : (formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) |formal= ID ct= COLON_TILDE pred= predicate -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred) );
	public final BLESStoASTParser.actual_assertion_parameter_return actual_assertion_parameter() throws RecognitionException {
		BLESStoASTParser.actual_assertion_parameter_return retval = new BLESStoASTParser.actual_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token formal=null;
		Token c=null;
		Token ct=null;
		ParserRuleReturnScope actual =null;
		ParserRuleReturnScope pred =null;

		BAST formal_tree=null;
		BAST c_tree=null;
		BAST ct_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_COLON_TILDE=new RewriteRuleTokenStream(adaptor,"token COLON_TILDE");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3245:3: (formal= ID c= COLON actual= assertion_expression -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual) |formal= ID ct= COLON_TILDE pred= predicate -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred) )
			int alt186=2;
			int LA186_0 = input.LA(1);
			if ( (LA186_0==ID) ) {
				int LA186_1 = input.LA(2);
				if ( (LA186_1==COLON) ) {
					alt186=1;
				}
				else if ( (LA186_1==COLON_TILDE) ) {
					alt186=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 186, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 186, 0, input);
				throw nvae;
			}

			switch (alt186) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3246:3: formal= ID c= COLON actual= assertion_expression
					{
					formal=(Token)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter14559); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(formal);

					c=(Token)match(input,COLON,FOLLOW_COLON_in_actual_assertion_parameter14563); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(c);

					pushFollow(FOLLOW_assertion_expression_in_actual_assertion_parameter14567);
					actual=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
					// AST REWRITE
					// elements: formal, actual
					// token labels: formal
					// rule labels: actual, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_formal=new RewriteRuleTokenStream(adaptor,"token formal",formal);
					RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3247:5: -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3247:8: ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $formal $actual)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETER, c, "PARAMETER["+(formal!=null?formal.getText():null)+"]"), root_1);
						adaptor.addChild(root_1, stream_formal.nextNode());
						adaptor.addChild(root_1, stream_actual.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3249:3: formal= ID ct= COLON_TILDE pred= predicate
					{
					formal=(Token)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter14596); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(formal);

					ct=(Token)match(input,COLON_TILDE,FOLLOW_COLON_TILDE_in_actual_assertion_parameter14600); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON_TILDE.add(ct);

					pushFollow(FOLLOW_predicate_in_actual_assertion_parameter14604);
					pred=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(pred.getTree());
					// AST REWRITE
					// elements: ct, pred, formal
					// token labels: formal, ct
					// rule labels: pred, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_formal=new RewriteRuleTokenStream(adaptor,"token formal",formal);
					RewriteRuleTokenStream stream_ct=new RewriteRuleTokenStream(adaptor,"token ct",ct);
					RewriteRuleSubtreeStream stream_pred=new RewriteRuleSubtreeStream(adaptor,"rule pred",pred!=null?pred.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3250:5: -> ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3250:8: ^( PARAMETER[$c,\"PARAMETER[\"+$formal.text+\"]\"] $ct $formal $pred)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(PARAMETER, c, "PARAMETER["+(formal!=null?formal.getText():null)+"]"), root_1);
						adaptor.addChild(root_1, stream_ct.nextNode());
						adaptor.addChild(root_1, stream_formal.nextNode());
						adaptor.addChild(root_1, stream_pred.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_assertion_parameter"


	public static class range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3270:1: range : numeric_expression range_symbol ^ numeric_expression ;
	public final BLESStoASTParser.range_return range() throws RecognitionException {
		BLESStoASTParser.range_return retval = new BLESStoASTParser.range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope numeric_expression338 =null;
		ParserRuleReturnScope range_symbol339 =null;
		ParserRuleReturnScope numeric_expression340 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3271:3: ( numeric_expression range_symbol ^ numeric_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3272:3: numeric_expression range_symbol ^ numeric_expression
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_numeric_expression_in_range14655);
			numeric_expression338=numeric_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_expression338.getTree());

			pushFollow(FOLLOW_range_symbol_in_range14657);
			range_symbol339=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol339.getTree(), root_0);
			pushFollow(FOLLOW_numeric_expression_in_range14660);
			numeric_expression340=numeric_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_expression340.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {

			    Dump.it("\nDid you forget to put spaces around your range symbol?\n");
			    Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.range");
			    tellBNF(GrammarStrings.range,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range"


	public static class assertion_range_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3282:1: assertion_range : assertion_expression range_symbol ^ assertion_expression ;
	public final BLESStoASTParser.assertion_range_return assertion_range() throws RecognitionException {
		BLESStoASTParser.assertion_range_return retval = new BLESStoASTParser.assertion_range_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope assertion_expression341 =null;
		ParserRuleReturnScope range_symbol342 =null;
		ParserRuleReturnScope assertion_expression343 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3283:3: ( assertion_expression range_symbol ^ assertion_expression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3284:3: assertion_expression range_symbol ^ assertion_expression
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_assertion_expression_in_assertion_range14686);
			assertion_expression341=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression341.getTree());

			pushFollow(FOLLOW_range_symbol_in_assertion_range14688);
			range_symbol342=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (BAST)adaptor.becomeRoot(range_symbol342.getTree(), root_0);
			pushFollow(FOLLOW_assertion_expression_in_assertion_range14691);
			assertion_expression343=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_expression343.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.assertion_range");
			    tellBNF(GrammarStrings.range,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_range"


	public static class assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3291:1: assertion_expression options {backtrack=true; } : ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) );
	public final BLESStoASTParser.assertion_expression_return assertion_expression() throws RecognitionException {
		BLESStoASTParser.assertion_expression_return retval = new BLESStoASTParser.assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_sum344=null;
		Token LITERAL_of347=null;
		Token LITERAL_product349=null;
		Token LITERAL_of352=null;
		Token LITERAL_numberof354=null;
		Token LITERAL_that357=null;
		Token PLUS360=null;
		Token TIMES362=null;
		Token MINUS364=null;
		Token DIVIDE366=null;
		Token EXP368=null;
		Token LITERAL_mod370=null;
		Token LITERAL_rem372=null;
		ParserRuleReturnScope logic_variables345 =null;
		ParserRuleReturnScope logic_variable_domain346 =null;
		ParserRuleReturnScope assertion_expression348 =null;
		ParserRuleReturnScope logic_variables350 =null;
		ParserRuleReturnScope logic_variable_domain351 =null;
		ParserRuleReturnScope assertion_expression353 =null;
		ParserRuleReturnScope logic_variables355 =null;
		ParserRuleReturnScope logic_variable_domain356 =null;
		ParserRuleReturnScope subpredicate358 =null;
		ParserRuleReturnScope assertion_subexpression359 =null;
		ParserRuleReturnScope assertion_subexpression361 =null;
		ParserRuleReturnScope assertion_subexpression363 =null;
		ParserRuleReturnScope assertion_subexpression365 =null;
		ParserRuleReturnScope assertion_subexpression367 =null;
		ParserRuleReturnScope assertion_subexpression369 =null;
		ParserRuleReturnScope assertion_subexpression371 =null;
		ParserRuleReturnScope assertion_subexpression373 =null;

		BAST LITERAL_sum344_tree=null;
		BAST LITERAL_of347_tree=null;
		BAST LITERAL_product349_tree=null;
		BAST LITERAL_of352_tree=null;
		BAST LITERAL_numberof354_tree=null;
		BAST LITERAL_that357_tree=null;
		BAST PLUS360_tree=null;
		BAST TIMES362_tree=null;
		BAST MINUS364_tree=null;
		BAST DIVIDE366_tree=null;
		BAST EXP368_tree=null;
		BAST LITERAL_mod370_tree=null;
		BAST LITERAL_rem372_tree=null;
		RewriteRuleTokenStream stream_LITERAL_of=new RewriteRuleTokenStream(adaptor,"token LITERAL_of");
		RewriteRuleTokenStream stream_LITERAL_numberof=new RewriteRuleTokenStream(adaptor,"token LITERAL_numberof");
		RewriteRuleTokenStream stream_LITERAL_that=new RewriteRuleTokenStream(adaptor,"token LITERAL_that");
		RewriteRuleTokenStream stream_LITERAL_mod=new RewriteRuleTokenStream(adaptor,"token LITERAL_mod");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LITERAL_product=new RewriteRuleTokenStream(adaptor,"token LITERAL_product");
		RewriteRuleTokenStream stream_LITERAL_sum=new RewriteRuleTokenStream(adaptor,"token LITERAL_sum");
		RewriteRuleTokenStream stream_LITERAL_rem=new RewriteRuleTokenStream(adaptor,"token LITERAL_rem");
		RewriteRuleTokenStream stream_EXP=new RewriteRuleTokenStream(adaptor,"token EXP");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,"token DIVIDE");
		RewriteRuleSubtreeStream stream_logic_variables=new RewriteRuleSubtreeStream(adaptor,"rule logic_variables");
		RewriteRuleSubtreeStream stream_subpredicate=new RewriteRuleSubtreeStream(adaptor,"rule subpredicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_assertion_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_subexpression");
		RewriteRuleSubtreeStream stream_logic_variable_domain=new RewriteRuleSubtreeStream(adaptor,"rule logic_variable_domain");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3293:3: ( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression ) | LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate ) | assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression ) )
			int alt193=4;
			switch ( input.LA(1) ) {
			case LITERAL_sum:
				{
				alt193=1;
				}
				break;
			case LITERAL_product:
				{
				alt193=2;
				}
				break;
			case LITERAL_numberof:
				{
				alt193=3;
				}
				break;
			case AADL_STRING_LITERAL:
			case ID:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_self:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case MINUS:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt193=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 193, 0, input);
				throw nvae;
			}
			switch (alt193) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3294:3: LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_sum344=(Token)match(input,LITERAL_sum,FOLLOW_LITERAL_sum_in_assertion_expression14726); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_sum.add(LITERAL_sum344);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14728);
					logic_variables345=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables345.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3294:31: ( logic_variable_domain )?
					int alt187=2;
					int LA187_0 = input.LA(1);
					if ( (LA187_0==LITERAL_in) ) {
						alt187=1;
					}
					switch (alt187) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3294:33: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14732);
							logic_variable_domain346=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain346.getTree());
							}
							break;

					}

					LITERAL_of347=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14737); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of347);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14739);
					assertion_expression348=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(assertion_expression348.getTree());
					// AST REWRITE
					// elements: logic_variables, LITERAL_of, logic_variable_domain, LITERAL_sum, assertion_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3295:5: -> ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:8: ^( LITERAL_sum logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_sum.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3295:39: ( logic_variable_domain )?
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_of.nextNode());
						adaptor.addChild(root_1, stream_assertion_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:3: LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression
					{
					LITERAL_product349=(Token)match(input,LITERAL_product,FOLLOW_LITERAL_product_in_assertion_expression14771); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_product.add(LITERAL_product349);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14773);
					logic_variables350=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables350.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:35: ( logic_variable_domain )?
					int alt188=2;
					int LA188_0 = input.LA(1);
					if ( (LA188_0==LITERAL_in) ) {
						alt188=1;
					}
					switch (alt188) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3297:37: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14777);
							logic_variable_domain351=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain351.getTree());
							}
							break;

					}

					LITERAL_of352=(Token)match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression14782); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_of.add(LITERAL_of352);

					pushFollow(FOLLOW_assertion_expression_in_assertion_expression14784);
					assertion_expression353=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(assertion_expression353.getTree());
					// AST REWRITE
					// elements: LITERAL_product, logic_variables, logic_variable_domain, assertion_expression, LITERAL_of
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3298:5: -> ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3298:8: ^( LITERAL_product logic_variables ( logic_variable_domain )? LITERAL_of assertion_expression )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_product.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3298:43: ( logic_variable_domain )?
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_of.nextNode());
						adaptor.addChild(root_1, stream_assertion_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:3: LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate
					{
					LITERAL_numberof354=(Token)match(input,LITERAL_numberof,FOLLOW_LITERAL_numberof_in_assertion_expression14814); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_numberof.add(LITERAL_numberof354);

					pushFollow(FOLLOW_logic_variables_in_assertion_expression14816);
					logic_variables355=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_logic_variables.add(logic_variables355.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:36: ( logic_variable_domain )?
					int alt189=2;
					int LA189_0 = input.LA(1);
					if ( (LA189_0==LITERAL_in) ) {
						alt189=1;
					}
					switch (alt189) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3300:38: logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression14820);
							logic_variable_domain356=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_logic_variable_domain.add(logic_variable_domain356.getTree());
							}
							break;

					}

					LITERAL_that357=(Token)match(input,LITERAL_that,FOLLOW_LITERAL_that_in_assertion_expression14825); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_that.add(LITERAL_that357);

					pushFollow(FOLLOW_subpredicate_in_assertion_expression14827);
					subpredicate358=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subpredicate.add(subpredicate358.getTree());
					// AST REWRITE
					// elements: logic_variables, logic_variable_domain, LITERAL_that, LITERAL_numberof, subpredicate
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3301:5: -> ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3301:8: ^( LITERAL_numberof logic_variables ( logic_variable_domain )? LITERAL_that subpredicate )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_numberof.nextNode(), root_1);
						adaptor.addChild(root_1, stream_logic_variables.nextTree());
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3301:44: ( logic_variable_domain )?
						if ( stream_logic_variable_domain.hasNext() ) {
							adaptor.addChild(root_1, stream_logic_variable_domain.nextTree());
						}
						stream_logic_variable_domain.reset();

						adaptor.addChild(root_1, stream_LITERAL_that.nextNode());
						adaptor.addChild(root_1, stream_subpredicate.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3303:3: assertion_subexpression ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
					{
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14861);
					assertion_subexpression359=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression359.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3304:3: ( ( PLUS assertion_subexpression )+ -> ^( PLUS ( assertion_subexpression )+ ) | ( TIMES assertion_subexpression )+ -> ^( TIMES ( assertion_subexpression )+ ) | MINUS assertion_subexpression -> ^( MINUS ( assertion_subexpression )+ ) | DIVIDE assertion_subexpression -> ^( DIVIDE ( assertion_subexpression )+ ) | EXP assertion_subexpression -> ^( EXP ( assertion_subexpression )+ ) | LITERAL_mod assertion_subexpression -> ^( LITERAL_mod ( assertion_subexpression )+ ) | LITERAL_rem assertion_subexpression -> ^( LITERAL_rem ( assertion_subexpression )+ ) | -> assertion_subexpression )
					int alt192=8;
					switch ( input.LA(1) ) {
					case PLUS:
						{
						alt192=1;
						}
						break;
					case TIMES:
						{
						alt192=2;
						}
						break;
					case MINUS:
						{
						alt192=3;
						}
						break;
					case DIVIDE:
						{
						alt192=4;
						}
						break;
					case EXP:
						{
						alt192=5;
						}
						break;
					case LITERAL_mod:
						{
						alt192=6;
						}
						break;
					case LITERAL_rem:
						{
						alt192=7;
						}
						break;
					case EOF:
					case ANNEX_END:
					case COLON:
					case COMMA:
					case COMMACOMMA:
					case COMMADOT:
					case DOTCOMMA:
					case DOTDOT:
					case IMP:
					case LITERAL_and:
					case LITERAL_are:
					case LITERAL_else:
					case LITERAL_iff:
					case LITERAL_implies:
					case LITERAL_of:
					case LITERAL_or:
					case LITERAL_that:
					case LITERAL_then:
					case LITERAL_xor:
					case QQ:
					case RASS:
					case RPAREN:
						{
						alt192=8;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 192, 0, input);
						throw nvae;
					}
					switch (alt192) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3305:3: ( PLUS assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3305:3: ( PLUS assertion_subexpression )+
							int cnt190=0;
							loop190:
							while (true) {
								int alt190=2;
								int LA190_0 = input.LA(1);
								if ( (LA190_0==PLUS) ) {
									alt190=1;
								}

								switch (alt190) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3305:5: PLUS assertion_subexpression
									{
									PLUS360=(Token)match(input,PLUS,FOLLOW_PLUS_in_assertion_expression14875); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_PLUS.add(PLUS360);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14877);
									assertion_subexpression361=assertion_subexpression();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression361.getTree());
									}
									break;

								default :
									if ( cnt190 >= 1 ) break loop190;
									if (state.backtracking>0) {state.failed=true; return retval;}
									EarlyExitException eee = new EarlyExitException(190, input);
									throw eee;
								}
								cnt190++;
							}

							// AST REWRITE
							// elements: assertion_subexpression, PLUS
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3306:5: -> ^( PLUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3306:8: ^( PLUS ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_PLUS.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3308:3: ( TIMES assertion_subexpression )+
							{
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3308:3: ( TIMES assertion_subexpression )+
							int cnt191=0;
							loop191:
							while (true) {
								int alt191=2;
								int LA191_0 = input.LA(1);
								if ( (LA191_0==TIMES) ) {
									alt191=1;
								}

								switch (alt191) {
								case 1 :
									// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3308:5: TIMES assertion_subexpression
									{
									TIMES362=(Token)match(input,TIMES,FOLLOW_TIMES_in_assertion_expression14910); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_TIMES.add(TIMES362);

									pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14912);
									assertion_subexpression363=assertion_subexpression();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression363.getTree());
									}
									break;

								default :
									if ( cnt191 >= 1 ) break loop191;
									if (state.backtracking>0) {state.failed=true; return retval;}
									EarlyExitException eee = new EarlyExitException(191, input);
									throw eee;
								}
								cnt191++;
							}

							// AST REWRITE
							// elements: TIMES, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3309:5: -> ^( TIMES ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3309:8: ^( TIMES ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_TIMES.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3311:3: MINUS assertion_subexpression
							{
							MINUS364=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_expression14946); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(MINUS364);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14948);
							assertion_subexpression365=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression365.getTree());
							// AST REWRITE
							// elements: MINUS, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3312:5: -> ^( MINUS ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3312:8: ^( MINUS ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_MINUS.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3314:3: DIVIDE assertion_subexpression
							{
							DIVIDE366=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_assertion_expression14979); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_DIVIDE.add(DIVIDE366);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression14981);
							assertion_subexpression367=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression367.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, DIVIDE
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3315:5: -> ^( DIVIDE ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3315:8: ^( DIVIDE ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_DIVIDE.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3317:3: EXP assertion_subexpression
							{
							EXP368=(Token)match(input,EXP,FOLLOW_EXP_in_assertion_expression15013); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EXP.add(EXP368);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression15015);
							assertion_subexpression369=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression369.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, EXP
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3318:5: -> ^( EXP ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3318:8: ^( EXP ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_EXP.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 6 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3320:3: LITERAL_mod assertion_subexpression
							{
							LITERAL_mod370=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_assertion_expression15047); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_mod.add(LITERAL_mod370);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression15049);
							assertion_subexpression371=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression371.getTree());
							// AST REWRITE
							// elements: assertion_subexpression, LITERAL_mod
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3321:5: -> ^( LITERAL_mod ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3321:8: ^( LITERAL_mod ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_mod.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 7 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3323:3: LITERAL_rem assertion_subexpression
							{
							LITERAL_rem372=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_assertion_expression15074); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_rem.add(LITERAL_rem372);

							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression15076);
							assertion_subexpression373=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_subexpression.add(assertion_subexpression373.getTree());
							// AST REWRITE
							// elements: LITERAL_rem, assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3324:5: -> ^( LITERAL_rem ( assertion_subexpression )+ )
							{
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3324:8: ^( LITERAL_rem ( assertion_subexpression )+ )
								{
								BAST root_1 = (BAST)adaptor.nil();
								root_1 = (BAST)adaptor.becomeRoot(stream_LITERAL_rem.nextNode(), root_1);
								if ( !(stream_assertion_subexpression.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_assertion_subexpression.hasNext() ) {
									adaptor.addChild(root_1, stream_assertion_subexpression.nextTree());
								}
								stream_assertion_subexpression.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 8 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3326:5: 
							{
							// AST REWRITE
							// elements: assertion_subexpression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (BAST)adaptor.nil();
							// 3326:5: -> assertion_subexpression
							{
								adaptor.addChild(root_0, stream_assertion_subexpression.nextTree());
							}


							retval.tree = root_0;
							}

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_expression"


	public static class assertion_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3334:1: assertion_subexpression : ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc);
	public final BLESStoASTParser.assertion_subexpression_return assertion_subexpression() throws RecognitionException {
		BLESStoASTParser.assertion_subexpression_return retval = new BLESStoASTParser.assertion_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token m=null;
		Token abs=null;
		ParserRuleReturnScope ts =null;
		ParserRuleReturnScope atc =null;

		BAST m_tree=null;
		BAST abs_tree=null;
		RewriteRuleTokenStream stream_LITERAL_abs=new RewriteRuleTokenStream(adaptor,"token LITERAL_abs");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_timed_expression=new RewriteRuleSubtreeStream(adaptor,"rule timed_expression");
		RewriteRuleSubtreeStream stream_assertion_type_conversion=new RewriteRuleSubtreeStream(adaptor,"rule assertion_type_conversion");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3335:3: ( (m= MINUS |abs= LITERAL_abs )? ts= timed_expression -> {m!=null}? ^( UNARY_MINUS[$m] $ts) -> {abs!=null}? ^( $abs $ts) -> $ts|atc= assertion_type_conversion -> $atc)
			int alt195=2;
			int LA195_0 = input.LA(1);
			if ( (LA195_0==AADL_STRING_LITERAL||LA195_0==ID||LA195_0==INTEGER_LIT||LA195_0==LBRACKET||LA195_0==LITERAL_abs||LA195_0==LITERAL_false||LA195_0==LITERAL_in||LA195_0==LITERAL_now||LA195_0==LITERAL_null||LA195_0==LITERAL_self||LA195_0==LITERAL_timeout||LA195_0==LITERAL_tops||LA195_0==LITERAL_true||LA195_0==LPAREN||LA195_0==MINUS||LA195_0==OCTOTHORPE||LA195_0==REAL_LIT) ) {
				alt195=1;
			}
			else if ( (LA195_0==LITERAL_complex||LA195_0==LITERAL_integer||LA195_0==LITERAL_natural||(LA195_0 >= LITERAL_rational && LA195_0 <= LITERAL_real)||LA195_0==LITERAL_time) ) {
				alt195=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 195, 0, input);
				throw nvae;
			}

			switch (alt195) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3336:3: (m= MINUS |abs= LITERAL_abs )? ts= timed_expression
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3336:3: (m= MINUS |abs= LITERAL_abs )?
					int alt194=3;
					int LA194_0 = input.LA(1);
					if ( (LA194_0==MINUS) ) {
						alt194=1;
					}
					else if ( (LA194_0==LITERAL_abs) ) {
						alt194=2;
					}
					switch (alt194) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3336:5: m= MINUS
							{
							m=(Token)match(input,MINUS,FOLLOW_MINUS_in_assertion_subexpression15136); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_MINUS.add(m);

							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3336:15: abs= LITERAL_abs
							{
							abs=(Token)match(input,LITERAL_abs,FOLLOW_LITERAL_abs_in_assertion_subexpression15142); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_abs.add(abs);

							}
							break;

					}

					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression15162);
					ts=timed_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_timed_expression.add(ts.getTree());
					// AST REWRITE
					// elements: ts, ts, abs, ts
					// token labels: abs
					// rule labels: retval, ts
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_abs=new RewriteRuleTokenStream(adaptor,"token abs",abs);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_ts=new RewriteRuleSubtreeStream(adaptor,"rule ts",ts!=null?ts.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3364:5: -> {m!=null}? ^( UNARY_MINUS[$m] $ts)
					if (m!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3364:19: ^( UNARY_MINUS[$m] $ts)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, m), root_1);
						adaptor.addChild(root_1, stream_ts.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3365:5: -> {abs!=null}? ^( $abs $ts)
					if (abs!=null) {
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3365:21: ^( $abs $ts)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_abs.nextNode(), root_1);
						adaptor.addChild(root_1, stream_ts.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}

					else // 3366:5: -> $ts
					{
						adaptor.addChild(root_0, stream_ts.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3372:6: atc= assertion_type_conversion
					{
					pushFollow(FOLLOW_assertion_type_conversion_in_assertion_subexpression15222);
					atc=assertion_type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_type_conversion.add(atc.getTree());
					// AST REWRITE
					// elements: atc
					// token labels: 
					// rule labels: atc, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_atc=new RewriteRuleSubtreeStream(adaptor,"rule atc",atc!=null?atc.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3373:5: -> $atc
					{
						adaptor.addChild(root_0, stream_atc.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); Dump.it("RecognitionException caught by BLESStoAST.assertion_subexpression");
			    tellBNF(GrammarStrings.predicateSubexpression,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_subexpression"


	public static class timed_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "timed_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3382:1: timed_expression : vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? ;
	public final BLESStoASTParser.timed_expression_return timed_expression() throws RecognitionException {
		BLESStoASTParser.timed_expression_return retval = new BLESStoASTParser.timed_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token TICK375=null;
		Token AT_SIGN376=null;
		Token CARET378=null;
		ParserRuleReturnScope vpa374 =null;
		ParserRuleReturnScope time_subexpression377 =null;
		ParserRuleReturnScope period_shift379 =null;

		BAST TICK375_tree=null;
		BAST AT_SIGN376_tree=null;
		BAST CARET378_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3383:3: ( vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3384:3: vpa ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_vpa_in_timed_expression15259);
			vpa374=vpa();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, vpa374.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3385:3: ( TICK ^| AT_SIGN ^ time_subexpression | CARET ^ period_shift )?
			int alt196=4;
			switch ( input.LA(1) ) {
				case TICK:
					{
					alt196=1;
					}
					break;
				case AT_SIGN:
					{
					alt196=2;
					}
					break;
				case CARET:
					{
					alt196=3;
					}
					break;
			}
			switch (alt196) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3385:4: TICK ^
					{
					TICK375=(Token)match(input,TICK,FOLLOW_TICK_in_timed_expression15264); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TICK375_tree = (BAST)adaptor.create(TICK375);
					root_0 = (BAST)adaptor.becomeRoot(TICK375_tree, root_0);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3386:6: AT_SIGN ^ time_subexpression
					{
					AT_SIGN376=(Token)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_expression15272); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AT_SIGN376_tree = (BAST)adaptor.create(AT_SIGN376);
					root_0 = (BAST)adaptor.becomeRoot(AT_SIGN376_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_timed_expression15275);
					time_subexpression377=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, time_subexpression377.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3387:6: CARET ^ period_shift
					{
					CARET378=(Token)match(input,CARET,FOLLOW_CARET_in_timed_expression15284); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					CARET378_tree = (BAST)adaptor.create(CARET378);
					root_0 = (BAST)adaptor.becomeRoot(CARET378_tree, root_0);
					}

					pushFollow(FOLLOW_period_shift_in_timed_expression15287);
					period_shift379=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, period_shift379.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_expression"


	public static class vpa_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "vpa"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3391:1: vpa : (v= value | parenthesized_assertion_expression | assertion_function_invocation );
	public final BLESStoASTParser.vpa_return vpa() throws RecognitionException {
		BLESStoASTParser.vpa_return retval = new BLESStoASTParser.vpa_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		ParserRuleReturnScope v =null;
		ParserRuleReturnScope parenthesized_assertion_expression380 =null;
		ParserRuleReturnScope assertion_function_invocation381 =null;


		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3392:3: (v= value | parenthesized_assertion_expression | assertion_function_invocation )
			int alt197=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt197=1;
				}
				break;
			case ID:
				{
				int LA197_2 = input.LA(2);
				if ( (LA197_2==LPAREN) ) {
					alt197=3;
				}
				else if ( (LA197_2==EOF||(LA197_2 >= AL && LA197_2 <= AM)||LA197_2==ANNEX_END||LA197_2==AT_SIGN||LA197_2==CARET||LA197_2==COLON||(LA197_2 >= COMMA && LA197_2 <= COMMADOT)||LA197_2==DIVIDE||(LA197_2 >= DOTCOMMA && LA197_2 <= DOUBLE_COLON)||LA197_2==EQ||LA197_2==EXP||LA197_2==GT||LA197_2==IMP||LA197_2==LBRACKET||LA197_2==LITERAL_and||LA197_2==LITERAL_are||LA197_2==LITERAL_else||LA197_2==LITERAL_iff||(LA197_2 >= LITERAL_implies && LA197_2 <= LITERAL_in)||LA197_2==LITERAL_mod||LA197_2==LITERAL_of||LA197_2==LITERAL_or||LA197_2==LITERAL_rem||(LA197_2 >= LITERAL_that && LA197_2 <= LITERAL_then)||LA197_2==LITERAL_xor||LA197_2==LT||LA197_2==MINUS||LA197_2==NEQ||LA197_2==OCTOTHORPE||(LA197_2 >= PERIOD && LA197_2 <= PLUS)||(LA197_2 >= QQ && LA197_2 <= RASS)||LA197_2==RPAREN||LA197_2==TICK||LA197_2==TIMES) ) {
					alt197=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 197, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt197=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 197, 0, input);
				throw nvae;
			}
			switch (alt197) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3393:3: v= value
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_value_in_vpa15315);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, v.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3395:3: parenthesized_assertion_expression
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_parenthesized_assertion_expression_in_vpa15325);
					parenthesized_assertion_expression380=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_assertion_expression380.getTree());

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3397:3: assertion_function_invocation
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_assertion_function_invocation_in_vpa15335);
					assertion_function_invocation381=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_function_invocation381.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vpa"


	public static class time_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3400:1: time_expression : lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? ;
	public final BLESStoASTParser.time_expression_return time_expression() throws RecognitionException {
		BLESStoASTParser.time_expression_return retval = new BLESStoASTParser.time_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token sym=null;
		Token PLUS382=null;
		Token TIMES383=null;
		List<Object> list_rhs=null;
		ParserRuleReturnScope lhs =null;
		RuleReturnScope rhs = null;
		BAST sym_tree=null;
		BAST PLUS382_tree=null;
		BAST TIMES383_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3401:3: (lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3402:3: lhs= time_subexpression ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
			{
			root_0 = (BAST)adaptor.nil();


			pushFollow(FOLLOW_time_subexpression_in_time_expression15352);
			lhs=time_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, lhs.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3403:3: ( (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* ) | (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* ) | (sym= MINUS ^rhs+= time_subexpression ) | (sym= DIVIDE ^rhs+= time_subexpression ) | (sym= EXP ^rhs+= time_subexpression ) | (sym= LITERAL_mod ^rhs+= time_subexpression ) | (sym= LITERAL_rem ^rhs+= time_subexpression ) )?
			int alt200=8;
			switch ( input.LA(1) ) {
				case PLUS:
					{
					alt200=1;
					}
					break;
				case TIMES:
					{
					alt200=2;
					}
					break;
				case MINUS:
					{
					alt200=3;
					}
					break;
				case DIVIDE:
					{
					alt200=4;
					}
					break;
				case EXP:
					{
					alt200=5;
					}
					break;
				case LITERAL_mod:
					{
					alt200=6;
					}
					break;
				case LITERAL_rem:
					{
					alt200=7;
					}
					break;
			}
			switch (alt200) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:3: (sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:4: sym= PLUS ^rhs+= time_subexpression ( PLUS rhs+= time_subexpression )*
					{
					sym=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15363); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15368);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:38: ( PLUS rhs+= time_subexpression )*
					loop198:
					while (true) {
						int alt198=2;
						int LA198_0 = input.LA(1);
						if ( (LA198_0==PLUS) ) {
							alt198=1;
						}

						switch (alt198) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3404:40: PLUS rhs+= time_subexpression
							{
							PLUS382=(Token)match(input,PLUS,FOLLOW_PLUS_in_time_expression15372); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PLUS382_tree = (BAST)adaptor.create(PLUS382);
							adaptor.addChild(root_0, PLUS382_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15376);
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop198;
						}
					}

					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:3: (sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )* )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:4: sym= TIMES ^rhs+= time_subexpression ( TIMES rhs+= time_subexpression )*
					{
					sym=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15391); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15396);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:39: ( TIMES rhs+= time_subexpression )*
					loop199:
					while (true) {
						int alt199=2;
						int LA199_0 = input.LA(1);
						if ( (LA199_0==TIMES) ) {
							alt199=1;
						}

						switch (alt199) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3406:41: TIMES rhs+= time_subexpression
							{
							TIMES383=(Token)match(input,TIMES,FOLLOW_TIMES_in_time_expression15400); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							TIMES383_tree = (BAST)adaptor.create(TIMES383);
							adaptor.addChild(root_0, TIMES383_tree);
							}

							pushFollow(FOLLOW_time_subexpression_in_time_expression15404);
							rhs=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

							if (list_rhs==null) list_rhs=new ArrayList<Object>();
							list_rhs.add(rhs.getTree());
							}
							break;

						default :
							break loop199;
						}
					}

					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3408:3: (sym= MINUS ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3408:3: (sym= MINUS ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3408:4: sym= MINUS ^rhs+= time_subexpression
					{
					sym=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_expression15419); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15424);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3410:3: (sym= DIVIDE ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3410:3: (sym= DIVIDE ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3410:4: sym= DIVIDE ^rhs+= time_subexpression
					{
					sym=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_time_expression15437); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15442);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3412:3: (sym= EXP ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3412:3: (sym= EXP ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3412:4: sym= EXP ^rhs+= time_subexpression
					{
					sym=(Token)match(input,EXP,FOLLOW_EXP_in_time_expression15455); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15460);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3414:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3414:3: (sym= LITERAL_mod ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3414:4: sym= LITERAL_mod ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_time_expression15473); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15478);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3416:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3416:3: (sym= LITERAL_rem ^rhs+= time_subexpression )
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3416:4: sym= LITERAL_rem ^rhs+= time_subexpression
					{
					sym=(Token)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_time_expression15491); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					sym_tree = (BAST)adaptor.create(sym);
					root_0 = (BAST)adaptor.becomeRoot(sym_tree, root_0);
					}

					pushFollow(FOLLOW_time_subexpression_in_time_expression15496);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rhs.getTree());

					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTree());
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_expression"


	public static class time_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "time_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3420:1: time_subexpression : (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) ;
	public final BLESStoASTParser.time_subexpression_return time_subexpression() throws RecognitionException {
		BLESStoASTParser.time_subexpression_return retval = new BLESStoASTParser.time_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token um=null;
		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope val =null;
		ParserRuleReturnScope afi =null;
		ParserRuleReturnScope exp =null;

		BAST um_tree=null;
		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_time_expression=new RewriteRuleSubtreeStream(adaptor,"rule time_expression");
		RewriteRuleSubtreeStream stream_assertion_function_invocation=new RewriteRuleSubtreeStream(adaptor,"rule assertion_function_invocation");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3421:3: ( (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN ) -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val) -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi) -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) ) -> {val!=null}? $val -> {afi!=null}? $afi -> ^( $lp $exp $rp) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:3: (um= MINUS )? (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:3: (um= MINUS )?
			int alt201=2;
			int LA201_0 = input.LA(1);
			if ( (LA201_0==MINUS) ) {
				alt201=1;
			}
			switch (alt201) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3422:4: um= MINUS
					{
					um=(Token)match(input,MINUS,FOLLOW_MINUS_in_time_subexpression15523); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(um);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3423:3: (val= value |afi= assertion_function_invocation |lp= LPAREN exp= time_expression rp= RPAREN )
			int alt202=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case INTEGER_LIT:
			case LBRACKET:
			case LITERAL_false:
			case LITERAL_in:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_self:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case REAL_LIT:
				{
				alt202=1;
				}
				break;
			case ID:
				{
				int LA202_2 = input.LA(2);
				if ( (LA202_2==LPAREN) ) {
					alt202=2;
				}
				else if ( (LA202_2==EOF||(LA202_2 >= AL && LA202_2 <= AM)||LA202_2==ANNEX_END||LA202_2==COLON||(LA202_2 >= COMMA && LA202_2 <= COMMADOT)||LA202_2==DIVIDE||(LA202_2 >= DOTCOMMA && LA202_2 <= DOUBLE_COLON)||LA202_2==EQ||LA202_2==EXP||LA202_2==GT||LA202_2==IMP||LA202_2==LBRACKET||LA202_2==LITERAL_and||LA202_2==LITERAL_are||LA202_2==LITERAL_else||LA202_2==LITERAL_iff||(LA202_2 >= LITERAL_implies && LA202_2 <= LITERAL_in)||LA202_2==LITERAL_mod||LA202_2==LITERAL_of||LA202_2==LITERAL_or||LA202_2==LITERAL_rem||(LA202_2 >= LITERAL_that && LA202_2 <= LITERAL_then)||LA202_2==LITERAL_xor||LA202_2==LT||LA202_2==MINUS||LA202_2==NEQ||LA202_2==OCTOTHORPE||(LA202_2 >= PERIOD && LA202_2 <= PLUS)||(LA202_2 >= QQ && LA202_2 <= RASS)||LA202_2==RPAREN||LA202_2==TICK||LA202_2==TIMES) ) {
					alt202=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 202, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt202=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 202, 0, input);
				throw nvae;
			}
			switch (alt202) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3423:5: val= value
					{
					pushFollow(FOLLOW_value_in_time_subexpression15533);
					val=value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value.add(val.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3424:5: afi= assertion_function_invocation
					{
					pushFollow(FOLLOW_assertion_function_invocation_in_time_subexpression15541);
					afi=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_function_invocation.add(afi.getTree());
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3425:5: lp= LPAREN exp= time_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_time_subexpression15550); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_time_expression_in_time_subexpression15554);
					exp=time_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_time_expression.add(exp.getTree());
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_time_subexpression15558); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					}
					break;

			}

			// AST REWRITE
			// elements: rp, exp, val, afi, val, lp, afi, lp, rp, exp
			// token labels: lp, rp
			// rule labels: val, afi, exp, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
			RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
			RewriteRuleSubtreeStream stream_val=new RewriteRuleSubtreeStream(adaptor,"rule val",val!=null?val.getTree():null);
			RewriteRuleSubtreeStream stream_afi=new RewriteRuleSubtreeStream(adaptor,"rule afi",afi!=null?afi.getTree():null);
			RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp",exp!=null?exp.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 3427:5: -> {(um!=null)&&(val!=null)}? ^( UNARY_MINUS[$um] $val)
			if ((um!=null)&&(val!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3427:35: ^( UNARY_MINUS[$um] $val)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				adaptor.addChild(root_1, stream_val.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3428:5: -> {(um!=null)&&(afi!=null)}? ^( UNARY_MINUS[$um] $afi)
			if ((um!=null)&&(afi!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3428:35: ^( UNARY_MINUS[$um] $afi)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				adaptor.addChild(root_1, stream_afi.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3429:5: -> {(um!=null)&&(lp!=null)}? ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
			if ((um!=null)&&(lp!=null)) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3429:34: ^( UNARY_MINUS[$um] ^( $lp $exp $rp) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(UNARY_MINUS, um), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3429:53: ^( $lp $exp $rp)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_2);
				adaptor.addChild(root_2, stream_exp.nextTree());
				adaptor.addChild(root_2, stream_rp.nextNode());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3430:5: -> {val!=null}? $val
			if (val!=null) {
				adaptor.addChild(root_0, stream_val.nextTree());
			}

			else // 3431:5: -> {afi!=null}? $afi
			if (afi!=null) {
				adaptor.addChild(root_0, stream_afi.nextTree());
			}

			else // 3432:5: -> ^( $lp $exp $rp)
			{
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3432:8: ^( $lp $exp $rp)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
				adaptor.addChild(root_1, stream_exp.nextTree());
				adaptor.addChild(root_1, stream_rp.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_subexpression"


	public static class assertion_function_invocation_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_function_invocation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3435:1: assertion_function_invocation : (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) );
	public final BLESStoASTParser.assertion_function_invocation_return assertion_function_invocation() throws RecognitionException {
		BLESStoASTParser.assertion_function_invocation_return retval = new BLESStoASTParser.assertion_function_invocation_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token assertion_function_identifier=null;
		Token lp=null;
		Token RPAREN384=null;
		Token COMMA385=null;
		Token RPAREN386=null;
		List<Object> list_list=null;
		ParserRuleReturnScope actual =null;
		RuleReturnScope list = null;
		BAST assertion_function_identifier_tree=null;
		BAST lp_tree=null;
		BAST RPAREN384_tree=null;
		BAST COMMA385_tree=null;
		BAST RPAREN386_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_actual_assertion_parameter=new RewriteRuleSubtreeStream(adaptor,"rule actual_assertion_parameter");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3436:3: (assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) ) |assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) ) )
			int alt205=2;
			int LA205_0 = input.LA(1);
			if ( (LA205_0==ID) ) {
				int LA205_1 = input.LA(2);
				if ( (LA205_1==LPAREN) ) {
					int LA205_2 = input.LA(3);
					if ( (LA205_2==AADL_STRING_LITERAL||LA205_2==INTEGER_LIT||LA205_2==LBRACKET||LA205_2==LITERAL_abs||LA205_2==LITERAL_complex||LA205_2==LITERAL_false||LA205_2==LITERAL_in||LA205_2==LITERAL_integer||LA205_2==LITERAL_natural||LA205_2==LITERAL_now||(LA205_2 >= LITERAL_null && LA205_2 <= LITERAL_numberof)||LA205_2==LITERAL_product||(LA205_2 >= LITERAL_rational && LA205_2 <= LITERAL_real)||LA205_2==LITERAL_self||LA205_2==LITERAL_sum||(LA205_2 >= LITERAL_time && LA205_2 <= LITERAL_timeout)||LA205_2==LITERAL_tops||LA205_2==LITERAL_true||LA205_2==LPAREN||LA205_2==MINUS||LA205_2==OCTOTHORPE||LA205_2==REAL_LIT||LA205_2==RPAREN) ) {
						alt205=1;
					}
					else if ( (LA205_2==ID) ) {
						int LA205_4 = input.LA(4);
						if ( (LA205_4==AT_SIGN||LA205_4==CARET||LA205_4==DIVIDE||LA205_4==DOUBLE_COLON||LA205_4==EXP||LA205_4==LBRACKET||LA205_4==LITERAL_mod||LA205_4==LITERAL_rem||LA205_4==LPAREN||LA205_4==MINUS||LA205_4==OCTOTHORPE||(LA205_4 >= PERIOD && LA205_4 <= PLUS)||LA205_4==QUESTION||LA205_4==RPAREN||LA205_4==TICK||LA205_4==TIMES) ) {
							alt205=1;
						}
						else if ( ((LA205_4 >= COLON && LA205_4 <= COLON_TILDE)) ) {
							alt205=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 205, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 205, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 205, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 205, 0, input);
				throw nvae;
			}

			switch (alt205) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3437:3: assertion_function_identifier= ID lp= LPAREN (actual= assertion_expression )? RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15678); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15682); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3437:52: (actual= assertion_expression )?
					int alt203=2;
					int LA203_0 = input.LA(1);
					if ( (LA203_0==AADL_STRING_LITERAL||LA203_0==ID||LA203_0==INTEGER_LIT||LA203_0==LBRACKET||LA203_0==LITERAL_abs||LA203_0==LITERAL_complex||LA203_0==LITERAL_false||LA203_0==LITERAL_in||LA203_0==LITERAL_integer||LA203_0==LITERAL_natural||LA203_0==LITERAL_now||(LA203_0 >= LITERAL_null && LA203_0 <= LITERAL_numberof)||LA203_0==LITERAL_product||(LA203_0 >= LITERAL_rational && LA203_0 <= LITERAL_real)||LA203_0==LITERAL_self||LA203_0==LITERAL_sum||(LA203_0 >= LITERAL_time && LA203_0 <= LITERAL_timeout)||LA203_0==LITERAL_tops||LA203_0==LITERAL_true||LA203_0==LPAREN||LA203_0==MINUS||LA203_0==OCTOTHORPE||LA203_0==REAL_LIT) ) {
						alt203=1;
					}
					switch (alt203) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3437:52: actual= assertion_expression
							{
							pushFollow(FOLLOW_assertion_expression_in_assertion_function_invocation15686);
							actual=assertion_expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_assertion_expression.add(actual.getTree());
							}
							break;

					}

					RPAREN384=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15689); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN384);

					// AST REWRITE
					// elements: assertion_function_identifier, actual
					// token labels: assertion_function_identifier
					// rule labels: actual, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_assertion_function_identifier=new RewriteRuleTokenStream(adaptor,"token assertion_function_identifier",assertion_function_identifier);
					RewriteRuleSubtreeStream stream_actual=new RewriteRuleSubtreeStream(adaptor,"rule actual",actual!=null?actual.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3438:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3438:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $actual)? ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3439:9: ^( $assertion_function_identifier ( $actual)? )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3439:45: ( $actual)?
						if ( stream_actual.hasNext() ) {
							adaptor.addChild(root_2, stream_actual.nextTree());
						}
						stream_actual.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3441:3: assertion_function_identifier= ID lp= LPAREN list+= actual_assertion_parameter ( COMMA list+= actual_assertion_parameter )* RPAREN
					{
					assertion_function_identifier=(Token)match(input,ID,FOLLOW_ID_in_assertion_function_invocation15736); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(assertion_function_identifier);

					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_function_invocation15740); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15749);
					list=actual_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(list.getTree());
					if (list_list==null) list_list=new ArrayList<Object>();
					list_list.add(list.getTree());
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3442:38: ( COMMA list+= actual_assertion_parameter )*
					loop204:
					while (true) {
						int alt204=2;
						int LA204_0 = input.LA(1);
						if ( (LA204_0==COMMA) ) {
							alt204=1;
						}

						switch (alt204) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3442:40: COMMA list+= actual_assertion_parameter
							{
							COMMA385=(Token)match(input,COMMA,FOLLOW_COMMA_in_assertion_function_invocation15753); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA385);

							pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15757);
							list=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_actual_assertion_parameter.add(list.getTree());
							if (list_list==null) list_list=new ArrayList<Object>();
							list_list.add(list.getTree());
							}
							break;

						default :
							break loop204;
						}
					}

					RPAREN386=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_function_invocation15762); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN386);

					// AST REWRITE
					// elements: assertion_function_identifier, list
					// token labels: assertion_function_identifier
					// rule labels: retval
					// token list labels: 
					// rule list labels: list
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_assertion_function_identifier=new RewriteRuleTokenStream(adaptor,"token assertion_function_identifier",assertion_function_identifier);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
					RewriteRuleSubtreeStream stream_list=new RewriteRuleSubtreeStream(adaptor,"token list",list_list);
					root_0 = (BAST)adaptor.nil();
					// 3443:5: -> ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3443:8: ^( INVOKE_FUNCTION[$lp,\"INVOKE_FUNCTION[\"+Integer.toString($lp.getLine()+startingLine)+\"]\"] ^( $assertion_function_identifier ( $list)+ ) )
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(INVOKE_FUNCTION, lp, "INVOKE_FUNCTION["+Integer.toString(lp.getLine()+startingLine)+"]"), root_1);
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3444:9: ^( $assertion_function_identifier ( $list)+ )
						{
						BAST root_2 = (BAST)adaptor.nil();
						root_2 = (BAST)adaptor.becomeRoot(stream_assertion_function_identifier.nextNode(), root_2);
						if ( !(stream_list.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_list.hasNext() ) {
							adaptor.addChild(root_2, stream_list.nextTree());
						}
						stream_list.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("Did you forget the formal identifier when invoking an assertion-function?");
			  Dump.it("actual_assertion_parameter ::= formal_identifier : actual_assertion_expression"); 
			  throw re;
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_invocation"


	public static class parenthesized_assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "parenthesized_assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3451:1: parenthesized_assertion_expression : ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) );
	public final BLESStoASTParser.parenthesized_assertion_expression_return parenthesized_assertion_expression() throws RecognitionException {
		BLESStoASTParser.parenthesized_assertion_expression_return retval = new BLESStoASTParser.parenthesized_assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token lp=null;
		Token rp=null;
		ParserRuleReturnScope cpe =null;
		ParserRuleReturnScope art =null;
		ParserRuleReturnScope caf =null;
		ParserRuleReturnScope pe =null;

		BAST lp_tree=null;
		BAST rp_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_conditional_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_expression");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");
		RewriteRuleSubtreeStream stream_conditional_assertion_function=new RewriteRuleSubtreeStream(adaptor,"rule conditional_assertion_function");
		RewriteRuleSubtreeStream stream_assertion_record_term=new RewriteRuleSubtreeStream(adaptor,"rule assertion_record_term");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3452:3: ( ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression -> $cpe| ( LPAREN ID ARROW )=>art= assertion_record_term -> $art| ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function -> $caf|lp= LPAREN pe= assertion_expression rp= RPAREN -> ^( $lp $pe $rp) )
			int alt206=4;
			int LA206_0 = input.LA(1);
			if ( (LA206_0==LPAREN) ) {
				int LA206_1 = input.LA(2);
				if ( (synpred17_BLESStoAST()) ) {
					alt206=1;
				}
				else if ( (synpred18_BLESStoAST()) ) {
					alt206=2;
				}
				else if ( (synpred19_BLESStoAST()) ) {
					alt206=3;
				}
				else if ( (true) ) {
					alt206=4;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 206, 0, input);
				throw nvae;
			}

			switch (alt206) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3453:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )=>cpe= conditional_assertion_expression
					{
					pushFollow(FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15849);
					cpe=conditional_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_expression.add(cpe.getTree());
					// AST REWRITE
					// elements: cpe
					// token labels: 
					// rule labels: cpe, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cpe=new RewriteRuleSubtreeStream(adaptor,"rule cpe",cpe!=null?cpe.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3455:5: -> $cpe
					{
						adaptor.addChild(root_0, stream_cpe.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3457:3: ( LPAREN ID ARROW )=>art= assertion_record_term
					{
					pushFollow(FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15879);
					art=assertion_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_record_term.add(art.getTree());
					// AST REWRITE
					// elements: art
					// token labels: 
					// rule labels: art, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_art=new RewriteRuleSubtreeStream(adaptor,"rule art",art!=null?art.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3459:5: -> $art
					{
						adaptor.addChild(root_0, stream_art.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3461:3: ( LPAREN parenthesized_predicate IMP )=>caf= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15913);
					caf=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_assertion_function.add(caf.getTree());
					// AST REWRITE
					// elements: caf
					// token labels: 
					// rule labels: caf, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_caf=new RewriteRuleSubtreeStream(adaptor,"rule caf",caf!=null?caf.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3463:5: -> $caf
					{
						adaptor.addChild(root_0, stream_caf.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3465:3: lp= LPAREN pe= assertion_expression rp= RPAREN
					{
					lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_assertion_expression15934); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(lp);

					pushFollow(FOLLOW_assertion_expression_in_parenthesized_assertion_expression15938);
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(pe.getTree());
					rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_assertion_expression15942); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(rp);

					// AST REWRITE
					// elements: lp, rp, pe
					// token labels: lp, rp
					// rule labels: pe, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_lp=new RewriteRuleTokenStream(adaptor,"token lp",lp);
					RewriteRuleTokenStream stream_rp=new RewriteRuleTokenStream(adaptor,"token rp",rp);
					RewriteRuleSubtreeStream stream_pe=new RewriteRuleSubtreeStream(adaptor,"rule pe",pe!=null?pe.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3466:5: -> ^( $lp $pe $rp)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3466:8: ^( $lp $pe $rp)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot(stream_lp.nextNode(), root_1);
						adaptor.addChild(root_1, stream_pe.nextTree());
						adaptor.addChild(root_1, stream_rp.nextNode());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_assertion_expression"


	public static class conditional_assertion_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "conditional_assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3469:1: conditional_assertion_expression : ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) );
	public final BLESStoASTParser.conditional_assertion_expression_return conditional_assertion_expression() throws RecognitionException {
		BLESStoASTParser.conditional_assertion_expression_return retval = new BLESStoASTParser.conditional_assertion_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token then=null;
		Token q=null;
		Token LPAREN387=null;
		Token LITERAL_if388=null;
		Token LITERAL_else389=null;
		Token RPAREN390=null;
		Token LPAREN391=null;
		Token COLON392=null;
		Token RPAREN393=null;
		ParserRuleReturnScope p =null;
		ParserRuleReturnScope t =null;
		ParserRuleReturnScope f =null;

		BAST then_tree=null;
		BAST q_tree=null;
		BAST LPAREN387_tree=null;
		BAST LITERAL_if388_tree=null;
		BAST LITERAL_else389_tree=null;
		BAST RPAREN390_tree=null;
		BAST LPAREN391_tree=null;
		BAST COLON392_tree=null;
		BAST RPAREN393_tree=null;
		RewriteRuleTokenStream stream_QQ=new RewriteRuleTokenStream(adaptor,"token QQ");
		RewriteRuleTokenStream stream_LITERAL_else=new RewriteRuleTokenStream(adaptor,"token LITERAL_else");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_LITERAL_then=new RewriteRuleTokenStream(adaptor,"token LITERAL_then");
		RewriteRuleTokenStream stream_LITERAL_if=new RewriteRuleTokenStream(adaptor,"token LITERAL_if");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_predicate=new RewriteRuleSubtreeStream(adaptor,"rule predicate");
		RewriteRuleSubtreeStream stream_assertion_expression=new RewriteRuleSubtreeStream(adaptor,"rule assertion_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3470:3: ( LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN -> ^( CONDITIONAL[$then] $p $t $f) | LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN -> ^( CONDITIONAL[$q] $p $t $f) )
			int alt207=2;
			int LA207_0 = input.LA(1);
			if ( (LA207_0==LPAREN) ) {
				int LA207_1 = input.LA(2);
				if ( (LA207_1==LITERAL_if) ) {
					alt207=1;
				}
				else if ( (LA207_1==AADL_STRING_LITERAL||LA207_1==ID||LA207_1==INTEGER_LIT||LA207_1==LBRACKET||LA207_1==LITERAL_abs||LA207_1==LITERAL_all||LA207_1==LITERAL_complex||LA207_1==LITERAL_def||LA207_1==LITERAL_exists||LA207_1==LITERAL_false||LA207_1==LITERAL_in||LA207_1==LITERAL_integer||LA207_1==LITERAL_natural||(LA207_1 >= LITERAL_not && LA207_1 <= LITERAL_now)||LA207_1==LITERAL_null||(LA207_1 >= LITERAL_rational && LA207_1 <= LITERAL_real)||LA207_1==LITERAL_self||LA207_1==LITERAL_stop||(LA207_1 >= LITERAL_time && LA207_1 <= LITERAL_timeout)||LA207_1==LITERAL_tops||LA207_1==LITERAL_true||LA207_1==LPAREN||LA207_1==MINUS||LA207_1==OCTOTHORPE||LA207_1==REAL_LIT) ) {
					alt207=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 207, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 207, 0, input);
				throw nvae;
			}

			switch (alt207) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3471:3: LPAREN LITERAL_if p= predicate then= LITERAL_then t= assertion_expression LITERAL_else f= assertion_expression RPAREN
					{
					LPAREN387=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression15974); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN387);

					LITERAL_if388=(Token)match(input,LITERAL_if,FOLLOW_LITERAL_if_in_conditional_assertion_expression15976); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_if.add(LITERAL_if388);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression15980);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					then=(Token)match(input,LITERAL_then,FOLLOW_LITERAL_then_in_conditional_assertion_expression15984); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_then.add(then);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15989);
					t=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(t.getTree());
					LITERAL_else389=(Token)match(input,LITERAL_else,FOLLOW_LITERAL_else_in_conditional_assertion_expression15991); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_else.add(LITERAL_else389);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression15996);
					f=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(f.getTree());
					RPAREN390=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression15998); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN390);

					// AST REWRITE
					// elements: p, t, f
					// token labels: 
					// rule labels: p, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3472:5: -> ^( CONDITIONAL[$then] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3472:8: ^( CONDITIONAL[$then] $p $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, then), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3474:3: LPAREN p= predicate q= QQ t= assertion_expression COLON f= assertion_expression RPAREN
					{
					LPAREN391=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_conditional_assertion_expression16026); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN391);

					pushFollow(FOLLOW_predicate_in_conditional_assertion_expression16030);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_predicate.add(p.getTree());
					q=(Token)match(input,QQ,FOLLOW_QQ_in_conditional_assertion_expression16034); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_QQ.add(q);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression16039);
					t=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(t.getTree());
					COLON392=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_assertion_expression16041); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON392);

					pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression16046);
					f=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assertion_expression.add(f.getTree());
					RPAREN393=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_conditional_assertion_expression16048); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN393);

					// AST REWRITE
					// elements: f, t, p
					// token labels: 
					// rule labels: p, t, f, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.getTree():null);
					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
					RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3475:5: -> ^( CONDITIONAL[$q] $p $t $f)
					{
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3475:8: ^( CONDITIONAL[$q] $p $t $f)
						{
						BAST root_1 = (BAST)adaptor.nil();
						root_1 = (BAST)adaptor.becomeRoot((BAST)adaptor.create(CONDITIONAL, q), root_1);
						adaptor.addChild(root_1, stream_p.nextTree());
						adaptor.addChild(root_1, stream_t.nextTree());
						adaptor.addChild(root_1, stream_f.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_expression"


	public static class assertion_record_term_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3478:1: assertion_record_term : LPAREN ^ ( assertion_record_value )+ RPAREN ;
	public final BLESStoASTParser.assertion_record_term_return assertion_record_term() throws RecognitionException {
		BLESStoASTParser.assertion_record_term_return retval = new BLESStoASTParser.assertion_record_term_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LPAREN394=null;
		Token RPAREN396=null;
		ParserRuleReturnScope assertion_record_value395 =null;

		BAST LPAREN394_tree=null;
		BAST RPAREN396_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3479:3: ( LPAREN ^ ( assertion_record_value )+ RPAREN )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3480:5: LPAREN ^ ( assertion_record_value )+ RPAREN
			{
			root_0 = (BAST)adaptor.nil();


			LPAREN394=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_assertion_record_term16086); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LPAREN394_tree = (BAST)adaptor.create(LPAREN394);
			root_0 = (BAST)adaptor.becomeRoot(LPAREN394_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3480:13: ( assertion_record_value )+
			int cnt208=0;
			loop208:
			while (true) {
				int alt208=2;
				int LA208_0 = input.LA(1);
				if ( (LA208_0==ID) ) {
					alt208=1;
				}

				switch (alt208) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3480:13: assertion_record_value
					{
					pushFollow(FOLLOW_assertion_record_value_in_assertion_record_term16089);
					assertion_record_value395=assertion_record_value();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, assertion_record_value395.getTree());

					}
					break;

				default :
					if ( cnt208 >= 1 ) break loop208;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(208, input);
					throw eee;
				}
				cnt208++;
			}

			RPAREN396=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_assertion_record_term16092); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RPAREN396_tree = (BAST)adaptor.create(RPAREN396);
			adaptor.addChild(root_0, RPAREN396_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_term"


	public static class assertion_record_value_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3483:1: assertion_record_value : ID ARROW ^ value SEMICOLON !;
	public final BLESStoASTParser.assertion_record_value_return assertion_record_value() throws RecognitionException {
		BLESStoASTParser.assertion_record_value_return retval = new BLESStoASTParser.assertion_record_value_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID397=null;
		Token ARROW398=null;
		Token SEMICOLON400=null;
		ParserRuleReturnScope value399 =null;

		BAST ID397_tree=null;
		BAST ARROW398_tree=null;
		BAST SEMICOLON400_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3484:3: ( ID ARROW ^ value SEMICOLON !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3485:3: ID ARROW ^ value SEMICOLON !
			{
			root_0 = (BAST)adaptor.nil();


			ID397=(Token)match(input,ID,FOLLOW_ID_in_assertion_record_value16107); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID397_tree = (BAST)adaptor.create(ID397);
			adaptor.addChild(root_0, ID397_tree);
			}

			ARROW398=(Token)match(input,ARROW,FOLLOW_ARROW_in_assertion_record_value16109); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ARROW398_tree = (BAST)adaptor.create(ARROW398);
			root_0 = (BAST)adaptor.becomeRoot(ARROW398_tree, root_0);
			}

			pushFollow(FOLLOW_value_in_assertion_record_value16112);
			value399=value();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, value399.getTree());

			SEMICOLON400=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_assertion_record_value16114); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_value"


	public static class assertion_parameter_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3488:1: assertion_parameter : ID ;
	public final BLESStoASTParser.assertion_parameter_return assertion_parameter() throws RecognitionException {
		BLESStoASTParser.assertion_parameter_return retval = new BLESStoASTParser.assertion_parameter_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token ID401=null;

		BAST ID401_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3489:3: ( ID )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3490:3: ID
			{
			root_0 = (BAST)adaptor.nil();


			ID401=(Token)match(input,ID,FOLLOW_ID_in_assertion_parameter16130); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID401_tree = (BAST)adaptor.create(ID401);
			adaptor.addChild(root_0, ID401_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_parameter"


	public static class assertion_type_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "assertion_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3493:1: assertion_type : ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference );
	public final BLESStoASTParser.assertion_type_return assertion_type() throws RecognitionException {
		BLESStoASTParser.assertion_type_return retval = new BLESStoASTParser.assertion_type_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_boolean402=null;
		Token LITERAL_natural403=null;
		Token LITERAL_integer404=null;
		Token LITERAL_rational405=null;
		Token LITERAL_real406=null;
		Token LITERAL_complex407=null;
		Token LITERAL_time408=null;
		ParserRuleReturnScope unique_component_classifier_reference409 =null;

		BAST LITERAL_boolean402_tree=null;
		BAST LITERAL_natural403_tree=null;
		BAST LITERAL_integer404_tree=null;
		BAST LITERAL_rational405_tree=null;
		BAST LITERAL_real406_tree=null;
		BAST LITERAL_complex407_tree=null;
		BAST LITERAL_time408_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3494:3: ( LITERAL_boolean | LITERAL_natural | LITERAL_integer | LITERAL_rational | LITERAL_real | LITERAL_complex | LITERAL_time | unique_component_classifier_reference )
			int alt209=8;
			switch ( input.LA(1) ) {
			case LITERAL_boolean:
				{
				alt209=1;
				}
				break;
			case LITERAL_natural:
				{
				alt209=2;
				}
				break;
			case LITERAL_integer:
				{
				alt209=3;
				}
				break;
			case LITERAL_rational:
				{
				alt209=4;
				}
				break;
			case LITERAL_real:
				{
				alt209=5;
				}
				break;
			case LITERAL_complex:
				{
				alt209=6;
				}
				break;
			case LITERAL_time:
				{
				alt209=7;
				}
				break;
			case ID:
				{
				alt209=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 209, 0, input);
				throw nvae;
			}
			switch (alt209) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:3: LITERAL_boolean
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_boolean402=(Token)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_assertion_type16148); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_boolean402_tree = (BAST)adaptor.create(LITERAL_boolean402);
					adaptor.addChild(root_0, LITERAL_boolean402_tree);
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:21: LITERAL_natural
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_natural403=(Token)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type16152); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_natural403_tree = (BAST)adaptor.create(LITERAL_natural403);
					adaptor.addChild(root_0, LITERAL_natural403_tree);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:39: LITERAL_integer
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_integer404=(Token)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type16156); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_integer404_tree = (BAST)adaptor.create(LITERAL_integer404);
					adaptor.addChild(root_0, LITERAL_integer404_tree);
					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:57: LITERAL_rational
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_rational405=(Token)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type16160); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_rational405_tree = (BAST)adaptor.create(LITERAL_rational405);
					adaptor.addChild(root_0, LITERAL_rational405_tree);
					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:76: LITERAL_real
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_real406=(Token)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type16164); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_real406_tree = (BAST)adaptor.create(LITERAL_real406);
					adaptor.addChild(root_0, LITERAL_real406_tree);
					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3495:91: LITERAL_complex
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_complex407=(Token)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type16168); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_complex407_tree = (BAST)adaptor.create(LITERAL_complex407);
					adaptor.addChild(root_0, LITERAL_complex407_tree);
					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3496:4: LITERAL_time
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_time408=(Token)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type16173); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_time408_tree = (BAST)adaptor.create(LITERAL_time408);
					adaptor.addChild(root_0, LITERAL_time408_tree);
					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3498:5: unique_component_classifier_reference
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_unique_component_classifier_reference_in_assertion_type16180);
					unique_component_classifier_reference409=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unique_component_classifier_reference409.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type"


	public static class availability_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3503:1: availability : LITERAL_availability ^ availability_subexpression ;
	public final BLESStoASTParser.availability_return availability() throws RecognitionException {
		BLESStoASTParser.availability_return retval = new BLESStoASTParser.availability_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_availability410=null;
		ParserRuleReturnScope availability_subexpression411 =null;

		BAST LITERAL_availability410_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3504:3: ( LITERAL_availability ^ availability_subexpression )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3505:3: LITERAL_availability ^ availability_subexpression
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_availability410=(Token)match(input,LITERAL_availability,FOLLOW_LITERAL_availability_in_availability16206); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_availability410_tree = (BAST)adaptor.create(LITERAL_availability410);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_availability410_tree, root_0);
			}

			pushFollow(FOLLOW_availability_subexpression_in_availability16210);
			availability_subexpression411=availability_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, availability_subexpression411.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability"


	public static class availability_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3508:1: availability_expression :ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae;
	public final BLESStoASTParser.availability_expression_return availability_expression() throws RecognitionException {
		BLESStoASTParser.availability_expression_return retval = new BLESStoASTParser.availability_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token dna=null;
		Token ro=null;
		Token rox=null;
		List<Object> list_ae=null;
		RuleReturnScope ae = null;
		BAST dna_tree=null;
		BAST ro_tree=null;
		BAST rox_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleTokenStream stream_LITERAL_xor=new RewriteRuleTokenStream(adaptor,"token LITERAL_xor");
		RewriteRuleSubtreeStream stream_availability_subexpression=new RewriteRuleSubtreeStream(adaptor,"rule availability_subexpression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3509:3: (ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )? -> {dna!=null}? ^( $dna ( $ae)+ ) -> {ro!=null}? ^( $ro ( $ae)+ ) -> {rox!=null}? ^( $rox ( $ae)+ ) -> $ae)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3510:3: ae+= availability_subexpression ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
			{
			pushFollow(FOLLOW_availability_subexpression_in_availability_expression16231);
			ae=availability_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
			if (list_ae==null) list_ae=new ArrayList<Object>();
			list_ae.add(ae.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3511:3: ( (dna= LITERAL_and ae+= availability_subexpression )+ | (ro= LITERAL_or ae+= availability_subexpression )+ | (rox= LITERAL_xor ae+= availability_subexpression )+ )?
			int alt213=4;
			switch ( input.LA(1) ) {
				case LITERAL_and:
					{
					alt213=1;
					}
					break;
				case LITERAL_or:
					{
					alt213=2;
					}
					break;
				case LITERAL_xor:
					{
					alt213=3;
					}
					break;
			}
			switch (alt213) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3512:5: (dna= LITERAL_and ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3512:5: (dna= LITERAL_and ae+= availability_subexpression )+
					int cnt210=0;
					loop210:
					while (true) {
						int alt210=2;
						int LA210_0 = input.LA(1);
						if ( (LA210_0==LITERAL_and) ) {
							alt210=1;
						}

						switch (alt210) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3512:7: dna= LITERAL_and ae+= availability_subexpression
							{
							dna=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_availability_expression16245); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_and.add(dna);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16249);
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt210 >= 1 ) break loop210;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(210, input);
							throw eee;
						}
						cnt210++;
					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3514:5: (ro= LITERAL_or ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3514:5: (ro= LITERAL_or ae+= availability_subexpression )+
					int cnt211=0;
					loop211:
					while (true) {
						int alt211=2;
						int LA211_0 = input.LA(1);
						if ( (LA211_0==LITERAL_or) ) {
							alt211=1;
						}

						switch (alt211) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3514:7: ro= LITERAL_or ae+= availability_subexpression
							{
							ro=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_availability_expression16268); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_or.add(ro);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16272);
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt211 >= 1 ) break loop211;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(211, input);
							throw eee;
						}
						cnt211++;
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3516:5: (rox= LITERAL_xor ae+= availability_subexpression )+
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3516:5: (rox= LITERAL_xor ae+= availability_subexpression )+
					int cnt212=0;
					loop212:
					while (true) {
						int alt212=2;
						int LA212_0 = input.LA(1);
						if ( (LA212_0==LITERAL_xor) ) {
							alt212=1;
						}

						switch (alt212) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3516:7: rox= LITERAL_xor ae+= availability_subexpression
							{
							rox=(Token)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_availability_expression16291); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LITERAL_xor.add(rox);

							pushFollow(FOLLOW_availability_subexpression_in_availability_expression16295);
							ae=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_availability_subexpression.add(ae.getTree());
							if (list_ae==null) list_ae=new ArrayList<Object>();
							list_ae.add(ae.getTree());
							}
							break;

						default :
							if ( cnt212 >= 1 ) break loop212;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(212, input);
							throw eee;
						}
						cnt212++;
					}

					}
					break;

			}

			// AST REWRITE
			// elements: ae, ae, ro, ae, rox, dna, ae
			// token labels: dna, rox, ro
			// rule labels: retval
			// token list labels: 
			// rule list labels: ae
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_dna=new RewriteRuleTokenStream(adaptor,"token dna",dna);
			RewriteRuleTokenStream stream_rox=new RewriteRuleTokenStream(adaptor,"token rox",rox);
			RewriteRuleTokenStream stream_ro=new RewriteRuleTokenStream(adaptor,"token ro",ro);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"token ae",list_ae);
			root_0 = (BAST)adaptor.nil();
			// 3518:5: -> {dna!=null}? ^( $dna ( $ae)+ )
			if (dna!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3518:21: ^( $dna ( $ae)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_dna.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3519:5: -> {ro!=null}? ^( $ro ( $ae)+ )
			if (ro!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3519:20: ^( $ro ( $ae)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_ro.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3520:5: -> {rox!=null}? ^( $rox ( $ae)+ )
			if (rox!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3520:21: ^( $rox ( $ae)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_rox.nextNode(), root_1);
				if ( !(stream_ae.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_ae.hasNext() ) {
					adaptor.addChild(root_1, stream_ae.nextTree());
				}
				stream_ae.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3521:5: -> $ae
			{
				adaptor.addChild(root_0, stream_ae.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_expression"


	public static class availability_subexpression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "availability_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3524:1: availability_subexpression : (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id;
	public final BLESStoASTParser.availability_subexpression_return availability_subexpression() throws RecognitionException {
		BLESStoASTParser.availability_subexpression_return retval = new BLESStoASTParser.availability_subexpression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token n=null;
		Token l=null;
		Token RPAREN412=null;
		ParserRuleReturnScope id =null;
		ParserRuleReturnScope ae =null;

		BAST n_tree=null;
		BAST l_tree=null;
		BAST RPAREN412_tree=null;
		RewriteRuleTokenStream stream_LITERAL_not=new RewriteRuleTokenStream(adaptor,"token LITERAL_not");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_availability_expression=new RewriteRuleSubtreeStream(adaptor,"rule availability_expression");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3525:3: ( (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN ) -> {n!=null&&id!=null}? ^( $n $id) -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) ) -> {ae!=null}? ^( $l $ae) -> $id)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3526:3: (n= LITERAL_not )? (id= identifier |l= LPAREN ae= availability_expression RPAREN )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3526:3: (n= LITERAL_not )?
			int alt214=2;
			int LA214_0 = input.LA(1);
			if ( (LA214_0==LITERAL_not) ) {
				alt214=1;
			}
			switch (alt214) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3526:5: n= LITERAL_not
					{
					n=(Token)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_availability_subexpression16387); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_not.add(n);

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3527:3: (id= identifier |l= LPAREN ae= availability_expression RPAREN )
			int alt215=2;
			int LA215_0 = input.LA(1);
			if ( (LA215_0==ID) ) {
				alt215=1;
			}
			else if ( (LA215_0==LPAREN) ) {
				alt215=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 215, 0, input);
				throw nvae;
			}

			switch (alt215) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3528:3: id= identifier
					{
					pushFollow(FOLLOW_identifier_in_availability_subexpression16402);
					id=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_identifier.add(id.getTree());
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3530:3: l= LPAREN ae= availability_expression RPAREN
					{
					l=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_availability_subexpression16412); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(l);

					pushFollow(FOLLOW_availability_expression_in_availability_subexpression16416);
					ae=availability_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_availability_expression.add(ae.getTree());
					RPAREN412=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_availability_subexpression16418); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN412);

					}
					break;

			}

			// AST REWRITE
			// elements: n, id, ae, l, n, id, ae, l
			// token labels: l, n
			// rule labels: ae, id, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_l=new RewriteRuleTokenStream(adaptor,"token l",l);
			RewriteRuleTokenStream stream_n=new RewriteRuleTokenStream(adaptor,"token n",n);
			RewriteRuleSubtreeStream stream_ae=new RewriteRuleSubtreeStream(adaptor,"rule ae",ae!=null?ae.getTree():null);
			RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id",id!=null?id.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (BAST)adaptor.nil();
			// 3532:5: -> {n!=null&&id!=null}? ^( $n $id)
			if (n!=null&&id!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3532:29: ^( $n $id)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				adaptor.addChild(root_1, stream_id.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3533:5: -> {n!=null&&ae!=null}? ^( $n ^( $l $ae) )
			if (n!=null&&ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3533:29: ^( $n ^( $l $ae) )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_n.nextNode(), root_1);
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3533:34: ^( $l $ae)
				{
				BAST root_2 = (BAST)adaptor.nil();
				root_2 = (BAST)adaptor.becomeRoot(stream_l.nextNode(), root_2);
				adaptor.addChild(root_2, stream_ae.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3534:5: -> {ae!=null}? ^( $l $ae)
			if (ae!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3534:20: ^( $l $ae)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_l.nextNode(), root_1);
				adaptor.addChild(root_1, stream_ae.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3535:5: -> $id
			{
				adaptor.addChild(root_0, stream_id.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_subexpression"


	public static class dispatch_condition_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3541:1: dispatch_condition : 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? ;
	public final BLESStoASTParser.dispatch_condition_return dispatch_condition() throws RecognitionException {
		BLESStoASTParser.dispatch_condition_return retval = new BLESStoASTParser.dispatch_condition_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token string_literal413=null;
		Token LITERAL_dispatch414=null;
		ParserRuleReturnScope dispatch_expression415 =null;

		BAST string_literal413_tree=null;
		BAST LITERAL_dispatch414_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3542:3: ( 'on' ! LITERAL_dispatch ^ ( dispatch_expression )? )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3543:3: 'on' ! LITERAL_dispatch ^ ( dispatch_expression )?
			{
			root_0 = (BAST)adaptor.nil();


			string_literal413=(Token)match(input,LITERAL_on,FOLLOW_LITERAL_on_in_dispatch_condition16506); if (state.failed) return retval;
			LITERAL_dispatch414=(Token)match(input,LITERAL_dispatch,FOLLOW_LITERAL_dispatch_in_dispatch_condition16509); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_dispatch414_tree = (BAST)adaptor.create(LITERAL_dispatch414);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_dispatch414_tree, root_0);
			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3543:28: ( dispatch_expression )?
			int alt216=2;
			int LA216_0 = input.LA(1);
			if ( (LA216_0==ID||LA216_0==LITERAL_stop||LA216_0==LITERAL_timeout) ) {
				alt216=1;
			}
			switch (alt216) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3543:28: dispatch_expression
					{
					pushFollow(FOLLOW_dispatch_expression_in_dispatch_condition16513);
					dispatch_expression415=dispatch_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dispatch_expression415.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			Dump.it("error token text=\""+retval.start.getText()+"\"");
			     reportError(re,(BAST)retval.getTree()); 
			    Dump.it("RecognitionException caught by BLESStoAST.dispatch_condition");
			    tellBNF(GrammarStrings.dispatchCondition,re,retval.tree);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_condition"


	public static class dispatch_expression_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3551:1: dispatch_expression : dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc;
	public final BLESStoASTParser.dispatch_expression_return dispatch_expression() throws RecognitionException {
		BLESStoASTParser.dispatch_expression_return retval = new BLESStoASTParser.dispatch_expression_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token o=null;
		List<Object> list_dc2=null;
		ParserRuleReturnScope dc =null;
		RuleReturnScope dc2 = null;
		BAST o_tree=null;
		RewriteRuleTokenStream stream_LITERAL_or=new RewriteRuleTokenStream(adaptor,"token LITERAL_or");
		RewriteRuleSubtreeStream stream_dispatch_conjunction=new RewriteRuleSubtreeStream(adaptor,"rule dispatch_conjunction");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3552:3: (dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )* -> {o!=null}? ^( $o $dc ( $dc2)+ ) -> $dc)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:3: dc= dispatch_conjunction (o= LITERAL_or dc2+= dispatch_conjunction )*
			{
			pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16541);
			dc=dispatch_conjunction();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dispatch_conjunction.add(dc.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:27: (o= LITERAL_or dc2+= dispatch_conjunction )*
			loop217:
			while (true) {
				int alt217=2;
				int LA217_0 = input.LA(1);
				if ( (LA217_0==LITERAL_or) ) {
					alt217=1;
				}

				switch (alt217) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3553:29: o= LITERAL_or dc2+= dispatch_conjunction
					{
					o=(Token)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_dispatch_expression16547); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_or.add(o);

					pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression16551);
					dc2=dispatch_conjunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dispatch_conjunction.add(dc2.getTree());
					if (list_dc2==null) list_dc2=new ArrayList<Object>();
					list_dc2.add(dc2.getTree());
					}
					break;

				default :
					break loop217;
				}
			}

			// AST REWRITE
			// elements: dc, o, dc2, dc
			// token labels: o
			// rule labels: retval, dc
			// token list labels: 
			// rule list labels: dc2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_o=new RewriteRuleTokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_dc=new RewriteRuleSubtreeStream(adaptor,"rule dc",dc!=null?dc.getTree():null);
			RewriteRuleSubtreeStream stream_dc2=new RewriteRuleSubtreeStream(adaptor,"token dc2",list_dc2);
			root_0 = (BAST)adaptor.nil();
			// 3554:5: -> {o!=null}? ^( $o $dc ( $dc2)+ )
			if (o!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3554:19: ^( $o $dc ( $dc2)+ )
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_o.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dc.nextTree());
				if ( !(stream_dc2.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_dc2.hasNext() ) {
					adaptor.addChild(root_1, stream_dc2.nextTree());
				}
				stream_dc2.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3555:5: -> $dc
			{
				adaptor.addChild(root_0, stream_dc.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_expression"


	public static class dispatch_conjunction_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_conjunction"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3558:1: dispatch_conjunction : dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt;
	public final BLESStoASTParser.dispatch_conjunction_return dispatch_conjunction() throws RecognitionException {
		BLESStoASTParser.dispatch_conjunction_return retval = new BLESStoASTParser.dispatch_conjunction_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token a=null;
		List<Object> list_dt2=null;
		ParserRuleReturnScope dt =null;
		RuleReturnScope dt2 = null;
		BAST a_tree=null;
		RewriteRuleTokenStream stream_LITERAL_and=new RewriteRuleTokenStream(adaptor,"token LITERAL_and");
		RewriteRuleSubtreeStream stream_dispatch_trigger=new RewriteRuleSubtreeStream(adaptor,"rule dispatch_trigger");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3559:3: (dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )* -> {a!=null}? ^( $a $dt $dt2) -> $dt)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3560:3: dt= dispatch_trigger (a= LITERAL_and dt2+= dispatch_trigger )*
			{
			pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16600);
			dt=dispatch_trigger();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dispatch_trigger.add(dt.getTree());
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3560:23: (a= LITERAL_and dt2+= dispatch_trigger )*
			loop218:
			while (true) {
				int alt218=2;
				int LA218_0 = input.LA(1);
				if ( (LA218_0==LITERAL_and) ) {
					alt218=1;
				}

				switch (alt218) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3560:25: a= LITERAL_and dt2+= dispatch_trigger
					{
					a=(Token)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_dispatch_conjunction16606); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_and.add(a);

					pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction16610);
					dt2=dispatch_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dispatch_trigger.add(dt2.getTree());
					if (list_dt2==null) list_dt2=new ArrayList<Object>();
					list_dt2.add(dt2.getTree());
					}
					break;

				default :
					break loop218;
				}
			}

			// AST REWRITE
			// elements: dt, a, dt2, dt
			// token labels: a
			// rule labels: dt, retval
			// token list labels: 
			// rule list labels: dt2
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_dt=new RewriteRuleSubtreeStream(adaptor,"rule dt",dt!=null?dt.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_dt2=new RewriteRuleSubtreeStream(adaptor,"token dt2",list_dt2);
			root_0 = (BAST)adaptor.nil();
			// 3561:5: -> {a!=null}? ^( $a $dt $dt2)
			if (a!=null) {
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3561:19: ^( $a $dt $dt2)
				{
				BAST root_1 = (BAST)adaptor.nil();
				root_1 = (BAST)adaptor.becomeRoot(stream_a.nextNode(), root_1);
				adaptor.addChild(root_1, stream_dt.nextTree());
				adaptor.addChild(root_1, stream_dt2.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 3562:5: -> $dt
			{
				adaptor.addChild(root_0, stream_dt.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_conjunction"


	public static class dispatch_trigger_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "dispatch_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3572:1: dispatch_trigger : ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop);
	public final BLESStoASTParser.dispatch_trigger_return dispatch_trigger() throws RecognitionException {
		BLESStoASTParser.dispatch_trigger_return retval = new BLESStoASTParser.dispatch_trigger_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token stop=null;
		Token LITERAL_timeout416=null;
		Token LPAREN417=null;
		Token RPAREN419=null;
		Token LITERAL_timeout421=null;
		ParserRuleReturnScope identifier418 =null;
		ParserRuleReturnScope behavior_time420 =null;
		ParserRuleReturnScope identifier422 =null;

		BAST stop_tree=null;
		BAST LITERAL_timeout416_tree=null;
		BAST LPAREN417_tree=null;
		BAST RPAREN419_tree=null;
		BAST LITERAL_timeout421_tree=null;
		RewriteRuleTokenStream stream_LITERAL_stop=new RewriteRuleTokenStream(adaptor,"token LITERAL_stop");

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3573:3: ( LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time | LITERAL_timeout ^| identifier |stop= LITERAL_stop -> $stop)
			int alt220=4;
			switch ( input.LA(1) ) {
			case LITERAL_timeout:
				{
				int LA220_1 = input.LA(2);
				if ( (LA220_1==LPAREN) ) {
					alt220=1;
				}
				else if ( (LA220_1==LITERAL_and||LA220_1==LITERAL_or||LA220_1==RCON) ) {
					alt220=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 220, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ID:
				{
				alt220=3;
				}
				break;
			case LITERAL_stop:
				{
				alt220=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 220, 0, input);
				throw nvae;
			}
			switch (alt220) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3575:3: LITERAL_timeout ^ LPAREN ( identifier )+ RPAREN behavior_time
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_timeout416=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16667); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_timeout416_tree = (BAST)adaptor.create(LITERAL_timeout416);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout416_tree, root_0);
					}

					LPAREN417=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_dispatch_trigger16670); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LPAREN417_tree = (BAST)adaptor.create(LPAREN417);
					adaptor.addChild(root_0, LPAREN417_tree);
					}

					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3575:67: ( identifier )+
					int cnt219=0;
					loop219:
					while (true) {
						int alt219=2;
						int LA219_0 = input.LA(1);
						if ( (LA219_0==ID) ) {
							alt219=1;
						}

						switch (alt219) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3575:67: identifier
							{
							pushFollow(FOLLOW_identifier_in_dispatch_trigger16673);
							identifier418=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier418.getTree());

							}
							break;

						default :
							if ( cnt219 >= 1 ) break loop219;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(219, input);
							throw eee;
						}
						cnt219++;
					}

					RPAREN419=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_dispatch_trigger16676); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					RPAREN419_tree = (BAST)adaptor.create(RPAREN419);
					adaptor.addChild(root_0, RPAREN419_tree);
					}

					pushFollow(FOLLOW_behavior_time_in_dispatch_trigger16679);
					behavior_time420=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, behavior_time420.getTree());

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3577:3: LITERAL_timeout ^
					{
					root_0 = (BAST)adaptor.nil();


					LITERAL_timeout421=(Token)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger16688); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					LITERAL_timeout421_tree = (BAST)adaptor.create(LITERAL_timeout421);
					root_0 = (BAST)adaptor.becomeRoot(LITERAL_timeout421_tree, root_0);
					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3579:43: identifier
					{
					root_0 = (BAST)adaptor.nil();


					pushFollow(FOLLOW_identifier_in_dispatch_trigger16699);
					identifier422=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier422.getTree());

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3581:3: stop= LITERAL_stop
					{
					stop=(Token)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_dispatch_trigger16709); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LITERAL_stop.add(stop);

					// AST REWRITE
					// elements: stop
					// token labels: stop
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleTokenStream stream_stop=new RewriteRuleTokenStream(adaptor,"token stop",stop);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (BAST)adaptor.nil();
					// 3582:5: -> $stop
					{
						adaptor.addChild(root_0, stream_stop.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_trigger"


	public static class in_modes_return extends ParserRuleReturnScope {
		BAST tree;
		@Override
		public BAST getTree() { return tree; }
	};


	// $ANTLR start "in_modes"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3670:1: in_modes : LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !;
	public final BLESStoASTParser.in_modes_return in_modes() throws RecognitionException {
		BLESStoASTParser.in_modes_return retval = new BLESStoASTParser.in_modes_return();
		retval.start = input.LT(1);

		BAST root_0 = null;

		Token LITERAL_in423=null;
		Token LITERAL_modes424=null;
		Token LPAREN425=null;
		Token COMMA427=null;
		Token RPAREN429=null;
		ParserRuleReturnScope identifier426 =null;
		ParserRuleReturnScope identifier428 =null;

		BAST LITERAL_in423_tree=null;
		BAST LITERAL_modes424_tree=null;
		BAST LPAREN425_tree=null;
		BAST COMMA427_tree=null;
		BAST RPAREN429_tree=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3671:3: ( LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3672:3: LITERAL_in ^ LITERAL_modes LPAREN ! identifier ( COMMA ! identifier )* RPAREN !
			{
			root_0 = (BAST)adaptor.nil();


			LITERAL_in423=(Token)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_in_modes16760); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_in423_tree = (BAST)adaptor.create(LITERAL_in423);
			root_0 = (BAST)adaptor.becomeRoot(LITERAL_in423_tree, root_0);
			}

			LITERAL_modes424=(Token)match(input,LITERAL_modes,FOLLOW_LITERAL_modes_in_in_modes16763); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LITERAL_modes424_tree = (BAST)adaptor.create(LITERAL_modes424);
			adaptor.addChild(root_0, LITERAL_modes424_tree);
			}

			LPAREN425=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_in_modes16767); if (state.failed) return retval;
			pushFollow(FOLLOW_identifier_in_in_modes16773);
			identifier426=identifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier426.getTree());

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3674:23: ( COMMA ! identifier )*
			loop221:
			while (true) {
				int alt221=2;
				int LA221_0 = input.LA(1);
				if ( (LA221_0==COMMA) ) {
					alt221=1;
				}

				switch (alt221) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3674:25: COMMA ! identifier
					{
					COMMA427=(Token)match(input,COMMA,FOLLOW_COMMA_in_in_modes16777); if (state.failed) return retval;
					pushFollow(FOLLOW_identifier_in_in_modes16781);
					identifier428=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, identifier428.getTree());

					}
					break;

				default :
					break loop221;
				}
			}

			RPAREN429=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_in_modes16788); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (BAST)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (BAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "in_modes"

	// $ANTLR start synpred1_BLESStoAST
	public final void synpred1_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2053:3: ( LBRACKET ID COLON )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2053:4: LBRACKET ID COLON
		{
		match(input,LBRACKET,FOLLOW_LBRACKET_in_synpred1_BLESStoAST6561); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred1_BLESStoAST6563); if (state.failed) return;

		match(input,COLON,FOLLOW_COLON_in_synpred1_BLESStoAST6565); if (state.failed) return;

		}

	}
	// $ANTLR end synpred1_BLESStoAST

	// $ANTLR start synpred2_BLESStoAST
	public final void synpred2_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:3: ( LPAREN LITERAL_if | LPAREN boolean_expression_or_relation QQ )
		int alt222=2;
		int LA222_0 = input.LA(1);
		if ( (LA222_0==LPAREN) ) {
			int LA222_1 = input.LA(2);
			if ( (LA222_1==LITERAL_if) ) {
				alt222=1;
			}
			else if ( (LA222_1==AADL_STRING_LITERAL||LA222_1==ID||LA222_1==INTEGER_LIT||LA222_1==LBRACKET||LA222_1==LITERAL_complex||LA222_1==LITERAL_false||LA222_1==LITERAL_in||LA222_1==LITERAL_integer||LA222_1==LITERAL_natural||(LA222_1 >= LITERAL_not && LA222_1 <= LITERAL_now)||LA222_1==LITERAL_null||(LA222_1 >= LITERAL_rational && LA222_1 <= LITERAL_real)||LA222_1==LITERAL_self||(LA222_1 >= LITERAL_time && LA222_1 <= LITERAL_timeout)||LA222_1==LITERAL_tops||LA222_1==LITERAL_true||LA222_1==LPAREN||LA222_1==MINUS||LA222_1==OCTOTHORPE||LA222_1==REAL_LIT) ) {
				alt222=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 222, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 222, 0, input);
			throw nvae;
		}

		switch (alt222) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred2_BLESStoAST9509); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred2_BLESStoAST9511); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2485:24: LPAREN boolean_expression_or_relation QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred2_BLESStoAST9515); if (state.failed) return;

				pushFollow(FOLLOW_boolean_expression_or_relation_in_synpred2_BLESStoAST9517);
				boolean_expression_or_relation();
				state._fsp--;
				if (state.failed) return;

				match(input,QQ,FOLLOW_QQ_in_synpred2_BLESStoAST9519); if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred2_BLESStoAST

	// $ANTLR start synpred3_BLESStoAST
	public final void synpred3_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2489:3: ( LPAREN case_choice )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2489:4: LPAREN case_choice
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred3_BLESStoAST9547); if (state.failed) return;

		pushFollow(FOLLOW_case_choice_in_synpred3_BLESStoAST9549);
		case_choice();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred3_BLESStoAST

	// $ANTLR start synpred4_BLESStoAST
	public final void synpred4_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:3: ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:4: port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		{
		pushFollow(FOLLOW_port_name_in_synpred4_BLESStoAST9854);
		port_name();
		state._fsp--;
		if (state.failed) return;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:14: ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated )
		int alt223=4;
		int LA223_0 = input.LA(1);
		if ( (LA223_0==QUESTION) ) {
			alt223=1;
		}
		else if ( (LA223_0==TICK) ) {
			switch ( input.LA(2) ) {
			case LITERAL_fresh:
				{
				alt223=2;
				}
				break;
			case LITERAL_count:
				{
				alt223=3;
				}
				break;
			case LITERAL_updated:
				{
				alt223=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 223, 2, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 223, 0, input);
			throw nvae;
		}

		switch (alt223) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:16: QUESTION
				{
				match(input,QUESTION,FOLLOW_QUESTION_in_synpred4_BLESStoAST9858); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:27: TICK LITERAL_fresh
				{
				match(input,TICK,FOLLOW_TICK_in_synpred4_BLESStoAST9862); if (state.failed) return;

				match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_synpred4_BLESStoAST9864); if (state.failed) return;

				}
				break;
			case 3 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:48: TICK LITERAL_count
				{
				match(input,TICK,FOLLOW_TICK_in_synpred4_BLESStoAST9868); if (state.failed) return;

				match(input,LITERAL_count,FOLLOW_LITERAL_count_in_synpred4_BLESStoAST9870); if (state.failed) return;

				}
				break;
			case 4 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2524:68: TICK LITERAL_updated
				{
				match(input,TICK,FOLLOW_TICK_in_synpred4_BLESStoAST9873); if (state.failed) return;

				match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_synpred4_BLESStoAST9875); if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred4_BLESStoAST

	// $ANTLR start synpred5_BLESStoAST
	public final void synpred5_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2620:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2620:4: LPAREN ID ARROW
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred5_BLESStoAST10591); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred5_BLESStoAST10593); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred5_BLESStoAST10595); if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_BLESStoAST

	// $ANTLR start synpred6_BLESStoAST
	public final void synpred6_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2624:3: ( subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2624:4: subexpression relation_symbol
		{
		pushFollow(FOLLOW_subexpression_in_synpred6_BLESStoAST10623);
		subexpression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_relation_symbol_in_synpred6_BLESStoAST10625);
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred6_BLESStoAST

	// $ANTLR start synpred7_BLESStoAST
	public final void synpred7_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2639:3: ( subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2639:4: subexpression relation_symbol
		{
		pushFollow(FOLLOW_subexpression_in_synpred7_BLESStoAST10713);
		subexpression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_relation_symbol_in_synpred7_BLESStoAST10715);
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred7_BLESStoAST

	// $ANTLR start synpred8_BLESStoAST
	public final void synpred8_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2998:3: ( parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:2998:4: parenthesized_predicate IMP
		{
		pushFollow(FOLLOW_parenthesized_predicate_in_synpred8_BLESStoAST12708);
		parenthesized_predicate();
		state._fsp--;
		if (state.failed) return;

		match(input,IMP,FOLLOW_IMP_in_synpred8_BLESStoAST12710); if (state.failed) return;

		}

	}
	// $ANTLR end synpred8_BLESStoAST

	// $ANTLR start synpred9_BLESStoAST
	public final void synpred9_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3067:5: ( assertion_expression range_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3067:7: assertion_expression range_symbol
		{
		pushFollow(FOLLOW_assertion_expression_in_synpred9_BLESStoAST13099);
		assertion_expression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_range_symbol_in_synpred9_BLESStoAST13101);
		range_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred9_BLESStoAST

	// $ANTLR start synpred10_BLESStoAST
	public final void synpred10_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:3: ( assertion_subexpression relation_symbol )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3112:4: assertion_subexpression relation_symbol
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13449);
		assertion_subexpression();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_relation_symbol_in_synpred10_BLESStoAST13451);
		relation_symbol();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred10_BLESStoAST

	// $ANTLR start synpred11_BLESStoAST
	public final void synpred11_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3117:3: ( assertion_subexpression LITERAL_in )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3117:4: assertion_subexpression LITERAL_in
		{
		pushFollow(FOLLOW_assertion_subexpression_in_synpred11_BLESStoAST13530);
		assertion_subexpression();
		state._fsp--;
		if (state.failed) return;

		match(input,LITERAL_in,FOLLOW_LITERAL_in_in_synpred11_BLESStoAST13532); if (state.failed) return;

		}

	}
	// $ANTLR end synpred11_BLESStoAST

	// $ANTLR start synpred12_BLESStoAST
	public final void synpred12_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3125:3: ( name PLUS_EQUALS )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3125:4: name PLUS_EQUALS
		{
		pushFollow(FOLLOW_name_in_synpred12_BLESStoAST13611);
		name();
		state._fsp--;
		if (state.failed) return;

		match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_synpred12_BLESStoAST13613); if (state.failed) return;

		}

	}
	// $ANTLR end synpred12_BLESStoAST

	// $ANTLR start synpred13_BLESStoAST
	public final void synpred13_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3139:5: ( ID LPAREN )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3139:6: ID LPAREN
		{
		match(input,ID,FOLLOW_ID_in_synpred13_BLESStoAST13783); if (state.failed) return;

		match(input,LPAREN,FOLLOW_LPAREN_in_synpred13_BLESStoAST13785); if (state.failed) return;

		}

	}
	// $ANTLR end synpred13_BLESStoAST

	// $ANTLR start synpred17_BLESStoAST
	public final void synpred17_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3453:3: ( LPAREN LITERAL_if | LPAREN predicate QQ )
		int alt227=2;
		int LA227_0 = input.LA(1);
		if ( (LA227_0==LPAREN) ) {
			int LA227_1 = input.LA(2);
			if ( (LA227_1==LITERAL_if) ) {
				alt227=1;
			}
			else if ( (LA227_1==AADL_STRING_LITERAL||LA227_1==ID||LA227_1==INTEGER_LIT||LA227_1==LBRACKET||LA227_1==LITERAL_abs||LA227_1==LITERAL_all||LA227_1==LITERAL_complex||LA227_1==LITERAL_def||LA227_1==LITERAL_exists||LA227_1==LITERAL_false||LA227_1==LITERAL_in||LA227_1==LITERAL_integer||LA227_1==LITERAL_natural||(LA227_1 >= LITERAL_not && LA227_1 <= LITERAL_now)||LA227_1==LITERAL_null||(LA227_1 >= LITERAL_rational && LA227_1 <= LITERAL_real)||LA227_1==LITERAL_self||LA227_1==LITERAL_stop||(LA227_1 >= LITERAL_time && LA227_1 <= LITERAL_timeout)||LA227_1==LITERAL_tops||LA227_1==LITERAL_true||LA227_1==LPAREN||LA227_1==MINUS||LA227_1==OCTOTHORPE||LA227_1==REAL_LIT) ) {
				alt227=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 227, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 227, 0, input);
			throw nvae;
		}

		switch (alt227) {
			case 1 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3453:4: LPAREN LITERAL_if
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred17_BLESStoAST15831); if (state.failed) return;

				match(input,LITERAL_if,FOLLOW_LITERAL_if_in_synpred17_BLESStoAST15833); if (state.failed) return;

				}
				break;
			case 2 :
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3453:24: LPAREN predicate QQ
				{
				match(input,LPAREN,FOLLOW_LPAREN_in_synpred17_BLESStoAST15837); if (state.failed) return;

				pushFollow(FOLLOW_predicate_in_synpred17_BLESStoAST15839);
				predicate();
				state._fsp--;
				if (state.failed) return;

				match(input,QQ,FOLLOW_QQ_in_synpred17_BLESStoAST15841); if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred17_BLESStoAST

	// $ANTLR start synpred18_BLESStoAST
	public final void synpred18_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3457:3: ( LPAREN ID ARROW )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3457:4: LPAREN ID ARROW
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred18_BLESStoAST15867); if (state.failed) return;

		match(input,ID,FOLLOW_ID_in_synpred18_BLESStoAST15869); if (state.failed) return;

		match(input,ARROW,FOLLOW_ARROW_in_synpred18_BLESStoAST15871); if (state.failed) return;

		}

	}
	// $ANTLR end synpred18_BLESStoAST

	// $ANTLR start synpred19_BLESStoAST
	public final void synpred19_BLESStoAST_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3461:3: ( LPAREN parenthesized_predicate IMP )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/BLESStoAST.g:3461:4: LPAREN parenthesized_predicate IMP
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred19_BLESStoAST15901); if (state.failed) return;

		pushFollow(FOLLOW_parenthesized_predicate_in_synpred19_BLESStoAST15903);
		parenthesized_predicate();
		state._fsp--;
		if (state.failed) return;

		match(input,IMP,FOLLOW_IMP_in_synpred19_BLESStoAST15905); if (state.failed) return;

		}

	}
	// $ANTLR end synpred19_BLESStoAST

	// Delegated rules

	public final boolean synpred3_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred11_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred11_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred8_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred8_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred6_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred6_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred13_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred13_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred19_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred19_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred17_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred17_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred9_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred9_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred7_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred7_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred12_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred12_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred10_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred10_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred18_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred18_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred5_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_BLESStoAST() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_BLESStoAST_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA55 dfa55 = new DFA55(this);
	protected DFA63 dfa63 = new DFA63(this);
	protected DFA99 dfa99 = new DFA99(this);
	protected DFA118 dfa118 = new DFA118(this);
	protected DFA162 dfa162 = new DFA162(this);
	static final String DFA55_eotS =
		"\22\uffff";
	static final String DFA55_eofS =
		"\22\uffff";
	static final String DFA55_minS =
		"\1\77\1\uffff\1\21\7\uffff\1\4\1\77\1\uffff\1\37\2\21\1\77\1\21";
	static final String DFA55_maxS =
		"\1\u00f6\1\uffff\1\u0124\7\uffff\1\u0116\1\77\1\uffff\1\u0126\2\u0124"+
		"\1\77\1\u0124";
	static final String DFA55_acceptS =
		"\1\uffff\1\1\1\uffff\1\3\1\4\1\5\1\6\1\7\1\10\1\11\2\uffff\1\2\5\uffff";
	static final String DFA55_specialS =
		"\22\uffff}>";
	static final String[] DFA55_transitionS = {
			"\1\2\60\uffff\1\4\20\uffff\1\11\5\uffff\4\7\53\uffff\1\3\32\uffff\1\5"+
			"\1\uffff\1\1\10\uffff\1\7\25\uffff\1\6\3\uffff\1\10",
			"",
			"\1\14\43\uffff\1\3\27\uffff\1\12\u00a8\uffff\1\3\14\uffff\1\13\14\uffff"+
			"\1\3\23\uffff\1\14",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\14\72\uffff\1\14\3\uffff\1\15\11\uffff\1\14\40\uffff\1\14\25\uffff"+
			"\1\14\24\uffff\1\14\2\uffff\1\14\13\uffff\1\14\2\uffff\2\14\1\uffff\1"+
			"\14\27\uffff\2\14\6\uffff\1\14\23\uffff\2\14\1\uffff\1\14\2\uffff\1\14"+
			"\15\uffff\1\14\3\uffff\1\14\3\uffff\1\14\27\uffff\1\14",
			"\1\16",
			"",
			"\2\14\11\uffff\1\14\1\uffff\2\14\10\uffff\1\14\46\uffff\1\14\14\uffff"+
			"\1\14\11\uffff\1\14\57\uffff\1\14\15\uffff\1\14\27\uffff\1\14\52\uffff"+
			"\1\14\4\uffff\1\14\11\uffff\1\14\16\uffff\1\17\22\uffff\1\14",
			"\1\14\43\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\14\43\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\14\14\uffff\1\3\23\uffff"+
			"\1\14",
			"\1\21",
			"\1\14\43\uffff\1\3\27\uffff\1\14\u00b5\uffff\1\20\14\uffff\1\3\23\uffff"+
			"\1\14"
	};

	static final short[] DFA55_eot = DFA.unpackEncodedString(DFA55_eotS);
	static final short[] DFA55_eof = DFA.unpackEncodedString(DFA55_eofS);
	static final char[] DFA55_min = DFA.unpackEncodedStringToUnsignedChars(DFA55_minS);
	static final char[] DFA55_max = DFA.unpackEncodedStringToUnsignedChars(DFA55_maxS);
	static final short[] DFA55_accept = DFA.unpackEncodedString(DFA55_acceptS);
	static final short[] DFA55_special = DFA.unpackEncodedString(DFA55_specialS);
	static final short[][] DFA55_transition;

	static {
		int numStates = DFA55_transitionS.length;
		DFA55_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA55_transition[i] = DFA.unpackEncodedString(DFA55_transitionS[i]);
		}
	}

	protected class DFA55 extends DFA {

		public DFA55(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 55;
			this.eot = DFA55_eot;
			this.eof = DFA55_eof;
			this.min = DFA55_min;
			this.max = DFA55_max;
			this.accept = DFA55_accept;
			this.special = DFA55_special;
			this.transition = DFA55_transition;
		}
		@Override
		public String getDescription() {
			return "2019:1: basic_action : ( LITERAL_skip | assignment | communication_action | computation_action | LITERAL_setmode identifier | when_throw | combinable_operation | simultaneous_assignment | issue_exception );";
		}
	}

	static final String DFA63_eotS =
		"\15\uffff";
	static final String DFA63_eofS =
		"\15\uffff";
	static final String DFA63_minS =
		"\1\77\1\65\2\uffff\1\77\1\uffff\1\103\1\uffff\1\65\1\u0113\1\77\2\65";
	static final String DFA63_maxS =
		"\1\u00b6\1\u0110\2\uffff\1\77\1\uffff\1\103\1\uffff\1\u0110\1\u0113\1"+
		"\77\2\u0110";
	static final String DFA63_acceptS =
		"\2\uffff\1\4\1\1\1\uffff\1\2\1\uffff\1\3\5\uffff";
	static final String DFA63_specialS =
		"\15\uffff}>";
	static final String[] DFA63_transitionS = {
			"\1\1\166\uffff\1\2",
			"\1\5\27\uffff\1\6\u00a8\uffff\1\3\14\uffff\1\4\14\uffff\1\7",
			"",
			"",
			"\1\10",
			"",
			"\1\11",
			"",
			"\1\5\u00cd\uffff\1\12\14\uffff\1\7",
			"\1\13",
			"\1\14",
			"\1\5\u00da\uffff\1\7",
			"\1\5\u00cd\uffff\1\12\14\uffff\1\7"
	};

	static final short[] DFA63_eot = DFA.unpackEncodedString(DFA63_eotS);
	static final short[] DFA63_eof = DFA.unpackEncodedString(DFA63_eofS);
	static final char[] DFA63_min = DFA.unpackEncodedStringToUnsignedChars(DFA63_minS);
	static final char[] DFA63_max = DFA.unpackEncodedStringToUnsignedChars(DFA63_maxS);
	static final short[] DFA63_accept = DFA.unpackEncodedString(DFA63_acceptS);
	static final short[] DFA63_special = DFA.unpackEncodedString(DFA63_specialS);
	static final short[][] DFA63_transition;

	static {
		int numStates = DFA63_transitionS.length;
		DFA63_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA63_transition[i] = DFA.unpackEncodedString(DFA63_transitionS[i]);
		}
	}

	protected class DFA63 extends DFA {

		public DFA63(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 63;
			this.eot = DFA63_eot;
			this.eof = DFA63_eof;
			this.min = DFA63_min;
			this.max = DFA63_max;
			this.accept = DFA63_accept;
			this.special = DFA63_special;
			this.transition = DFA63_transition;
		}
		@Override
		public String getDescription() {
			return "2127:1: communication_action : (pc= procedure_call -> $pc|po= port_output -> $po|pi= port_input -> $pi|pause= LITERAL_pause -> $pause);";
		}
	}

	static final String DFA99_eotS =
		"\13\uffff";
	static final String DFA99_eofS =
		"\2\uffff\1\1\2\uffff\1\1\5\uffff";
	static final String DFA99_minS =
		"\1\4\1\uffff\1\7\1\uffff\1\77\1\7\2\77\1\34\1\uffff\1\56";
	static final String DFA99_maxS =
		"\1\u0116\1\uffff\1\u0126\1\uffff\1\77\1\u0126\1\u0118\1\77\1\u0124\1\uffff"+
		"\1\u0103";
	static final String DFA99_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\5\uffff\1\3\1\uffff";
	static final String DFA99_specialS =
		"\13\uffff}>";
	static final String[] DFA99_transitionS = {
			"\1\1\72\uffff\1\2\3\uffff\1\1\11\uffff\1\1\40\uffff\1\3\25\uffff\1\1"+
			"\24\uffff\1\1\2\uffff\1\3\13\uffff\1\3\2\uffff\2\1\1\uffff\1\1\27\uffff"+
			"\2\3\6\uffff\1\1\23\uffff\1\3\1\1\1\uffff\1\1\2\uffff\1\1\15\uffff\1"+
			"\1\3\uffff\1\1\3\uffff\1\1\27\uffff\1\1",
			"",
			"\3\1\17\uffff\1\1\2\uffff\1\1\1\uffff\3\1\11\uffff\1\1\1\uffff\2\1\1"+
			"\4\5\uffff\1\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\2\1\1\uffff"+
			"\1\1\15\uffff\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4"+
			"\uffff\2\1\3\uffff\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1"+
			"\1\5\uffff\2\1\2\uffff\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff"+
			"\1\1\6\uffff\1\1\2\uffff\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff"+
			"\1\1\13\uffff\1\1\2\uffff\1\1\3\uffff\2\1\1\uffff\3\1\2\uffff\1\1\1\uffff"+
			"\1\1\1\uffff\1\1\4\uffff\2\1\12\uffff\2\1\2\uffff\3\1\2\uffff\1\1\1\uffff"+
			"\1\1\11\uffff\1\1\1\uffff\1\1",
			"",
			"\1\5",
			"\3\1\17\uffff\1\1\2\uffff\1\1\1\uffff\3\1\11\uffff\1\1\1\uffff\2\1\1"+
			"\7\5\uffff\1\1\1\uffff\1\1\5\uffff\2\1\1\uffff\1\1\14\uffff\1\1\2\uffff"+
			"\1\1\15\uffff\1\1\14\uffff\1\1\5\uffff\1\1\3\uffff\1\1\2\uffff\1\1\4"+
			"\uffff\2\1\3\uffff\1\1\5\uffff\5\1\3\uffff\2\1\3\uffff\2\1\7\uffff\1"+
			"\1\5\uffff\2\1\2\uffff\1\1\5\uffff\1\1\4\uffff\1\1\3\uffff\1\1\14\uffff"+
			"\1\1\6\uffff\1\1\2\uffff\1\1\3\uffff\1\1\1\uffff\1\1\10\uffff\1\1\2\uffff"+
			"\1\1\13\uffff\1\1\2\uffff\1\1\3\uffff\2\1\1\uffff\1\1\1\6\1\1\2\uffff"+
			"\1\1\1\uffff\1\1\1\uffff\1\1\4\uffff\2\1\12\uffff\1\1\3\uffff\3\1\2\uffff"+
			"\1\1\1\uffff\1\1\13\uffff\1\1",
			"\1\10\u00d8\uffff\1\11",
			"\1\12",
			"\1\11\1\uffff\1\1\56\uffff\1\1\u00b5\uffff\1\1\40\uffff\1\1",
			"",
			"\1\7\u00c7\uffff\1\11\7\uffff\1\1\4\uffff\1\1"
	};

	static final short[] DFA99_eot = DFA.unpackEncodedString(DFA99_eotS);
	static final short[] DFA99_eof = DFA.unpackEncodedString(DFA99_eofS);
	static final char[] DFA99_min = DFA.unpackEncodedStringToUnsignedChars(DFA99_minS);
	static final char[] DFA99_max = DFA.unpackEncodedStringToUnsignedChars(DFA99_maxS);
	static final short[] DFA99_accept = DFA.unpackEncodedString(DFA99_acceptS);
	static final short[] DFA99_special = DFA.unpackEncodedString(DFA99_specialS);
	static final short[][] DFA99_transition;

	static {
		int numStates = DFA99_transitionS.length;
		DFA99_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA99_transition[i] = DFA.unpackEncodedString(DFA99_transitionS[i]);
		}
	}

	protected class DFA99 extends DFA {

		public DFA99(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 99;
			this.eot = DFA99_eot;
			this.eof = DFA99_eof;
			this.min = DFA99_min;
			this.max = DFA99_max;
			this.accept = DFA99_accept;
			this.special = DFA99_special;
			this.transition = DFA99_transition;
		}
		@Override
		public String getDescription() {
			return "2355:1: subexpression : ( (m= MINUS |n= LITERAL_not )? (v= value |ps= parenthesized_subexpression ) -> {m!=null&&v!=null}? ^( UNARY_MINUS[$m] $v) -> {m!=null&&ps!=null}? ^( UNARY_MINUS[$m] $ps) -> {n!=null&&v!=null}? ^( $n $v) -> {n!=null&&ps!=null}? ^( $n $ps) -> {v!=null}? $v -> $ps|tc= type_conversion -> $tc|fc= function_call -> $fc);";
		}
	}

	static final String DFA118_eotS =
		"\26\uffff";
	static final String DFA118_eofS =
		"\2\uffff\1\14\6\uffff\1\14\3\uffff\1\14\5\uffff\3\14";
	static final String DFA118_minS =
		"\1\4\1\uffff\1\7\5\uffff\1\77\1\7\1\uffff\1\4\1\uffff\1\7\3\uffff\1\37"+
		"\1\77\3\7";
	static final String DFA118_maxS =
		"\1\u0116\1\uffff\1\u0126\5\uffff\1\77\1\u0126\1\uffff\1\u0116\1\uffff"+
		"\1\u0126\3\uffff\1\u0126\1\77\3\u0126";
	static final String DFA118_acceptS =
		"\1\uffff\1\1\1\uffff\1\4\1\5\1\6\1\7\1\10\2\uffff\1\2\1\uffff\1\3\1\uffff"+
		"\3\2\5\uffff";
	static final String DFA118_specialS =
		"\2\uffff\1\2\6\uffff\1\4\3\uffff\1\5\5\uffff\1\0\1\3\1\1}>";
	static final String[] DFA118_transitionS = {
			"\1\1\72\uffff\1\2\3\uffff\1\1\11\uffff\1\1\66\uffff\1\1\24\uffff\1\3"+
			"\22\uffff\1\6\1\uffff\1\5\37\uffff\1\1\24\uffff\1\4\1\uffff\1\7\2\uffff"+
			"\1\1\25\uffff\1\1\27\uffff\1\1",
			"",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\1\1\5\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2"+
			"\14\13\uffff\1\14\1\13\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff"+
			"\1\14\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14"+
			"\5\uffff\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\2\14\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14"+
			"\14\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10"+
			"\uffff\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff"+
			"\3\14\2\uffff\1\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\10\1\14\12\uffff"+
			"\1\14\1\12\1\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\11"+
			"\1\uffff\1\14",
			"",
			"",
			"",
			"",
			"",
			"\1\15",
			"\2\14\1\uffff\1\14\21\uffff\1\14\1\uffff\3\14\11\uffff\1\14\1\uffff"+
			"\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\1\14\2\uffff\1\1\1\14\34\uffff"+
			"\1\14\3\uffff\1\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1"+
			"\14\1\uffff\2\14\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1"+
			"\14\23\uffff\2\14\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1"+
			"\14\1\uffff\1\14\7\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14"+
			"\15\uffff\1\14",
			"",
			"\1\14\72\uffff\1\14\3\uffff\1\21\11\uffff\1\14\40\uffff\1\14\25\uffff"+
			"\1\14\24\uffff\1\14\2\uffff\1\14\13\uffff\1\14\2\uffff\2\14\1\uffff\1"+
			"\14\27\uffff\2\14\6\uffff\1\14\23\uffff\2\14\1\uffff\1\14\2\uffff\1\14"+
			"\15\uffff\1\14\3\uffff\1\14\3\uffff\1\14\27\uffff\1\14",
			"",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14"+
			"\13\uffff\2\14\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14"+
			"\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14"+
			"\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14"+
			"\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff"+
			"\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\1\uffff\1\1\4\uffff\1\22\1\14\12\uffff"+
			"\1\14\1\12\1\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23"+
			"\1\uffff\1\14",
			"",
			"",
			"",
			"\2\14\11\uffff\1\14\1\uffff\2\14\10\uffff\1\14\46\uffff\1\14\14\uffff"+
			"\1\14\11\uffff\1\14\57\uffff\1\14\15\uffff\1\14\27\uffff\1\14\52\uffff"+
			"\1\14\4\uffff\1\14\11\uffff\1\14\16\uffff\1\24\22\uffff\1\14",
			"\1\25",
			"\2\14\1\uffff\1\14\21\uffff\1\14\1\uffff\3\14\11\uffff\1\14\1\uffff"+
			"\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\1\14\3\uffff\1\14\34\uffff\1"+
			"\14\3\uffff\1\14\23\uffff\1\17\7\uffff\1\14\23\uffff\1\16\4\uffff\1\14"+
			"\1\uffff\2\14\12\uffff\1\14\13\uffff\1\14\1\uffff\1\14\27\uffff\1\14"+
			"\23\uffff\2\14\14\uffff\1\20\10\uffff\1\14\1\uffff\1\14\2\uffff\1\14"+
			"\1\uffff\1\14\7\uffff\1\14\12\uffff\1\14\1\uffff\1\14\6\uffff\1\14\15"+
			"\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14"+
			"\13\uffff\2\14\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14"+
			"\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14"+
			"\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14"+
			"\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff"+
			"\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\6\uffff\2\14\12\uffff\1\14\1\12\1\14\1"+
			"\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14",
			"\4\14\7\uffff\1\14\6\uffff\2\14\1\uffff\1\14\1\uffff\3\14\11\uffff\1"+
			"\14\1\uffff\2\14\6\uffff\1\14\1\uffff\1\14\5\uffff\2\14\1\uffff\2\14"+
			"\13\uffff\2\14\1\uffff\1\14\15\uffff\1\14\3\uffff\1\14\10\uffff\1\14"+
			"\5\uffff\1\14\3\uffff\1\14\2\uffff\1\14\4\uffff\2\14\3\uffff\1\14\5\uffff"+
			"\5\14\3\uffff\2\14\3\uffff\3\14\1\uffff\2\14\3\uffff\1\14\5\uffff\2\14"+
			"\2\uffff\1\14\5\uffff\1\14\2\uffff\1\14\1\uffff\1\14\3\uffff\1\14\14"+
			"\uffff\1\14\6\uffff\1\14\2\uffff\1\14\3\uffff\1\14\1\uffff\1\14\10\uffff"+
			"\1\14\1\uffff\2\14\13\uffff\1\14\2\uffff\1\14\3\uffff\2\14\1\uffff\3"+
			"\14\2\uffff\1\14\1\uffff\1\14\6\uffff\1\22\1\14\12\uffff\1\14\1\12\1"+
			"\14\1\uffff\3\14\2\uffff\1\14\1\uffff\1\14\11\uffff\1\23\1\uffff\1\14"
	};

	static final short[] DFA118_eot = DFA.unpackEncodedString(DFA118_eotS);
	static final short[] DFA118_eof = DFA.unpackEncodedString(DFA118_eofS);
	static final char[] DFA118_min = DFA.unpackEncodedStringToUnsignedChars(DFA118_minS);
	static final char[] DFA118_max = DFA.unpackEncodedStringToUnsignedChars(DFA118_maxS);
	static final short[] DFA118_accept = DFA.unpackEncodedString(DFA118_acceptS);
	static final short[] DFA118_special = DFA.unpackEncodedString(DFA118_specialS);
	static final short[][] DFA118_transition;

	static {
		int numStates = DFA118_transitionS.length;
		DFA118_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA118_transition[i] = DFA.unpackEncodedString(DFA118_transitionS[i]);
		}
	}

	protected class DFA118 extends DFA {

		public DFA118(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 118;
			this.eot = DFA118_eot;
			this.eof = DFA118_eof;
			this.min = DFA118_min;
			this.max = DFA118_max;
			this.accept = DFA118_accept;
			this.special = DFA118_special;
			this.transition = DFA118_transition;
		}
		@Override
		public String getDescription() {
			return "2518:1: value : (vc= value_constant -> $vc| ( port_name ( QUESTION | TICK LITERAL_fresh | TICK LITERAL_count | TICK LITERAL_updated ) )=>pn= port_name (q= QUESTION |tf= TICK f= LITERAL_fresh |tc= TICK c= LITERAL_count |tc= TICK u= LITERAL_updated ) -> {$f!=null}? ^( $tf $pn $f) -> {$c!=null}? ^( $tc $pn $c) -> {$u!=null}? ^( $tc $pn $u) -> ^( $q $pn) |nam= name -> $nam|li= LITERAL_in 'mode' LPAREN (i+= identifier )+ RPAREN -> ^( INMODE[$li,\"in mode\"] ( $i)+ ) |timeout= LITERAL_timeout -> $timeout|nu= LITERAL_null -> $nu|now= LITERAL_now -> $now|tops= LITERAL_tops -> $tops);";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA118_19 = input.LA(1);
						 
						int index118_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_19==LITERAL_fresh) && (synpred4_BLESStoAST())) {s = 14;}
						else if ( (LA118_19==LITERAL_count) && (synpred4_BLESStoAST())) {s = 15;}
						else if ( (LA118_19==LITERAL_updated) && (synpred4_BLESStoAST())) {s = 16;}
						else if ( (LA118_19==EOF||(LA118_19 >= AL && LA118_19 <= AM)||LA118_19==ANNEX_END||LA118_19==COLON||(LA118_19 >= COMMA && LA118_19 <= COMMADOT)||LA118_19==DIVIDE||(LA118_19 >= DOTCOMMA && LA118_19 <= DOTDOT)||LA118_19==EQ||LA118_19==EXP||LA118_19==GT||LA118_19==IMP||LA118_19==LITERAL_and||LA118_19==LITERAL_are||LA118_19==LITERAL_else||LA118_19==LITERAL_iff||(LA118_19 >= LITERAL_implies && LA118_19 <= LITERAL_in)||LA118_19==LITERAL_mod||LA118_19==LITERAL_of||LA118_19==LITERAL_or||LA118_19==LITERAL_rem||(LA118_19 >= LITERAL_that && LA118_19 <= LITERAL_then)||LA118_19==LITERAL_xor||LA118_19==LT||LA118_19==MINUS||LA118_19==NEQ||LA118_19==PLUS||LA118_19==QQ||LA118_19==RASS||LA118_19==RPAREN||LA118_19==TIMES) ) {s = 12;}
						 
						input.seek(index118_19);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA118_21 = input.LA(1);
						 
						int index118_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_21==QUESTION) && (synpred4_BLESStoAST())) {s = 10;}
						else if ( (LA118_21==TICK) ) {s = 19;}
						else if ( (LA118_21==PERIOD) ) {s = 18;}
						else if ( (LA118_21==EOF||(LA118_21 >= AL && LA118_21 <= ANNEX_END)||LA118_21==AT_SIGN||(LA118_21 >= BOX && LA118_21 <= CARET)||LA118_21==COLON||(LA118_21 >= COMMA && LA118_21 <= COMMADOT)||LA118_21==DIVIDE||(LA118_21 >= DOTCOMMA && LA118_21 <= DOTDOT)||LA118_21==EQ||LA118_21==EXP||(LA118_21 >= GT && LA118_21 <= GUARD)||(LA118_21 >= ID && LA118_21 <= IMP)||(LA118_21 >= LASS && LA118_21 <= LBRACKET)||LA118_21==LCURLY||LA118_21==LITERAL_and||LA118_21==LITERAL_are||LA118_21==LITERAL_cand||LA118_21==LITERAL_computation||LA118_21==LITERAL_cor||LA118_21==LITERAL_declare||(LA118_21 >= LITERAL_do && LA118_21 <= LITERAL_else)||LA118_21==LITERAL_exception||(LA118_21 >= LITERAL_fetchadd && LA118_21 <= LITERAL_fi)||(LA118_21 >= LITERAL_for && LA118_21 <= LITERAL_forall)||(LA118_21 >= LITERAL_hr && LA118_21 <= LITERAL_iff)||(LA118_21 >= LITERAL_implies && LA118_21 <= LITERAL_in)||LA118_21==LITERAL_invariant||(LA118_21 >= LITERAL_min && LA118_21 <= LITERAL_mod)||LA118_21==LITERAL_ms||LA118_21==LITERAL_ns||LA118_21==LITERAL_of||LA118_21==LITERAL_or||LA118_21==LITERAL_pause||LA118_21==LITERAL_ps||LA118_21==LITERAL_rem||LA118_21==LITERAL_sec||LA118_21==LITERAL_setmode||LA118_21==LITERAL_skip||LA118_21==LITERAL_swap||(LA118_21 >= LITERAL_that && LA118_21 <= LITERAL_then)||LA118_21==LITERAL_until||LA118_21==LITERAL_us||(LA118_21 >= LITERAL_when && LA118_21 <= LITERAL_while)||(LA118_21 >= LITERAL_xor && LA118_21 <= LT)||LA118_21==MINUS||LA118_21==NEQ||LA118_21==PLUS||LA118_21==QQ||LA118_21==RASS||(LA118_21 >= RBRACKET && LA118_21 <= RCURLY)||LA118_21==RPAREN||LA118_21==SEMICOLON||LA118_21==TIMES) ) {s = 12;}
						 
						input.seek(index118_21);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA118_2 = input.LA(1);
						 
						int index118_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_2==DOUBLE_COLON||LA118_2==OCTOTHORPE) ) {s = 1;}
						else if ( (LA118_2==PERIOD) ) {s = 8;}
						else if ( (LA118_2==TICK) ) {s = 9;}
						else if ( (LA118_2==QUESTION) && (synpred4_BLESStoAST())) {s = 10;}
						else if ( (LA118_2==LBRACKET) ) {s = 11;}
						else if ( (LA118_2==EOF||(LA118_2 >= AL && LA118_2 <= ANNEX_END)||LA118_2==AT_SIGN||(LA118_2 >= BOX && LA118_2 <= CARET)||LA118_2==COLON||(LA118_2 >= COMMA && LA118_2 <= COMMADOT)||LA118_2==DIVIDE||(LA118_2 >= DOTCOMMA && LA118_2 <= DOTDOT)||LA118_2==EQ||LA118_2==EXP||(LA118_2 >= GT && LA118_2 <= GUARD)||(LA118_2 >= ID && LA118_2 <= IMP)||LA118_2==LASS||LA118_2==LCURLY||LA118_2==LITERAL_and||LA118_2==LITERAL_are||LA118_2==LITERAL_cand||LA118_2==LITERAL_computation||LA118_2==LITERAL_cor||LA118_2==LITERAL_declare||(LA118_2 >= LITERAL_do && LA118_2 <= LITERAL_else)||LA118_2==LITERAL_exception||(LA118_2 >= LITERAL_fetchadd && LA118_2 <= LITERAL_fi)||(LA118_2 >= LITERAL_for && LA118_2 <= LITERAL_forall)||(LA118_2 >= LITERAL_hr && LA118_2 <= LITERAL_iff)||(LA118_2 >= LITERAL_implies && LA118_2 <= LITERAL_in)||LA118_2==LITERAL_invariant||(LA118_2 >= LITERAL_min && LA118_2 <= LITERAL_mod)||LA118_2==LITERAL_ms||LA118_2==LITERAL_ns||LA118_2==LITERAL_of||LA118_2==LITERAL_or||LA118_2==LITERAL_pause||LA118_2==LITERAL_ps||LA118_2==LITERAL_rem||LA118_2==LITERAL_sec||LA118_2==LITERAL_setmode||LA118_2==LITERAL_skip||LA118_2==LITERAL_swap||(LA118_2 >= LITERAL_that && LA118_2 <= LITERAL_then)||LA118_2==LITERAL_until||LA118_2==LITERAL_us||(LA118_2 >= LITERAL_when && LA118_2 <= LITERAL_while)||(LA118_2 >= LITERAL_xor && LA118_2 <= LT)||LA118_2==MINUS||LA118_2==NEQ||LA118_2==PLUS||LA118_2==QQ||LA118_2==RASS||(LA118_2 >= RBRACKET && LA118_2 <= RCURLY)||LA118_2==RPAREN||LA118_2==SEMICOLON||LA118_2==TIMES) ) {s = 12;}
						 
						input.seek(index118_2);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA118_20 = input.LA(1);
						 
						int index118_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_20==QUESTION) && (synpred4_BLESStoAST())) {s = 10;}
						else if ( (LA118_20==TICK) ) {s = 19;}
						else if ( (LA118_20==EOF||(LA118_20 >= AL && LA118_20 <= ANNEX_END)||LA118_20==AT_SIGN||(LA118_20 >= BOX && LA118_20 <= CARET)||LA118_20==COLON||(LA118_20 >= COMMA && LA118_20 <= COMMADOT)||LA118_20==DIVIDE||(LA118_20 >= DOTCOMMA && LA118_20 <= DOTDOT)||LA118_20==EQ||LA118_20==EXP||(LA118_20 >= GT && LA118_20 <= GUARD)||(LA118_20 >= ID && LA118_20 <= IMP)||(LA118_20 >= LASS && LA118_20 <= LBRACKET)||LA118_20==LCURLY||LA118_20==LITERAL_and||LA118_20==LITERAL_are||LA118_20==LITERAL_cand||LA118_20==LITERAL_computation||LA118_20==LITERAL_cor||LA118_20==LITERAL_declare||(LA118_20 >= LITERAL_do && LA118_20 <= LITERAL_else)||LA118_20==LITERAL_exception||(LA118_20 >= LITERAL_fetchadd && LA118_20 <= LITERAL_fi)||(LA118_20 >= LITERAL_for && LA118_20 <= LITERAL_forall)||(LA118_20 >= LITERAL_hr && LA118_20 <= LITERAL_iff)||(LA118_20 >= LITERAL_implies && LA118_20 <= LITERAL_in)||LA118_20==LITERAL_invariant||(LA118_20 >= LITERAL_min && LA118_20 <= LITERAL_mod)||LA118_20==LITERAL_ms||LA118_20==LITERAL_ns||LA118_20==LITERAL_of||LA118_20==LITERAL_or||LA118_20==LITERAL_pause||LA118_20==LITERAL_ps||LA118_20==LITERAL_rem||LA118_20==LITERAL_sec||LA118_20==LITERAL_setmode||LA118_20==LITERAL_skip||LA118_20==LITERAL_swap||(LA118_20 >= LITERAL_that && LA118_20 <= LITERAL_then)||LA118_20==LITERAL_until||LA118_20==LITERAL_us||(LA118_20 >= LITERAL_when && LA118_20 <= LITERAL_while)||(LA118_20 >= LITERAL_xor && LA118_20 <= LT)||LA118_20==MINUS||LA118_20==NEQ||(LA118_20 >= PERIOD && LA118_20 <= PLUS)||LA118_20==QQ||LA118_20==RASS||(LA118_20 >= RBRACKET && LA118_20 <= RCURLY)||LA118_20==RPAREN||LA118_20==SEMICOLON||LA118_20==TIMES) ) {s = 12;}
						 
						input.seek(index118_20);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA118_9 = input.LA(1);
						 
						int index118_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_9==LITERAL_fresh) && (synpred4_BLESStoAST())) {s = 14;}
						else if ( (LA118_9==LITERAL_count) && (synpred4_BLESStoAST())) {s = 15;}
						else if ( (LA118_9==LITERAL_updated) && (synpred4_BLESStoAST())) {s = 16;}
						else if ( (LA118_9==ID) ) {s = 1;}
						else if ( (LA118_9==EOF||(LA118_9 >= AL && LA118_9 <= AM)||LA118_9==ANNEX_END||LA118_9==COLON||(LA118_9 >= COMMA && LA118_9 <= COMMADOT)||LA118_9==DIVIDE||(LA118_9 >= DOTCOMMA && LA118_9 <= DOTDOT)||LA118_9==EQ||LA118_9==EXP||LA118_9==GT||LA118_9==IMP||LA118_9==LITERAL_and||LA118_9==LITERAL_are||LA118_9==LITERAL_else||LA118_9==LITERAL_iff||(LA118_9 >= LITERAL_implies && LA118_9 <= LITERAL_in)||LA118_9==LITERAL_mod||LA118_9==LITERAL_of||LA118_9==LITERAL_or||LA118_9==LITERAL_rem||(LA118_9 >= LITERAL_that && LA118_9 <= LITERAL_then)||LA118_9==LITERAL_xor||LA118_9==LT||LA118_9==MINUS||LA118_9==NEQ||LA118_9==PLUS||LA118_9==QQ||LA118_9==RASS||LA118_9==RPAREN||LA118_9==TIMES) ) {s = 12;}
						 
						input.seek(index118_9);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA118_13 = input.LA(1);
						 
						int index118_13 = input.index();
						input.rewind();
						s = -1;
						if ( (LA118_13==OCTOTHORPE) ) {s = 1;}
						else if ( (LA118_13==PERIOD) ) {s = 18;}
						else if ( (LA118_13==QUESTION) && (synpred4_BLESStoAST())) {s = 10;}
						else if ( (LA118_13==TICK) ) {s = 19;}
						else if ( (LA118_13==EOF||(LA118_13 >= AL && LA118_13 <= ANNEX_END)||LA118_13==AT_SIGN||(LA118_13 >= BOX && LA118_13 <= CARET)||LA118_13==COLON||(LA118_13 >= COMMA && LA118_13 <= COMMADOT)||LA118_13==DIVIDE||(LA118_13 >= DOTCOMMA && LA118_13 <= DOTDOT)||LA118_13==EQ||LA118_13==EXP||(LA118_13 >= GT && LA118_13 <= GUARD)||(LA118_13 >= ID && LA118_13 <= IMP)||(LA118_13 >= LASS && LA118_13 <= LBRACKET)||LA118_13==LCURLY||LA118_13==LITERAL_and||LA118_13==LITERAL_are||LA118_13==LITERAL_cand||LA118_13==LITERAL_computation||LA118_13==LITERAL_cor||LA118_13==LITERAL_declare||(LA118_13 >= LITERAL_do && LA118_13 <= LITERAL_else)||LA118_13==LITERAL_exception||(LA118_13 >= LITERAL_fetchadd && LA118_13 <= LITERAL_fi)||(LA118_13 >= LITERAL_for && LA118_13 <= LITERAL_forall)||(LA118_13 >= LITERAL_hr && LA118_13 <= LITERAL_iff)||(LA118_13 >= LITERAL_implies && LA118_13 <= LITERAL_in)||LA118_13==LITERAL_invariant||(LA118_13 >= LITERAL_min && LA118_13 <= LITERAL_mod)||LA118_13==LITERAL_ms||LA118_13==LITERAL_ns||LA118_13==LITERAL_of||LA118_13==LITERAL_or||LA118_13==LITERAL_pause||LA118_13==LITERAL_ps||LA118_13==LITERAL_rem||LA118_13==LITERAL_sec||LA118_13==LITERAL_setmode||LA118_13==LITERAL_skip||LA118_13==LITERAL_swap||(LA118_13 >= LITERAL_that && LA118_13 <= LITERAL_then)||LA118_13==LITERAL_until||LA118_13==LITERAL_us||(LA118_13 >= LITERAL_when && LA118_13 <= LITERAL_while)||(LA118_13 >= LITERAL_xor && LA118_13 <= LT)||LA118_13==MINUS||LA118_13==NEQ||LA118_13==PLUS||LA118_13==QQ||LA118_13==RASS||(LA118_13 >= RBRACKET && LA118_13 <= RCURLY)||LA118_13==RPAREN||LA118_13==SEMICOLON||LA118_13==TIMES) ) {s = 12;}
						 
						input.seek(index118_13);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 118, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA162_eotS =
		"\32\uffff";
	static final String DFA162_eofS =
		"\32\uffff";
	static final String DFA162_minS =
		"\1\4\1\7\3\uffff\1\21\1\u0105\2\uffff\1\77\1\uffff\1\21\2\77\1\21\1\u0125"+
		"\1\77\1\21\2\77\1\21\1\u0125\1\77\1\21\1\77\1\21";
	static final String DFA162_maxS =
		"\1\u0116\1\u0124\3\uffff\1\77\1\u0125\2\uffff\1\77\1\uffff\1\56\2\77\1"+
		"\36\1\u0125\1\77\1\56\2\77\1\36\1\u0125\1\77\1\56\1\77\1\36";
	static final String DFA162_acceptS =
		"\2\uffff\1\2\1\5\1\6\2\uffff\1\3\1\4\1\uffff\1\1\17\uffff";
	static final String DFA162_specialS =
		"\32\uffff}>";
	static final String[] DFA162_transitionS = {
			"\1\4\14\uffff\1\3\55\uffff\1\1\3\uffff\1\4\11\uffff\1\4\13\uffff\1\4"+
			"\2\uffff\1\4\21\uffff\1\4\11\uffff\1\4\11\uffff\1\4\1\uffff\1\4\24\uffff"+
			"\1\4\2\uffff\1\4\13\uffff\1\4\2\uffff\2\4\1\uffff\1\4\27\uffff\2\4\6"+
			"\uffff\1\4\10\uffff\1\4\12\uffff\2\4\1\uffff\1\4\2\uffff\1\4\15\uffff"+
			"\1\4\3\uffff\1\4\3\uffff\1\4\6\uffff\1\2\20\uffff\1\4",
			"\2\4\11\uffff\1\4\7\uffff\1\4\1\uffff\1\5\21\uffff\1\4\5\uffff\1\4\7"+
			"\uffff\1\4\3\uffff\1\4\14\uffff\1\4\17\uffff\1\4\70\uffff\1\4\1\uffff"+
			"\2\4\30\uffff\1\4\102\uffff\3\4\4\uffff\1\4\1\uffff\1\4\4\uffff\1\4\2"+
			"\uffff\1\4\11\uffff\2\4\22\uffff\1\4",
			"",
			"",
			"",
			"\1\10\12\uffff\1\7\42\uffff\1\6",
			"\1\12\37\uffff\1\11",
			"",
			"",
			"\1\13",
			"",
			"\1\10\12\uffff\1\7\1\uffff\1\15\17\uffff\1\14",
			"\1\16",
			"\1\17",
			"\1\10\12\uffff\1\7\1\uffff\1\15",
			"\1\20",
			"\1\21",
			"\1\10\12\uffff\1\7\1\uffff\1\23\17\uffff\1\22",
			"\1\24",
			"\1\25",
			"\1\10\12\uffff\1\7\1\uffff\1\23",
			"\1\26",
			"\1\27",
			"\1\10\12\uffff\1\7\1\uffff\1\23\17\uffff\1\30",
			"\1\31",
			"\1\10\12\uffff\1\7\1\uffff\1\23"
	};

	static final short[] DFA162_eot = DFA.unpackEncodedString(DFA162_eotS);
	static final short[] DFA162_eof = DFA.unpackEncodedString(DFA162_eofS);
	static final char[] DFA162_min = DFA.unpackEncodedStringToUnsignedChars(DFA162_minS);
	static final char[] DFA162_max = DFA.unpackEncodedStringToUnsignedChars(DFA162_maxS);
	static final short[] DFA162_accept = DFA.unpackEncodedString(DFA162_acceptS);
	static final short[] DFA162_special = DFA.unpackEncodedString(DFA162_specialS);
	static final short[][] DFA162_transition;

	static {
		int numStates = DFA162_transitionS.length;
		DFA162_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA162_transition[i] = DFA.unpackEncodedString(DFA162_transitionS[i]);
		}
	}

	protected class DFA162 extends DFA {

		public DFA162(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 162;
			this.eot = DFA162_eot;
			this.eof = DFA162_eof;
			this.min = DFA162_min;
			this.max = DFA162_max;
			this.accept = DFA162_accept;
			this.special = DFA162_special;
			this.transition = DFA162_transition;
		}
		@Override
		public String getDescription() {
			return "2934:1: assertion_body : ( (a= identifier cln= COLON lv1= identifier ae= assertion_enumeration ) -> ^( ASSERTION_ENUMERATION[$a.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($a.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv1) $ae) |ae= assertion_enumeration -> ^( ASSERTION_ENUMERATION[$ae.tree.getToken(),\n \"ASSERTION_ENUMERATION[\"+Integer.toString($ae.tree.getLine()+startingLine)+\"]\"] $ae) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? COLON p= predicate ) -> {lv!=null}? ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $p) -> ^( ASSERTION[$p.tree.getToken(),\"ASSERTION[\"+Integer.toString($p.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $p) | (a= identifier cln= COLON (lv= formal_assertion_parameter_list )? ASSIGN e= assertion_function_value ) -> {lv!=null}? ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) ^( PARAMETERS $lv) $e) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] ^( LABEL $a) $e) | ( ASSIGN e= assertion_function_value ) -> ^( ASSERTION_FUNCTION[$e.tree.getToken(),\n \"ASSERTION_FUNCTION[\"+Integer.toString($e.tree.getLine()+startingLine)+\"]\"] $e) |p3= predicate -> ^( ASSERTION[$p3.tree.getToken(),\"ASSERTION[\"+Integer.toString($p3.tree.getLine()+startingLine)+\"]\"] $p3) );";
		}
	}

	public static final BitSet FOLLOW_LBRACKET_in_rational_literal2632 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L,0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2636 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2641 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_304_in_rational_literal2643 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L,0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal2647 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal2652 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_rational_literal2654 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_complex_literal2751 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2755 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2760 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_complex_literal2762 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal2766 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal2771 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_complex_literal2773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_identifier2927 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_annex_library_assertions3302 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_annex_library_assertions3312 = new BitSet(new long[]{0x0000000000000402L,0x0000000000001000L});
	public static final BitSet FOLLOW_ANNEX_END_in_annex_library_assertions3332 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_thread_behavior4007 = new BitSet(new long[]{0x0001000000000000L,0x0000001800000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_thread_behavior4014 = new BitSet(new long[]{0x0000000000000000L,0x0000001800000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_availability_in_thread_behavior4021 = new BitSet(new long[]{0x0000000000000000L,0x0000000800000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_assert_clause_in_thread_behavior4028 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_invariant_clause_in_thread_behavior4035 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000800000400000L});
	public static final BitSet FOLLOW_variables_in_thread_behavior4042 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_LITERAL_states_in_thread_behavior4049 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_state_in_thread_behavior4055 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000008000000000L});
	public static final BitSet FOLLOW_transitions_in_thread_behavior4064 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_thread_behavior4068 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_assert_in_assert_clause4157 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_assert_clause4161 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_invariant_clause4205 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_invariant_clause4209 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variables_in_variables4252 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_variables4258 = new BitSet(new long[]{0x8000000000000002L});
	public static final BitSet FOLLOW_LITERAL_declare_in_quantified_variables4310 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_variable_in_quantified_variables4316 = new BitSet(new long[]{0x8000000000000002L});
	public static final BitSet FOLLOW_declarators_in_behavior_variable4376 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_variable4380 = new BitSet(new long[]{0x8000000000000000L,0x8008402400000000L,0x0000050010001000L,0x00010004011401C0L});
	public static final BitSet FOLLOW_LITERAL_nonvolatile_in_behavior_variable4389 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_shared_in_behavior_variable4395 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_constant_in_behavior_variable4401 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_spread_in_behavior_variable4407 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_variable4415 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_type_in_behavior_variable4425 = new BitSet(new long[]{0x0000000000020000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_ASSIGN_in_behavior_variable4431 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_behavior_variable4435 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_variable4445 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_variable4454 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_declarators4591 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_declarators4596 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_declarators4601 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_state4685 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_state4690 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L,0x0000000008001000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_initial_in_behavior_state4695 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_complete_in_behavior_state4701 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_state4707 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_state_in_behavior_state4713 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_state4717 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_state4720 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_transitions_in_transitions4780 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_behavior_transition_in_transitions4784 = new BitSet(new long[]{0x8000000000000002L});
	public static final BitSet FOLLOW_behavior_transition_label_in_behavior_transition4831 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_behavior_transition4833 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4843 = new BitSet(new long[]{0x0000000040000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_COMMA_in_behavior_transition4847 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4852 = new BitSet(new long[]{0x0000000040000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_LCON_in_behavior_transition4861 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0002590012000010L,0x4440012C000040C0L,0x0000000000500000L});
	public static final BitSet FOLLOW_behavior_condition_in_behavior_transition4865 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
	public static final BitSet FOLLOW_RCON_in_behavior_transition4868 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition4875 = new BitSet(new long[]{0x0004000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_LCURLY_in_behavior_transition4882 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_behavior_transition4886 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_behavior_transition4888 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_EMPTY_CURLY_in_behavior_transition4892 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_assertion_in_behavior_transition4900 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_transition4905 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_behavior_transition_label5069 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_behavior_transition_label5073 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_behavior_transition_label5077 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_behavior_transition_label5079 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_condition_in_behavior_condition5117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_execute_condition_in_behavior_condition5121 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_mode_condition_in_behavior_condition5125 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_or_relation_in_execute_condition5143 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_mode_condition5159 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_mode_condition5162 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5180 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5186 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5190 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_logical_operator_in_trigger_logical_expression5200 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression5204 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5275 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5277 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5284 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger5286 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_event_trigger5296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_event_trigger5302 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_event_trigger5305 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_event_trigger5307 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_subprogram_behavior5369 = new BitSet(new long[]{0x0001000000000000L,0x0080000800008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_subprogram_behavior5376 = new BitSet(new long[]{0x0000000000000000L,0x0080000800008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_assert_clause_in_subprogram_behavior5384 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_LITERAL_pre_in_subprogram_behavior5393 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5397 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L,0x0100000000000000L});
	public static final BitSet FOLLOW_LITERAL_post_in_subprogram_behavior5408 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior5412 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_subprogram_behavior5421 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_subprogram_behavior5425 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5585 = new BitSet(new long[]{0x8000000000000000L,0x1081000000008000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_action_in_asserted_action5594 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_asserted_action5600 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_basic_action_in_action5721 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_alternative_in_action5727 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_while_loop_in_action5733 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_loop_in_action5739 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_do_until_loop_in_action5745 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_action5751 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_lattice_quantification_in_action5757 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_if_in_alternative5784 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5792 = new BitSet(new long[]{0x0000000002000000L});
	public static final BitSet FOLLOW_BOX_in_alternative5798 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_guarded_action_in_alternative5802 = new BitSet(new long[]{0x0000000002000000L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_LITERAL_fi_in_alternative5810 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_guarded_action5853 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_guarded_action5857 = new BitSet(new long[]{0x2000000000000000L});
	public static final BitSet FOLLOW_GUARD_in_guarded_action5859 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_guarded_action5862 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_forall_in_universal_lattice_quantification5889 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_lattice_variables_in_universal_lattice_quantification5898 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_universal_lattice_quantification5902 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_range_in_universal_lattice_quantification5906 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification5915 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5966 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5971 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5975 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables5978 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables5982 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_LITERAL_while_in_while_loop6044 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_while_loop6050 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_while_loop6055 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_while_loop6057 = new BitSet(new long[]{0x0000000000000000L,0x0080004000008000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_while_loop6064 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_while_loop6068 = new BitSet(new long[]{0x0000000000000000L,0x0080004000008000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_while_loop6077 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_while_loop6082 = new BitSet(new long[]{0x0000000000000000L,0x0080000000008000L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_while_loop6093 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_for_in_for_loop6158 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_for_loop6166 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_for_loop6171 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_for_loop6176 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_for_loop6178 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_for_loop6183 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_for_loop6192 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_for_loop6196 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_LCURLY_in_for_loop6203 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_for_loop6208 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_for_loop6210 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_do_in_do_until_loop6280 = new BitSet(new long[]{0x8000000000000000L,0x1081004000009000L,0x0040000020218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_do_until_loop6288 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_do_until_loop6292 = new BitSet(new long[]{0x8000000000000000L,0x1081004000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_LITERAL_bound_in_do_until_loop6301 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_do_until_loop6306 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_do_until_loop6317 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000080000000000L});
	public static final BitSet FOLLOW_LITERAL_until_in_do_until_loop6323 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_do_until_loop6325 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_do_until_loop6330 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_do_until_loop6332 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_skip_in_basic_action6402 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_basic_action6408 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_communication_action_in_basic_action6415 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_computation_action_in_basic_action6422 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_setmode_in_basic_action6428 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_basic_action6431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_throw_in_basic_action6437 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_combinable_operation_in_basic_action6443 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simultaneous_assignment_in_basic_action6449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_issue_exception_in_basic_action6455 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_tick_in_assignment6482 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assignment6486 = new BitSet(new long[]{0x8000000000000010L,0x0000400080002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_assignment6490 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_name_tick6534 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_name_tick6538 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_record_term6572 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_record_term6580 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_any_in_expression_or_record_term6587 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_record_term6602 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_record_term6606 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_record_term6608 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_record_value_in_record_term6612 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_record_term6615 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_value6652 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_record_value6654 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4000012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_record_value6657 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_value6659 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_simultaneous_assignment6685 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6689 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6695 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment6699 = new BitSet(new long[]{0x0000000040020000L});
	public static final BitSet FOLLOW_ASSIGN_in_simultaneous_assignment6709 = new BitSet(new long[]{0x8000000000000010L,0x0000400080002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6713 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment6719 = new BitSet(new long[]{0x8000000000000010L,0x0000400080002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment6723 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_simultaneous_assignment6728 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exception_in_issue_exception6790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_issue_exception6793 = new BitSet(new long[]{0x8000000000000010L});
	public static final BitSet FOLLOW_identifier_in_issue_exception6803 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_issue_exception6805 = new BitSet(new long[]{0x0000000000000010L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_issue_exception6813 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_issue_exception6815 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_computation_in_computation_action6844 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_computation_action6851 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6854 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_computation_action6858 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_computation_action6861 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_computation_action6869 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_behavior_time6900 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000208800100000L,0x0000400000002008L});
	public static final BitSet FOLLOW_time_unit_in_behavior_time6905 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_procedure_call_in_communication_action6995 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_output_in_communication_action7013 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_input_in_communication_action7031 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_pause_in_communication_action7049 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_procedure_call7086 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_procedure_call7090 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000000000000010L,0x4040010000004000L,0x0000000001400000L});
	public static final BitSet FOLLOW_formal_actual_list_in_procedure_call7094 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_procedure_call7097 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_output7154 = new BitSet(new long[]{0x0020000000000000L});
	public static final BitSet FOLLOW_EXCLAMATION_in_port_output7156 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_output7160 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_port_output7164 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_port_output7166 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_port_input7224 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_QUESTION_in_port_input7226 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_port_input7228 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_name_in_port_input7233 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_port_input7235 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_port_name7278 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7281 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7284 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_port_name7287 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_port_name7290 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_identifier_in_port_name7304 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_port_name7306 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_port_name7310 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_port_name7312 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7331 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_actual_list7337 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000000000000010L,0x4040010000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list7341 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_identifier_in_formal_actual7396 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_actual7398 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000000000000010L,0x4040010000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_actual_parameter_in_formal_actual7404 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_actual_parameter7423 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_actual_parameter7431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_actual_parameter7439 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_quantified_variables_in_existential_lattice_quantification7465 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_LCURLY_in_existential_lattice_quantification7470 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_behavior_actions_in_existential_lattice_quantification7474 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_existential_lattice_quantification7476 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_timeout_clause_in_existential_lattice_quantification7482 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L});
	public static final BitSet FOLLOW_catch_clause_in_existential_lattice_quantification7487 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_catch_in_catch_clause7511 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_catch_clause_term_in_catch_clause7514 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_timeout_clause7530 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_timeout_clause7533 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_catch_clause_term7554 = new BitSet(new long[]{0x8000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_identifier_in_catch_clause_term7561 = new BitSet(new long[]{0x8000000010000000L});
	public static final BitSet FOLLOW_LITERAL_all_in_catch_clause_term7568 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_catch_clause_term7574 = new BitSet(new long[]{0x8000000000000000L,0x0001000000000000L,0x0040000000000782L,0x00440000100A0000L});
	public static final BitSet FOLLOW_basic_action_in_catch_clause_term7578 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_catch_clause_term7580 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_when_in_when_throw7636 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_when_throw7639 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_when_throw7643 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_when_throw7645 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_LITERAL_throw_in_when_throw7648 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_when_throw7651 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchadd_in_combinable_operation7666 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7669 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7673 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7675 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7686 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7690 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7694 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7699 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchor_in_combinable_operation7708 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7711 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7715 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7717 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7728 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7732 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7736 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7741 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchand_in_combinable_operation7750 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7753 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7757 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7759 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7770 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7774 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7778 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7783 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchxor_in_combinable_operation7792 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7795 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7799 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7801 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_combinable_operation7812 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7816 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7820 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7825 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_swap_in_combinable_operation7834 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_combinable_operation7838 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7842 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7844 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation7855 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_combinable_operation7859 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_combinable_operation7863 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_combinable_operation7868 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7891 = new BitSet(new long[]{0x0000000000000202L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7907 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7911 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions7915 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7919 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7940 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7944 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions7948 = new BitSet(new long[]{0x8000000000000000L,0x1081000000009000L,0x0040000000218782L,0x004C0000100A0000L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions7952 = new BitSet(new long[]{0x0000000000000202L});
	public static final BitSet FOLLOW_partial_name_in_name8047 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_name8053 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_partial_name_in_name8057 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_identifier_in_partial_name8124 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_partial_name8133 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_range_in_partial_name8137 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_partial_name8139 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8188 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_parameter_list8197 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_range_in_parameter_list8201 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8263 = new BitSet(new long[]{0x0000300180000002L});
	public static final BitSet FOLLOW_range_symbol_in_expression_or_range8267 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_expression_or_range8270 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_variable_name8297 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression8323 = new BitSet(new long[]{0x0040040000000002L,0x0010040020000000L,0x0004001000000000L,0x0420000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_expression8339 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8343 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_expression8359 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8363 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_expression8377 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8381 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_expression8392 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8396 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_expression8407 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8411 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_expression8422 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_expression8437 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8441 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_expression8454 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8458 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_expression8474 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8478 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_expression8494 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8498 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_expression8512 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8516 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_expression8527 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression8531 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_subexpression8603 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_LITERAL_not_in_subexpression8609 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_subexpression8621 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression8627 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_conversion_in_subexpression8727 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_function_call_in_subexpression8747 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_type_conversion8777 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_type_conversion8786 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_type_conversion8795 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_type_conversion8804 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_type_conversion8813 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_type_conversion8821 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion8830 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type_conversion8861 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type_conversion8870 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type_conversion8879 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type_conversion8888 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type_conversion8897 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type_conversion8905 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion8914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8949 = new BitSet(new long[]{0x0000000000000002L,0x0010040020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_boolean_expression8965 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8969 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_boolean_expression8985 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression8989 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_boolean_expression9005 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression9009 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_cand_in_boolean_expression9023 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression9027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_cor_in_boolean_expression9038 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000580002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression9042 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_boolean_subexpression9114 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_boolean_subexpression9126 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_boolean_subexpression9132 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9217 = new BitSet(new long[]{0x0040040000000002L,0x0000000000000000L,0x0000001000000000L,0x0400000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_numeric_expression9233 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9237 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_numeric_expression9253 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9257 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_numeric_expression9271 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_numeric_expression9286 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9290 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_numeric_expression9301 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9305 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_numeric_expression9316 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9320 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_numeric_expression9331 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_subexpression_in_numeric_expression9335 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_numeric_subexpression9407 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_numeric_subexpression9419 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_numeric_subexpression9425 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_expression_in_parenthesized_subexpression9527 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_expression_in_parenthesized_subexpression9557 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_subexpression9576 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_or_relation_in_parenthesized_subexpression9580 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_subexpression9584 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_expression9621 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9625 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9631 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9635 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_case_expression9639 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_case_expression9643 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_case_expression9650 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_case_choice9687 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_case_choice9692 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_case_choice9694 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_case_choice9697 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_case_choice9702 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9717 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_expression9719 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9723 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_expression9727 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9732 = new BitSet(new long[]{0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_expression9734 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9739 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9741 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_expression9771 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_conditional_expression9775 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_conditional_expression9779 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9784 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_expression9786 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_conditional_expression9791 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_expression9793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_value9833 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_value9885 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000010000L});
	public static final BitSet FOLLOW_QUESTION_in_value9891 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9897 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_value9901 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9907 = new BitSet(new long[]{0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_value9911 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_value9918 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_value9922 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_value10017 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_value10032 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_LITERAL_mode_in_value10034 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_value10036 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_value10041 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_value10044 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_value10070 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_null_in_value10085 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_now_in_value10100 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_tops_in_value10115 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_value_constant10143 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_value_constant10147 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_constant_in_value_constant10153 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_value_constant10159 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_value_in_value_constant10165 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_value_constant10171 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10202 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_enumeration_value10206 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_value10210 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_constant_in_property10246 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_reference_in_property10250 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_constant10268 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_constant10272 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_constant10278 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10295 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10299 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference10314 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_self_in_property_reference10344 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10348 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10352 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference10358 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_property_reference10392 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference10396 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference10400 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference10410 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_LBRACKET_in_property_field10450 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_set_in_property_field10453 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_property_field10461 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_property_field10469 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000200000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_set_in_property_field10472 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_property_name10498 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_name10502 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_property_name10507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_numeric_constant10545 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_LIT_in_numeric_constant10552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rational_literal_in_numeric_constant10561 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_complex_literal_in_numeric_constant10565 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_numeric_constant10571 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_relation10603 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10633 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_expression_or_relation10642 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_expression_or_relation10646 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_relation10674 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10723 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_boolean_expression_or_relation10733 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subexpression_in_boolean_expression_or_relation10737 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_expression_in_boolean_expression_or_relation10764 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_function_call10813 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_function_call10815 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_function_call10825 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_function_call10829 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_function_parameters_in_function_call10833 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_function_call10836 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10895 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10899 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10905 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters10915 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters10920 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_ID_in_formal_expression_pair10942 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_formal_expression_pair10944 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_expression_in_formal_expression_pair10949 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_name_in_type10974 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_type_in_type10993 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_type_in_type11012 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_type_in_type11031 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_type_in_type11050 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_variant_type_in_type11069 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_type11091 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_string_in_type11106 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_enumeration_in_enumeration_type11135 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_enumeration_type11138 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11143 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_enumeration_type11149 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_enumeration_type11152 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_enumeration_type11156 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_number_type11211 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_integer_in_number_type11220 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_rational_in_number_type11229 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_real_in_number_type11238 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_complex_in_number_type11247 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_time_in_number_type11255 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_number_range_in_number_type11263 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
	public static final BitSet FOLLOW_LITERAL_units_in_number_type11270 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000208800100000L,0x0000400000002008L});
	public static final BitSet FOLLOW_units_designator_in_number_type11274 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_number_range11339 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4400000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_constant_number_range_in_number_range11342 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_number_range11344 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11362 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4000000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11367 = new BitSet(new long[]{0x0000200000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range11371 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4400000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_MINUS_in_constant_number_range11375 = new BitSet(new long[]{0x8000000000000000L,0x0000000000002008L,0x0000000000000000L,0x4000000000004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range11380 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_units_designator11494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_unit_in_units_designator11500 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11540 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference11544 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11549 = new BitSet(new long[]{0x0000400000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11561 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11566 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11624 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference11632 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_unique_component_classifier_reference11637 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_type_name11713 = new BitSet(new long[]{0x0000400000000002L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_type_name11718 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_type_name11723 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_array_in_array_type11750 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_LBRACKET_in_array_type11753 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_array_range_list_in_array_type11756 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_array_type11758 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_array_type11761 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_type_in_array_type11763 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_record_in_record_type11790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_record_type11793 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_record_field_in_record_type11796 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_record_type11799 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_record_field11828 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_record_field11830 = new BitSet(new long[]{0x8000000000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L});
	public static final BitSet FOLLOW_type_in_record_field11833 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_record_field11835 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11865 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11869 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11872 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list11876 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list11879 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11916 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11922 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11928 = new BitSet(new long[]{0x0000200000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_natural_range11938 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000004000L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_natural_range11945 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_natural_range11951 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_natural_range11957 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variant_in_variant_type11994 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_variant_type12002 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_record_field_in_variant_type12005 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_variant_type12008 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_subclause12037 = new BitSet(new long[]{0x8000000000000010L,0x0100400012003008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_subclause12048 = new BitSet(new long[]{0x0000000000000402L,0x0000000000001000L});
	public static final BitSet FOLLOW_predicate_in_assertion_annex_subclause12071 = new BitSet(new long[]{0x0000000000000402L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_subclause12092 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ANNEX_START_in_assertion_annex_library12120 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_library12131 = new BitSet(new long[]{0x0000000000000402L,0x0000000000001000L});
	public static final BitSet FOLLOW_ANNEX_END_in_assertion_annex_library12154 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LASS_in_assertion12184 = new BitSet(new long[]{0x8000000000020010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400020L});
	public static final BitSet FOLLOW_assertion_body_in_assertion12189 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_RASS_in_assertion12191 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12246 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12250 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12254 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12258 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion_body12314 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12341 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12345 = new BitSet(new long[]{0x8000000010000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12349 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12352 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12356 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_assertion_body12448 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_assertion_body12452 = new BitSet(new long[]{0x8000000000020000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion_body12456 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12459 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12463 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSIGN_in_assertion_body12554 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion_body12558 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_assertion_body12594 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_formal_assertion_parameter12645 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_TILDE_in_formal_assertion_parameter12647 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_type_name_in_formal_assertion_parameter12650 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12666 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12670 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12673 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list12682 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list12684 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_assertion_function_value12718 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_value12737 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_function12763 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12770 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12776 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12780 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_conditional_assertion_function12787 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function12791 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_function12801 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_condition_value_pair12842 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_condition_value_pair12844 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_condition_value_pair12847 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12865 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12868 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_COMMA_in_assertion_enumeration12871 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration12874 = new BitSet(new long[]{0x0000000040000002L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration12889 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_assertion_enumeration12892 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_enumeration_pair12911 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_enumeration_pair12914 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_enumeration_pair12917 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_all_in_universal_quantification12936 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_universal_quantification12939 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_universal_quantification12941 = new BitSet(new long[]{0x0000000000000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_LITERAL_are_in_universal_quantification12945 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_universal_quantification12948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exists_in_existential_quantification12974 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_existential_quantification12977 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_existential_quantification12979 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_existential_quantification12983 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_existential_quantification12986 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_logic_variables13014 = new BitSet(new long[]{0x0000000050000000L});
	public static final BitSet FOLLOW_COMMA_in_logic_variables13017 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_logic_variables13021 = new BitSet(new long[]{0x0000000050000000L});
	public static final BitSet FOLLOW_COLON_in_logic_variables13027 = new BitSet(new long[]{0x8000000000000000L,0x0000402000000000L,0x0000010010000000L,0x00000004000000C0L});
	public static final BitSet FOLLOW_assertion_type_in_logic_variables13031 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_logic_variable_domain13083 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x4000D90012000014L,0x4440012C088040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13112 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_logic_variable_domain13116 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain13120 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_in_logic_variable_domain13155 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_quantification_in_predicate13215 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_quantification_in_predicate13223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13232 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000001L,0x0004000001400000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13250 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13253 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate13257 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13260 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13280 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13283 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate13287 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13290 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13313 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13316 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate13320 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13323 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_implies_in_predicate13345 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13348 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_iff_in_predicate13367 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13370 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IMP_in_predicate13388 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_predicate13391 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_subpredicate13433 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000510012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13463 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_subpredicate13467 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13546 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_subpredicate13550 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_range_in_subpredicate13554 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_subpredicate13622 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000040L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_subpredicate13626 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_subpredicate13632 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_subpredicate13674 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_subpredicate13712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_subpredicate13748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_invocation_in_subpredicate13793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_predicate_in_subpredicate13827 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_def_in_subpredicate13864 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_assertion_parameter_in_subpredicate13868 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_timed_predicate13917 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate13921 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate13925 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_timed_predicate13931 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_predicate13939 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_predicate13942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_predicate13951 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_timed_predicate13954 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_predicate13992 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_parenthesized_predicate13995 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_predicate13997 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_floatingAtom14017 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_period_shift14045 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14063 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14067 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift14093 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14097 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L,0x0000004001000010L});
	public static final BitSet FOLLOW_MINUS_in_period_shift14108 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14112 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14116 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_period_shift14130 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14134 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14138 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14152 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14156 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000010L});
	public static final BitSet FOLLOW_PLUS_in_period_shift14159 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14163 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000010L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14169 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14185 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14189 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004001000000L});
	public static final BitSet FOLLOW_TIMES_in_period_shift14192 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_period_shift14196 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14202 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift14218 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14386 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14390 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14392 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14427 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14431 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_invocation14435 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14437 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_predicate_invocation14480 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_predicate_invocation14484 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14488 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_predicate_invocation14492 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation14496 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_predicate_invocation14502 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter14559 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_actual_assertion_parameter14563 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_actual_assertion_parameter14567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter14596 = new BitSet(new long[]{0x0000000020000000L});
	public static final BitSet FOLLOW_COLON_TILDE_in_actual_assertion_parameter14600 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_actual_assertion_parameter14604 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_expression_in_range14655 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_range14657 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_numeric_expression_in_range14660 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14686 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_assertion_range14688 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range14691 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_sum_in_assertion_expression14726 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14728 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14737 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14739 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_product_in_assertion_expression14771 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14773 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14777 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression14782 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression14784 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_numberof_in_assertion_expression14814 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression14816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression14820 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_assertion_expression14825 = new BitSet(new long[]{0x8000000000000010L,0x0100400002002008L,0x0000590012000010L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_subpredicate_in_assertion_expression14827 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14861 = new BitSet(new long[]{0x0040040000000002L,0x0000000000000000L,0x0000001000000000L,0x0400000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_assertion_expression14875 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14877 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_assertion_expression14910 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14912 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_assertion_expression14946 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_assertion_expression14979 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression14981 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_assertion_expression15013 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression15015 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_assertion_expression15047 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression15049 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_assertion_expression15074 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x0000510012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression15076 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_assertion_subexpression15136 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_LITERAL_abs_in_assertion_subexpression15142 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression15162 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_type_conversion_in_assertion_subexpression15222 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_vpa_in_timed_expression15259 = new BitSet(new long[]{0x0000000004040002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
	public static final BitSet FOLLOW_TICK_in_timed_expression15264 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_expression15272 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_expression15275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CARET_in_timed_expression15284 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_period_shift_in_timed_expression15287 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_vpa15315 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_vpa15325 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_vpa15335 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15352 = new BitSet(new long[]{0x0040040000000002L,0x0000000000000000L,0x0000001000000000L,0x0400000000000400L,0x0000004000000010L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15363 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15368 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_PLUS_in_time_expression15372 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15376 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000010L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15391 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15396 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_TIMES_in_time_expression15400 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15404 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_MINUS_in_time_expression15419 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15424 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DIVIDE_in_time_expression15437 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15442 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXP_in_time_expression15455 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15460 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_mod_in_time_expression15473 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15478 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rem_in_time_expression15491 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression15496 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_time_subexpression15523 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4040012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_time_subexpression15533 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_time_subexpression15541 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_time_subexpression15550 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4440012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_time_expression_in_time_subexpression15554 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_time_subexpression15558 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15678 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15682 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000001400000L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_invocation15686 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15689 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation15736 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_function_invocation15740 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15749 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_assertion_function_invocation15753 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation15757 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_function_invocation15762 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression15849 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_record_term_in_parenthesized_assertion_expression15879 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_parenthesized_assertion_expression15913 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_assertion_expression15934 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_parenthesized_assertion_expression15938 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_assertion_expression15942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression15974 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_conditional_assertion_expression15976 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression15980 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_LITERAL_then_in_conditional_assertion_expression15984 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15989 = new BitSet(new long[]{0x0000000000000000L,0x2000000000000000L});
	public static final BitSet FOLLOW_LITERAL_else_in_conditional_assertion_expression15991 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression15996 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression15998 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_conditional_assertion_expression16026 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression16030 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_conditional_assertion_expression16034 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression16039 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_conditional_assertion_expression16041 = new BitSet(new long[]{0x8000000000000010L,0x0000400002002008L,0x4000D10012000010L,0x4440012C080040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression16046 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_conditional_assertion_expression16048 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_record_term16086 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_assertion_record_value_in_assertion_record_term16089 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_record_term16092 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_record_value16107 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_assertion_record_value16109 = new BitSet(new long[]{0x8000000000000010L,0x0000000000002008L,0x0000500002000010L,0x4000012800004000L,0x0000000000400000L});
	public static final BitSet FOLLOW_value_in_assertion_record_value16112 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_assertion_record_value16114 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_assertion_parameter16130 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_assertion_type16148 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type16152 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type16156 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type16160 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type16164 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type16168 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type16173 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_assertion_type16180 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_availability_in_availability16206 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability16210 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16231 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L,0x0004000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_availability_expression16245 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16249 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_availability_expression16268 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16272 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_availability_expression16291 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression16295 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_not_in_availability_subexpression16387 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_identifier_in_availability_subexpression16402 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_availability_subexpression16412 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_expression_in_availability_subexpression16416 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_availability_subexpression16418 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_dispatch_condition16506 = new BitSet(new long[]{0x0000000000000000L,0x0800000000000000L});
	public static final BitSet FOLLOW_LITERAL_dispatch_in_dispatch_condition16509 = new BitSet(new long[]{0x8000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_expression_in_dispatch_condition16513 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16541 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_dispatch_expression16547 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression16551 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0004000000000000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16600 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_and_in_dispatch_conjunction16606 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction16610 = new BitSet(new long[]{0x0000000000000002L,0x0000000020000000L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16667 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_dispatch_trigger16670 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16673 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_dispatch_trigger16676 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_dispatch_trigger16679 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger16688 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_identifier_in_dispatch_trigger16699 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_dispatch_trigger16709 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_in_in_in_modes16760 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_LITERAL_modes_in_in_modes16763 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_in_modes16767 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16773 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_COMMA_in_in_modes16777 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_in_modes16781 = new BitSet(new long[]{0x0000000040000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_in_modes16788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LBRACKET_in_synpred1_BLESStoAST6561 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred1_BLESStoAST6563 = new BitSet(new long[]{0x0000000010000000L});
	public static final BitSet FOLLOW_COLON_in_synpred1_BLESStoAST6565 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred2_BLESStoAST9509 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred2_BLESStoAST9511 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred2_BLESStoAST9515 = new BitSet(new long[]{0x8000000000000010L,0x0000400000002008L,0x0000590012000010L,0x4440012C000040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_synpred2_BLESStoAST9517 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_synpred2_BLESStoAST9519 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred3_BLESStoAST9547 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_case_choice_in_synpred3_BLESStoAST9549 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_port_name_in_synpred4_BLESStoAST9854 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000010000L});
	public static final BitSet FOLLOW_QUESTION_in_synpred4_BLESStoAST9858 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred4_BLESStoAST9862 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_synpred4_BLESStoAST9864 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred4_BLESStoAST9868 = new BitSet(new long[]{0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_synpred4_BLESStoAST9870 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_synpred4_BLESStoAST9873 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_synpred4_BLESStoAST9875 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred5_BLESStoAST10591 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred5_BLESStoAST10593 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred5_BLESStoAST10595 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred6_BLESStoAST10623 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred6_BLESStoAST10625 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subexpression_in_synpred7_BLESStoAST10713 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred7_BLESStoAST10715 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred8_BLESStoAST12708 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_synpred8_BLESStoAST12710 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_synpred9_BLESStoAST13099 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_symbol_in_synpred9_BLESStoAST13101 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred10_BLESStoAST13449 = new BitSet(new long[]{0x1010000000000180L,0x0000000000000000L,0x0000000000000000L,0x1080000000000000L});
	public static final BitSet FOLLOW_relation_symbol_in_synpred10_BLESStoAST13451 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_subexpression_in_synpred11_BLESStoAST13530 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_synpred11_BLESStoAST13532 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_synpred12_BLESStoAST13611 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000040L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_synpred12_BLESStoAST13613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_synpred13_BLESStoAST13783 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_synpred13_BLESStoAST13785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred17_BLESStoAST15831 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_LITERAL_if_in_synpred17_BLESStoAST15833 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred17_BLESStoAST15837 = new BitSet(new long[]{0x8000000000000010L,0x0100400012002008L,0x0000590012000014L,0x4440012C008040C0L,0x0000000000400000L});
	public static final BitSet FOLLOW_predicate_in_synpred17_BLESStoAST15839 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_QQ_in_synpred17_BLESStoAST15841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred18_BLESStoAST15867 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_synpred18_BLESStoAST15869 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ARROW_in_synpred18_BLESStoAST15871 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred19_BLESStoAST15901 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_synpred19_BLESStoAST15903 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_synpred19_BLESStoAST15905 = new BitSet(new long[]{0x0000000000000002L});
}
