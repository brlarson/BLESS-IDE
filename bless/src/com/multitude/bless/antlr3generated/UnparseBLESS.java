// $ANTLR 3.5.2 /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g 2023-02-21 12:41:12

//copyright 2020 Multitude Corporation
package com.multitude.bless.antlr3generated;
import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;
import org.antlr.stringtemplate.*;
import com.multitude.bless.tree.BAST;
import com.multitude.bless.ui.preferences.ConfigurationPreferencePage;
import com.multitude.bless.app.Global;
import com.multitude.bless.exceptions.Dump;
import com.multitude.bless.exceptions.HelpfulHints;
import com.multitude.bless.exceptions.BLESSmarker;
import com.multitude.bless.app.Global;
import com.multitude.aadl.bless.maps.BlessMaps;


import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.stringtemplate.*;
import org.antlr.stringtemplate.language.*;
import java.util.HashMap;
@SuppressWarnings("all")
public class UnparseBLESS extends TreeParser {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AADL_STRING_LITERAL", "AADL_STRING_PART", 
		"ACTION", "AL", "AM", "AMPERSAND", "ANNEX_END", "ANNEX_START", "ARROW", 
		"ASSERTION", "ASSERTION_ANNEX", "ASSERTION_ENUMERATION", "ASSERTION_FUNCTION", 
		"ASSIGN", "AT_SIGN", "BASE", "BASED_INTEGER", "BEHAVIOR_GUARD", "BEHAVIOR_TIME", 
		"BI", "BOUND", "BOX", "CARET", "CASE_EXPRESSION", "COLON", "COLON_TILDE", 
		"COMMA", "COMMACOMMA", "COMMADOT", "COMPLEX", "COMPONENT", "CONDITION", 
		"CONDITIONAL", "CONDITIONAL_FUNCTION", "CONNECTION", "COUNTING_TRIGGER", 
		"DESTINATION", "DIGIT", "DIVIDE", "DOLLAR", "DOTCOMMA", "DOTDOT", "DOUBLE_COLON", 
		"DOUBLE_QUOTE", "DO_NOT_PROVE", "DUMMY", "EMPTY_CURLY", "END_ASSERTION_PROPERTY", 
		"EQ", "EXCLAMATION", "EXP", "EXPONENT", "EXTENDED_DIGIT", "FLOATING", 
		"FUNCTION", "FUNCTION_CALL", "GT", "GUARD", "HEX_DIGIT", "ID", "IMP", 
		"INMODE", "INOUT", "INTEGER_LIT", "INT_EXPONENT", "INVARIANT", "INVOKE", 
		"INVOKE_FUNCTION", "IP_NAME", "IP_PE", "IP_PRED", "LABEL", "LASS", "LBRACKET", 
		"LCON", "LCURLY", "LITERAL_Assertion", "LITERAL_Invariant", "LITERAL_Postcondition", 
		"LITERAL_Precondition", "LITERAL_Typed", "LITERAL_aadlboolean", "LITERAL_aadlinteger", 
		"LITERAL_aadlreal", "LITERAL_aadlstring", "LITERAL_abs", "LITERAL_abstract", 
		"LITERAL_access", "LITERAL_all", "LITERAL_and", "LITERAL_annex", "LITERAL_any", 
		"LITERAL_applies", "LITERAL_are", "LITERAL_array", "LITERAL_assert", "LITERAL_availability", 
		"LITERAL_boolean", "LITERAL_bound", "LITERAL_bus", "LITERAL_call", "LITERAL_calls", 
		"LITERAL_cand", "LITERAL_catch", "LITERAL_classifier", "LITERAL_complete", 
		"LITERAL_complex", "LITERAL_component", "LITERAL_computation", "LITERAL_connection", 
		"LITERAL_connections", "LITERAL_constant", "LITERAL_cor", "LITERAL_count", 
		"LITERAL_data", "LITERAL_declare", "LITERAL_def", "LITERAL_delay", "LITERAL_device", 
		"LITERAL_dispatch", "LITERAL_do", "LITERAL_else", "LITERAL_end", "LITERAL_enumeration", 
		"LITERAL_event", "LITERAL_exception", "LITERAL_exists", "LITERAL_extends", 
		"LITERAL_false", "LITERAL_feature", "LITERAL_features", "LITERAL_fetchadd", 
		"LITERAL_fetchand", "LITERAL_fetchor", "LITERAL_fetchxor", "LITERAL_fi", 
		"LITERAL_final", "LITERAL_flow", "LITERAL_flows", "LITERAL_for", "LITERAL_forall", 
		"LITERAL_fresh", "LITERAL_function", "LITERAL_group", "LITERAL_hr", "LITERAL_if", 
		"LITERAL_iff", "LITERAL_implementation", "LITERAL_implies", "LITERAL_in", 
		"LITERAL_inherit", "LITERAL_initial", "LITERAL_integer", "LITERAL_invariant", 
		"LITERAL_inverse", "LITERAL_is", "LITERAL_list", "LITERAL_lower_bound", 
		"LITERAL_memory", "LITERAL_min", "LITERAL_mod", "LITERAL_mode", "LITERAL_modes", 
		"LITERAL_ms", "LITERAL_natural", "LITERAL_none", "LITERAL_nonvolatile", 
		"LITERAL_not", "LITERAL_now", "LITERAL_ns", "LITERAL_null", "LITERAL_numberof", 
		"LITERAL_of", "LITERAL_on", "LITERAL_or", "LITERAL_out", "LITERAL_package", 
		"LITERAL_parameter", "LITERAL_pause", "LITERAL_port", "LITERAL_post", 
		"LITERAL_pre", "LITERAL_private", "LITERAL_procedure", "LITERAL_process", 
		"LITERAL_processor", "LITERAL_product", "LITERAL_properties", "LITERAL_property", 
		"LITERAL_prototypes", "LITERAL_provides", "LITERAL_ps", "LITERAL_public", 
		"LITERAL_range", "LITERAL_rational", "LITERAL_real", "LITERAL_record", 
		"LITERAL_reference", "LITERAL_rem", "LITERAL_renames", "LITERAL_requires", 
		"LITERAL_sec", "LITERAL_self", "LITERAL_sequence", "LITERAL_set", "LITERAL_setmode", 
		"LITERAL_shared", "LITERAL_skip", "LITERAL_spread", "LITERAL_state", "LITERAL_states", 
		"LITERAL_stop", "LITERAL_string", "LITERAL_subcomponents", "LITERAL_subprogram", 
		"LITERAL_sum", "LITERAL_swap", "LITERAL_system", "LITERAL_that", "LITERAL_then", 
		"LITERAL_thread", "LITERAL_throw", "LITERAL_time", "LITERAL_timeout", 
		"LITERAL_to", "LITERAL_tops", "LITERAL_transition", "LITERAL_transitions", 
		"LITERAL_true", "LITERAL_type", "LITERAL_units", "LITERAL_until", "LITERAL_updated", 
		"LITERAL_upper_bound", "LITERAL_us", "LITERAL_variables", "LITERAL_variant", 
		"LITERAL_virtual", "LITERAL_when", "LITERAL_while", "LITERAL_with", "LITERAL_xor", 
		"LPAREN", "LT", "LTE_STRING", "LT_STRING", "MINUS", "MT_STRING", "NEQ", 
		"OBLIGATION", "OCTOTHORPE", "ON", "P", "PARAMETER", "PARAMETERS", "PERIOD", 
		"PLUS", "PLUS_ARROW", "PLUS_EQUALS", "PORT", "PORT_INPUT", "PORT_OUTPUT", 
		"PREDICATE_RELATION", "PROCEDURE", "PROCEDURE_CALL", "PROPERTY_LIST", 
		"Q", "QQ", "QUESTION", "RASS", "RATIONAL", "RBRACKET", "RCON", "RCURLY", 
		"REAL_LIT", "RECORD_VALUE", "RPAREN", "S", "SEMICOLON", "SLCOMMENT", "SOURCE", 
		"START", "START_ASSERTION_PROPERTY", "STOP", "SUBCOMPONENT", "SUBPROGRAM_ANNEX", 
		"THREAD_ANNEX", "THREAD_GROUP", "TICK", "TILDE", "TIMES", "TOP", "TRANSITION", 
		"TYPE", "TYPE_OPERATOR", "TYPE_OPERATOR_INVOCATION", "UNARY_MINUS", "VALUE", 
		"WP", "WS", "'|'"
	};
	public static final int EOF=-1;
	public static final int T__304=304;
	public static final int AADL_STRING_LITERAL=4;
	public static final int AADL_STRING_PART=5;
	public static final int ACTION=6;
	public static final int AL=7;
	public static final int AM=8;
	public static final int AMPERSAND=9;
	public static final int ANNEX_END=10;
	public static final int ANNEX_START=11;
	public static final int ARROW=12;
	public static final int ASSERTION=13;
	public static final int ASSERTION_ANNEX=14;
	public static final int ASSERTION_ENUMERATION=15;
	public static final int ASSERTION_FUNCTION=16;
	public static final int ASSIGN=17;
	public static final int AT_SIGN=18;
	public static final int BASE=19;
	public static final int BASED_INTEGER=20;
	public static final int BEHAVIOR_GUARD=21;
	public static final int BEHAVIOR_TIME=22;
	public static final int BI=23;
	public static final int BOUND=24;
	public static final int BOX=25;
	public static final int CARET=26;
	public static final int CASE_EXPRESSION=27;
	public static final int COLON=28;
	public static final int COLON_TILDE=29;
	public static final int COMMA=30;
	public static final int COMMACOMMA=31;
	public static final int COMMADOT=32;
	public static final int COMPLEX=33;
	public static final int COMPONENT=34;
	public static final int CONDITION=35;
	public static final int CONDITIONAL=36;
	public static final int CONDITIONAL_FUNCTION=37;
	public static final int CONNECTION=38;
	public static final int COUNTING_TRIGGER=39;
	public static final int DESTINATION=40;
	public static final int DIGIT=41;
	public static final int DIVIDE=42;
	public static final int DOLLAR=43;
	public static final int DOTCOMMA=44;
	public static final int DOTDOT=45;
	public static final int DOUBLE_COLON=46;
	public static final int DOUBLE_QUOTE=47;
	public static final int DO_NOT_PROVE=48;
	public static final int DUMMY=49;
	public static final int EMPTY_CURLY=50;
	public static final int END_ASSERTION_PROPERTY=51;
	public static final int EQ=52;
	public static final int EXCLAMATION=53;
	public static final int EXP=54;
	public static final int EXPONENT=55;
	public static final int EXTENDED_DIGIT=56;
	public static final int FLOATING=57;
	public static final int FUNCTION=58;
	public static final int FUNCTION_CALL=59;
	public static final int GT=60;
	public static final int GUARD=61;
	public static final int HEX_DIGIT=62;
	public static final int ID=63;
	public static final int IMP=64;
	public static final int INMODE=65;
	public static final int INOUT=66;
	public static final int INTEGER_LIT=67;
	public static final int INT_EXPONENT=68;
	public static final int INVARIANT=69;
	public static final int INVOKE=70;
	public static final int INVOKE_FUNCTION=71;
	public static final int IP_NAME=72;
	public static final int IP_PE=73;
	public static final int IP_PRED=74;
	public static final int LABEL=75;
	public static final int LASS=76;
	public static final int LBRACKET=77;
	public static final int LCON=78;
	public static final int LCURLY=79;
	public static final int LITERAL_Assertion=80;
	public static final int LITERAL_Invariant=81;
	public static final int LITERAL_Postcondition=82;
	public static final int LITERAL_Precondition=83;
	public static final int LITERAL_Typed=84;
	public static final int LITERAL_aadlboolean=85;
	public static final int LITERAL_aadlinteger=86;
	public static final int LITERAL_aadlreal=87;
	public static final int LITERAL_aadlstring=88;
	public static final int LITERAL_abs=89;
	public static final int LITERAL_abstract=90;
	public static final int LITERAL_access=91;
	public static final int LITERAL_all=92;
	public static final int LITERAL_and=93;
	public static final int LITERAL_annex=94;
	public static final int LITERAL_any=95;
	public static final int LITERAL_applies=96;
	public static final int LITERAL_are=97;
	public static final int LITERAL_array=98;
	public static final int LITERAL_assert=99;
	public static final int LITERAL_availability=100;
	public static final int LITERAL_boolean=101;
	public static final int LITERAL_bound=102;
	public static final int LITERAL_bus=103;
	public static final int LITERAL_call=104;
	public static final int LITERAL_calls=105;
	public static final int LITERAL_cand=106;
	public static final int LITERAL_catch=107;
	public static final int LITERAL_classifier=108;
	public static final int LITERAL_complete=109;
	public static final int LITERAL_complex=110;
	public static final int LITERAL_component=111;
	public static final int LITERAL_computation=112;
	public static final int LITERAL_connection=113;
	public static final int LITERAL_connections=114;
	public static final int LITERAL_constant=115;
	public static final int LITERAL_cor=116;
	public static final int LITERAL_count=117;
	public static final int LITERAL_data=118;
	public static final int LITERAL_declare=119;
	public static final int LITERAL_def=120;
	public static final int LITERAL_delay=121;
	public static final int LITERAL_device=122;
	public static final int LITERAL_dispatch=123;
	public static final int LITERAL_do=124;
	public static final int LITERAL_else=125;
	public static final int LITERAL_end=126;
	public static final int LITERAL_enumeration=127;
	public static final int LITERAL_event=128;
	public static final int LITERAL_exception=129;
	public static final int LITERAL_exists=130;
	public static final int LITERAL_extends=131;
	public static final int LITERAL_false=132;
	public static final int LITERAL_feature=133;
	public static final int LITERAL_features=134;
	public static final int LITERAL_fetchadd=135;
	public static final int LITERAL_fetchand=136;
	public static final int LITERAL_fetchor=137;
	public static final int LITERAL_fetchxor=138;
	public static final int LITERAL_fi=139;
	public static final int LITERAL_final=140;
	public static final int LITERAL_flow=141;
	public static final int LITERAL_flows=142;
	public static final int LITERAL_for=143;
	public static final int LITERAL_forall=144;
	public static final int LITERAL_fresh=145;
	public static final int LITERAL_function=146;
	public static final int LITERAL_group=147;
	public static final int LITERAL_hr=148;
	public static final int LITERAL_if=149;
	public static final int LITERAL_iff=150;
	public static final int LITERAL_implementation=151;
	public static final int LITERAL_implies=152;
	public static final int LITERAL_in=153;
	public static final int LITERAL_inherit=154;
	public static final int LITERAL_initial=155;
	public static final int LITERAL_integer=156;
	public static final int LITERAL_invariant=157;
	public static final int LITERAL_inverse=158;
	public static final int LITERAL_is=159;
	public static final int LITERAL_list=160;
	public static final int LITERAL_lower_bound=161;
	public static final int LITERAL_memory=162;
	public static final int LITERAL_min=163;
	public static final int LITERAL_mod=164;
	public static final int LITERAL_mode=165;
	public static final int LITERAL_modes=166;
	public static final int LITERAL_ms=167;
	public static final int LITERAL_natural=168;
	public static final int LITERAL_none=169;
	public static final int LITERAL_nonvolatile=170;
	public static final int LITERAL_not=171;
	public static final int LITERAL_now=172;
	public static final int LITERAL_ns=173;
	public static final int LITERAL_null=174;
	public static final int LITERAL_numberof=175;
	public static final int LITERAL_of=176;
	public static final int LITERAL_on=177;
	public static final int LITERAL_or=178;
	public static final int LITERAL_out=179;
	public static final int LITERAL_package=180;
	public static final int LITERAL_parameter=181;
	public static final int LITERAL_pause=182;
	public static final int LITERAL_port=183;
	public static final int LITERAL_post=184;
	public static final int LITERAL_pre=185;
	public static final int LITERAL_private=186;
	public static final int LITERAL_procedure=187;
	public static final int LITERAL_process=188;
	public static final int LITERAL_processor=189;
	public static final int LITERAL_product=190;
	public static final int LITERAL_properties=191;
	public static final int LITERAL_property=192;
	public static final int LITERAL_prototypes=193;
	public static final int LITERAL_provides=194;
	public static final int LITERAL_ps=195;
	public static final int LITERAL_public=196;
	public static final int LITERAL_range=197;
	public static final int LITERAL_rational=198;
	public static final int LITERAL_real=199;
	public static final int LITERAL_record=200;
	public static final int LITERAL_reference=201;
	public static final int LITERAL_rem=202;
	public static final int LITERAL_renames=203;
	public static final int LITERAL_requires=204;
	public static final int LITERAL_sec=205;
	public static final int LITERAL_self=206;
	public static final int LITERAL_sequence=207;
	public static final int LITERAL_set=208;
	public static final int LITERAL_setmode=209;
	public static final int LITERAL_shared=210;
	public static final int LITERAL_skip=211;
	public static final int LITERAL_spread=212;
	public static final int LITERAL_state=213;
	public static final int LITERAL_states=214;
	public static final int LITERAL_stop=215;
	public static final int LITERAL_string=216;
	public static final int LITERAL_subcomponents=217;
	public static final int LITERAL_subprogram=218;
	public static final int LITERAL_sum=219;
	public static final int LITERAL_swap=220;
	public static final int LITERAL_system=221;
	public static final int LITERAL_that=222;
	public static final int LITERAL_then=223;
	public static final int LITERAL_thread=224;
	public static final int LITERAL_throw=225;
	public static final int LITERAL_time=226;
	public static final int LITERAL_timeout=227;
	public static final int LITERAL_to=228;
	public static final int LITERAL_tops=229;
	public static final int LITERAL_transition=230;
	public static final int LITERAL_transitions=231;
	public static final int LITERAL_true=232;
	public static final int LITERAL_type=233;
	public static final int LITERAL_units=234;
	public static final int LITERAL_until=235;
	public static final int LITERAL_updated=236;
	public static final int LITERAL_upper_bound=237;
	public static final int LITERAL_us=238;
	public static final int LITERAL_variables=239;
	public static final int LITERAL_variant=240;
	public static final int LITERAL_virtual=241;
	public static final int LITERAL_when=242;
	public static final int LITERAL_while=243;
	public static final int LITERAL_with=244;
	public static final int LITERAL_xor=245;
	public static final int LPAREN=246;
	public static final int LT=247;
	public static final int LTE_STRING=248;
	public static final int LT_STRING=249;
	public static final int MINUS=250;
	public static final int MT_STRING=251;
	public static final int NEQ=252;
	public static final int OBLIGATION=253;
	public static final int OCTOTHORPE=254;
	public static final int ON=255;
	public static final int P=256;
	public static final int PARAMETER=257;
	public static final int PARAMETERS=258;
	public static final int PERIOD=259;
	public static final int PLUS=260;
	public static final int PLUS_ARROW=261;
	public static final int PLUS_EQUALS=262;
	public static final int PORT=263;
	public static final int PORT_INPUT=264;
	public static final int PORT_OUTPUT=265;
	public static final int PREDICATE_RELATION=266;
	public static final int PROCEDURE=267;
	public static final int PROCEDURE_CALL=268;
	public static final int PROPERTY_LIST=269;
	public static final int Q=270;
	public static final int QQ=271;
	public static final int QUESTION=272;
	public static final int RASS=273;
	public static final int RATIONAL=274;
	public static final int RBRACKET=275;
	public static final int RCON=276;
	public static final int RCURLY=277;
	public static final int REAL_LIT=278;
	public static final int RECORD_VALUE=279;
	public static final int RPAREN=280;
	public static final int S=281;
	public static final int SEMICOLON=282;
	public static final int SLCOMMENT=283;
	public static final int SOURCE=284;
	public static final int START=285;
	public static final int START_ASSERTION_PROPERTY=286;
	public static final int STOP=287;
	public static final int SUBCOMPONENT=288;
	public static final int SUBPROGRAM_ANNEX=289;
	public static final int THREAD_ANNEX=290;
	public static final int THREAD_GROUP=291;
	public static final int TICK=292;
	public static final int TILDE=293;
	public static final int TIMES=294;
	public static final int TOP=295;
	public static final int TRANSITION=296;
	public static final int TYPE=297;
	public static final int TYPE_OPERATOR=298;
	public static final int TYPE_OPERATOR_INVOCATION=299;
	public static final int UNARY_MINUS=300;
	public static final int VALUE=301;
	public static final int WP=302;
	public static final int WS=303;

	// delegates
	public TreeParser[] getDelegates() {
		return new TreeParser[] {};
	}

	// delegators


	public UnparseBLESS(TreeNodeStream input) {
		this(input, new RecognizerSharedState());
	}
	public UnparseBLESS(TreeNodeStream input, RecognizerSharedState state) {
		super(input, state);
	}

	protected StringTemplateGroup templateLib =
	  new StringTemplateGroup("UnparseBLESSTemplates", AngleBracketTemplateLexer.class);

	public void setTemplateLib(StringTemplateGroup templateLib) {
	  this.templateLib = templateLib;
	}
	public StringTemplateGroup getTemplateLib() {
	  return templateLib;
	}
	/** allows convenient multi-value initialization:
	 *  "new STAttrMap().put(...).put(...)"
	 */
	@SuppressWarnings("serial")
	public static class STAttrMap extends HashMap<String, Object> {
		public STAttrMap put(String attrName, Object value) {
			super.put(attrName, value);
			return this;
		}
	}
	@Override public String[] getTokenNames() { return UnparseBLESS.tokenNames; }
	@Override public String getGrammarFileName() { return "/Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g"; }


	public static int countRecognitionErrors = 0; //accumulates count of recognition errors
	public static boolean recognitionErrorOccurred = false;    //did a parse error occur?
	public static boolean suppressRecognitionException = false;  //inhibit report error of RecognitionException 
	//public static StringTemplateGroup templates=null;	//templates currently used by UnparseBLESS
	public static boolean lookUpPropertyValues = false;  //look up AADL property values when unparsing rather than name
	public static String singletonName = "";	//Slang name for AADL component hving subprogram subcomponents

	//public boolean SAL=false;  //are we unparsing to SAL?

	public String componentName = "";

	 int startingLine = 0; //starting line of sublanguage in AADL file

	  public  void 
	setStartingLine(int line) //sets starting line
	  {
	  startingLine = line;
	  }

	public  int
	getStartingLine()
	  {
	  return startingLine;
	  }
	  

	//ANTLR string template magic
	  public static StringTemplate 
	template(String name) 
	  {
	  return Global.templates.getInstanceOf(name);
	  }

	  public static StringTemplate 
	text(String t) 
	  {
	  return new StringTemplate(Global.templates,t);
	  }

	  public void 
	reportError(RecognitionException ex)
	  {
	  if (!suppressRecognitionException)
	  {
	 // if (true)
	 // {
	  if (countRecognitionErrors<Global.YouIdiotReportLimit)
	    {
	//   Dump.it("\nUnparseBLESS.reportError(RecognitionException ex)=>"+
	//    Integer.toString(countRecognitionErrors)+" ");
	  Dump.it(getErrorHeader(ex));
	  Dump.it(ex);
	   recognitionErrorOccurred = true;
	   ex.line = ex.line+startingLine;
	   super.reportError(ex);
	  ex.printStackTrace();
	//  Dump.re(ex);
	    }
	  countRecognitionErrors++;
	//  }
	//  // Global.stopProof = true;	//stop proving!
	  }
	  } //end of reportError

	static int typeNameNumber = 0;	//counts type names created


	static StringTemplate getNextTypeID()
		{
		typeNameNumber++;
		return text(makeIntoString(typeNameNumber));
		}

	public static String makeIntoString(int i)
		{
		return Integer.toString(i);
		}

	static StringTemplate  getPackageName()
		{
		return text(Global.packageOrPropertySetID);
		}

	  static StringTemplate slang_simultaneous_assignment(List<Object> l, List<Object> r)
	    {
	    String spaces = "    ";
	    StringBuffer sb = new StringBuffer();
	    sb.append("//simultaneous assignment\n");
	    sb.append(spaces+"//assign to fresh values\n");
	    for (int i=0;i<l.size();i++)
	      {
	      String lhs = ((StringTemplate)l.get(i)).toString().replace("'", "");
	      String rhs = ((StringTemplate)r.get(i)).toString();
	      sb.append(spaces+"val new_"+lhs+" = "+rhs+"\n");
	      }
	    sb.append(spaces+"//copy to variables\n");
	    for (int i=0;i<l.size();i++)
	      {
	      String lhs = ((StringTemplate)l.get(i)).toString().replace("'", "");
	      sb.append(spaces+lhs+" = new_"+lhs+"\n");
	      }
	    return text(sb.toString());
	    }

	static StringTemplate  makeDimensionFromRange(StringTemplate l, StringTemplate r)
		{
		String l_value = l.toString();
		int l_int = 0;
		try
			{
			l_int = Integer.decode(l_value).intValue();
			}
		catch (NumberFormatException ex)
			{
			//look up the value of the ID or enumeration literal
			//otherwise leave as 0
			}	
		String r_value = r.toString();
		int r_int = 1;
		try
			{
			r_int = Integer.decode(r_value).intValue();
			}
		catch (NumberFormatException ex)
			{
			//look up the value of the ID or enumeration literal
			//otherwise use length of string
			r_int = r_value.length();
			}	
		int dimension = r_int-l_int;
		return text(makeIntoString(dimension));
		}  //end of makeDimensionFromRange
		
	static StringTemplate getAadlPropertyValue(BAST dc)
		  {
		  if (!dc.hasType(DOUBLE_COLON))
		    return text("parameter to UnparseBLESS.getAadlPropertyValue must have root DOUBLE_COLON");
		  return text(Global.getAadlPropertyValue(dc.getChild(0).getText(),dc.getChild(1).getText()));
		  }  //end of getAadlPropertyValue
		  
	  
	static StringTemplate getSlangFunctionCall(String functionID)
	  {
	  return text(singletonName+"_subprograms."+functionID);
	  }
	  

	  


	public static class identifier_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "identifier"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:210:1: identifier : word= ID -> {%{$word.text}};
	public final UnparseBLESS.identifier_return identifier() throws RecognitionException {
		UnparseBLESS.identifier_return retval = new UnparseBLESS.identifier_return();
		retval.start = input.LT(1);

		BAST word=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:211:2: (word= ID -> {%{$word.text}})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:212:2: word= ID
			{
			word=(BAST)match(input,ID,FOLLOW_ID_in_identifier66); if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 213:3: -> {%{$word.text}}
			  {
			  	retval.st = new StringTemplate(templateLib,(word!=null?word.getText():null));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "identifier"


	public static class annex_library_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "annex_library"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:585:1: annex_library : ^( ASSERTION_ANNEX (ass+= assertion )+ ) -> annex_library_assertion(ass=$ass);
	public final UnparseBLESS.annex_library_return annex_library() throws RecognitionException {
		UnparseBLESS.annex_library_return retval = new UnparseBLESS.annex_library_return();
		retval.start = input.LT(1);

		List<Object> list_ass=null;
		RuleReturnScope ass = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:586:2: ( ^( ASSERTION_ANNEX (ass+= assertion )+ ) -> annex_library_assertion(ass=$ass))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:587:3: ^( ASSERTION_ANNEX (ass+= assertion )+ )
			{
			match(input,ASSERTION_ANNEX,FOLLOW_ASSERTION_ANNEX_in_annex_library466); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:587:24: (ass+= assertion )+
			int cnt1=0;
			loop1:
			while (true) {
				int alt1=2;
				int LA1_0 = input.LA(1);
				if ( (LA1_0==ASSERTION||(LA1_0 >= ASSERTION_ENUMERATION && LA1_0 <= ASSERTION_FUNCTION)) ) {
					alt1=1;
				}

				switch (alt1) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:587:24: ass+= assertion
					{
					pushFollow(FOLLOW_assertion_in_annex_library470);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if (list_ass==null) list_ass=new ArrayList<Object>();
					list_ass.add(ass.getTemplate());
					}
					break;

				default :
					if ( cnt1 >= 1 ) break loop1;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(1, input);
					throw eee;
				}
				cnt1++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 588:2: -> annex_library_assertion(ass=$ass)
			  {
			  	retval.st = templateLib.getInstanceOf("annex_library_assertion",new STAttrMap().put("ass", list_ass));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "annex_library"


	public static class thread_behavior_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "thread_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1290:1: thread_behavior : ^( THREAD_ANNEX ^( LITERAL_states (bs+= behavior_state )+ ) (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? (tran= transitions )? (no_proof= DO_NOT_PROVE )? STOP ) -> thread_behavior(np=$no_proof.textsv=$sv.stbs=$bstran=$tran.stac=$ac.stinv=$inv.stname=componentName);
	public final UnparseBLESS.thread_behavior_return thread_behavior() throws RecognitionException {
		UnparseBLESS.thread_behavior_return retval = new UnparseBLESS.thread_behavior_return();
		retval.start = input.LT(1);

		BAST no_proof=null;
		List<Object> list_bs=null;
		TreeRuleReturnScope ac =null;
		TreeRuleReturnScope inv =null;
		TreeRuleReturnScope sv =null;
		TreeRuleReturnScope tran =null;
		RuleReturnScope bs = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1291:2: ( ^( THREAD_ANNEX ^( LITERAL_states (bs+= behavior_state )+ ) (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? (tran= transitions )? (no_proof= DO_NOT_PROVE )? STOP ) -> thread_behavior(np=$no_proof.textsv=$sv.stbs=$bstran=$tran.stac=$ac.stinv=$inv.stname=componentName))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1292:2: ^( THREAD_ANNEX ^( LITERAL_states (bs+= behavior_state )+ ) (ac= assert_clause )? (inv= invariant_clause )? (sv= variables )? (tran= transitions )? (no_proof= DO_NOT_PROVE )? STOP )
			{
			match(input,THREAD_ANNEX,FOLLOW_THREAD_ANNEX_in_thread_behavior1257); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			match(input,LITERAL_states,FOLLOW_LITERAL_states_in_thread_behavior1261); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1292:38: (bs+= behavior_state )+
			int cnt2=0;
			loop2:
			while (true) {
				int alt2=2;
				int LA2_0 = input.LA(1);
				if ( (LA2_0==LITERAL_state) ) {
					alt2=1;
				}

				switch (alt2) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1292:38: bs+= behavior_state
					{
					pushFollow(FOLLOW_behavior_state_in_thread_behavior1265);
					bs=behavior_state();
					state._fsp--;
					if (state.failed) return retval;
					if (list_bs==null) list_bs=new ArrayList<Object>();
					list_bs.add(bs.getTemplate());
					}
					break;

				default :
					if ( cnt2 >= 1 ) break loop2;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(2, input);
					throw eee;
				}
				cnt2++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1294:6: (ac= assert_clause )?
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==LITERAL_assert) ) {
				alt3=1;
			}
			switch (alt3) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1294:6: ac= assert_clause
					{
					pushFollow(FOLLOW_assert_clause_in_thread_behavior1277);
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1295:7: (inv= invariant_clause )?
			int alt4=2;
			int LA4_0 = input.LA(1);
			if ( (LA4_0==LITERAL_invariant) ) {
				alt4=1;
			}
			switch (alt4) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1295:7: inv= invariant_clause
					{
					pushFollow(FOLLOW_invariant_clause_in_thread_behavior1285);
					inv=invariant_clause();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1296:5: (sv= variables )?
			int alt5=2;
			int LA5_0 = input.LA(1);
			if ( (LA5_0==LITERAL_variables) ) {
				alt5=1;
			}
			switch (alt5) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1296:5: sv= variables
					{
					pushFollow(FOLLOW_variables_in_thread_behavior1292);
					sv=variables();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1297:7: (tran= transitions )?
			int alt6=2;
			int LA6_0 = input.LA(1);
			if ( (LA6_0==LITERAL_transitions) ) {
				alt6=1;
			}
			switch (alt6) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1297:7: tran= transitions
					{
					pushFollow(FOLLOW_transitions_in_thread_behavior1300);
					tran=transitions();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1298:13: (no_proof= DO_NOT_PROVE )?
			int alt7=2;
			int LA7_0 = input.LA(1);
			if ( (LA7_0==DO_NOT_PROVE) ) {
				alt7=1;
			}
			switch (alt7) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1298:13: no_proof= DO_NOT_PROVE
					{
					no_proof=(BAST)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_thread_behavior1309); if (state.failed) return retval;
					}
					break;

			}

			match(input,STOP,FOLLOW_STOP_in_thread_behavior1314); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1300:3: -> thread_behavior(np=$no_proof.textsv=$sv.stbs=$bstran=$tran.stac=$ac.stinv=$inv.stname=componentName)
			  {
			  	retval.st = templateLib.getInstanceOf("thread_behavior",new STAttrMap().put("np", (no_proof!=null?no_proof.getText():null)).put("sv", (sv!=null?((StringTemplate)sv.getTemplate()):null)).put("bs", list_bs).put("tran", (tran!=null?((StringTemplate)tran.getTemplate()):null)).put("ac", (ac!=null?((StringTemplate)ac.getTemplate()):null)).put("inv", (inv!=null?((StringTemplate)inv.getTemplate()):null)).put("name", componentName));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "thread_behavior"


	public static class assert_clause_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assert_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1312:1: assert_clause : ^( LITERAL_assert (ass+= assertion )+ ) -> template(ass=$ass) <<assert \n <ass; separator=\"\\n\"> \n>>;
	public final UnparseBLESS.assert_clause_return assert_clause() throws RecognitionException {
		UnparseBLESS.assert_clause_return retval = new UnparseBLESS.assert_clause_return();
		retval.start = input.LT(1);

		List<Object> list_ass=null;
		RuleReturnScope ass = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1313:3: ( ^( LITERAL_assert (ass+= assertion )+ ) -> template(ass=$ass) <<assert \n <ass; separator=\"\\n\"> \n>>)
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1314:3: ^( LITERAL_assert (ass+= assertion )+ )
			{
			match(input,LITERAL_assert,FOLLOW_LITERAL_assert_in_assert_clause1376); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1314:23: (ass+= assertion )+
			int cnt8=0;
			loop8:
			while (true) {
				int alt8=2;
				int LA8_0 = input.LA(1);
				if ( (LA8_0==ASSERTION||(LA8_0 >= ASSERTION_ENUMERATION && LA8_0 <= ASSERTION_FUNCTION)) ) {
					alt8=1;
				}

				switch (alt8) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1314:23: ass+= assertion
					{
					pushFollow(FOLLOW_assertion_in_assert_clause1380);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					if (list_ass==null) list_ass=new ArrayList<Object>();
					list_ass.add(ass.getTemplate());
					}
					break;

				default :
					if ( cnt8 >= 1 ) break loop8;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(8, input);
					throw eee;
				}
				cnt8++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1315:4: -> template(ass=$ass) <<assert \n <ass; separator=\"\\n\"> \n>>
			  {
			  	retval.st = new StringTemplate(templateLib, "assert \n  <ass; separator=\"\\n\"> \n",new STAttrMap().put("ass", list_ass));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assert_clause"


	public static class invariant_clause_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "invariant_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1321:1: invariant_clause : ^( LITERAL_invariant a= assertion ) -> invariant_clause(a=$a.st);
	public final UnparseBLESS.invariant_clause_return invariant_clause() throws RecognitionException {
		UnparseBLESS.invariant_clause_return retval = new UnparseBLESS.invariant_clause_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope a =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1322:3: ( ^( LITERAL_invariant a= assertion ) -> invariant_clause(a=$a.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1323:3: ^( LITERAL_invariant a= assertion )
			{
			match(input,LITERAL_invariant,FOLLOW_LITERAL_invariant_in_invariant_clause1412); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_in_invariant_clause1416);
			a=assertion();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1324:4: -> invariant_clause(a=$a.st)
			  {
			  	retval.st = templateLib.getInstanceOf("invariant_clause",new STAttrMap().put("a", (a!=null?((StringTemplate)a.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "invariant_clause"


	public static class variables_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1330:1: variables : ^( LITERAL_variables (bv+= behavior_variable )* ) -> variables(bv=$bv);
	public final UnparseBLESS.variables_return variables() throws RecognitionException {
		UnparseBLESS.variables_return retval = new UnparseBLESS.variables_return();
		retval.start = input.LT(1);

		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1331:2: ( ^( LITERAL_variables (bv+= behavior_variable )* ) -> variables(bv=$bv))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1332:2: ^( LITERAL_variables (bv+= behavior_variable )* )
			{
			match(input,LITERAL_variables,FOLLOW_LITERAL_variables_in_variables1448); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1332:24: (bv+= behavior_variable )*
				loop9:
				while (true) {
					int alt9=2;
					int LA9_0 = input.LA(1);
					if ( (LA9_0==COLON) ) {
						alt9=1;
					}

					switch (alt9) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1332:24: bv+= behavior_variable
						{
						pushFollow(FOLLOW_behavior_variable_in_variables1452);
						bv=behavior_variable();
						state._fsp--;
						if (state.failed) return retval;
						if (list_bv==null) list_bv=new ArrayList<Object>();
						list_bv.add(bv.getTemplate());
						}
						break;

					default :
						break loop9;
					}
				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1335:3: -> variables(bv=$bv)
			  {
			  	retval.st = templateLib.getInstanceOf("variables",new STAttrMap().put("bv", list_bv));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variables"


	public static class behavior_variable_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_variable"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1338:1: behavior_variable : ^( COLON ( ^( COMMA (d+= ID )+ ) |d+= ID ) ^( TYPE t= type ) ( ^(agn= ASSIGN e= expression ) )? (ass= assertion )? ( (p= LITERAL_nonvolatile |sh= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final ) )? SEMICOLON ) -> behavior_variable_type(d=$dt=$t.stp=$p.texts=$sh.textcon=$con.textsp=$sp.texte=$e.stfinl=$finl.textass=$ass.st);
	public final UnparseBLESS.behavior_variable_return behavior_variable() throws RecognitionException {
		UnparseBLESS.behavior_variable_return retval = new UnparseBLESS.behavior_variable_return();
		retval.start = input.LT(1);

		BAST agn=null;
		BAST p=null;
		BAST sh=null;
		BAST con=null;
		BAST sp=null;
		BAST finl=null;
		BAST d=null;
		List<Object> list_d=null;
		TreeRuleReturnScope t =null;
		TreeRuleReturnScope e =null;
		TreeRuleReturnScope ass =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1339:2: ( ^( COLON ( ^( COMMA (d+= ID )+ ) |d+= ID ) ^( TYPE t= type ) ( ^(agn= ASSIGN e= expression ) )? (ass= assertion )? ( (p= LITERAL_nonvolatile |sh= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final ) )? SEMICOLON ) -> behavior_variable_type(d=$dt=$t.stp=$p.texts=$sh.textcon=$con.textsp=$sp.texte=$e.stfinl=$finl.textass=$ass.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1340:2: ^( COLON ( ^( COMMA (d+= ID )+ ) |d+= ID ) ^( TYPE t= type ) ( ^(agn= ASSIGN e= expression ) )? (ass= assertion )? ( (p= LITERAL_nonvolatile |sh= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final ) )? SEMICOLON )
			{
			match(input,COLON,FOLLOW_COLON_in_behavior_variable1485); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1342:5: ( ^( COMMA (d+= ID )+ ) |d+= ID )
			int alt11=2;
			int LA11_0 = input.LA(1);
			if ( (LA11_0==COMMA) ) {
				alt11=1;
			}
			else if ( (LA11_0==ID) ) {
				alt11=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 11, 0, input);
				throw nvae;
			}

			switch (alt11) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1342:6: ^( COMMA (d+= ID )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_behavior_variable1495); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1342:15: (d+= ID )+
					int cnt10=0;
					loop10:
					while (true) {
						int alt10=2;
						int LA10_0 = input.LA(1);
						if ( (LA10_0==ID) ) {
							alt10=1;
						}

						switch (alt10) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1342:15: d+= ID
							{
							d=(BAST)match(input,ID,FOLLOW_ID_in_behavior_variable1499); if (state.failed) return retval;
							if (list_d==null) list_d=new ArrayList<Object>();
							list_d.add(d);
							}
							break;

						default :
							if ( cnt10 >= 1 ) break loop10;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(10, input);
							throw eee;
						}
						cnt10++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1342:24: d+= ID
					{
					d=(BAST)match(input,ID,FOLLOW_ID_in_behavior_variable1507); if (state.failed) return retval;
					if (list_d==null) list_d=new ArrayList<Object>();
					list_d.add(d);
					}
					break;

			}

			match(input,TYPE,FOLLOW_TYPE_in_behavior_variable1514); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_type_in_behavior_variable1518);
			t=type();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1344:4: ( ^(agn= ASSIGN e= expression ) )?
			int alt12=2;
			int LA12_0 = input.LA(1);
			if ( (LA12_0==ASSIGN) ) {
				alt12=1;
			}
			switch (alt12) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1344:6: ^(agn= ASSIGN e= expression )
					{
					agn=(BAST)match(input,ASSIGN,FOLLOW_ASSIGN_in_behavior_variable1530); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_behavior_variable1534);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1345:4: (ass= assertion )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==ASSERTION||(LA13_0 >= ASSERTION_ENUMERATION && LA13_0 <= ASSERTION_FUNCTION)) ) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1345:6: ass= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_variable1548);
					ass=assertion();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1346:4: ( (p= LITERAL_nonvolatile |sh= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final ) )?
			int alt15=2;
			int LA15_0 = input.LA(1);
			if ( (LA15_0==LITERAL_constant||LA15_0==LITERAL_final||LA15_0==LITERAL_nonvolatile||LA15_0==LITERAL_shared||LA15_0==LITERAL_spread) ) {
				alt15=1;
			}
			switch (alt15) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1346:6: (p= LITERAL_nonvolatile |sh= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1346:6: (p= LITERAL_nonvolatile |sh= LITERAL_shared |con= LITERAL_constant |sp= LITERAL_spread |finl= LITERAL_final )
					int alt14=5;
					switch ( input.LA(1) ) {
					case LITERAL_nonvolatile:
						{
						alt14=1;
						}
						break;
					case LITERAL_shared:
						{
						alt14=2;
						}
						break;
					case LITERAL_constant:
						{
						alt14=3;
						}
						break;
					case LITERAL_spread:
						{
						alt14=4;
						}
						break;
					case LITERAL_final:
						{
						alt14=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 14, 0, input);
						throw nvae;
					}
					switch (alt14) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1346:9: p= LITERAL_nonvolatile
							{
							p=(BAST)match(input,LITERAL_nonvolatile,FOLLOW_LITERAL_nonvolatile_in_behavior_variable1563); if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1347:6: sh= LITERAL_shared
							{
							sh=(BAST)match(input,LITERAL_shared,FOLLOW_LITERAL_shared_in_behavior_variable1575); if (state.failed) return retval;
							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1347:26: con= LITERAL_constant
							{
							con=(BAST)match(input,LITERAL_constant,FOLLOW_LITERAL_constant_in_behavior_variable1581); if (state.failed) return retval;
							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1348:8: sp= LITERAL_spread
							{
							sp=(BAST)match(input,LITERAL_spread,FOLLOW_LITERAL_spread_in_behavior_variable1593); if (state.failed) return retval;
							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1348:28: finl= LITERAL_final
							{
							finl=(BAST)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_variable1599); if (state.failed) return retval;
							}
							break;

					}

					}
					break;

			}

			match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_variable1609); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1351:3: -> behavior_variable_type(d=$dt=$t.stp=$p.texts=$sh.textcon=$con.textsp=$sp.texte=$e.stfinl=$finl.textass=$ass.st)
			  {
			  	retval.st = templateLib.getInstanceOf("behavior_variable_type",new STAttrMap().put("d", list_d).put("t", (t!=null?((StringTemplate)t.getTemplate()):null)).put("p", (p!=null?p.getText():null)).put("s", (sh!=null?sh.getText():null)).put("con", (con!=null?con.getText():null)).put("sp", (sp!=null?sp.getText():null)).put("e", (e!=null?((StringTemplate)e.getTemplate()):null)).put("finl", (finl!=null?finl.getText():null)).put("ass", (ass!=null?((StringTemplate)ass.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_variable"


	public static class behavior_state_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_state"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1400:1: behavior_state : ^( LITERAL_state (in= LITERAL_initial )? (com= LITERAL_complete )? (finl= LITERAL_final )? bsi= identifier (a= assertion )? ) -> behavior_state(bsi=$bsi.sti=$in.textcom=$com.textfinl=$finl.texta=$a.st);
	public final UnparseBLESS.behavior_state_return behavior_state() throws RecognitionException {
		UnparseBLESS.behavior_state_return retval = new UnparseBLESS.behavior_state_return();
		retval.start = input.LT(1);

		BAST in=null;
		BAST com=null;
		BAST finl=null;
		TreeRuleReturnScope bsi =null;
		TreeRuleReturnScope a =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1401:2: ( ^( LITERAL_state (in= LITERAL_initial )? (com= LITERAL_complete )? (finl= LITERAL_final )? bsi= identifier (a= assertion )? ) -> behavior_state(bsi=$bsi.sti=$in.textcom=$com.textfinl=$finl.texta=$a.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:2: ^( LITERAL_state (in= LITERAL_initial )? (com= LITERAL_complete )? (finl= LITERAL_final )? bsi= identifier (a= assertion )? )
			{
			match(input,LITERAL_state,FOLLOW_LITERAL_state_in_behavior_state1686); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:20: (in= LITERAL_initial )?
			int alt16=2;
			int LA16_0 = input.LA(1);
			if ( (LA16_0==LITERAL_initial) ) {
				alt16=1;
			}
			switch (alt16) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:20: in= LITERAL_initial
					{
					in=(BAST)match(input,LITERAL_initial,FOLLOW_LITERAL_initial_in_behavior_state1690); if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:41: (com= LITERAL_complete )?
			int alt17=2;
			int LA17_0 = input.LA(1);
			if ( (LA17_0==LITERAL_complete) ) {
				alt17=1;
			}
			switch (alt17) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:41: com= LITERAL_complete
					{
					com=(BAST)match(input,LITERAL_complete,FOLLOW_LITERAL_complete_in_behavior_state1695); if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:64: (finl= LITERAL_final )?
			int alt18=2;
			int LA18_0 = input.LA(1);
			if ( (LA18_0==LITERAL_final) ) {
				alt18=1;
			}
			switch (alt18) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:64: finl= LITERAL_final
					{
					finl=(BAST)match(input,LITERAL_final,FOLLOW_LITERAL_final_in_behavior_state1700); if (state.failed) return retval;
					}
					break;

			}

			pushFollow(FOLLOW_identifier_in_behavior_state1705);
			bsi=identifier();
			state._fsp--;
			if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:96: (a= assertion )?
			int alt19=2;
			int LA19_0 = input.LA(1);
			if ( (LA19_0==ASSERTION||(LA19_0 >= ASSERTION_ENUMERATION && LA19_0 <= ASSERTION_FUNCTION)) ) {
				alt19=1;
			}
			switch (alt19) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1402:96: a= assertion
					{
					pushFollow(FOLLOW_assertion_in_behavior_state1709);
					a=assertion();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1403:3: -> behavior_state(bsi=$bsi.sti=$in.textcom=$com.textfinl=$finl.texta=$a.st)
			  {
			  	retval.st = templateLib.getInstanceOf("behavior_state",new STAttrMap().put("bsi", (bsi!=null?((StringTemplate)bsi.getTemplate()):null)).put("i", (in!=null?in.getText():null)).put("com", (com!=null?com.getText():null)).put("finl", (finl!=null?finl.getText():null)).put("a", (a!=null?((StringTemplate)a.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_state"


	public static class transitions_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "transitions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1409:1: transitions : ^( LITERAL_transitions (bt+= behavior_transition )+ ) -> transitions(bt=$bt);
	public final UnparseBLESS.transitions_return transitions() throws RecognitionException {
		UnparseBLESS.transitions_return retval = new UnparseBLESS.transitions_return();
		retval.start = input.LT(1);

		List<Object> list_bt=null;
		RuleReturnScope bt = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1410:2: ( ^( LITERAL_transitions (bt+= behavior_transition )+ ) -> transitions(bt=$bt))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1411:2: ^( LITERAL_transitions (bt+= behavior_transition )+ )
			{
			match(input,LITERAL_transitions,FOLLOW_LITERAL_transitions_in_transitions1760); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1411:26: (bt+= behavior_transition )+
			int cnt20=0;
			loop20:
			while (true) {
				int alt20=2;
				int LA20_0 = input.LA(1);
				if ( (LA20_0==TRANSITION) ) {
					alt20=1;
				}

				switch (alt20) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1411:26: bt+= behavior_transition
					{
					pushFollow(FOLLOW_behavior_transition_in_transitions1764);
					bt=behavior_transition();
					state._fsp--;
					if (state.failed) return retval;
					if (list_bt==null) list_bt=new ArrayList<Object>();
					list_bt.add(bt.getTemplate());
					}
					break;

				default :
					if ( cnt20 >= 1 ) break loop20;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(20, input);
					throw eee;
				}
				cnt20++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1412:3: -> transitions(bt=$bt)
			  {
			  	retval.st = templateLib.getInstanceOf("transitions",new STAttrMap().put("bt", list_bt));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "transitions"


	public static class behavior_transition_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_transition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1419:1: behavior_transition : ^( TRANSITION ^( LABEL (btl= behavior_transition_label )? ) ^( SOURCE (ssi+= ID )+ ) ^( CONDITION (bc= behavior_condition )? ) ^( DESTINATION dsi= ID ) ^( ACTION (ba= behavior_actions )? ) ^( Q (btq= assertion )? ) ) -> behavior_transition(btl=$btl.stssi=$ssibc=$bc.stdsi=$dsi.textba=$ba.stbtq=$btq.st);
	public final UnparseBLESS.behavior_transition_return behavior_transition() throws RecognitionException {
		UnparseBLESS.behavior_transition_return retval = new UnparseBLESS.behavior_transition_return();
		retval.start = input.LT(1);

		BAST dsi=null;
		BAST ssi=null;
		List<Object> list_ssi=null;
		TreeRuleReturnScope btl =null;
		TreeRuleReturnScope bc =null;
		TreeRuleReturnScope ba =null;
		TreeRuleReturnScope btq =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1420:2: ( ^( TRANSITION ^( LABEL (btl= behavior_transition_label )? ) ^( SOURCE (ssi+= ID )+ ) ^( CONDITION (bc= behavior_condition )? ) ^( DESTINATION dsi= ID ) ^( ACTION (ba= behavior_actions )? ) ^( Q (btq= assertion )? ) ) -> behavior_transition(btl=$btl.stssi=$ssibc=$bc.stdsi=$dsi.textba=$ba.stbtq=$btq.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1421:2: ^( TRANSITION ^( LABEL (btl= behavior_transition_label )? ) ^( SOURCE (ssi+= ID )+ ) ^( CONDITION (bc= behavior_condition )? ) ^( DESTINATION dsi= ID ) ^( ACTION (ba= behavior_actions )? ) ^( Q (btq= assertion )? ) )
			{
			match(input,TRANSITION,FOLLOW_TRANSITION_in_behavior_transition1799); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			match(input,LABEL,FOLLOW_LABEL_in_behavior_transition1803); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1421:28: (btl= behavior_transition_label )?
				int alt21=2;
				int LA21_0 = input.LA(1);
				if ( (LA21_0==ID) ) {
					alt21=1;
				}
				switch (alt21) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1421:28: btl= behavior_transition_label
						{
						pushFollow(FOLLOW_behavior_transition_label_in_behavior_transition1807);
						btl=behavior_transition_label();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input,SOURCE,FOLLOW_SOURCE_in_behavior_transition1814); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1421:71: (ssi+= ID )+
			int cnt22=0;
			loop22:
			while (true) {
				int alt22=2;
				int LA22_0 = input.LA(1);
				if ( (LA22_0==ID) ) {
					alt22=1;
				}

				switch (alt22) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1421:71: ssi+= ID
					{
					ssi=(BAST)match(input,ID,FOLLOW_ID_in_behavior_transition1818); if (state.failed) return retval;
					if (list_ssi==null) list_ssi=new ArrayList<Object>();
					list_ssi.add(ssi);
					}
					break;

				default :
					if ( cnt22 >= 1 ) break loop22;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(22, input);
					throw eee;
				}
				cnt22++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			match(input,CONDITION,FOLLOW_CONDITION_in_behavior_transition1829); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1422:18: (bc= behavior_condition )?
				int alt23=2;
				int LA23_0 = input.LA(1);
				if ( (LA23_0==AADL_STRING_LITERAL||(LA23_0 >= AL && LA23_0 <= AM)||LA23_0==CASE_EXPRESSION||LA23_0==COMPLEX||LA23_0==CONDITIONAL||LA23_0==DIVIDE||LA23_0==DOUBLE_COLON||LA23_0==EQ||LA23_0==EXP||(LA23_0 >= FUNCTION_CALL && LA23_0 <= GT)||LA23_0==ID||LA23_0==INMODE||LA23_0==INTEGER_LIT||LA23_0==LITERAL_and||LA23_0==LITERAL_cand||LA23_0==LITERAL_complex||LA23_0==LITERAL_cor||LA23_0==LITERAL_dispatch||LA23_0==LITERAL_false||LA23_0==LITERAL_integer||LA23_0==LITERAL_mod||LA23_0==LITERAL_natural||(LA23_0 >= LITERAL_not && LA23_0 <= LITERAL_now)||LA23_0==LITERAL_null||(LA23_0 >= LITERAL_on && LA23_0 <= LITERAL_or)||(LA23_0 >= LITERAL_rational && LA23_0 <= LITERAL_real)||LA23_0==LITERAL_rem||(LA23_0 >= LITERAL_time && LA23_0 <= LITERAL_timeout)||LA23_0==LITERAL_tops||LA23_0==LITERAL_true||(LA23_0 >= LITERAL_xor && LA23_0 <= LT)||LA23_0==MINUS||LA23_0==NEQ||LA23_0==OCTOTHORPE||(LA23_0 >= PERIOD && LA23_0 <= PLUS)||LA23_0==QUESTION||LA23_0==RATIONAL||LA23_0==REAL_LIT||LA23_0==TICK||LA23_0==TIMES||LA23_0==UNARY_MINUS) ) {
					alt23=1;
				}
				switch (alt23) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1422:18: bc= behavior_condition
						{
						pushFollow(FOLLOW_behavior_condition_in_behavior_transition1833);
						bc=behavior_condition();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input,DESTINATION,FOLLOW_DESTINATION_in_behavior_transition1843); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			dsi=(BAST)match(input,ID,FOLLOW_ID_in_behavior_transition1847); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			match(input,ACTION,FOLLOW_ACTION_in_behavior_transition1853); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1423:39: (ba= behavior_actions )?
				int alt24=2;
				int LA24_0 = input.LA(1);
				if ( (LA24_0==ACTION||LA24_0==AMPERSAND||LA24_0==SEMICOLON) ) {
					alt24=1;
				}
				switch (alt24) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1423:39: ba= behavior_actions
						{
						pushFollow(FOLLOW_behavior_actions_in_behavior_transition1857);
						ba=behavior_actions();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input,Q,FOLLOW_Q_in_behavior_transition1864); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1423:68: (btq= assertion )?
				int alt25=2;
				int LA25_0 = input.LA(1);
				if ( (LA25_0==ASSERTION||(LA25_0 >= ASSERTION_ENUMERATION && LA25_0 <= ASSERTION_FUNCTION)) ) {
					alt25=1;
				}
				switch (alt25) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1423:68: btq= assertion
						{
						pushFollow(FOLLOW_assertion_in_behavior_transition1868);
						btq=assertion();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1424:3: -> behavior_transition(btl=$btl.stssi=$ssibc=$bc.stdsi=$dsi.textba=$ba.stbtq=$btq.st)
			  {
			  	retval.st = templateLib.getInstanceOf("behavior_transition",new STAttrMap().put("btl", (btl!=null?((StringTemplate)btl.getTemplate()):null)).put("ssi", list_ssi).put("bc", (bc!=null?((StringTemplate)bc.getTemplate()):null)).put("dsi", (dsi!=null?dsi.getText():null)).put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)).put("btq", (btq!=null?((StringTemplate)btq.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition"


	public static class behavior_transition_label_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_transition_label"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1429:1: behavior_transition_label : ( ^(i= ID n= INTEGER_LIT ) -> template(i=$i.textn=$n.text) \"<i>[<n>]\"|i2= ID -> template(i2=$i2.text) \"<i2>\");
	public final UnparseBLESS.behavior_transition_label_return behavior_transition_label() throws RecognitionException {
		UnparseBLESS.behavior_transition_label_return retval = new UnparseBLESS.behavior_transition_label_return();
		retval.start = input.LT(1);

		BAST i=null;
		BAST n=null;
		BAST i2=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1430:2: ( ^(i= ID n= INTEGER_LIT ) -> template(i=$i.textn=$n.text) \"<i>[<n>]\"|i2= ID -> template(i2=$i2.text) \"<i2>\")
			int alt26=2;
			int LA26_0 = input.LA(1);
			if ( (LA26_0==ID) ) {
				int LA26_1 = input.LA(2);
				if ( (LA26_1==DOWN) ) {
					alt26=1;
				}
				else if ( (LA26_1==UP) ) {
					alt26=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 26, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 26, 0, input);
				throw nvae;
			}

			switch (alt26) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1431:2: ^(i= ID n= INTEGER_LIT )
					{
					i=(BAST)match(input,ID,FOLLOW_ID_in_behavior_transition_label1923); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					n=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_behavior_transition_label1927); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1432:3: -> template(i=$i.textn=$n.text) \"<i>[<n>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i>[<n>]",new STAttrMap().put("i", (i!=null?i.getText():null)).put("n", (n!=null?n.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1434:2: i2= ID
					{
					i2=(BAST)match(input,ID,FOLLOW_ID_in_behavior_transition_label1952); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1435:3: -> template(i2=$i2.text) \"<i2>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i2>",new STAttrMap().put("i2", (i2!=null?i2.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_transition_label"


	public static class behavior_condition_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1438:1: behavior_condition : (dc= dispatch_condition -> {$dc.st}|e= execute_condition -> {$e.st}|c= mode_condition -> {$c.st});
	public final UnparseBLESS.behavior_condition_return behavior_condition() throws RecognitionException {
		UnparseBLESS.behavior_condition_return retval = new UnparseBLESS.behavior_condition_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope dc =null;
		TreeRuleReturnScope e =null;
		TreeRuleReturnScope c =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1439:2: (dc= dispatch_condition -> {$dc.st}|e= execute_condition -> {$e.st}|c= mode_condition -> {$c.st})
			int alt27=3;
			switch ( input.LA(1) ) {
			case LITERAL_dispatch:
				{
				alt27=1;
				}
				break;
			case AADL_STRING_LITERAL:
			case AL:
			case AM:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DIVIDE:
			case DOUBLE_COLON:
			case EQ:
			case EXP:
			case FUNCTION_CALL:
			case GT:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_and:
			case LITERAL_cand:
			case LITERAL_complex:
			case LITERAL_cor:
			case LITERAL_false:
			case LITERAL_integer:
			case LITERAL_mod:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_or:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_rem:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LITERAL_xor:
			case LPAREN:
			case LT:
			case MINUS:
			case NEQ:
			case OCTOTHORPE:
			case PERIOD:
			case PLUS:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
			case TIMES:
			case UNARY_MINUS:
				{
				alt27=2;
				}
				break;
			case LITERAL_on:
				{
				alt27=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 27, 0, input);
				throw nvae;
			}
			switch (alt27) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1440:2: dc= dispatch_condition
					{
					pushFollow(FOLLOW_dispatch_condition_in_behavior_condition1981);
					dc=dispatch_condition();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1441:3: -> {$dc.st}
					  {
					  	retval.st = (dc!=null?((StringTemplate)dc.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1442:4: e= execute_condition
					{
					pushFollow(FOLLOW_execute_condition_in_behavior_condition1996);
					e=execute_condition();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1443:3: -> {$e.st}
					  {
					  	retval.st = (e!=null?((StringTemplate)e.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1444:4: c= mode_condition
					{
					pushFollow(FOLLOW_mode_condition_in_behavior_condition2009);
					c=mode_condition();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1445:3: -> {$c.st}
					  {
					  	retval.st = (c!=null?((StringTemplate)c.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_condition"


	public static class execute_condition_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "execute_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1448:1: execute_condition : be= expression_or_relation -> {$be.st};
	public final UnparseBLESS.execute_condition_return execute_condition() throws RecognitionException {
		UnparseBLESS.execute_condition_return retval = new UnparseBLESS.execute_condition_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope be =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1449:2: (be= expression_or_relation -> {$be.st})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1450:2: be= expression_or_relation
			{
			pushFollow(FOLLOW_expression_or_relation_in_execute_condition2033);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1451:3: -> {$be.st}
			  {
			  	retval.st = (be!=null?((StringTemplate)be.getTemplate()):null);
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "execute_condition"


	public static class mode_condition_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "mode_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1455:1: mode_condition : ^( LITERAL_on mt= trigger_logical_expression ) -> template(mt=$mt.st) \"on <mt>\";
	public final UnparseBLESS.mode_condition_return mode_condition() throws RecognitionException {
		UnparseBLESS.mode_condition_return retval = new UnparseBLESS.mode_condition_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope mt =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1456:3: ( ^( LITERAL_on mt= trigger_logical_expression ) -> template(mt=$mt.st) \"on <mt>\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1457:4: ^( LITERAL_on mt= trigger_logical_expression )
			{
			match(input,LITERAL_on,FOLLOW_LITERAL_on_in_mode_condition2057); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_trigger_logical_expression_in_mode_condition2061);
			mt=trigger_logical_expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1458:6: -> template(mt=$mt.st) \"on <mt>\"
			  {
			  	retval.st = new StringTemplate(templateLib, "on <mt>",new STAttrMap().put("mt", (mt!=null?((StringTemplate)mt.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mode_condition"


	public static class trigger_logical_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "trigger_logical_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1461:1: trigger_logical_expression : (et= event_trigger -> {$et.st}| ^( LITERAL_and triggers+= event_trigger ) -> l_and(bs=$triggers)| ^( LITERAL_or triggers+= event_trigger ) -> l_or(bs=$triggers)| ^( LITERAL_xor triggers+= event_trigger ) -> l_xor(bs=$triggers)| ^( LITERAL_cand triggers+= event_trigger ) -> l_cand(bs=$triggers)| ^( LITERAL_cor triggers+= event_trigger ) -> l_cor(bs=$triggers));
	public final UnparseBLESS.trigger_logical_expression_return trigger_logical_expression() throws RecognitionException {
		UnparseBLESS.trigger_logical_expression_return retval = new UnparseBLESS.trigger_logical_expression_return();
		retval.start = input.LT(1);

		List<Object> list_triggers=null;
		TreeRuleReturnScope et =null;
		RuleReturnScope triggers = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1462:3: (et= event_trigger -> {$et.st}| ^( LITERAL_and triggers+= event_trigger ) -> l_and(bs=$triggers)| ^( LITERAL_or triggers+= event_trigger ) -> l_or(bs=$triggers)| ^( LITERAL_xor triggers+= event_trigger ) -> l_xor(bs=$triggers)| ^( LITERAL_cand triggers+= event_trigger ) -> l_cand(bs=$triggers)| ^( LITERAL_cor triggers+= event_trigger ) -> l_cor(bs=$triggers))
			int alt28=6;
			switch ( input.LA(1) ) {
			case ID:
			case LPAREN:
			case PERIOD:
				{
				alt28=1;
				}
				break;
			case LITERAL_and:
				{
				alt28=2;
				}
				break;
			case LITERAL_or:
				{
				alt28=3;
				}
				break;
			case LITERAL_xor:
				{
				alt28=4;
				}
				break;
			case LITERAL_cand:
				{
				alt28=5;
				}
				break;
			case LITERAL_cor:
				{
				alt28=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 28, 0, input);
				throw nvae;
			}
			switch (alt28) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1463:3: et= event_trigger
					{
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression2094);
					et=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1464:5: -> {$et.st}
					  {
					  	retval.st = (et!=null?((StringTemplate)et.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1466:3: ^( LITERAL_and triggers+= event_trigger )
					{
					match(input,LITERAL_and,FOLLOW_LITERAL_and_in_trigger_logical_expression2111); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression2115);
					triggers=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if (list_triggers==null) list_triggers=new ArrayList<Object>();
					list_triggers.add(triggers.getTemplate());
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1467:5: -> l_and(bs=$triggers)
					  {
					  	retval.st = templateLib.getInstanceOf("l_and",new STAttrMap().put("bs", list_triggers));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1470:3: ^( LITERAL_or triggers+= event_trigger )
					{
					match(input,LITERAL_or,FOLLOW_LITERAL_or_in_trigger_logical_expression2139); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression2143);
					triggers=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if (list_triggers==null) list_triggers=new ArrayList<Object>();
					list_triggers.add(triggers.getTemplate());
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1471:5: -> l_or(bs=$triggers)
					  {
					  	retval.st = templateLib.getInstanceOf("l_or",new STAttrMap().put("bs", list_triggers));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1474:3: ^( LITERAL_xor triggers+= event_trigger )
					{
					match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_trigger_logical_expression2167); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression2171);
					triggers=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if (list_triggers==null) list_triggers=new ArrayList<Object>();
					list_triggers.add(triggers.getTemplate());
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1475:5: -> l_xor(bs=$triggers)
					  {
					  	retval.st = templateLib.getInstanceOf("l_xor",new STAttrMap().put("bs", list_triggers));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1478:3: ^( LITERAL_cand triggers+= event_trigger )
					{
					match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_trigger_logical_expression2195); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression2199);
					triggers=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if (list_triggers==null) list_triggers=new ArrayList<Object>();
					list_triggers.add(triggers.getTemplate());
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1479:5: -> l_cand(bs=$triggers)
					  {
					  	retval.st = templateLib.getInstanceOf("l_cand",new STAttrMap().put("bs", list_triggers));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1482:3: ^( LITERAL_cor triggers+= event_trigger )
					{
					match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_trigger_logical_expression2223); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_event_trigger_in_trigger_logical_expression2227);
					triggers=event_trigger();
					state._fsp--;
					if (state.failed) return retval;
					if (list_triggers==null) list_triggers=new ArrayList<Object>();
					list_triggers.add(triggers.getTemplate());
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1483:6: -> l_cor(bs=$triggers)
					  {
					  	retval.st = templateLib.getInstanceOf("l_cor",new STAttrMap().put("bs", list_triggers));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trigger_logical_expression"


	public static class event_trigger_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "event_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1487:1: event_trigger : (port= ID -> {%{$port.text}}| ^( PERIOD id+= ID ) -> template(id=$id) \"<id, separator=\".\">\"| ^( LPAREN tle= trigger_logical_expression RPAREN ) -> template(tle=$tle.st) \"(<tle>)\");
	public final UnparseBLESS.event_trigger_return event_trigger() throws RecognitionException {
		UnparseBLESS.event_trigger_return retval = new UnparseBLESS.event_trigger_return();
		retval.start = input.LT(1);

		BAST port=null;
		BAST id=null;
		List<Object> list_id=null;
		TreeRuleReturnScope tle =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1488:3: (port= ID -> {%{$port.text}}| ^( PERIOD id+= ID ) -> template(id=$id) \"<id, separator=\".\">\"| ^( LPAREN tle= trigger_logical_expression RPAREN ) -> template(tle=$tle.st) \"(<tle>)\")
			int alt29=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt29=1;
				}
				break;
			case PERIOD:
				{
				alt29=2;
				}
				break;
			case LPAREN:
				{
				alt29=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 29, 0, input);
				throw nvae;
			}
			switch (alt29) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1489:3: port= ID
					{
					port=(BAST)match(input,ID,FOLLOW_ID_in_event_trigger2261); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1490:5: -> {%{$port.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(port!=null?port.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1492:3: ^( PERIOD id+= ID )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_event_trigger2278); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					id=(BAST)match(input,ID,FOLLOW_ID_in_event_trigger2282); if (state.failed) return retval;
					if (list_id==null) list_id=new ArrayList<Object>();
					list_id.add(id);
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1493:5: -> template(id=$id) \"<id, separator=\".\">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<id, separator=\".\">",new STAttrMap().put("id", list_id));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1495:3: ^( LPAREN tle= trigger_logical_expression RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_event_trigger2308); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_trigger_logical_expression_in_event_trigger2312);
					tle=trigger_logical_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input,RPAREN,FOLLOW_RPAREN_in_event_trigger2314); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1496:5: -> template(tle=$tle.st) \"(<tle>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<tle>)",new STAttrMap().put("tle", (tle!=null?((StringTemplate)tle.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "event_trigger"


	public static class subprogram_behavior_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "subprogram_behavior"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1502:1: subprogram_behavior : ^( SUBPROGRAM_ANNEX (ac= assert_clause )? ( ^( LITERAL_pre p1= assertion ) )? ( ^( LITERAL_post p2= assertion ) )? elq= existential_lattice_quantification ) (no_proof= DO_NOT_PROVE )? -> subprogram_behavior(np=$no_proof.textac=$ac.stp1=$p1.stp2=$p2.stelq=$elq.st);
	public final UnparseBLESS.subprogram_behavior_return subprogram_behavior() throws RecognitionException {
		UnparseBLESS.subprogram_behavior_return retval = new UnparseBLESS.subprogram_behavior_return();
		retval.start = input.LT(1);

		BAST no_proof=null;
		TreeRuleReturnScope ac =null;
		TreeRuleReturnScope p1 =null;
		TreeRuleReturnScope p2 =null;
		TreeRuleReturnScope elq =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1503:2: ( ^( SUBPROGRAM_ANNEX (ac= assert_clause )? ( ^( LITERAL_pre p1= assertion ) )? ( ^( LITERAL_post p2= assertion ) )? elq= existential_lattice_quantification ) (no_proof= DO_NOT_PROVE )? -> subprogram_behavior(np=$no_proof.textac=$ac.stp1=$p1.stp2=$p2.stelq=$elq.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1504:2: ^( SUBPROGRAM_ANNEX (ac= assert_clause )? ( ^( LITERAL_pre p1= assertion ) )? ( ^( LITERAL_post p2= assertion ) )? elq= existential_lattice_quantification ) (no_proof= DO_NOT_PROVE )?
			{
			match(input,SUBPROGRAM_ANNEX,FOLLOW_SUBPROGRAM_ANNEX_in_subprogram_behavior2349); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1506:5: (ac= assert_clause )?
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==LITERAL_assert) ) {
				alt30=1;
			}
			switch (alt30) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1506:5: ac= assert_clause
					{
					pushFollow(FOLLOW_assert_clause_in_subprogram_behavior2357);
					ac=assert_clause();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1507:3: ( ^( LITERAL_pre p1= assertion ) )?
			int alt31=2;
			int LA31_0 = input.LA(1);
			if ( (LA31_0==LITERAL_pre) ) {
				alt31=1;
			}
			switch (alt31) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1507:5: ^( LITERAL_pre p1= assertion )
					{
					match(input,LITERAL_pre,FOLLOW_LITERAL_pre_in_subprogram_behavior2365); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_in_subprogram_behavior2369);
					p1=assertion();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1508:3: ( ^( LITERAL_post p2= assertion ) )?
			int alt32=2;
			int LA32_0 = input.LA(1);
			if ( (LA32_0==LITERAL_post) ) {
				alt32=1;
			}
			switch (alt32) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1508:5: ^( LITERAL_post p2= assertion )
					{
					match(input,LITERAL_post,FOLLOW_LITERAL_post_in_subprogram_behavior2381); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_in_subprogram_behavior2385);
					p2=assertion();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					}
					break;

			}

			pushFollow(FOLLOW_existential_lattice_quantification_in_subprogram_behavior2395);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1510:13: (no_proof= DO_NOT_PROVE )?
			int alt33=2;
			int LA33_0 = input.LA(1);
			if ( (LA33_0==DO_NOT_PROVE) ) {
				alt33=1;
			}
			switch (alt33) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1510:13: no_proof= DO_NOT_PROVE
					{
					no_proof=(BAST)match(input,DO_NOT_PROVE,FOLLOW_DO_NOT_PROVE_in_subprogram_behavior2405); if (state.failed) return retval;
					}
					break;

			}

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1511:2: -> subprogram_behavior(np=$no_proof.textac=$ac.stp1=$p1.stp2=$p2.stelq=$elq.st)
			  {
			  	retval.st = templateLib.getInstanceOf("subprogram_behavior",new STAttrMap().put("np", (no_proof!=null?no_proof.getText():null)).put("ac", (ac!=null?((StringTemplate)ac.getTemplate()):null)).put("p1", (p1!=null?((StringTemplate)p1.getTemplate()):null)).put("p2", (p2!=null?((StringTemplate)p2.getTemplate()):null)).put("elq", (elq!=null?((StringTemplate)elq.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subprogram_behavior"


	public static class asserted_action_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "asserted_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1515:1: asserted_action : aas= asserted_action_stub -> {$aas.code};
	public final UnparseBLESS.asserted_action_return asserted_action() throws RecognitionException {
		UnparseBLESS.asserted_action_return retval = new UnparseBLESS.asserted_action_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope aas =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1516:2: (aas= asserted_action_stub -> {$aas.code})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1517:2: aas= asserted_action_stub
			{
			pushFollow(FOLLOW_asserted_action_stub_in_asserted_action2447);
			aas=asserted_action_stub();
			state._fsp--;
			if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1518:3: -> {$aas.code}
			  {
			  	retval.st = (aas!=null?((UnparseBLESS.asserted_action_stub_return)aas).code:null);
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "asserted_action"


	public static class asserted_action_stub_return extends TreeRuleReturnScope {
		public StringTemplate code=Global.templates.getInstanceOf("asserted_action");
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "asserted_action_stub"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1521:1: asserted_action_stub returns [StringTemplate code=Global.templates.getInstanceOf(\"asserted_action\")] : ^( ACTION ^( P (pr= assertion )? ) ^( S s= action ) ^( Q (po= assertion )? ) ) ;
	public final UnparseBLESS.asserted_action_stub_return asserted_action_stub() throws RecognitionException {
		UnparseBLESS.asserted_action_stub_return retval = new UnparseBLESS.asserted_action_stub_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope pr =null;
		TreeRuleReturnScope s =null;
		TreeRuleReturnScope po =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1522:2: ( ^( ACTION ^( P (pr= assertion )? ) ^( S s= action ) ^( Q (po= assertion )? ) ) )
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1523:2: ^( ACTION ^( P (pr= assertion )? ) ^( S s= action ) ^( Q (po= assertion )? ) )
			{
			match(input,ACTION,FOLLOW_ACTION_in_asserted_action_stub2472); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			match(input,P,FOLLOW_P_in_asserted_action_stub2478); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1524:7: (pr= assertion )?
				int alt34=2;
				int LA34_0 = input.LA(1);
				if ( (LA34_0==ASSERTION||(LA34_0 >= ASSERTION_ENUMERATION && LA34_0 <= ASSERTION_FUNCTION)) ) {
					alt34=1;
				}
				switch (alt34) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1524:8: pr= assertion
						{
						pushFollow(FOLLOW_assertion_in_asserted_action_stub2483);
						pr=assertion();
						state._fsp--;
						if (state.failed) return retval;
						if ( state.backtracking==0 ) { retval.code.setAttribute("p", pr);}
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input,S,FOLLOW_S_in_asserted_action_stub2496); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_action_in_asserted_action_stub2500);
			s=action();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) {retval.code.setAttribute("s", s);}
			match(input, Token.UP, null); if (state.failed) return retval;

			match(input,Q,FOLLOW_Q_in_asserted_action_stub2509); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1526:7: (po= assertion )?
				int alt35=2;
				int LA35_0 = input.LA(1);
				if ( (LA35_0==ASSERTION||(LA35_0 >= ASSERTION_ENUMERATION && LA35_0 <= ASSERTION_FUNCTION)) ) {
					alt35=1;
				}
				switch (alt35) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1526:8: po= assertion
						{
						pushFollow(FOLLOW_assertion_in_asserted_action_stub2514);
						po=assertion();
						state._fsp--;
						if (state.failed) return retval;
						if ( state.backtracking==0 ) {retval.code.setAttribute("q", po);}
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "asserted_action_stub"


	public static class action_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1529:1: action : (ba= basic_action -> {$ba.st}|alt= alternative -> {$alt.st}|ulq= universal_lattice_quantification -> {$ulq.st}|wl= while_loop -> {$wl.st}|dul= do_until_loop -> {$dul.st}|fl= for_loop -> {$fl.st}|elq= existential_lattice_quantification -> {$elq.st});
	public final UnparseBLESS.action_return action() throws RecognitionException {
		UnparseBLESS.action_return retval = new UnparseBLESS.action_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope ba =null;
		TreeRuleReturnScope alt =null;
		TreeRuleReturnScope ulq =null;
		TreeRuleReturnScope wl =null;
		TreeRuleReturnScope dul =null;
		TreeRuleReturnScope fl =null;
		TreeRuleReturnScope elq =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1530:2: (ba= basic_action -> {$ba.st}|alt= alternative -> {$alt.st}|ulq= universal_lattice_quantification -> {$ulq.st}|wl= while_loop -> {$wl.st}|dul= do_until_loop -> {$dul.st}|fl= for_loop -> {$fl.st}|elq= existential_lattice_quantification -> {$elq.st})
			int alt36=7;
			switch ( input.LA(1) ) {
			case ASSIGN:
			case LITERAL_computation:
			case LITERAL_delay:
			case LITERAL_exception:
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_pause:
			case LITERAL_setmode:
			case LITERAL_skip:
			case LITERAL_swap:
			case LITERAL_when:
			case PORT_INPUT:
			case PORT_OUTPUT:
			case PROCEDURE_CALL:
				{
				alt36=1;
				}
				break;
			case LITERAL_if:
				{
				alt36=2;
				}
				break;
			case LITERAL_forall:
				{
				alt36=3;
				}
				break;
			case LITERAL_while:
				{
				alt36=4;
				}
				break;
			case LITERAL_do:
				{
				alt36=5;
				}
				break;
			case LITERAL_for:
				{
				alt36=6;
				}
				break;
			case LCURLY:
				{
				alt36=7;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 36, 0, input);
				throw nvae;
			}
			switch (alt36) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1531:2: ba= basic_action
					{
					pushFollow(FOLLOW_basic_action_in_action2539);
					ba=basic_action();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1532:5: -> {$ba.st}
					  {
					  	retval.st = (ba!=null?((StringTemplate)ba.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1533:4: alt= alternative
					{
					pushFollow(FOLLOW_alternative_in_action2555);
					alt=alternative();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1534:5: -> {$alt.st}
					  {
					  	retval.st = (alt!=null?((StringTemplate)alt.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1535:4: ulq= universal_lattice_quantification
					{
					pushFollow(FOLLOW_universal_lattice_quantification_in_action2569);
					ulq=universal_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1536:5: -> {$ulq.st}
					  {
					  	retval.st = (ulq!=null?((StringTemplate)ulq.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1537:4: wl= while_loop
					{
					pushFollow(FOLLOW_while_loop_in_action2583);
					wl=while_loop();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1538:5: -> {$wl.st}
					  {
					  	retval.st = (wl!=null?((StringTemplate)wl.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1539:4: dul= do_until_loop
					{
					pushFollow(FOLLOW_do_until_loop_in_action2597);
					dul=do_until_loop();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1540:5: -> {$dul.st}
					  {
					  	retval.st = (dul!=null?((StringTemplate)dul.getTemplate()):null);
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1541:4: fl= for_loop
					{
					pushFollow(FOLLOW_for_loop_in_action2611);
					fl=for_loop();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1542:5: -> {$fl.st}
					  {
					  	retval.st = (fl!=null?((StringTemplate)fl.getTemplate()):null);
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1543:4: elq= existential_lattice_quantification
					{
					pushFollow(FOLLOW_existential_lattice_quantification_in_action2625);
					elq=existential_lattice_quantification();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1544:5: -> {$elq.st}
					  {
					  	retval.st = (elq!=null?((StringTemplate)elq.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "action"


	public static class alternative_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "alternative"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1547:1: alternative : ^( LITERAL_if (gf+= guarded_action )+ ) -> alternative(gf=$gf);
	public final UnparseBLESS.alternative_return alternative() throws RecognitionException {
		UnparseBLESS.alternative_return retval = new UnparseBLESS.alternative_return();
		retval.start = input.LT(1);

		List<Object> list_gf=null;
		RuleReturnScope gf = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1548:2: ( ^( LITERAL_if (gf+= guarded_action )+ ) -> alternative(gf=$gf))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1549:2: ^( LITERAL_if (gf+= guarded_action )+ )
			{
			match(input,LITERAL_if,FOLLOW_LITERAL_if_in_alternative2647); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1550:6: (gf+= guarded_action )+
			int cnt37=0;
			loop37:
			while (true) {
				int alt37=2;
				int LA37_0 = input.LA(1);
				if ( (LA37_0==GUARD) ) {
					alt37=1;
				}

				switch (alt37) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1550:6: gf+= guarded_action
					{
					pushFollow(FOLLOW_guarded_action_in_alternative2655);
					gf=guarded_action();
					state._fsp--;
					if (state.failed) return retval;
					if (list_gf==null) list_gf=new ArrayList<Object>();
					list_gf.add(gf.getTemplate());
					}
					break;

				default :
					if ( cnt37 >= 1 ) break loop37;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(37, input);
					throw eee;
				}
				cnt37++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1551:3: -> alternative(gf=$gf)
			  {
			  	retval.st = templateLib.getInstanceOf("alternative",new STAttrMap().put("gf", list_gf));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "alternative"


	public static class guarded_action_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "guarded_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1559:1: guarded_action : ^( GUARD be= expression_or_relation ba= asserted_action ) -> guarded_action(be=$be.stba=$ba.st);
	public final UnparseBLESS.guarded_action_return guarded_action() throws RecognitionException {
		UnparseBLESS.guarded_action_return retval = new UnparseBLESS.guarded_action_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope be =null;
		TreeRuleReturnScope ba =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1560:2: ( ^( GUARD be= expression_or_relation ba= asserted_action ) -> guarded_action(be=$be.stba=$ba.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1561:2: ^( GUARD be= expression_or_relation ba= asserted_action )
			{
			match(input,GUARD,FOLLOW_GUARD_in_guarded_action2688); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_guarded_action2692);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_asserted_action_in_guarded_action2696);
			ba=asserted_action();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1562:3: -> guarded_action(be=$be.stba=$ba.st)
			  {
			  	retval.st = templateLib.getInstanceOf("guarded_action",new STAttrMap().put("be", (be!=null?((StringTemplate)be.getTemplate()):null)).put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "guarded_action"


	public static class universal_lattice_quantification_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "universal_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1567:1: universal_lattice_quantification : ^( LITERAL_forall lv= lattice_variables ^( LITERAL_in ir= range ) elq= existential_lattice_quantification ) -> ulq(lv=$lv.stir=$ir.stelq=$elq.st);
	public final UnparseBLESS.universal_lattice_quantification_return universal_lattice_quantification() throws RecognitionException {
		UnparseBLESS.universal_lattice_quantification_return retval = new UnparseBLESS.universal_lattice_quantification_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope lv =null;
		TreeRuleReturnScope ir =null;
		TreeRuleReturnScope elq =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1568:2: ( ^( LITERAL_forall lv= lattice_variables ^( LITERAL_in ir= range ) elq= existential_lattice_quantification ) -> ulq(lv=$lv.stir=$ir.stelq=$elq.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1569:2: ^( LITERAL_forall lv= lattice_variables ^( LITERAL_in ir= range ) elq= existential_lattice_quantification )
			{
			match(input,LITERAL_forall,FOLLOW_LITERAL_forall_in_universal_lattice_quantification2729); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_lattice_variables_in_universal_lattice_quantification2735);
			lv=lattice_variables();
			state._fsp--;
			if (state.failed) return retval;
			match(input,LITERAL_in,FOLLOW_LITERAL_in_in_universal_lattice_quantification2740); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_range_in_universal_lattice_quantification2744);
			ir=range();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			pushFollow(FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification2753);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1574:3: -> ulq(lv=$lv.stir=$ir.stelq=$elq.st)
			  {
			  	retval.st = templateLib.getInstanceOf("ulq",new STAttrMap().put("lv", (lv!=null?((StringTemplate)lv.getTemplate()):null)).put("ir", (ir!=null?((StringTemplate)ir.getTemplate()):null)).put("elq", (elq!=null?((StringTemplate)elq.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_lattice_quantification"


	public static class while_loop_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "while_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1580:1: while_loop : ^( LITERAL_while be= expression_or_relation ^( INVARIANT (inv= assertion )? ) ^( BOUND (bd= expression )? ) elq= existential_lattice_quantification ) -> while_loop(be=$be.stelq=$elq.stbd=$bd.stinv=$inv.st);
	public final UnparseBLESS.while_loop_return while_loop() throws RecognitionException {
		UnparseBLESS.while_loop_return retval = new UnparseBLESS.while_loop_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope be =null;
		TreeRuleReturnScope inv =null;
		TreeRuleReturnScope bd =null;
		TreeRuleReturnScope elq =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1581:2: ( ^( LITERAL_while be= expression_or_relation ^( INVARIANT (inv= assertion )? ) ^( BOUND (bd= expression )? ) elq= existential_lattice_quantification ) -> while_loop(be=$be.stelq=$elq.stbd=$bd.stinv=$inv.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1582:2: ^( LITERAL_while be= expression_or_relation ^( INVARIANT (inv= assertion )? ) ^( BOUND (bd= expression )? ) elq= existential_lattice_quantification )
			{
			match(input,LITERAL_while,FOLLOW_LITERAL_while_in_while_loop2792); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_while_loop2796);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			match(input,INVARIANT,FOLLOW_INVARIANT_in_while_loop2799); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1582:59: (inv= assertion )?
				int alt38=2;
				int LA38_0 = input.LA(1);
				if ( (LA38_0==ASSERTION||(LA38_0 >= ASSERTION_ENUMERATION && LA38_0 <= ASSERTION_FUNCTION)) ) {
					alt38=1;
				}
				switch (alt38) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1582:59: inv= assertion
						{
						pushFollow(FOLLOW_assertion_in_while_loop2803);
						inv=assertion();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input,BOUND,FOLLOW_BOUND_in_while_loop2811); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1583:13: (bd= expression )?
				int alt39=2;
				int LA39_0 = input.LA(1);
				if ( (LA39_0==AADL_STRING_LITERAL||LA39_0==CASE_EXPRESSION||LA39_0==COMPLEX||LA39_0==CONDITIONAL||LA39_0==DIVIDE||LA39_0==DOUBLE_COLON||LA39_0==EXP||LA39_0==FUNCTION_CALL||LA39_0==ID||LA39_0==INMODE||LA39_0==INTEGER_LIT||LA39_0==LITERAL_and||LA39_0==LITERAL_cand||LA39_0==LITERAL_complex||LA39_0==LITERAL_cor||LA39_0==LITERAL_false||LA39_0==LITERAL_integer||LA39_0==LITERAL_mod||LA39_0==LITERAL_natural||(LA39_0 >= LITERAL_not && LA39_0 <= LITERAL_now)||LA39_0==LITERAL_null||LA39_0==LITERAL_or||(LA39_0 >= LITERAL_rational && LA39_0 <= LITERAL_real)||LA39_0==LITERAL_rem||(LA39_0 >= LITERAL_time && LA39_0 <= LITERAL_timeout)||LA39_0==LITERAL_tops||LA39_0==LITERAL_true||(LA39_0 >= LITERAL_xor && LA39_0 <= LPAREN)||LA39_0==MINUS||LA39_0==OCTOTHORPE||(LA39_0 >= PERIOD && LA39_0 <= PLUS)||LA39_0==QUESTION||LA39_0==RATIONAL||LA39_0==REAL_LIT||LA39_0==TICK||LA39_0==TIMES||LA39_0==UNARY_MINUS) ) {
					alt39=1;
				}
				switch (alt39) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1583:13: bd= expression
						{
						pushFollow(FOLLOW_expression_in_while_loop2815);
						bd=expression();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			pushFollow(FOLLOW_existential_lattice_quantification_in_while_loop2821);
			elq=existential_lattice_quantification();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1584:3: -> while_loop(be=$be.stelq=$elq.stbd=$bd.stinv=$inv.st)
			  {
			  	retval.st = templateLib.getInstanceOf("while_loop",new STAttrMap().put("be", (be!=null?((StringTemplate)be.getTemplate()):null)).put("elq", (elq!=null?((StringTemplate)elq.getTemplate()):null)).put("bd", (bd!=null?((StringTemplate)bd.getTemplate()):null)).put("inv", (inv!=null?((StringTemplate)inv.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "while_loop"


	public static class for_loop_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "for_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1587:1: for_loop : ^( LITERAL_for a= ID ^( LITERAL_in lb= expression ub= expression ) ^( INVARIANT (inv= assertion )? ) act= behavior_actions ) -> for_loop(a=$a.textlb=$lb.stub=$ub.stba=$act.stinv=$inv.st);
	public final UnparseBLESS.for_loop_return for_loop() throws RecognitionException {
		UnparseBLESS.for_loop_return retval = new UnparseBLESS.for_loop_return();
		retval.start = input.LT(1);

		BAST a=null;
		TreeRuleReturnScope lb =null;
		TreeRuleReturnScope ub =null;
		TreeRuleReturnScope inv =null;
		TreeRuleReturnScope act =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1588:2: ( ^( LITERAL_for a= ID ^( LITERAL_in lb= expression ub= expression ) ^( INVARIANT (inv= assertion )? ) act= behavior_actions ) -> for_loop(a=$a.textlb=$lb.stub=$ub.stba=$act.stinv=$inv.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1589:2: ^( LITERAL_for a= ID ^( LITERAL_in lb= expression ub= expression ) ^( INVARIANT (inv= assertion )? ) act= behavior_actions )
			{
			match(input,LITERAL_for,FOLLOW_LITERAL_for_in_for_loop2862); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			a=(BAST)match(input,ID,FOLLOW_ID_in_for_loop2866); if (state.failed) return retval;
			match(input,LITERAL_in,FOLLOW_LITERAL_in_in_for_loop2872); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_for_loop2876);
			lb=expression();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_for_loop2880);
			ub=expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			match(input,INVARIANT,FOLLOW_INVARIANT_in_for_loop2888); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1591:19: (inv= assertion )?
				int alt40=2;
				int LA40_0 = input.LA(1);
				if ( (LA40_0==ASSERTION||(LA40_0 >= ASSERTION_ENUMERATION && LA40_0 <= ASSERTION_FUNCTION)) ) {
					alt40=1;
				}
				switch (alt40) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1591:19: inv= assertion
						{
						pushFollow(FOLLOW_assertion_in_for_loop2892);
						inv=assertion();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			pushFollow(FOLLOW_behavior_actions_in_for_loop2901);
			act=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1593:3: -> for_loop(a=$a.textlb=$lb.stub=$ub.stba=$act.stinv=$inv.st)
			  {
			  	retval.st = templateLib.getInstanceOf("for_loop",new STAttrMap().put("a", (a!=null?a.getText():null)).put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)).put("ba", (act!=null?((StringTemplate)act.getTemplate()):null)).put("inv", (inv!=null?((StringTemplate)inv.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_loop"


	public static class do_until_loop_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "do_until_loop"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1596:1: do_until_loop : ^( LITERAL_do ^( LITERAL_until be= expression_or_relation ) ^( INVARIANT (inv= assertion )? ) ^( BOUND (bd= expression )? ) ba= behavior_actions ) -> do_until(be=$be.stba=$ba.stbd=$bd.stinv=$inv.st);
	public final UnparseBLESS.do_until_loop_return do_until_loop() throws RecognitionException {
		UnparseBLESS.do_until_loop_return retval = new UnparseBLESS.do_until_loop_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope be =null;
		TreeRuleReturnScope inv =null;
		TreeRuleReturnScope bd =null;
		TreeRuleReturnScope ba =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1597:2: ( ^( LITERAL_do ^( LITERAL_until be= expression_or_relation ) ^( INVARIANT (inv= assertion )? ) ^( BOUND (bd= expression )? ) ba= behavior_actions ) -> do_until(be=$be.stba=$ba.stbd=$bd.stinv=$inv.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1598:2: ^( LITERAL_do ^( LITERAL_until be= expression_or_relation ) ^( INVARIANT (inv= assertion )? ) ^( BOUND (bd= expression )? ) ba= behavior_actions )
			{
			match(input,LITERAL_do,FOLLOW_LITERAL_do_in_do_until_loop2947); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			match(input,LITERAL_until,FOLLOW_LITERAL_until_in_do_until_loop2950); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_do_until_loop2954);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			match(input,INVARIANT,FOLLOW_INVARIANT_in_do_until_loop2958); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1598:73: (inv= assertion )?
				int alt41=2;
				int LA41_0 = input.LA(1);
				if ( (LA41_0==ASSERTION||(LA41_0 >= ASSERTION_ENUMERATION && LA41_0 <= ASSERTION_FUNCTION)) ) {
					alt41=1;
				}
				switch (alt41) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1598:73: inv= assertion
						{
						pushFollow(FOLLOW_assertion_in_do_until_loop2962);
						inv=assertion();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			match(input,BOUND,FOLLOW_BOUND_in_do_until_loop2970); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1599:13: (bd= expression )?
				int alt42=2;
				int LA42_0 = input.LA(1);
				if ( (LA42_0==AADL_STRING_LITERAL||LA42_0==CASE_EXPRESSION||LA42_0==COMPLEX||LA42_0==CONDITIONAL||LA42_0==DIVIDE||LA42_0==DOUBLE_COLON||LA42_0==EXP||LA42_0==FUNCTION_CALL||LA42_0==ID||LA42_0==INMODE||LA42_0==INTEGER_LIT||LA42_0==LITERAL_and||LA42_0==LITERAL_cand||LA42_0==LITERAL_complex||LA42_0==LITERAL_cor||LA42_0==LITERAL_false||LA42_0==LITERAL_integer||LA42_0==LITERAL_mod||LA42_0==LITERAL_natural||(LA42_0 >= LITERAL_not && LA42_0 <= LITERAL_now)||LA42_0==LITERAL_null||LA42_0==LITERAL_or||(LA42_0 >= LITERAL_rational && LA42_0 <= LITERAL_real)||LA42_0==LITERAL_rem||(LA42_0 >= LITERAL_time && LA42_0 <= LITERAL_timeout)||LA42_0==LITERAL_tops||LA42_0==LITERAL_true||(LA42_0 >= LITERAL_xor && LA42_0 <= LPAREN)||LA42_0==MINUS||LA42_0==OCTOTHORPE||(LA42_0 >= PERIOD && LA42_0 <= PLUS)||LA42_0==QUESTION||LA42_0==RATIONAL||LA42_0==REAL_LIT||LA42_0==TICK||LA42_0==TIMES||LA42_0==UNARY_MINUS) ) {
					alt42=1;
				}
				switch (alt42) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1599:13: bd= expression
						{
						pushFollow(FOLLOW_expression_in_do_until_loop2974);
						bd=expression();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			pushFollow(FOLLOW_behavior_actions_in_do_until_loop2980);
			ba=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1600:3: -> do_until(be=$be.stba=$ba.stbd=$bd.stinv=$inv.st)
			  {
			  	retval.st = templateLib.getInstanceOf("do_until",new STAttrMap().put("be", (be!=null?((StringTemplate)be.getTemplate()):null)).put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)).put("bd", (bd!=null?((StringTemplate)bd.getTemplate()):null)).put("inv", (inv!=null?((StringTemplate)inv.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "do_until_loop"


	public static class basic_action_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "basic_action"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1605:1: basic_action : ( LITERAL_skip -> skip(|sa= simultaneous_assignment -> {$sa.st}|a= assignment -> {$a.st}|c= communication -> {$c.st}|ta= timed_actions -> {$ta.st}| LITERAL_setmode m= ID -> template(m=$m.text) \"setmode <m>\"|wt= when_throw -> {$wt.st}|co= combinable_operation -> {$co.st}|ie= issue_exception -> {$ie.st});
	public final UnparseBLESS.basic_action_return basic_action() throws RecognitionException {
		UnparseBLESS.basic_action_return retval = new UnparseBLESS.basic_action_return();
		retval.start = input.LT(1);

		BAST m=null;
		TreeRuleReturnScope sa =null;
		TreeRuleReturnScope a =null;
		TreeRuleReturnScope c =null;
		TreeRuleReturnScope ta =null;
		TreeRuleReturnScope wt =null;
		TreeRuleReturnScope co =null;
		TreeRuleReturnScope ie =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1606:2: ( LITERAL_skip -> skip(|sa= simultaneous_assignment -> {$sa.st}|a= assignment -> {$a.st}|c= communication -> {$c.st}|ta= timed_actions -> {$ta.st}| LITERAL_setmode m= ID -> template(m=$m.text) \"setmode <m>\"|wt= when_throw -> {$wt.st}|co= combinable_operation -> {$co.st}|ie= issue_exception -> {$ie.st})
			int alt43=9;
			switch ( input.LA(1) ) {
			case LITERAL_skip:
				{
				alt43=1;
				}
				break;
			case ASSIGN:
				{
				int LA43_2 = input.LA(2);
				if ( (LA43_2==DOWN) ) {
					int LA43_9 = input.LA(3);
					if ( (LA43_9==COMMA) ) {
						alt43=2;
					}
					else if ( (LA43_9==ID||LA43_9==PERIOD||LA43_9==TICK) ) {
						alt43=3;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 43, 9, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 43, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_pause:
			case PORT_INPUT:
			case PORT_OUTPUT:
			case PROCEDURE_CALL:
				{
				alt43=4;
				}
				break;
			case LITERAL_computation:
			case LITERAL_delay:
				{
				alt43=5;
				}
				break;
			case LITERAL_setmode:
				{
				alt43=6;
				}
				break;
			case LITERAL_when:
				{
				alt43=7;
				}
				break;
			case LITERAL_fetchadd:
			case LITERAL_fetchand:
			case LITERAL_fetchor:
			case LITERAL_fetchxor:
			case LITERAL_swap:
				{
				alt43=8;
				}
				break;
			case LITERAL_exception:
				{
				alt43=9;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 43, 0, input);
				throw nvae;
			}
			switch (alt43) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1607:2: LITERAL_skip
					{
					match(input,LITERAL_skip,FOLLOW_LITERAL_skip_in_basic_action3022); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1608:3: -> skip(
					  {
					  	retval.st = templateLib.getInstanceOf("skip");
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1609:4: sa= simultaneous_assignment
					{
					pushFollow(FOLLOW_simultaneous_assignment_in_basic_action3036);
					sa=simultaneous_assignment();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1610:5: -> {$sa.st}
					  {
					  	retval.st = (sa!=null?((StringTemplate)sa.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1611:4: a= assignment
					{
					pushFollow(FOLLOW_assignment_in_basic_action3052);
					a=assignment();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1612:10: -> {$a.st}
					  {
					  	retval.st = (a!=null?((StringTemplate)a.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1613:4: c= communication
					{
					pushFollow(FOLLOW_communication_in_basic_action3072);
					c=communication();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1614:10: -> {$c.st}
					  {
					  	retval.st = (c!=null?((StringTemplate)c.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1615:4: ta= timed_actions
					{
					pushFollow(FOLLOW_timed_actions_in_basic_action3093);
					ta=timed_actions();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1616:10: -> {$ta.st}
					  {
					  	retval.st = (ta!=null?((StringTemplate)ta.getTemplate()):null);
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1617:4: LITERAL_setmode m= ID
					{
					match(input,LITERAL_setmode,FOLLOW_LITERAL_setmode_in_basic_action3111); if (state.failed) return retval;
					m=(BAST)match(input,ID,FOLLOW_ID_in_basic_action3115); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1618:3: -> template(m=$m.text) \"setmode <m>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "setmode <m>",new STAttrMap().put("m", (m!=null?m.getText():null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1619:4: wt= when_throw
					{
					pushFollow(FOLLOW_when_throw_in_basic_action3133);
					wt=when_throw();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1620:10: -> {$wt.st}
					  {
					  	retval.st = (wt!=null?((StringTemplate)wt.getTemplate()):null);
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1621:5: co= combinable_operation
					{
					pushFollow(FOLLOW_combinable_operation_in_basic_action3154);
					co=combinable_operation();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1622:11: -> {$co.st}
					  {
					  	retval.st = (co!=null?((StringTemplate)co.getTemplate()):null);
					  }


					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1623:5: ie= issue_exception
					{
					pushFollow(FOLLOW_issue_exception_in_basic_action3176);
					ie=issue_exception();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1624:6: -> {$ie.st}
					  {
					  	retval.st = (ie!=null?((StringTemplate)ie.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "basic_action"


	public static class assignment_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1627:1: assignment : ^( ASSIGN nt= name_tick eort= expression_or_record_term ) -> assignment(nt=$nt.steort=$eort.st);
	public final UnparseBLESS.assignment_return assignment() throws RecognitionException {
		UnparseBLESS.assignment_return retval = new UnparseBLESS.assignment_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope nt =null;
		TreeRuleReturnScope eort =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1628:2: ( ^( ASSIGN nt= name_tick eort= expression_or_record_term ) -> assignment(nt=$nt.steort=$eort.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1629:2: ^( ASSIGN nt= name_tick eort= expression_or_record_term )
			{
			match(input,ASSIGN,FOLLOW_ASSIGN_in_assignment3200); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_name_tick_in_assignment3204);
			nt=name_tick();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_record_term_in_assignment3208);
			eort=expression_or_record_term();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1630:4: -> assignment(nt=$nt.steort=$eort.st)
			  {
			  	retval.st = templateLib.getInstanceOf("assignment",new STAttrMap().put("nt", (nt!=null?((StringTemplate)nt.getTemplate()):null)).put("eort", (eort!=null?((StringTemplate)eort.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignment"


	public static class name_tick_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "name_tick"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1634:1: name_tick : ( ^( TICK vn= name ) -> name_tick(vn=$vn.st)|vn= name -> {$vn.st});
	public final UnparseBLESS.name_tick_return name_tick() throws RecognitionException {
		UnparseBLESS.name_tick_return retval = new UnparseBLESS.name_tick_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope vn =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1635:3: ( ^( TICK vn= name ) -> name_tick(vn=$vn.st)|vn= name -> {$vn.st})
			int alt44=2;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==TICK) ) {
				alt44=1;
			}
			else if ( (LA44_0==ID||LA44_0==PERIOD) ) {
				alt44=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 44, 0, input);
				throw nvae;
			}

			switch (alt44) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1636:4: ^( TICK vn= name )
					{
					match(input,TICK,FOLLOW_TICK_in_name_tick3242); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_name_in_name_tick3247);
					vn=name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1637:6: -> name_tick(vn=$vn.st)
					  {
					  	retval.st = templateLib.getInstanceOf("name_tick",new STAttrMap().put("vn", (vn!=null?((StringTemplate)vn.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1640:4: vn= name
					{
					pushFollow(FOLLOW_name_in_name_tick3275);
					vn=name();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1641:6: -> {$vn.st}
					  {
					  	retval.st = (vn!=null?((StringTemplate)vn.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name_tick"


	public static class expression_or_record_term_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "expression_or_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1644:1: expression_or_record_term : (e= expression -> {$e.st}|rt= record_term -> {$rt.st}|any= LITERAL_any -> {%{$any.text}});
	public final UnparseBLESS.expression_or_record_term_return expression_or_record_term() throws RecognitionException {
		UnparseBLESS.expression_or_record_term_return retval = new UnparseBLESS.expression_or_record_term_return();
		retval.start = input.LT(1);

		BAST any=null;
		TreeRuleReturnScope e =null;
		TreeRuleReturnScope rt =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1645:3: (e= expression -> {$e.st}|rt= record_term -> {$rt.st}|any= LITERAL_any -> {%{$any.text}})
			int alt45=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DIVIDE:
			case DOUBLE_COLON:
			case EXP:
			case FUNCTION_CALL:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_and:
			case LITERAL_cand:
			case LITERAL_complex:
			case LITERAL_cor:
			case LITERAL_false:
			case LITERAL_integer:
			case LITERAL_mod:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_or:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_rem:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LITERAL_xor:
			case MINUS:
			case OCTOTHORPE:
			case PERIOD:
			case PLUS:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
			case TIMES:
			case UNARY_MINUS:
				{
				alt45=1;
				}
				break;
			case LPAREN:
				{
				int LA45_2 = input.LA(2);
				if ( (LA45_2==DOWN) ) {
					int LA45_4 = input.LA(3);
					if ( (LA45_4==AADL_STRING_LITERAL||(LA45_4 >= AL && LA45_4 <= AM)||LA45_4==CASE_EXPRESSION||LA45_4==COMPLEX||LA45_4==CONDITIONAL||LA45_4==DIVIDE||LA45_4==DOUBLE_COLON||LA45_4==EQ||LA45_4==EXP||(LA45_4 >= FUNCTION_CALL && LA45_4 <= GT)||LA45_4==ID||LA45_4==INMODE||LA45_4==INTEGER_LIT||LA45_4==LITERAL_and||LA45_4==LITERAL_cand||LA45_4==LITERAL_complex||LA45_4==LITERAL_cor||LA45_4==LITERAL_false||LA45_4==LITERAL_integer||LA45_4==LITERAL_mod||LA45_4==LITERAL_natural||(LA45_4 >= LITERAL_not && LA45_4 <= LITERAL_now)||LA45_4==LITERAL_null||LA45_4==LITERAL_or||(LA45_4 >= LITERAL_rational && LA45_4 <= LITERAL_real)||LA45_4==LITERAL_rem||(LA45_4 >= LITERAL_time && LA45_4 <= LITERAL_timeout)||LA45_4==LITERAL_tops||LA45_4==LITERAL_true||(LA45_4 >= LITERAL_xor && LA45_4 <= LT)||LA45_4==MINUS||LA45_4==NEQ||LA45_4==OCTOTHORPE||(LA45_4 >= PERIOD && LA45_4 <= PLUS)||LA45_4==QUESTION||LA45_4==RATIONAL||LA45_4==REAL_LIT||LA45_4==TICK||LA45_4==TIMES||LA45_4==UNARY_MINUS) ) {
						alt45=1;
					}
					else if ( (LA45_4==ARROW) ) {
						alt45=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 45, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 45, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_any:
				{
				alt45=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 45, 0, input);
				throw nvae;
			}
			switch (alt45) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1646:3: e= expression
					{
					pushFollow(FOLLOW_expression_in_expression_or_record_term3305);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1647:5: -> {$e.st}
					  {
					  	retval.st = (e!=null?((StringTemplate)e.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1649:3: rt= record_term
					{
					pushFollow(FOLLOW_record_term_in_expression_or_record_term3325);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1650:5: -> {$rt.st}
					  {
					  	retval.st = (rt!=null?((StringTemplate)rt.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1651:5: any= LITERAL_any
					{
					any=(BAST)match(input,LITERAL_any,FOLLOW_LITERAL_any_in_expression_or_record_term3341); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1652:5: -> {%{$any.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(any!=null?any.getText():null));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_record_term"


	public static class simultaneous_assignment_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "simultaneous_assignment"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1655:1: simultaneous_assignment : ^( ASSIGN ^( COMMA (lhs+= name_tick )+ ) ^( COMMA (rhs+= expression_or_record_term )+ ) ) -> {Global.usingSlangStringTemplateGroup}? {slang_simultaneous_assignment($lhs,$rhs)} -> simultaneous_assignment(l=$lhsr=$rhs);
	public final UnparseBLESS.simultaneous_assignment_return simultaneous_assignment() throws RecognitionException {
		UnparseBLESS.simultaneous_assignment_return retval = new UnparseBLESS.simultaneous_assignment_return();
		retval.start = input.LT(1);

		List<Object> list_lhs=null;
		List<Object> list_rhs=null;
		RuleReturnScope lhs = null;
		RuleReturnScope rhs = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1656:3: ( ^( ASSIGN ^( COMMA (lhs+= name_tick )+ ) ^( COMMA (rhs+= expression_or_record_term )+ ) ) -> {Global.usingSlangStringTemplateGroup}? {slang_simultaneous_assignment($lhs,$rhs)} -> simultaneous_assignment(l=$lhsr=$rhs))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1657:3: ^( ASSIGN ^( COMMA (lhs+= name_tick )+ ) ^( COMMA (rhs+= expression_or_record_term )+ ) )
			{
			match(input,ASSIGN,FOLLOW_ASSIGN_in_simultaneous_assignment3366); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment3370); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1657:25: (lhs+= name_tick )+
			int cnt46=0;
			loop46:
			while (true) {
				int alt46=2;
				int LA46_0 = input.LA(1);
				if ( (LA46_0==ID||LA46_0==PERIOD||LA46_0==TICK) ) {
					alt46=1;
				}

				switch (alt46) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1657:25: lhs+= name_tick
					{
					pushFollow(FOLLOW_name_tick_in_simultaneous_assignment3374);
					lhs=name_tick();
					state._fsp--;
					if (state.failed) return retval;
					if (list_lhs==null) list_lhs=new ArrayList<Object>();
					list_lhs.add(lhs.getTemplate());
					}
					break;

				default :
					if ( cnt46 >= 1 ) break loop46;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(46, input);
					throw eee;
				}
				cnt46++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			match(input,COMMA,FOLLOW_COMMA_in_simultaneous_assignment3381); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1657:52: (rhs+= expression_or_record_term )+
			int cnt47=0;
			loop47:
			while (true) {
				int alt47=2;
				int LA47_0 = input.LA(1);
				if ( (LA47_0==AADL_STRING_LITERAL||LA47_0==CASE_EXPRESSION||LA47_0==COMPLEX||LA47_0==CONDITIONAL||LA47_0==DIVIDE||LA47_0==DOUBLE_COLON||LA47_0==EXP||LA47_0==FUNCTION_CALL||LA47_0==ID||LA47_0==INMODE||LA47_0==INTEGER_LIT||LA47_0==LITERAL_and||LA47_0==LITERAL_any||LA47_0==LITERAL_cand||LA47_0==LITERAL_complex||LA47_0==LITERAL_cor||LA47_0==LITERAL_false||LA47_0==LITERAL_integer||LA47_0==LITERAL_mod||LA47_0==LITERAL_natural||(LA47_0 >= LITERAL_not && LA47_0 <= LITERAL_now)||LA47_0==LITERAL_null||LA47_0==LITERAL_or||(LA47_0 >= LITERAL_rational && LA47_0 <= LITERAL_real)||LA47_0==LITERAL_rem||(LA47_0 >= LITERAL_time && LA47_0 <= LITERAL_timeout)||LA47_0==LITERAL_tops||LA47_0==LITERAL_true||(LA47_0 >= LITERAL_xor && LA47_0 <= LPAREN)||LA47_0==MINUS||LA47_0==OCTOTHORPE||(LA47_0 >= PERIOD && LA47_0 <= PLUS)||LA47_0==QUESTION||LA47_0==RATIONAL||LA47_0==REAL_LIT||LA47_0==TICK||LA47_0==TIMES||LA47_0==UNARY_MINUS) ) {
					alt47=1;
				}

				switch (alt47) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1657:52: rhs+= expression_or_record_term
					{
					pushFollow(FOLLOW_expression_or_record_term_in_simultaneous_assignment3385);
					rhs=expression_or_record_term();
					state._fsp--;
					if (state.failed) return retval;
					if (list_rhs==null) list_rhs=new ArrayList<Object>();
					list_rhs.add(rhs.getTemplate());
					}
					break;

				default :
					if ( cnt47 >= 1 ) break loop47;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(47, input);
					throw eee;
				}
				cnt47++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1658:5: -> {Global.usingSlangStringTemplateGroup}? {slang_simultaneous_assignment($lhs,$rhs)}
			  if (Global.usingSlangStringTemplateGroup) {
			  	retval.st = slang_simultaneous_assignment(list_lhs,list_rhs);
			  }

			  else // 1659:5: -> simultaneous_assignment(l=$lhsr=$rhs)
			  {
			  	retval.st = templateLib.getInstanceOf("simultaneous_assignment",new STAttrMap().put("l", list_lhs).put("r", list_rhs));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simultaneous_assignment"


	public static class issue_exception_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "issue_exception"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1662:1: issue_exception : ( ^( LITERAL_exception exception_state= ID message= AADL_STRING_LITERAL ) -> template(es=$exception_state.textm=$message.text) \"exception (<es>,<m>)\"| ^( LITERAL_exception message= AADL_STRING_LITERAL ) -> template(m=$message.text) \"exception (<m>)\");
	public final UnparseBLESS.issue_exception_return issue_exception() throws RecognitionException {
		UnparseBLESS.issue_exception_return retval = new UnparseBLESS.issue_exception_return();
		retval.start = input.LT(1);

		BAST exception_state=null;
		BAST message=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1663:3: ( ^( LITERAL_exception exception_state= ID message= AADL_STRING_LITERAL ) -> template(es=$exception_state.textm=$message.text) \"exception (<es>,<m>)\"| ^( LITERAL_exception message= AADL_STRING_LITERAL ) -> template(m=$message.text) \"exception (<m>)\")
			int alt48=2;
			int LA48_0 = input.LA(1);
			if ( (LA48_0==LITERAL_exception) ) {
				int LA48_1 = input.LA(2);
				if ( (LA48_1==DOWN) ) {
					int LA48_2 = input.LA(3);
					if ( (LA48_2==ID) ) {
						alt48=1;
					}
					else if ( (LA48_2==AADL_STRING_LITERAL) ) {
						alt48=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 48, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 48, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 48, 0, input);
				throw nvae;
			}

			switch (alt48) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1664:3: ^( LITERAL_exception exception_state= ID message= AADL_STRING_LITERAL )
					{
					match(input,LITERAL_exception,FOLLOW_LITERAL_exception_in_issue_exception3434); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					exception_state=(BAST)match(input,ID,FOLLOW_ID_in_issue_exception3438); if (state.failed) return retval;
					message=(BAST)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_issue_exception3442); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1665:5: -> template(es=$exception_state.textm=$message.text) \"exception (<es>,<m>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "exception (<es>,<m>)",new STAttrMap().put("es", (exception_state!=null?exception_state.getText():null)).put("m", (message!=null?message.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1668:3: ^( LITERAL_exception message= AADL_STRING_LITERAL )
					{
					match(input,LITERAL_exception,FOLLOW_LITERAL_exception_in_issue_exception3477); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					message=(BAST)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_issue_exception3481); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1669:5: -> template(m=$message.text) \"exception (<m>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "exception (<m>)",new STAttrMap().put("m", (message!=null?message.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "issue_exception"


	public static class timed_actions_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "timed_actions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1673:1: timed_actions : ( ^( LITERAL_computation (bt+= behavior_time )+ ) -> template(bt=$bt) \"computation(<bt; wrap, anchor, separator=\", \">)\"| ^( LITERAL_delay (bt2+= behavior_time )+ ) -> template(bt2=$bt2) \"delay(<bt2; wrap, anchor, separator=\", \">)\");
	public final UnparseBLESS.timed_actions_return timed_actions() throws RecognitionException {
		UnparseBLESS.timed_actions_return retval = new UnparseBLESS.timed_actions_return();
		retval.start = input.LT(1);

		List<Object> list_bt=null;
		List<Object> list_bt2=null;
		RuleReturnScope bt = null;
		RuleReturnScope bt2 = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1674:2: ( ^( LITERAL_computation (bt+= behavior_time )+ ) -> template(bt=$bt) \"computation(<bt; wrap, anchor, separator=\", \">)\"| ^( LITERAL_delay (bt2+= behavior_time )+ ) -> template(bt2=$bt2) \"delay(<bt2; wrap, anchor, separator=\", \">)\")
			int alt51=2;
			int LA51_0 = input.LA(1);
			if ( (LA51_0==LITERAL_computation) ) {
				alt51=1;
			}
			else if ( (LA51_0==LITERAL_delay) ) {
				alt51=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 51, 0, input);
				throw nvae;
			}

			switch (alt51) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1675:2: ^( LITERAL_computation (bt+= behavior_time )+ )
					{
					match(input,LITERAL_computation,FOLLOW_LITERAL_computation_in_timed_actions3521); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1675:26: (bt+= behavior_time )+
					int cnt49=0;
					loop49:
					while (true) {
						int alt49=2;
						int LA49_0 = input.LA(1);
						if ( (LA49_0==BEHAVIOR_TIME) ) {
							alt49=1;
						}

						switch (alt49) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1675:26: bt+= behavior_time
							{
							pushFollow(FOLLOW_behavior_time_in_timed_actions3525);
							bt=behavior_time();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bt==null) list_bt=new ArrayList<Object>();
							list_bt.add(bt.getTemplate());
							}
							break;

						default :
							if ( cnt49 >= 1 ) break loop49;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(49, input);
							throw eee;
						}
						cnt49++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1676:3: -> template(bt=$bt) \"computation(<bt; wrap, anchor, separator=\", \">)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "computation(<bt; wrap, anchor, separator=\", \">)",new STAttrMap().put("bt", list_bt));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1678:2: ^( LITERAL_delay (bt2+= behavior_time )+ )
					{
					match(input,LITERAL_delay,FOLLOW_LITERAL_delay_in_timed_actions3548); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1678:21: (bt2+= behavior_time )+
					int cnt50=0;
					loop50:
					while (true) {
						int alt50=2;
						int LA50_0 = input.LA(1);
						if ( (LA50_0==BEHAVIOR_TIME) ) {
							alt50=1;
						}

						switch (alt50) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1678:21: bt2+= behavior_time
							{
							pushFollow(FOLLOW_behavior_time_in_timed_actions3552);
							bt2=behavior_time();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bt2==null) list_bt2=new ArrayList<Object>();
							list_bt2.add(bt2.getTemplate());
							}
							break;

						default :
							if ( cnt50 >= 1 ) break loop50;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(50, input);
							throw eee;
						}
						cnt50++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1679:3: -> template(bt2=$bt2) \"delay(<bt2; wrap, anchor, separator=\", \">)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "delay(<bt2; wrap, anchor, separator=\", \">)",new STAttrMap().put("bt2", list_bt2));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_actions"


	public static class behavior_time_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_time"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1682:1: behavior_time : ^( BEHAVIOR_TIME e= expression (u= time_unit )? ) -> behavior_time(e=$e.stu=$u.st);
	public final UnparseBLESS.behavior_time_return behavior_time() throws RecognitionException {
		UnparseBLESS.behavior_time_return retval = new UnparseBLESS.behavior_time_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope e =null;
		TreeRuleReturnScope u =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1683:2: ( ^( BEHAVIOR_TIME e= expression (u= time_unit )? ) -> behavior_time(e=$e.stu=$u.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1684:2: ^( BEHAVIOR_TIME e= expression (u= time_unit )? )
			{
			match(input,BEHAVIOR_TIME,FOLLOW_BEHAVIOR_TIME_in_behavior_time3584); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_behavior_time3588);
			e=expression();
			state._fsp--;
			if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1684:32: (u= time_unit )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==LITERAL_hr||LA52_0==LITERAL_min||LA52_0==LITERAL_ms||LA52_0==LITERAL_ps||LA52_0==LITERAL_sec||LA52_0==LITERAL_us) ) {
				alt52=1;
			}
			switch (alt52) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1684:32: u= time_unit
					{
					pushFollow(FOLLOW_time_unit_in_behavior_time3592);
					u=time_unit();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1685:4: -> behavior_time(e=$e.stu=$u.st)
			  {
			  	retval.st = templateLib.getInstanceOf("behavior_time",new STAttrMap().put("e", (e!=null?((StringTemplate)e.getTemplate()):null)).put("u", (u!=null?((StringTemplate)u.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_time"


	public static class time_unit_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "time_unit"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1692:1: time_unit : (tu= LITERAL_ps |tu= LITERAL_us |tu= LITERAL_ms |tu= LITERAL_sec |tu= LITERAL_min |tu= LITERAL_hr ) -> {%{$tu.text}};
	public final UnparseBLESS.time_unit_return time_unit() throws RecognitionException {
		UnparseBLESS.time_unit_return retval = new UnparseBLESS.time_unit_return();
		retval.start = input.LT(1);

		BAST tu=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1693:3: ( (tu= LITERAL_ps |tu= LITERAL_us |tu= LITERAL_ms |tu= LITERAL_sec |tu= LITERAL_min |tu= LITERAL_hr ) -> {%{$tu.text}})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1694:3: (tu= LITERAL_ps |tu= LITERAL_us |tu= LITERAL_ms |tu= LITERAL_sec |tu= LITERAL_min |tu= LITERAL_hr )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1694:3: (tu= LITERAL_ps |tu= LITERAL_us |tu= LITERAL_ms |tu= LITERAL_sec |tu= LITERAL_min |tu= LITERAL_hr )
			int alt53=6;
			switch ( input.LA(1) ) {
			case LITERAL_ps:
				{
				alt53=1;
				}
				break;
			case LITERAL_us:
				{
				alt53=2;
				}
				break;
			case LITERAL_ms:
				{
				alt53=3;
				}
				break;
			case LITERAL_sec:
				{
				alt53=4;
				}
				break;
			case LITERAL_min:
				{
				alt53=5;
				}
				break;
			case LITERAL_hr:
				{
				alt53=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 53, 0, input);
				throw nvae;
			}
			switch (alt53) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1694:5: tu= LITERAL_ps
					{
					tu=(BAST)match(input,LITERAL_ps,FOLLOW_LITERAL_ps_in_time_unit3633); if (state.failed) return retval;
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1695:5: tu= LITERAL_us
					{
					tu=(BAST)match(input,LITERAL_us,FOLLOW_LITERAL_us_in_time_unit3641); if (state.failed) return retval;
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1696:5: tu= LITERAL_ms
					{
					tu=(BAST)match(input,LITERAL_ms,FOLLOW_LITERAL_ms_in_time_unit3650); if (state.failed) return retval;
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1697:5: tu= LITERAL_sec
					{
					tu=(BAST)match(input,LITERAL_sec,FOLLOW_LITERAL_sec_in_time_unit3659); if (state.failed) return retval;
					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1698:5: tu= LITERAL_min
					{
					tu=(BAST)match(input,LITERAL_min,FOLLOW_LITERAL_min_in_time_unit3668); if (state.failed) return retval;
					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1699:5: tu= LITERAL_hr
					{
					tu=(BAST)match(input,LITERAL_hr,FOLLOW_LITERAL_hr_in_time_unit3681); if (state.failed) return retval;
					}
					break;

			}

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1700:5: -> {%{$tu.text}}
			  {
			  	retval.st = new StringTemplate(templateLib,(tu!=null?tu.getText():null));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_unit"


	public static class communication_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "communication"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1703:1: communication : ( ^( PROCEDURE_CALL p= ID spb= formal_actual_list ) -> procedure_call(p=$p.textspb=$spb.st)| ^( PROCEDURE_CALL p= ID ) -> procedure_call(p=$p.text)| ^( PORT_OUTPUT o= port_name be= expression_or_relation ) -> port_output(o=$o.stbe=$be.st)| ^( PORT_OUTPUT o= port_name ) -> event_port_output(o=$o.st)| ^( PORT_INPUT i= port_name n= name ) -> port_input(i=$i.stn=$n.st)|pause= LITERAL_pause -> {%{$pause.text}});
	public final UnparseBLESS.communication_return communication() throws RecognitionException {
		UnparseBLESS.communication_return retval = new UnparseBLESS.communication_return();
		retval.start = input.LT(1);

		BAST p=null;
		BAST pause=null;
		TreeRuleReturnScope spb =null;
		TreeRuleReturnScope o =null;
		TreeRuleReturnScope be =null;
		TreeRuleReturnScope i =null;
		TreeRuleReturnScope n =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1704:2: ( ^( PROCEDURE_CALL p= ID spb= formal_actual_list ) -> procedure_call(p=$p.textspb=$spb.st)| ^( PROCEDURE_CALL p= ID ) -> procedure_call(p=$p.text)| ^( PORT_OUTPUT o= port_name be= expression_or_relation ) -> port_output(o=$o.stbe=$be.st)| ^( PORT_OUTPUT o= port_name ) -> event_port_output(o=$o.st)| ^( PORT_INPUT i= port_name n= name ) -> port_input(i=$i.stn=$n.st)|pause= LITERAL_pause -> {%{$pause.text}})
			int alt54=6;
			alt54 = dfa54.predict(input);
			switch (alt54) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1705:2: ^( PROCEDURE_CALL p= ID spb= formal_actual_list )
					{
					match(input,PROCEDURE_CALL,FOLLOW_PROCEDURE_CALL_in_communication3711); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					p=(BAST)match(input,ID,FOLLOW_ID_in_communication3715); if (state.failed) return retval;
					pushFollow(FOLLOW_formal_actual_list_in_communication3719);
					spb=formal_actual_list();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1706:3: -> procedure_call(p=$p.textspb=$spb.st)
					  {
					  	retval.st = templateLib.getInstanceOf("procedure_call",new STAttrMap().put("p", (p!=null?p.getText():null)).put("spb", (spb!=null?((StringTemplate)spb.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1708:2: ^( PROCEDURE_CALL p= ID )
					{
					match(input,PROCEDURE_CALL,FOLLOW_PROCEDURE_CALL_in_communication3742); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					p=(BAST)match(input,ID,FOLLOW_ID_in_communication3746); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1709:3: -> procedure_call(p=$p.text)
					  {
					  	retval.st = templateLib.getInstanceOf("procedure_call",new STAttrMap().put("p", (p!=null?p.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1711:2: ^( PORT_OUTPUT o= port_name be= expression_or_relation )
					{
					match(input,PORT_OUTPUT,FOLLOW_PORT_OUTPUT_in_communication3765); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_communication3769);
					o=port_name();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_expression_or_relation_in_communication3773);
					be=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1712:4: -> port_output(o=$o.stbe=$be.st)
					  {
					  	retval.st = templateLib.getInstanceOf("port_output",new STAttrMap().put("o", (o!=null?((StringTemplate)o.getTemplate()):null)).put("be", (be!=null?((StringTemplate)be.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1715:2: ^( PORT_OUTPUT o= port_name )
					{
					match(input,PORT_OUTPUT,FOLLOW_PORT_OUTPUT_in_communication3798); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_communication3802);
					o=port_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1716:4: -> event_port_output(o=$o.st)
					  {
					  	retval.st = templateLib.getInstanceOf("event_port_output",new STAttrMap().put("o", (o!=null?((StringTemplate)o.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1719:2: ^( PORT_INPUT i= port_name n= name )
					{
					match(input,PORT_INPUT,FOLLOW_PORT_INPUT_in_communication3823); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_communication3827);
					i=port_name();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_name_in_communication3832);
					n=name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1720:5: -> port_input(i=$i.stn=$n.st)
					  {
					  	retval.st = templateLib.getInstanceOf("port_input",new STAttrMap().put("i", (i!=null?((StringTemplate)i.getTemplate()):null)).put("n", (n!=null?((StringTemplate)n.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1722:5: pause= LITERAL_pause
					{
					pause=(BAST)match(input,LITERAL_pause,FOLLOW_LITERAL_pause_in_communication3859); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1723:5: -> {%{$pause.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(pause!=null?pause.getText():null));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "communication"


	public static class port_name_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "port_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1726:1: port_name : (port= ID -> {%{$ID.text}}| ^( PERIOD (ids+= ID )+ ) -> template(ids=$ids) \"<ids; separator=\".\">\"| ^( LBRACKET portarray= ID portindex= INTEGER_LIT RBRACKET ) -> template(a=$portarray.textidx=$portindex.text) \"<a>[<idx>]\");
	public final UnparseBLESS.port_name_return port_name() throws RecognitionException {
		UnparseBLESS.port_name_return retval = new UnparseBLESS.port_name_return();
		retval.start = input.LT(1);

		BAST port=null;
		BAST portarray=null;
		BAST portindex=null;
		BAST ids=null;
		List<Object> list_ids=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1727:2: (port= ID -> {%{$ID.text}}| ^( PERIOD (ids+= ID )+ ) -> template(ids=$ids) \"<ids; separator=\".\">\"| ^( LBRACKET portarray= ID portindex= INTEGER_LIT RBRACKET ) -> template(a=$portarray.textidx=$portindex.text) \"<a>[<idx>]\")
			int alt56=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt56=1;
				}
				break;
			case PERIOD:
				{
				alt56=2;
				}
				break;
			case LBRACKET:
				{
				alt56=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 56, 0, input);
				throw nvae;
			}
			switch (alt56) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1728:2: port= ID
					{
					port=(BAST)match(input,ID,FOLLOW_ID_in_port_name3881); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1729:4: -> {%{$ID.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(port!=null?port.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1731:2: ^( PERIOD (ids+= ID )+ )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_port_name3895); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1731:14: (ids+= ID )+
					int cnt55=0;
					loop55:
					while (true) {
						int alt55=2;
						int LA55_0 = input.LA(1);
						if ( (LA55_0==ID) ) {
							alt55=1;
						}

						switch (alt55) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1731:14: ids+= ID
							{
							ids=(BAST)match(input,ID,FOLLOW_ID_in_port_name3899); if (state.failed) return retval;
							if (list_ids==null) list_ids=new ArrayList<Object>();
							list_ids.add(ids);
							}
							break;

						default :
							if ( cnt55 >= 1 ) break loop55;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(55, input);
							throw eee;
						}
						cnt55++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1732:4: -> template(ids=$ids) \"<ids; separator=\".\">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<ids; separator=\".\">",new STAttrMap().put("ids", list_ids));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1737:2: ^( LBRACKET portarray= ID portindex= INTEGER_LIT RBRACKET )
					{
					match(input,LBRACKET,FOLLOW_LBRACKET_in_port_name3924); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					portarray=(BAST)match(input,ID,FOLLOW_ID_in_port_name3928); if (state.failed) return retval;
					portindex=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_port_name3932); if (state.failed) return retval;
					match(input,RBRACKET,FOLLOW_RBRACKET_in_port_name3934); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1738:4: -> template(a=$portarray.textidx=$portindex.text) \"<a>[<idx>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<a>[<idx>]",new STAttrMap().put("a", (portarray!=null?portarray.getText():null)).put("idx", (portindex!=null?portindex.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "port_name"


	public static class formal_actual_list_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "formal_actual_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1742:1: formal_actual_list : ( ^( COMMA (ns+= formal_actual )+ ) -> formal_actual_list(ns=$ns)|n= formal_actual -> {$n.st});
	public final UnparseBLESS.formal_actual_list_return formal_actual_list() throws RecognitionException {
		UnparseBLESS.formal_actual_list_return retval = new UnparseBLESS.formal_actual_list_return();
		retval.start = input.LT(1);

		List<Object> list_ns=null;
		TreeRuleReturnScope n =null;
		RuleReturnScope ns = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1743:2: ( ^( COMMA (ns+= formal_actual )+ ) -> formal_actual_list(ns=$ns)|n= formal_actual -> {$n.st})
			int alt58=2;
			int LA58_0 = input.LA(1);
			if ( (LA58_0==COMMA) ) {
				alt58=1;
			}
			else if ( (LA58_0==AADL_STRING_LITERAL||(LA58_0 >= CASE_EXPRESSION && LA58_0 <= COLON)||LA58_0==COMPLEX||LA58_0==CONDITIONAL||LA58_0==DOUBLE_COLON||LA58_0==ID||LA58_0==INTEGER_LIT||LA58_0==LITERAL_false||LA58_0==LITERAL_true||LA58_0==LPAREN||LA58_0==OCTOTHORPE||LA58_0==PERIOD||LA58_0==RATIONAL||LA58_0==REAL_LIT||LA58_0==TICK) ) {
				alt58=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 58, 0, input);
				throw nvae;
			}

			switch (alt58) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1744:2: ^( COMMA (ns+= formal_actual )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_formal_actual_list3970); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1744:13: (ns+= formal_actual )+
					int cnt57=0;
					loop57:
					while (true) {
						int alt57=2;
						int LA57_0 = input.LA(1);
						if ( (LA57_0==AADL_STRING_LITERAL||(LA57_0 >= CASE_EXPRESSION && LA57_0 <= COLON)||LA57_0==COMPLEX||LA57_0==CONDITIONAL||LA57_0==DOUBLE_COLON||LA57_0==ID||LA57_0==INTEGER_LIT||LA57_0==LITERAL_false||LA57_0==LITERAL_true||LA57_0==LPAREN||LA57_0==OCTOTHORPE||LA57_0==PERIOD||LA57_0==RATIONAL||LA57_0==REAL_LIT||LA57_0==TICK) ) {
							alt57=1;
						}

						switch (alt57) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1744:13: ns+= formal_actual
							{
							pushFollow(FOLLOW_formal_actual_in_formal_actual_list3974);
							ns=formal_actual();
							state._fsp--;
							if (state.failed) return retval;
							if (list_ns==null) list_ns=new ArrayList<Object>();
							list_ns.add(ns.getTemplate());
							}
							break;

						default :
							if ( cnt57 >= 1 ) break loop57;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(57, input);
							throw eee;
						}
						cnt57++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1745:3: -> formal_actual_list(ns=$ns)
					  {
					  	retval.st = templateLib.getInstanceOf("formal_actual_list",new STAttrMap().put("ns", list_ns));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1748:2: n= formal_actual
					{
					pushFollow(FOLLOW_formal_actual_in_formal_actual_list3996);
					n=formal_actual();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1749:3: -> {$n.st}
					  {
					  	retval.st = (n!=null?((StringTemplate)n.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual_list"


	public static class formal_actual_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "formal_actual"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1752:1: formal_actual : ( ^( COLON formal= ID ap= actual_parameter ) -> formal_actual(f=$formal.textap=$ap.st)|ap= actual_parameter -> {$ap.st});
	public final UnparseBLESS.formal_actual_return formal_actual() throws RecognitionException {
		UnparseBLESS.formal_actual_return retval = new UnparseBLESS.formal_actual_return();
		retval.start = input.LT(1);

		BAST formal=null;
		TreeRuleReturnScope ap =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1753:3: ( ^( COLON formal= ID ap= actual_parameter ) -> formal_actual(f=$formal.textap=$ap.st)|ap= actual_parameter -> {$ap.st})
			int alt59=2;
			int LA59_0 = input.LA(1);
			if ( (LA59_0==COLON) ) {
				alt59=1;
			}
			else if ( (LA59_0==AADL_STRING_LITERAL||LA59_0==CASE_EXPRESSION||LA59_0==COMPLEX||LA59_0==CONDITIONAL||LA59_0==DOUBLE_COLON||LA59_0==ID||LA59_0==INTEGER_LIT||LA59_0==LITERAL_false||LA59_0==LITERAL_true||LA59_0==LPAREN||LA59_0==OCTOTHORPE||LA59_0==PERIOD||LA59_0==RATIONAL||LA59_0==REAL_LIT||LA59_0==TICK) ) {
				alt59=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 59, 0, input);
				throw nvae;
			}

			switch (alt59) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1754:3: ^( COLON formal= ID ap= actual_parameter )
					{
					match(input,COLON,FOLLOW_COLON_in_formal_actual4019); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					formal=(BAST)match(input,ID,FOLLOW_ID_in_formal_actual4023); if (state.failed) return retval;
					pushFollow(FOLLOW_actual_parameter_in_formal_actual4027);
					ap=actual_parameter();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1755:5: -> formal_actual(f=$formal.textap=$ap.st)
					  {
					  	retval.st = templateLib.getInstanceOf("formal_actual",new STAttrMap().put("f", (formal!=null?formal.getText():null)).put("ap", (ap!=null?((StringTemplate)ap.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1758:3: ap= actual_parameter
					{
					pushFollow(FOLLOW_actual_parameter_in_formal_actual4058);
					ap=actual_parameter();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1759:5: -> {$ap.st}
					  {
					  	retval.st = (ap!=null?((StringTemplate)ap.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_actual"


	public static class actual_parameter_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "actual_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1763:1: actual_parameter : (vc= value_constant -> {$vc.st}|n= name -> {$n.st}|ps= parenthesized_subexpression -> {$ps.st});
	public final UnparseBLESS.actual_parameter_return actual_parameter() throws RecognitionException {
		UnparseBLESS.actual_parameter_return retval = new UnparseBLESS.actual_parameter_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope vc =null;
		TreeRuleReturnScope n =null;
		TreeRuleReturnScope ps =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1764:2: (vc= value_constant -> {$vc.st}|n= name -> {$n.st}|ps= parenthesized_subexpression -> {$ps.st})
			int alt60=3;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case COMPLEX:
			case DOUBLE_COLON:
			case INTEGER_LIT:
			case LITERAL_false:
			case LITERAL_true:
			case OCTOTHORPE:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
				{
				alt60=1;
				}
				break;
			case ID:
			case PERIOD:
				{
				alt60=2;
				}
				break;
			case CASE_EXPRESSION:
			case CONDITIONAL:
			case LPAREN:
				{
				alt60=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 60, 0, input);
				throw nvae;
			}
			switch (alt60) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1771:3: vc= value_constant
					{
					pushFollow(FOLLOW_value_constant_in_actual_parameter4085);
					vc=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1772:5: -> {$vc.st}
					  {
					  	retval.st = (vc!=null?((StringTemplate)vc.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1774:3: n= name
					{
					pushFollow(FOLLOW_name_in_actual_parameter4105);
					n=name();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1775:5: -> {$n.st}
					  {
					  	retval.st = (n!=null?((StringTemplate)n.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1777:3: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_actual_parameter4123);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1778:5: -> {$ps.st}
					  {
					  	retval.st = (ps!=null?((StringTemplate)ps.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_parameter"


	public static class quantified_variables_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "quantified_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1781:1: quantified_variables : ^(v= LITERAL_declare (bv+= behavior_variable )+ ) -> quantified_variables(bv=$bv);
	public final UnparseBLESS.quantified_variables_return quantified_variables() throws RecognitionException {
		UnparseBLESS.quantified_variables_return retval = new UnparseBLESS.quantified_variables_return();
		retval.start = input.LT(1);

		BAST v=null;
		List<Object> list_bv=null;
		RuleReturnScope bv = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1782:3: ( ^(v= LITERAL_declare (bv+= behavior_variable )+ ) -> quantified_variables(bv=$bv))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1783:3: ^(v= LITERAL_declare (bv+= behavior_variable )+ )
			{
			v=(BAST)match(input,LITERAL_declare,FOLLOW_LITERAL_declare_in_quantified_variables4154); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1783:23: (bv+= behavior_variable )+
			int cnt61=0;
			loop61:
			while (true) {
				int alt61=2;
				int LA61_0 = input.LA(1);
				if ( (LA61_0==COLON) ) {
					alt61=1;
				}

				switch (alt61) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1783:25: bv+= behavior_variable
					{
					pushFollow(FOLLOW_behavior_variable_in_quantified_variables4160);
					bv=behavior_variable();
					state._fsp--;
					if (state.failed) return retval;
					if (list_bv==null) list_bv=new ArrayList<Object>();
					list_bv.add(bv.getTemplate());
					}
					break;

				default :
					if ( cnt61 >= 1 ) break loop61;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(61, input);
					throw eee;
				}
				cnt61++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1784:5: -> quantified_variables(bv=$bv)
			  {
			  	retval.st = templateLib.getInstanceOf("quantified_variables",new STAttrMap().put("bv", list_bv));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "quantified_variables"


	public static class existential_lattice_quantification_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "existential_lattice_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1796:1: existential_lattice_quantification : ^( LCURLY (v= quantified_variables )? ba= behavior_actions RCURLY (timeout= timeout_clause )? (cc= catch_clause )? ) -> elq(v=$v.stba=$ba.stcc=$cc.st);
	public final UnparseBLESS.existential_lattice_quantification_return existential_lattice_quantification() throws RecognitionException {
		UnparseBLESS.existential_lattice_quantification_return retval = new UnparseBLESS.existential_lattice_quantification_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope v =null;
		TreeRuleReturnScope ba =null;
		TreeRuleReturnScope timeout =null;
		TreeRuleReturnScope cc =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1797:2: ( ^( LCURLY (v= quantified_variables )? ba= behavior_actions RCURLY (timeout= timeout_clause )? (cc= catch_clause )? ) -> elq(v=$v.stba=$ba.stcc=$cc.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1798:2: ^( LCURLY (v= quantified_variables )? ba= behavior_actions RCURLY (timeout= timeout_clause )? (cc= catch_clause )? )
			{
			match(input,LCURLY,FOLLOW_LCURLY_in_existential_lattice_quantification4203); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1798:12: (v= quantified_variables )?
			int alt62=2;
			int LA62_0 = input.LA(1);
			if ( (LA62_0==LITERAL_declare) ) {
				alt62=1;
			}
			switch (alt62) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1798:12: v= quantified_variables
					{
					pushFollow(FOLLOW_quantified_variables_in_existential_lattice_quantification4207);
					v=quantified_variables();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			pushFollow(FOLLOW_behavior_actions_in_existential_lattice_quantification4212);
			ba=behavior_actions();
			state._fsp--;
			if (state.failed) return retval;
			match(input,RCURLY,FOLLOW_RCURLY_in_existential_lattice_quantification4214); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1799:12: (timeout= timeout_clause )?
			int alt63=2;
			int LA63_0 = input.LA(1);
			if ( (LA63_0==LITERAL_timeout) ) {
				alt63=1;
			}
			switch (alt63) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1799:12: timeout= timeout_clause
					{
					pushFollow(FOLLOW_timeout_clause_in_existential_lattice_quantification4224);
					timeout=timeout_clause();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1800:7: (cc= catch_clause )?
			int alt64=2;
			int LA64_0 = input.LA(1);
			if ( (LA64_0==LITERAL_catch) ) {
				alt64=1;
			}
			switch (alt64) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1800:7: cc= catch_clause
					{
					pushFollow(FOLLOW_catch_clause_in_existential_lattice_quantification4234);
					cc=catch_clause();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1801:3: -> elq(v=$v.stba=$ba.stcc=$cc.st)
			  {
			  	retval.st = templateLib.getInstanceOf("elq",new STAttrMap().put("v", (v!=null?((StringTemplate)v.getTemplate()):null)).put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)).put("cc", (cc!=null?((StringTemplate)cc.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_lattice_quantification"


	public static class timeout_clause_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "timeout_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1810:1: timeout_clause : ^( LITERAL_timeout time= behavior_time ) -> template(time=$time.st) \"timeout <time>\";
	public final UnparseBLESS.timeout_clause_return timeout_clause() throws RecognitionException {
		UnparseBLESS.timeout_clause_return retval = new UnparseBLESS.timeout_clause_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope time =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1811:3: ( ^( LITERAL_timeout time= behavior_time ) -> template(time=$time.st) \"timeout <time>\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1812:3: ^( LITERAL_timeout time= behavior_time )
			{
			match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_timeout_clause4278); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_behavior_time_in_timeout_clause4282);
			time=behavior_time();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1813:4: -> template(time=$time.st) \"timeout <time>\"
			  {
			  	retval.st = new StringTemplate(templateLib, "timeout <time>",new STAttrMap().put("time", (time!=null?((StringTemplate)time.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timeout_clause"


	public static class catch_clause_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "catch_clause"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1816:1: catch_clause : ^( LITERAL_catch (cct+= catch_clause_term )+ ) -> catch_clause(cct=$cct);
	public final UnparseBLESS.catch_clause_return catch_clause() throws RecognitionException {
		UnparseBLESS.catch_clause_return retval = new UnparseBLESS.catch_clause_return();
		retval.start = input.LT(1);

		List<Object> list_cct=null;
		RuleReturnScope cct = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1817:3: ( ^( LITERAL_catch (cct+= catch_clause_term )+ ) -> catch_clause(cct=$cct))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1818:3: ^( LITERAL_catch (cct+= catch_clause_term )+ )
			{
			match(input,LITERAL_catch,FOLLOW_LITERAL_catch_in_catch_clause4312); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1818:22: (cct+= catch_clause_term )+
			int cnt65=0;
			loop65:
			while (true) {
				int alt65=2;
				int LA65_0 = input.LA(1);
				if ( (LA65_0==COLON) ) {
					alt65=1;
				}

				switch (alt65) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1818:22: cct+= catch_clause_term
					{
					pushFollow(FOLLOW_catch_clause_term_in_catch_clause4316);
					cct=catch_clause_term();
					state._fsp--;
					if (state.failed) return retval;
					if (list_cct==null) list_cct=new ArrayList<Object>();
					list_cct.add(cct.getTemplate());
					}
					break;

				default :
					if ( cnt65 >= 1 ) break loop65;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(65, input);
					throw eee;
				}
				cnt65++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1819:5: -> catch_clause(cct=$cct)
			  {
			  	retval.st = templateLib.getInstanceOf("catch_clause",new STAttrMap().put("cct", list_cct));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause"


	public static class catch_clause_term_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "catch_clause_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1823:1: catch_clause_term : ( ^( COLON LITERAL_all ba= basic_action ) -> template(ba=$ba.st) \"(all:<ba>)\"| ^( COLON ei+= ID ba= basic_action ) -> catch_clause_term(ei=$eiba=$ba.st));
	public final UnparseBLESS.catch_clause_term_return catch_clause_term() throws RecognitionException {
		UnparseBLESS.catch_clause_term_return retval = new UnparseBLESS.catch_clause_term_return();
		retval.start = input.LT(1);

		BAST ei=null;
		List<Object> list_ei=null;
		TreeRuleReturnScope ba =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1824:3: ( ^( COLON LITERAL_all ba= basic_action ) -> template(ba=$ba.st) \"(all:<ba>)\"| ^( COLON ei+= ID ba= basic_action ) -> catch_clause_term(ei=$eiba=$ba.st))
			int alt66=2;
			int LA66_0 = input.LA(1);
			if ( (LA66_0==COLON) ) {
				int LA66_1 = input.LA(2);
				if ( (LA66_1==DOWN) ) {
					int LA66_2 = input.LA(3);
					if ( (LA66_2==LITERAL_all) ) {
						alt66=1;
					}
					else if ( (LA66_2==ID) ) {
						alt66=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 66, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 66, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 66, 0, input);
				throw nvae;
			}

			switch (alt66) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1825:3: ^( COLON LITERAL_all ba= basic_action )
					{
					match(input,COLON,FOLLOW_COLON_in_catch_clause_term4350); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LITERAL_all,FOLLOW_LITERAL_all_in_catch_clause_term4352); if (state.failed) return retval;
					pushFollow(FOLLOW_basic_action_in_catch_clause_term4356);
					ba=basic_action();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1826:4: -> template(ba=$ba.st) \"(all:<ba>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(all:<ba>)",new STAttrMap().put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1828:3: ^( COLON ei+= ID ba= basic_action )
					{
					match(input,COLON,FOLLOW_COLON_in_catch_clause_term4380); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					ei=(BAST)match(input,ID,FOLLOW_ID_in_catch_clause_term4384); if (state.failed) return retval;
					if (list_ei==null) list_ei=new ArrayList<Object>();
					list_ei.add(ei);
					pushFollow(FOLLOW_basic_action_in_catch_clause_term4388);
					ba=basic_action();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1829:5: -> catch_clause_term(ei=$eiba=$ba.st)
					  {
					  	retval.st = templateLib.getInstanceOf("catch_clause_term",new STAttrMap().put("ei", list_ei).put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catch_clause_term"


	public static class when_throw_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "when_throw"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1833:1: when_throw : ^( LITERAL_when e= expression LITERAL_throw x= ID ) -> template(e=$e.stx=$x.text) \"when (<e>)<\\n>throw <x>\";
	public final UnparseBLESS.when_throw_return when_throw() throws RecognitionException {
		UnparseBLESS.when_throw_return retval = new UnparseBLESS.when_throw_return();
		retval.start = input.LT(1);

		BAST x=null;
		TreeRuleReturnScope e =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1834:2: ( ^( LITERAL_when e= expression LITERAL_throw x= ID ) -> template(e=$e.stx=$x.text) \"when (<e>)<\\n>throw <x>\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1835:2: ^( LITERAL_when e= expression LITERAL_throw x= ID )
			{
			match(input,LITERAL_when,FOLLOW_LITERAL_when_in_when_throw4421); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_when_throw4425);
			e=expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input,LITERAL_throw,FOLLOW_LITERAL_throw_in_when_throw4427); if (state.failed) return retval;
			x=(BAST)match(input,ID,FOLLOW_ID_in_when_throw4431); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1836:3: -> template(e=$e.stx=$x.text) \"when (<e>)<\\n>throw <x>\"
			  {
			  	retval.st = new StringTemplate(templateLib, "when (<e>)<\\n>throw <x>",new STAttrMap().put("e", (e!=null?((StringTemplate)e.getTemplate()):null)).put("x", (x!=null?x.getText():null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "when_throw"


	public static class combinable_operation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "combinable_operation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1840:1: combinable_operation : ( ^(cl= combinable_literal tar= variable_name val= expression (result= ID )? ) -> {result!=null}? template(cl=$cl.stt=$tar.stv=$val.str=$result.text) \"<cl>(<t>,<v>,<r>)\" -> template(cl=$cl.stt=$tar.stv=$val.st) \"<cl>(<t>,<v>)\"| ^( LITERAL_swap vn= variable_name ref= variable_name result= ID ) -> template(t=$vn.stv=$ref.str=$result.text) \"swap(<t>,<v>,<r>)\");
	public final UnparseBLESS.combinable_operation_return combinable_operation() throws RecognitionException {
		UnparseBLESS.combinable_operation_return retval = new UnparseBLESS.combinable_operation_return();
		retval.start = input.LT(1);

		BAST result=null;
		TreeRuleReturnScope cl =null;
		TreeRuleReturnScope tar =null;
		TreeRuleReturnScope val =null;
		TreeRuleReturnScope vn =null;
		TreeRuleReturnScope ref =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1841:3: ( ^(cl= combinable_literal tar= variable_name val= expression (result= ID )? ) -> {result!=null}? template(cl=$cl.stt=$tar.stv=$val.str=$result.text) \"<cl>(<t>,<v>,<r>)\" -> template(cl=$cl.stt=$tar.stv=$val.st) \"<cl>(<t>,<v>)\"| ^( LITERAL_swap vn= variable_name ref= variable_name result= ID ) -> template(t=$vn.stv=$ref.str=$result.text) \"swap(<t>,<v>,<r>)\")
			int alt68=2;
			int LA68_0 = input.LA(1);
			if ( ((LA68_0 >= LITERAL_fetchadd && LA68_0 <= LITERAL_fetchxor)) ) {
				alt68=1;
			}
			else if ( (LA68_0==LITERAL_swap) ) {
				alt68=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 68, 0, input);
				throw nvae;
			}

			switch (alt68) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1842:3: ^(cl= combinable_literal tar= variable_name val= expression (result= ID )? )
					{
					pushFollow(FOLLOW_combinable_literal_in_combinable_operation4466);
					cl=combinable_literal();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation4470);
					tar=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_combinable_operation4474);
					val=expression();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1842:66: (result= ID )?
					int alt67=2;
					int LA67_0 = input.LA(1);
					if ( (LA67_0==ID) ) {
						alt67=1;
					}
					switch (alt67) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1842:66: result= ID
							{
							result=(BAST)match(input,ID,FOLLOW_ID_in_combinable_operation4478); if (state.failed) return retval;
							}
							break;

					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1843:5: -> {result!=null}? template(cl=$cl.stt=$tar.stv=$val.str=$result.text) \"<cl>(<t>,<v>,<r>)\"
					  if (result!=null) {
					  	retval.st = new StringTemplate(templateLib, "<cl>(<t>,<v>,<r>)",new STAttrMap().put("cl", (cl!=null?((StringTemplate)cl.getTemplate()):null)).put("t", (tar!=null?((StringTemplate)tar.getTemplate()):null)).put("v", (val!=null?((StringTemplate)val.getTemplate()):null)).put("r", (result!=null?result.getText():null)));
					  }

					  else // 1845:5: -> template(cl=$cl.stt=$tar.stv=$val.st) \"<cl>(<t>,<v>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<cl>(<t>,<v>)",new STAttrMap().put("cl", (cl!=null?((StringTemplate)cl.getTemplate()):null)).put("t", (tar!=null?((StringTemplate)tar.getTemplate()):null)).put("v", (val!=null?((StringTemplate)val.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1848:2: ^( LITERAL_swap vn= variable_name ref= variable_name result= ID )
					{
					match(input,LITERAL_swap,FOLLOW_LITERAL_swap_in_combinable_operation4556); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation4560);
					vn=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_variable_name_in_combinable_operation4564);
					ref=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					result=(BAST)match(input,ID,FOLLOW_ID_in_combinable_operation4568); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1849:5: -> template(t=$vn.stv=$ref.str=$result.text) \"swap(<t>,<v>,<r>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "swap(<t>,<v>,<r>)",new STAttrMap().put("t", (vn!=null?((StringTemplate)vn.getTemplate()):null)).put("v", (ref!=null?((StringTemplate)ref.getTemplate()):null)).put("r", (result!=null?result.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "combinable_operation"


	public static class combinable_literal_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "combinable_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1853:1: combinable_literal : (f= LITERAL_fetchadd |f= LITERAL_fetchor |f= LITERAL_fetchand |f= LITERAL_fetchxor ) -> {%{$f.text}};
	public final UnparseBLESS.combinable_literal_return combinable_literal() throws RecognitionException {
		UnparseBLESS.combinable_literal_return retval = new UnparseBLESS.combinable_literal_return();
		retval.start = input.LT(1);

		BAST f=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1855:3: ( (f= LITERAL_fetchadd |f= LITERAL_fetchor |f= LITERAL_fetchand |f= LITERAL_fetchxor ) -> {%{$f.text}})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1856:3: (f= LITERAL_fetchadd |f= LITERAL_fetchor |f= LITERAL_fetchand |f= LITERAL_fetchxor )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1856:3: (f= LITERAL_fetchadd |f= LITERAL_fetchor |f= LITERAL_fetchand |f= LITERAL_fetchxor )
			int alt69=4;
			switch ( input.LA(1) ) {
			case LITERAL_fetchadd:
				{
				alt69=1;
				}
				break;
			case LITERAL_fetchor:
				{
				alt69=2;
				}
				break;
			case LITERAL_fetchand:
				{
				alt69=3;
				}
				break;
			case LITERAL_fetchxor:
				{
				alt69=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 69, 0, input);
				throw nvae;
			}
			switch (alt69) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1857:3: f= LITERAL_fetchadd
					{
					f=(BAST)match(input,LITERAL_fetchadd,FOLLOW_LITERAL_fetchadd_in_combinable_literal4624); if (state.failed) return retval;
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1859:3: f= LITERAL_fetchor
					{
					f=(BAST)match(input,LITERAL_fetchor,FOLLOW_LITERAL_fetchor_in_combinable_literal4636); if (state.failed) return retval;
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1861:3: f= LITERAL_fetchand
					{
					f=(BAST)match(input,LITERAL_fetchand,FOLLOW_LITERAL_fetchand_in_combinable_literal4648); if (state.failed) return retval;
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1863:3: f= LITERAL_fetchxor
					{
					f=(BAST)match(input,LITERAL_fetchxor,FOLLOW_LITERAL_fetchxor_in_combinable_literal4661); if (state.failed) return retval;
					}
					break;

			}

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1865:3: -> {%{$f.text}}
			  {
			  	retval.st = new StringTemplate(templateLib,(f!=null?f.getText():null));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "combinable_literal"


	public static class behavior_actions_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "behavior_actions"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1869:1: behavior_actions : (aa= asserted_action -> {$aa.st}| ^(semi= SEMICOLON (scom+= asserted_action )+ ) -> sequential_composition(f=$scom)| ^(amp= AMPERSAND (ccom+= asserted_action )+ ) -> concurrent_composition(g=$ccom));
	public final UnparseBLESS.behavior_actions_return behavior_actions() throws RecognitionException {
		UnparseBLESS.behavior_actions_return retval = new UnparseBLESS.behavior_actions_return();
		retval.start = input.LT(1);

		BAST semi=null;
		BAST amp=null;
		List<Object> list_scom=null;
		List<Object> list_ccom=null;
		TreeRuleReturnScope aa =null;
		RuleReturnScope scom = null;
		RuleReturnScope ccom = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1870:2: (aa= asserted_action -> {$aa.st}| ^(semi= SEMICOLON (scom+= asserted_action )+ ) -> sequential_composition(f=$scom)| ^(amp= AMPERSAND (ccom+= asserted_action )+ ) -> concurrent_composition(g=$ccom))
			int alt72=3;
			switch ( input.LA(1) ) {
			case ACTION:
				{
				alt72=1;
				}
				break;
			case SEMICOLON:
				{
				alt72=2;
				}
				break;
			case AMPERSAND:
				{
				alt72=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 72, 0, input);
				throw nvae;
			}
			switch (alt72) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1871:2: aa= asserted_action
					{
					pushFollow(FOLLOW_asserted_action_in_behavior_actions4691);
					aa=asserted_action();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1872:3: -> {$aa.st}
					  {
					  	retval.st = (aa!=null?((StringTemplate)aa.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1875:2: ^(semi= SEMICOLON (scom+= asserted_action )+ )
					{
					semi=(BAST)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_behavior_actions4709); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1875:23: (scom+= asserted_action )+
					int cnt70=0;
					loop70:
					while (true) {
						int alt70=2;
						int LA70_0 = input.LA(1);
						if ( (LA70_0==ACTION) ) {
							alt70=1;
						}

						switch (alt70) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1875:23: scom+= asserted_action
							{
							pushFollow(FOLLOW_asserted_action_in_behavior_actions4713);
							scom=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if (list_scom==null) list_scom=new ArrayList<Object>();
							list_scom.add(scom.getTemplate());
							}
							break;

						default :
							if ( cnt70 >= 1 ) break loop70;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(70, input);
							throw eee;
						}
						cnt70++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1876:3: -> sequential_composition(f=$scom)
					  {
					  	retval.st = templateLib.getInstanceOf("sequential_composition",new STAttrMap().put("f", list_scom));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1880:2: ^(amp= AMPERSAND (ccom+= asserted_action )+ )
					{
					amp=(BAST)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_behavior_actions4737); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1880:22: (ccom+= asserted_action )+
					int cnt71=0;
					loop71:
					while (true) {
						int alt71=2;
						int LA71_0 = input.LA(1);
						if ( (LA71_0==ACTION) ) {
							alt71=1;
						}

						switch (alt71) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1880:22: ccom+= asserted_action
							{
							pushFollow(FOLLOW_asserted_action_in_behavior_actions4741);
							ccom=asserted_action();
							state._fsp--;
							if (state.failed) return retval;
							if (list_ccom==null) list_ccom=new ArrayList<Object>();
							list_ccom.add(ccom.getTemplate());
							}
							break;

						default :
							if ( cnt71 >= 1 ) break loop71;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(71, input);
							throw eee;
						}
						cnt71++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1881:3: -> concurrent_composition(g=$ccom)
					  {
					  	retval.st = templateLib.getInstanceOf("concurrent_composition",new STAttrMap().put("g", list_ccom));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "behavior_actions"


	public static class name_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1890:1: name : ( ^( PERIOD (pn+= partial_name )+ ) -> name(p=$pn)|pp= partial_name -> name(pp=$pp.st));
	public final UnparseBLESS.name_return name() throws RecognitionException {
		UnparseBLESS.name_return retval = new UnparseBLESS.name_return();
		retval.start = input.LT(1);

		List<Object> list_pn=null;
		TreeRuleReturnScope pp =null;
		RuleReturnScope pn = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1891:2: ( ^( PERIOD (pn+= partial_name )+ ) -> name(p=$pn)|pp= partial_name -> name(pp=$pp.st))
			int alt74=2;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==PERIOD) ) {
				alt74=1;
			}
			else if ( (LA74_0==ID) ) {
				alt74=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 74, 0, input);
				throw nvae;
			}

			switch (alt74) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1892:2: ^( PERIOD (pn+= partial_name )+ )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_name4774); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1892:13: (pn+= partial_name )+
					int cnt73=0;
					loop73:
					while (true) {
						int alt73=2;
						int LA73_0 = input.LA(1);
						if ( (LA73_0==ID) ) {
							alt73=1;
						}

						switch (alt73) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1892:13: pn+= partial_name
							{
							pushFollow(FOLLOW_partial_name_in_name4778);
							pn=partial_name();
							state._fsp--;
							if (state.failed) return retval;
							if (list_pn==null) list_pn=new ArrayList<Object>();
							list_pn.add(pn.getTemplate());
							}
							break;

						default :
							if ( cnt73 >= 1 ) break loop73;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(73, input);
							throw eee;
						}
						cnt73++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1893:4: -> name(p=$pn)
					  {
					  	retval.st = templateLib.getInstanceOf("name",new STAttrMap().put("p", list_pn));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1896:2: pp= partial_name
					{
					pushFollow(FOLLOW_partial_name_in_name4802);
					pp=partial_name();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1897:4: -> name(pp=$pp.st)
					  {
					  	retval.st = templateLib.getInstanceOf("name",new STAttrMap().put("pp", (pp!=null?((StringTemplate)pp.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name"


	public static class partial_name_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "partial_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1902:1: partial_name : ( ID -> {%{$ID.text}}| ^( ID (idx+= expressionOrRange )+ ) -> template(i=$ID.textidx=$idx) \"<i>[<idx; separator=\"][\">]\");
	public final UnparseBLESS.partial_name_return partial_name() throws RecognitionException {
		UnparseBLESS.partial_name_return retval = new UnparseBLESS.partial_name_return();
		retval.start = input.LT(1);

		BAST ID1=null;
		BAST ID2=null;
		List<Object> list_idx=null;
		RuleReturnScope idx = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1903:2: ( ID -> {%{$ID.text}}| ^( ID (idx+= expressionOrRange )+ ) -> template(i=$ID.textidx=$idx) \"<i>[<idx; separator=\"][\">]\")
			int alt76=2;
			int LA76_0 = input.LA(1);
			if ( (LA76_0==ID) ) {
				int LA76_1 = input.LA(2);
				if ( (LA76_1==DOWN) ) {
					alt76=2;
				}
				else if ( (LA76_1==EOF||(LA76_1 >= UP && LA76_1 <= AADL_STRING_LITERAL)||(LA76_1 >= ACTION && LA76_1 <= AM)||LA76_1==AT_SIGN||(LA76_1 >= CARET && LA76_1 <= COLON)||(LA76_1 >= COMMACOMMA && LA76_1 <= COMPLEX)||LA76_1==CONDITIONAL||LA76_1==DIVIDE||(LA76_1 >= DOTCOMMA && LA76_1 <= DOUBLE_COLON)||LA76_1==EQ||LA76_1==EXP||(LA76_1 >= FUNCTION_CALL && LA76_1 <= GT)||LA76_1==ID||LA76_1==INMODE||LA76_1==INTEGER_LIT||(LA76_1 >= INVARIANT && LA76_1 <= INVOKE_FUNCTION)||LA76_1==LITERAL_abs||LA76_1==LITERAL_and||LA76_1==LITERAL_any||LA76_1==LITERAL_cand||LA76_1==LITERAL_complex||LA76_1==LITERAL_cor||LA76_1==LITERAL_def||LA76_1==LITERAL_false||LA76_1==LITERAL_hr||LA76_1==LITERAL_in||LA76_1==LITERAL_integer||(LA76_1 >= LITERAL_min && LA76_1 <= LITERAL_mod)||(LA76_1 >= LITERAL_ms && LA76_1 <= LITERAL_natural)||(LA76_1 >= LITERAL_not && LA76_1 <= LITERAL_now)||(LA76_1 >= LITERAL_null && LA76_1 <= LITERAL_numberof)||LA76_1==LITERAL_or||LA76_1==LITERAL_product||LA76_1==LITERAL_ps||(LA76_1 >= LITERAL_rational && LA76_1 <= LITERAL_real)||LA76_1==LITERAL_rem||LA76_1==LITERAL_sec||LA76_1==LITERAL_stop||LA76_1==LITERAL_sum||(LA76_1 >= LITERAL_throw && LA76_1 <= LITERAL_timeout)||LA76_1==LITERAL_tops||LA76_1==LITERAL_true||LA76_1==LITERAL_us||(LA76_1 >= LITERAL_xor && LA76_1 <= LT)||LA76_1==MINUS||LA76_1==NEQ||LA76_1==OCTOTHORPE||(LA76_1 >= PERIOD && LA76_1 <= PLUS)||LA76_1==PLUS_EQUALS||LA76_1==QUESTION||LA76_1==RATIONAL||LA76_1==REAL_LIT||LA76_1==RPAREN||LA76_1==TICK||LA76_1==TIMES||LA76_1==UNARY_MINUS||LA76_1==WP) ) {
					alt76=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 76, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 76, 0, input);
				throw nvae;
			}

			switch (alt76) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1904:2: ID
					{
					ID1=(BAST)match(input,ID,FOLLOW_ID_in_partial_name4831); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1904:6: -> {%{$ID.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(ID1!=null?ID1.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1907:2: ^( ID (idx+= expressionOrRange )+ )
					{
					ID2=(BAST)match(input,ID,FOLLOW_ID_in_partial_name4845); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1907:11: (idx+= expressionOrRange )+
					int cnt75=0;
					loop75:
					while (true) {
						int alt75=2;
						int LA75_0 = input.LA(1);
						if ( (LA75_0==AADL_STRING_LITERAL||LA75_0==CASE_EXPRESSION||(LA75_0 >= COMMACOMMA && LA75_0 <= COMPLEX)||LA75_0==CONDITIONAL||LA75_0==DIVIDE||(LA75_0 >= DOTCOMMA && LA75_0 <= DOUBLE_COLON)||LA75_0==EXP||LA75_0==FUNCTION_CALL||LA75_0==ID||LA75_0==INMODE||LA75_0==INTEGER_LIT||LA75_0==LITERAL_and||LA75_0==LITERAL_cand||LA75_0==LITERAL_complex||LA75_0==LITERAL_cor||LA75_0==LITERAL_false||LA75_0==LITERAL_integer||LA75_0==LITERAL_mod||LA75_0==LITERAL_natural||(LA75_0 >= LITERAL_not && LA75_0 <= LITERAL_now)||LA75_0==LITERAL_null||LA75_0==LITERAL_or||(LA75_0 >= LITERAL_rational && LA75_0 <= LITERAL_real)||LA75_0==LITERAL_rem||(LA75_0 >= LITERAL_time && LA75_0 <= LITERAL_timeout)||LA75_0==LITERAL_tops||LA75_0==LITERAL_true||(LA75_0 >= LITERAL_xor && LA75_0 <= LPAREN)||LA75_0==MINUS||LA75_0==OCTOTHORPE||(LA75_0 >= PERIOD && LA75_0 <= PLUS)||LA75_0==QUESTION||LA75_0==RATIONAL||LA75_0==REAL_LIT||LA75_0==TICK||LA75_0==TIMES||LA75_0==UNARY_MINUS) ) {
							alt75=1;
						}

						switch (alt75) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1907:11: idx+= expressionOrRange
							{
							pushFollow(FOLLOW_expressionOrRange_in_partial_name4849);
							idx=expressionOrRange();
							state._fsp--;
							if (state.failed) return retval;
							if (list_idx==null) list_idx=new ArrayList<Object>();
							list_idx.add(idx.getTemplate());
							}
							break;

						default :
							if ( cnt75 >= 1 ) break loop75;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(75, input);
							throw eee;
						}
						cnt75++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1908:3: -> template(i=$ID.textidx=$idx) \"<i>[<idx; separator=\"][\">]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i>[<idx; separator=\"][\">]",new STAttrMap().put("i", (ID2!=null?ID2.getText():null)).put("idx", list_idx));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "partial_name"


	public static class parameter_list_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1912:1: parameter_list : ( ^( COMMA (eor+= expressionOrRange )+ ) -> template(eor=$eor) \"<eor; separator=\",\">\"|eor2= expressionOrRange -> {$eor2.st});
	public final UnparseBLESS.parameter_list_return parameter_list() throws RecognitionException {
		UnparseBLESS.parameter_list_return retval = new UnparseBLESS.parameter_list_return();
		retval.start = input.LT(1);

		List<Object> list_eor=null;
		TreeRuleReturnScope eor2 =null;
		RuleReturnScope eor = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1913:2: ( ^( COMMA (eor+= expressionOrRange )+ ) -> template(eor=$eor) \"<eor; separator=\",\">\"|eor2= expressionOrRange -> {$eor2.st})
			int alt78=2;
			int LA78_0 = input.LA(1);
			if ( (LA78_0==COMMA) ) {
				alt78=1;
			}
			else if ( (LA78_0==AADL_STRING_LITERAL||LA78_0==CASE_EXPRESSION||(LA78_0 >= COMMACOMMA && LA78_0 <= COMPLEX)||LA78_0==CONDITIONAL||LA78_0==DIVIDE||(LA78_0 >= DOTCOMMA && LA78_0 <= DOUBLE_COLON)||LA78_0==EXP||LA78_0==FUNCTION_CALL||LA78_0==ID||LA78_0==INMODE||LA78_0==INTEGER_LIT||LA78_0==LITERAL_and||LA78_0==LITERAL_cand||LA78_0==LITERAL_complex||LA78_0==LITERAL_cor||LA78_0==LITERAL_false||LA78_0==LITERAL_integer||LA78_0==LITERAL_mod||LA78_0==LITERAL_natural||(LA78_0 >= LITERAL_not && LA78_0 <= LITERAL_now)||LA78_0==LITERAL_null||LA78_0==LITERAL_or||(LA78_0 >= LITERAL_rational && LA78_0 <= LITERAL_real)||LA78_0==LITERAL_rem||(LA78_0 >= LITERAL_time && LA78_0 <= LITERAL_timeout)||LA78_0==LITERAL_tops||LA78_0==LITERAL_true||(LA78_0 >= LITERAL_xor && LA78_0 <= LPAREN)||LA78_0==MINUS||LA78_0==OCTOTHORPE||(LA78_0 >= PERIOD && LA78_0 <= PLUS)||LA78_0==QUESTION||LA78_0==RATIONAL||LA78_0==REAL_LIT||LA78_0==TICK||LA78_0==TIMES||LA78_0==UNARY_MINUS) ) {
				alt78=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 78, 0, input);
				throw nvae;
			}

			switch (alt78) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1914:2: ^( COMMA (eor+= expressionOrRange )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_parameter_list4887); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1914:13: (eor+= expressionOrRange )+
					int cnt77=0;
					loop77:
					while (true) {
						int alt77=2;
						int LA77_0 = input.LA(1);
						if ( (LA77_0==AADL_STRING_LITERAL||LA77_0==CASE_EXPRESSION||(LA77_0 >= COMMACOMMA && LA77_0 <= COMPLEX)||LA77_0==CONDITIONAL||LA77_0==DIVIDE||(LA77_0 >= DOTCOMMA && LA77_0 <= DOUBLE_COLON)||LA77_0==EXP||LA77_0==FUNCTION_CALL||LA77_0==ID||LA77_0==INMODE||LA77_0==INTEGER_LIT||LA77_0==LITERAL_and||LA77_0==LITERAL_cand||LA77_0==LITERAL_complex||LA77_0==LITERAL_cor||LA77_0==LITERAL_false||LA77_0==LITERAL_integer||LA77_0==LITERAL_mod||LA77_0==LITERAL_natural||(LA77_0 >= LITERAL_not && LA77_0 <= LITERAL_now)||LA77_0==LITERAL_null||LA77_0==LITERAL_or||(LA77_0 >= LITERAL_rational && LA77_0 <= LITERAL_real)||LA77_0==LITERAL_rem||(LA77_0 >= LITERAL_time && LA77_0 <= LITERAL_timeout)||LA77_0==LITERAL_tops||LA77_0==LITERAL_true||(LA77_0 >= LITERAL_xor && LA77_0 <= LPAREN)||LA77_0==MINUS||LA77_0==OCTOTHORPE||(LA77_0 >= PERIOD && LA77_0 <= PLUS)||LA77_0==QUESTION||LA77_0==RATIONAL||LA77_0==REAL_LIT||LA77_0==TICK||LA77_0==TIMES||LA77_0==UNARY_MINUS) ) {
							alt77=1;
						}

						switch (alt77) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1914:13: eor+= expressionOrRange
							{
							pushFollow(FOLLOW_expressionOrRange_in_parameter_list4891);
							eor=expressionOrRange();
							state._fsp--;
							if (state.failed) return retval;
							if (list_eor==null) list_eor=new ArrayList<Object>();
							list_eor.add(eor.getTemplate());
							}
							break;

						default :
							if ( cnt77 >= 1 ) break loop77;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(77, input);
							throw eee;
						}
						cnt77++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1915:3: -> template(eor=$eor) \"<eor; separator=\",\">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<eor; separator=\",\">",new STAttrMap().put("eor", list_eor));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1917:2: eor2= expressionOrRange
					{
					pushFollow(FOLLOW_expressionOrRange_in_parameter_list4914);
					eor2=expressionOrRange();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1918:3: -> {$eor2.st}
					  {
					  	retval.st = (eor2!=null?((StringTemplate)eor2.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameter_list"


	public static class range_symbol_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "range_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1921:1: range_symbol : (rs= DOTDOT |rs= COMMADOT |rs= DOTCOMMA |rs= COMMACOMMA ) -> {%{$rs.text}};
	public final UnparseBLESS.range_symbol_return range_symbol() throws RecognitionException {
		UnparseBLESS.range_symbol_return retval = new UnparseBLESS.range_symbol_return();
		retval.start = input.LT(1);

		BAST rs=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1922:3: ( (rs= DOTDOT |rs= COMMADOT |rs= DOTCOMMA |rs= COMMACOMMA ) -> {%{$rs.text}})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1923:3: (rs= DOTDOT |rs= COMMADOT |rs= DOTCOMMA |rs= COMMACOMMA )
			{
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1923:3: (rs= DOTDOT |rs= COMMADOT |rs= DOTCOMMA |rs= COMMACOMMA )
			int alt79=4;
			switch ( input.LA(1) ) {
			case DOTDOT:
				{
				alt79=1;
				}
				break;
			case COMMADOT:
				{
				alt79=2;
				}
				break;
			case DOTCOMMA:
				{
				alt79=3;
				}
				break;
			case COMMACOMMA:
				{
				alt79=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 79, 0, input);
				throw nvae;
			}
			switch (alt79) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1923:4: rs= DOTDOT
					{
					rs=(BAST)match(input,DOTDOT,FOLLOW_DOTDOT_in_range_symbol4942); if (state.failed) return retval;
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1923:16: rs= COMMADOT
					{
					rs=(BAST)match(input,COMMADOT,FOLLOW_COMMADOT_in_range_symbol4948); if (state.failed) return retval;
					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1923:30: rs= DOTCOMMA
					{
					rs=(BAST)match(input,DOTCOMMA,FOLLOW_DOTCOMMA_in_range_symbol4954); if (state.failed) return retval;
					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1923:44: rs= COMMACOMMA
					{
					rs=(BAST)match(input,COMMACOMMA,FOLLOW_COMMACOMMA_in_range_symbol4960); if (state.failed) return retval;
					}
					break;

			}

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 1924:5: -> {%{$rs.text}}
			  {
			  	retval.st = new StringTemplate(templateLib,(rs!=null?rs.getText():null));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range_symbol"


	public static class expressionOrRange_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "expressionOrRange"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1931:1: expressionOrRange : ( ^(rs= range_symbol l= expression h= expression ) -> template(lb=$l.stub=$h.strs=$rs.st) \"<lb><rs><ub>\"|e= expression -> {$e.st});
	public final UnparseBLESS.expressionOrRange_return expressionOrRange() throws RecognitionException {
		UnparseBLESS.expressionOrRange_return retval = new UnparseBLESS.expressionOrRange_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope rs =null;
		TreeRuleReturnScope l =null;
		TreeRuleReturnScope h =null;
		TreeRuleReturnScope e =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1932:2: ( ^(rs= range_symbol l= expression h= expression ) -> template(lb=$l.stub=$h.strs=$rs.st) \"<lb><rs><ub>\"|e= expression -> {$e.st})
			int alt80=2;
			int LA80_0 = input.LA(1);
			if ( ((LA80_0 >= COMMACOMMA && LA80_0 <= COMMADOT)||(LA80_0 >= DOTCOMMA && LA80_0 <= DOTDOT)) ) {
				alt80=1;
			}
			else if ( (LA80_0==AADL_STRING_LITERAL||LA80_0==CASE_EXPRESSION||LA80_0==COMPLEX||LA80_0==CONDITIONAL||LA80_0==DIVIDE||LA80_0==DOUBLE_COLON||LA80_0==EXP||LA80_0==FUNCTION_CALL||LA80_0==ID||LA80_0==INMODE||LA80_0==INTEGER_LIT||LA80_0==LITERAL_and||LA80_0==LITERAL_cand||LA80_0==LITERAL_complex||LA80_0==LITERAL_cor||LA80_0==LITERAL_false||LA80_0==LITERAL_integer||LA80_0==LITERAL_mod||LA80_0==LITERAL_natural||(LA80_0 >= LITERAL_not && LA80_0 <= LITERAL_now)||LA80_0==LITERAL_null||LA80_0==LITERAL_or||(LA80_0 >= LITERAL_rational && LA80_0 <= LITERAL_real)||LA80_0==LITERAL_rem||(LA80_0 >= LITERAL_time && LA80_0 <= LITERAL_timeout)||LA80_0==LITERAL_tops||LA80_0==LITERAL_true||(LA80_0 >= LITERAL_xor && LA80_0 <= LPAREN)||LA80_0==MINUS||LA80_0==OCTOTHORPE||(LA80_0 >= PERIOD && LA80_0 <= PLUS)||LA80_0==QUESTION||LA80_0==RATIONAL||LA80_0==REAL_LIT||LA80_0==TICK||LA80_0==TIMES||LA80_0==UNARY_MINUS) ) {
				alt80=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 80, 0, input);
				throw nvae;
			}

			switch (alt80) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1933:2: ^(rs= range_symbol l= expression h= expression )
					{
					pushFollow(FOLLOW_range_symbol_in_expressionOrRange4993);
					rs=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_expressionOrRange4997);
					l=expression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_expression_in_expressionOrRange5001);
					h=expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1934:3: -> template(lb=$l.stub=$h.strs=$rs.st) \"<lb><rs><ub>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lb><rs><ub>",new STAttrMap().put("lb", (l!=null?((StringTemplate)l.getTemplate()):null)).put("ub", (h!=null?((StringTemplate)h.getTemplate()):null)).put("rs", (rs!=null?((StringTemplate)rs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1937:2: e= expression
					{
					pushFollow(FOLLOW_expression_in_expressionOrRange5035);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1938:3: -> {$e.st}
					  {
					  	retval.st = (e!=null?((StringTemplate)e.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expressionOrRange"


	public static class expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1942:1: expression : ( ^(n= PLUS (a+= subexpression )+ ) -> add(terms=$a)| ^(n= TIMES (a2+= subexpression )+ ) -> multiply(terms=$a2)| ^(n= MINUS l= subexpression r= subexpression ) -> two_element_expression_spaced(op=$n.textl=$l.str=$r.st)| ^(n= DIVIDE numer= subexpression d= subexpression ) -> two_element_expression_spaced(op=$n.textl=$numer.str=$d.st)| ^(n= LITERAL_mod l2= subexpression r2= subexpression ) -> mod(l=$l2.str=$r2.st)| ^(n= LITERAL_rem l6= subexpression r6= subexpression ) -> rem(l=$l6.str=$r6.st)| ^(n= EXP l3= subexpression r3= subexpression ) -> exp(l=$l3.str=$r3.st)| ^(n= LITERAL_and (a3+= subexpression )+ ) -> l_and(bs=$a3)| ^(n= LITERAL_or (a4+= subexpression )+ ) -> l_or(bs=$a4)| ^(n= LITERAL_xor (a5+= subexpression )+ ) -> l_xor(bs=$a5)| ^(n= LITERAL_cand (l4+= subexpression )+ ) -> l_cand(bs=$l4)| ^(n= LITERAL_cor (l5+= subexpression )+ ) -> l_cor(bs=$l5)|only= subexpression -> {$only.st});
	public final UnparseBLESS.expression_return expression() throws RecognitionException {
		UnparseBLESS.expression_return retval = new UnparseBLESS.expression_return();
		retval.start = input.LT(1);

		BAST n=null;
		List<Object> list_a=null;
		List<Object> list_a2=null;
		List<Object> list_a3=null;
		List<Object> list_a4=null;
		List<Object> list_a5=null;
		List<Object> list_l4=null;
		List<Object> list_l5=null;
		TreeRuleReturnScope l =null;
		TreeRuleReturnScope r =null;
		TreeRuleReturnScope numer =null;
		TreeRuleReturnScope d =null;
		TreeRuleReturnScope l2 =null;
		TreeRuleReturnScope r2 =null;
		TreeRuleReturnScope l6 =null;
		TreeRuleReturnScope r6 =null;
		TreeRuleReturnScope l3 =null;
		TreeRuleReturnScope r3 =null;
		TreeRuleReturnScope only =null;
		RuleReturnScope a = null;
		RuleReturnScope a2 = null;
		RuleReturnScope a3 = null;
		RuleReturnScope a4 = null;
		RuleReturnScope a5 = null;
		RuleReturnScope l4 = null;
		RuleReturnScope l5 = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1943:2: ( ^(n= PLUS (a+= subexpression )+ ) -> add(terms=$a)| ^(n= TIMES (a2+= subexpression )+ ) -> multiply(terms=$a2)| ^(n= MINUS l= subexpression r= subexpression ) -> two_element_expression_spaced(op=$n.textl=$l.str=$r.st)| ^(n= DIVIDE numer= subexpression d= subexpression ) -> two_element_expression_spaced(op=$n.textl=$numer.str=$d.st)| ^(n= LITERAL_mod l2= subexpression r2= subexpression ) -> mod(l=$l2.str=$r2.st)| ^(n= LITERAL_rem l6= subexpression r6= subexpression ) -> rem(l=$l6.str=$r6.st)| ^(n= EXP l3= subexpression r3= subexpression ) -> exp(l=$l3.str=$r3.st)| ^(n= LITERAL_and (a3+= subexpression )+ ) -> l_and(bs=$a3)| ^(n= LITERAL_or (a4+= subexpression )+ ) -> l_or(bs=$a4)| ^(n= LITERAL_xor (a5+= subexpression )+ ) -> l_xor(bs=$a5)| ^(n= LITERAL_cand (l4+= subexpression )+ ) -> l_cand(bs=$l4)| ^(n= LITERAL_cor (l5+= subexpression )+ ) -> l_cor(bs=$l5)|only= subexpression -> {$only.st})
			int alt88=13;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt88=1;
				}
				break;
			case TIMES:
				{
				alt88=2;
				}
				break;
			case MINUS:
				{
				alt88=3;
				}
				break;
			case DIVIDE:
				{
				alt88=4;
				}
				break;
			case LITERAL_mod:
				{
				alt88=5;
				}
				break;
			case LITERAL_rem:
				{
				alt88=6;
				}
				break;
			case EXP:
				{
				alt88=7;
				}
				break;
			case LITERAL_and:
				{
				alt88=8;
				}
				break;
			case LITERAL_or:
				{
				alt88=9;
				}
				break;
			case LITERAL_xor:
				{
				alt88=10;
				}
				break;
			case LITERAL_cand:
				{
				alt88=11;
				}
				break;
			case LITERAL_cor:
				{
				alt88=12;
				}
				break;
			case AADL_STRING_LITERAL:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DOUBLE_COLON:
			case FUNCTION_CALL:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_complex:
			case LITERAL_false:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
			case UNARY_MINUS:
				{
				alt88=13;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 88, 0, input);
				throw nvae;
			}
			switch (alt88) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1944:2: ^(n= PLUS (a+= subexpression )+ )
					{
					n=(BAST)match(input,PLUS,FOLLOW_PLUS_in_expression5065); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1944:13: (a+= subexpression )+
					int cnt81=0;
					loop81:
					while (true) {
						int alt81=2;
						int LA81_0 = input.LA(1);
						if ( (LA81_0==AADL_STRING_LITERAL||LA81_0==CASE_EXPRESSION||LA81_0==COMPLEX||LA81_0==CONDITIONAL||LA81_0==DOUBLE_COLON||LA81_0==FUNCTION_CALL||LA81_0==ID||LA81_0==INMODE||LA81_0==INTEGER_LIT||LA81_0==LITERAL_complex||LA81_0==LITERAL_false||LA81_0==LITERAL_integer||LA81_0==LITERAL_natural||(LA81_0 >= LITERAL_not && LA81_0 <= LITERAL_now)||LA81_0==LITERAL_null||(LA81_0 >= LITERAL_rational && LA81_0 <= LITERAL_real)||(LA81_0 >= LITERAL_time && LA81_0 <= LITERAL_timeout)||LA81_0==LITERAL_tops||LA81_0==LITERAL_true||LA81_0==LPAREN||LA81_0==OCTOTHORPE||LA81_0==PERIOD||LA81_0==QUESTION||LA81_0==RATIONAL||LA81_0==REAL_LIT||LA81_0==TICK||LA81_0==UNARY_MINUS) ) {
							alt81=1;
						}

						switch (alt81) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1944:13: a+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5069);
							a=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTemplate());
							}
							break;

						default :
							if ( cnt81 >= 1 ) break loop81;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(81, input);
							throw eee;
						}
						cnt81++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1945:3: -> add(terms=$a)
					  {
					  	retval.st = templateLib.getInstanceOf("add",new STAttrMap().put("terms", list_a));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1947:2: ^(n= TIMES (a2+= subexpression )+ )
					{
					n=(BAST)match(input,TIMES,FOLLOW_TIMES_in_expression5093); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1947:15: (a2+= subexpression )+
					int cnt82=0;
					loop82:
					while (true) {
						int alt82=2;
						int LA82_0 = input.LA(1);
						if ( (LA82_0==AADL_STRING_LITERAL||LA82_0==CASE_EXPRESSION||LA82_0==COMPLEX||LA82_0==CONDITIONAL||LA82_0==DOUBLE_COLON||LA82_0==FUNCTION_CALL||LA82_0==ID||LA82_0==INMODE||LA82_0==INTEGER_LIT||LA82_0==LITERAL_complex||LA82_0==LITERAL_false||LA82_0==LITERAL_integer||LA82_0==LITERAL_natural||(LA82_0 >= LITERAL_not && LA82_0 <= LITERAL_now)||LA82_0==LITERAL_null||(LA82_0 >= LITERAL_rational && LA82_0 <= LITERAL_real)||(LA82_0 >= LITERAL_time && LA82_0 <= LITERAL_timeout)||LA82_0==LITERAL_tops||LA82_0==LITERAL_true||LA82_0==LPAREN||LA82_0==OCTOTHORPE||LA82_0==PERIOD||LA82_0==QUESTION||LA82_0==RATIONAL||LA82_0==REAL_LIT||LA82_0==TICK||LA82_0==UNARY_MINUS) ) {
							alt82=1;
						}

						switch (alt82) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1947:15: a2+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5097);
							a2=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_a2==null) list_a2=new ArrayList<Object>();
							list_a2.add(a2.getTemplate());
							}
							break;

						default :
							if ( cnt82 >= 1 ) break loop82;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(82, input);
							throw eee;
						}
						cnt82++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1948:3: -> multiply(terms=$a2)
					  {
					  	retval.st = templateLib.getInstanceOf("multiply",new STAttrMap().put("terms", list_a2));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1950:2: ^(n= MINUS l= subexpression r= subexpression )
					{
					n=(BAST)match(input,MINUS,FOLLOW_MINUS_in_expression5121); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5125);
					l=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5129);
					r=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1951:4: -> two_element_expression_spaced(op=$n.textl=$l.str=$r.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression_spaced",new STAttrMap().put("op", (n!=null?n.getText():null)).put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("r", (r!=null?((StringTemplate)r.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1953:2: ^(n= DIVIDE numer= subexpression d= subexpression )
					{
					n=(BAST)match(input,DIVIDE,FOLLOW_DIVIDE_in_expression5161); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5165);
					numer=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5169);
					d=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1954:4: -> two_element_expression_spaced(op=$n.textl=$numer.str=$d.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression_spaced",new STAttrMap().put("op", (n!=null?n.getText():null)).put("l", (numer!=null?((StringTemplate)numer.getTemplate()):null)).put("r", (d!=null?((StringTemplate)d.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1956:2: ^(n= LITERAL_mod l2= subexpression r2= subexpression )
					{
					n=(BAST)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_expression5201); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5205);
					l2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5209);
					r2=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1957:4: -> mod(l=$l2.str=$r2.st)
					  {
					  	retval.st = templateLib.getInstanceOf("mod",new STAttrMap().put("l", (l2!=null?((StringTemplate)l2.getTemplate()):null)).put("r", (r2!=null?((StringTemplate)r2.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1959:2: ^(n= LITERAL_rem l6= subexpression r6= subexpression )
					{
					n=(BAST)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_expression5237); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5241);
					l6=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5245);
					r6=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1960:4: -> rem(l=$l6.str=$r6.st)
					  {
					  	retval.st = templateLib.getInstanceOf("rem",new STAttrMap().put("l", (l6!=null?((StringTemplate)l6.getTemplate()):null)).put("r", (r6!=null?((StringTemplate)r6.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1962:2: ^(n= EXP l3= subexpression r3= subexpression )
					{
					n=(BAST)match(input,EXP,FOLLOW_EXP_in_expression5273); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5277);
					l3=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_expression5281);
					r3=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1963:4: -> exp(l=$l3.str=$r3.st)
					  {
					  	retval.st = templateLib.getInstanceOf("exp",new STAttrMap().put("l", (l3!=null?((StringTemplate)l3.getTemplate()):null)).put("r", (r3!=null?((StringTemplate)r3.getTemplate()):null)));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1965:2: ^(n= LITERAL_and (a3+= subexpression )+ )
					{
					n=(BAST)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_expression5309); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1965:21: (a3+= subexpression )+
					int cnt83=0;
					loop83:
					while (true) {
						int alt83=2;
						int LA83_0 = input.LA(1);
						if ( (LA83_0==AADL_STRING_LITERAL||LA83_0==CASE_EXPRESSION||LA83_0==COMPLEX||LA83_0==CONDITIONAL||LA83_0==DOUBLE_COLON||LA83_0==FUNCTION_CALL||LA83_0==ID||LA83_0==INMODE||LA83_0==INTEGER_LIT||LA83_0==LITERAL_complex||LA83_0==LITERAL_false||LA83_0==LITERAL_integer||LA83_0==LITERAL_natural||(LA83_0 >= LITERAL_not && LA83_0 <= LITERAL_now)||LA83_0==LITERAL_null||(LA83_0 >= LITERAL_rational && LA83_0 <= LITERAL_real)||(LA83_0 >= LITERAL_time && LA83_0 <= LITERAL_timeout)||LA83_0==LITERAL_tops||LA83_0==LITERAL_true||LA83_0==LPAREN||LA83_0==OCTOTHORPE||LA83_0==PERIOD||LA83_0==QUESTION||LA83_0==RATIONAL||LA83_0==REAL_LIT||LA83_0==TICK||LA83_0==UNARY_MINUS) ) {
							alt83=1;
						}

						switch (alt83) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1965:21: a3+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5313);
							a3=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_a3==null) list_a3=new ArrayList<Object>();
							list_a3.add(a3.getTemplate());
							}
							break;

						default :
							if ( cnt83 >= 1 ) break loop83;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(83, input);
							throw eee;
						}
						cnt83++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1966:3: -> l_and(bs=$a3)
					  {
					  	retval.st = templateLib.getInstanceOf("l_and",new STAttrMap().put("bs", list_a3));
					  }


					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1968:2: ^(n= LITERAL_or (a4+= subexpression )+ )
					{
					n=(BAST)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_expression5337); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1968:20: (a4+= subexpression )+
					int cnt84=0;
					loop84:
					while (true) {
						int alt84=2;
						int LA84_0 = input.LA(1);
						if ( (LA84_0==AADL_STRING_LITERAL||LA84_0==CASE_EXPRESSION||LA84_0==COMPLEX||LA84_0==CONDITIONAL||LA84_0==DOUBLE_COLON||LA84_0==FUNCTION_CALL||LA84_0==ID||LA84_0==INMODE||LA84_0==INTEGER_LIT||LA84_0==LITERAL_complex||LA84_0==LITERAL_false||LA84_0==LITERAL_integer||LA84_0==LITERAL_natural||(LA84_0 >= LITERAL_not && LA84_0 <= LITERAL_now)||LA84_0==LITERAL_null||(LA84_0 >= LITERAL_rational && LA84_0 <= LITERAL_real)||(LA84_0 >= LITERAL_time && LA84_0 <= LITERAL_timeout)||LA84_0==LITERAL_tops||LA84_0==LITERAL_true||LA84_0==LPAREN||LA84_0==OCTOTHORPE||LA84_0==PERIOD||LA84_0==QUESTION||LA84_0==RATIONAL||LA84_0==REAL_LIT||LA84_0==TICK||LA84_0==UNARY_MINUS) ) {
							alt84=1;
						}

						switch (alt84) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1968:20: a4+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5341);
							a4=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_a4==null) list_a4=new ArrayList<Object>();
							list_a4.add(a4.getTemplate());
							}
							break;

						default :
							if ( cnt84 >= 1 ) break loop84;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(84, input);
							throw eee;
						}
						cnt84++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1969:3: -> l_or(bs=$a4)
					  {
					  	retval.st = templateLib.getInstanceOf("l_or",new STAttrMap().put("bs", list_a4));
					  }


					}

					}
					break;
				case 10 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1971:2: ^(n= LITERAL_xor (a5+= subexpression )+ )
					{
					n=(BAST)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_expression5365); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1971:21: (a5+= subexpression )+
					int cnt85=0;
					loop85:
					while (true) {
						int alt85=2;
						int LA85_0 = input.LA(1);
						if ( (LA85_0==AADL_STRING_LITERAL||LA85_0==CASE_EXPRESSION||LA85_0==COMPLEX||LA85_0==CONDITIONAL||LA85_0==DOUBLE_COLON||LA85_0==FUNCTION_CALL||LA85_0==ID||LA85_0==INMODE||LA85_0==INTEGER_LIT||LA85_0==LITERAL_complex||LA85_0==LITERAL_false||LA85_0==LITERAL_integer||LA85_0==LITERAL_natural||(LA85_0 >= LITERAL_not && LA85_0 <= LITERAL_now)||LA85_0==LITERAL_null||(LA85_0 >= LITERAL_rational && LA85_0 <= LITERAL_real)||(LA85_0 >= LITERAL_time && LA85_0 <= LITERAL_timeout)||LA85_0==LITERAL_tops||LA85_0==LITERAL_true||LA85_0==LPAREN||LA85_0==OCTOTHORPE||LA85_0==PERIOD||LA85_0==QUESTION||LA85_0==RATIONAL||LA85_0==REAL_LIT||LA85_0==TICK||LA85_0==UNARY_MINUS) ) {
							alt85=1;
						}

						switch (alt85) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1971:21: a5+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5369);
							a5=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_a5==null) list_a5=new ArrayList<Object>();
							list_a5.add(a5.getTemplate());
							}
							break;

						default :
							if ( cnt85 >= 1 ) break loop85;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(85, input);
							throw eee;
						}
						cnt85++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1972:3: -> l_xor(bs=$a5)
					  {
					  	retval.st = templateLib.getInstanceOf("l_xor",new STAttrMap().put("bs", list_a5));
					  }


					}

					}
					break;
				case 11 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1974:2: ^(n= LITERAL_cand (l4+= subexpression )+ )
					{
					n=(BAST)match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_expression5394); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1974:22: (l4+= subexpression )+
					int cnt86=0;
					loop86:
					while (true) {
						int alt86=2;
						int LA86_0 = input.LA(1);
						if ( (LA86_0==AADL_STRING_LITERAL||LA86_0==CASE_EXPRESSION||LA86_0==COMPLEX||LA86_0==CONDITIONAL||LA86_0==DOUBLE_COLON||LA86_0==FUNCTION_CALL||LA86_0==ID||LA86_0==INMODE||LA86_0==INTEGER_LIT||LA86_0==LITERAL_complex||LA86_0==LITERAL_false||LA86_0==LITERAL_integer||LA86_0==LITERAL_natural||(LA86_0 >= LITERAL_not && LA86_0 <= LITERAL_now)||LA86_0==LITERAL_null||(LA86_0 >= LITERAL_rational && LA86_0 <= LITERAL_real)||(LA86_0 >= LITERAL_time && LA86_0 <= LITERAL_timeout)||LA86_0==LITERAL_tops||LA86_0==LITERAL_true||LA86_0==LPAREN||LA86_0==OCTOTHORPE||LA86_0==PERIOD||LA86_0==QUESTION||LA86_0==RATIONAL||LA86_0==REAL_LIT||LA86_0==TICK||LA86_0==UNARY_MINUS) ) {
							alt86=1;
						}

						switch (alt86) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1974:22: l4+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5398);
							l4=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_l4==null) list_l4=new ArrayList<Object>();
							list_l4.add(l4.getTemplate());
							}
							break;

						default :
							if ( cnt86 >= 1 ) break loop86;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(86, input);
							throw eee;
						}
						cnt86++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1975:4: -> l_cand(bs=$l4)
					  {
					  	retval.st = templateLib.getInstanceOf("l_cand",new STAttrMap().put("bs", list_l4));
					  }


					}

					}
					break;
				case 12 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1977:2: ^(n= LITERAL_cor (l5+= subexpression )+ )
					{
					n=(BAST)match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_expression5423); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1977:21: (l5+= subexpression )+
					int cnt87=0;
					loop87:
					while (true) {
						int alt87=2;
						int LA87_0 = input.LA(1);
						if ( (LA87_0==AADL_STRING_LITERAL||LA87_0==CASE_EXPRESSION||LA87_0==COMPLEX||LA87_0==CONDITIONAL||LA87_0==DOUBLE_COLON||LA87_0==FUNCTION_CALL||LA87_0==ID||LA87_0==INMODE||LA87_0==INTEGER_LIT||LA87_0==LITERAL_complex||LA87_0==LITERAL_false||LA87_0==LITERAL_integer||LA87_0==LITERAL_natural||(LA87_0 >= LITERAL_not && LA87_0 <= LITERAL_now)||LA87_0==LITERAL_null||(LA87_0 >= LITERAL_rational && LA87_0 <= LITERAL_real)||(LA87_0 >= LITERAL_time && LA87_0 <= LITERAL_timeout)||LA87_0==LITERAL_tops||LA87_0==LITERAL_true||LA87_0==LPAREN||LA87_0==OCTOTHORPE||LA87_0==PERIOD||LA87_0==QUESTION||LA87_0==RATIONAL||LA87_0==REAL_LIT||LA87_0==TICK||LA87_0==UNARY_MINUS) ) {
							alt87=1;
						}

						switch (alt87) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1977:21: l5+= subexpression
							{
							pushFollow(FOLLOW_subexpression_in_expression5427);
							l5=subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_l5==null) list_l5=new ArrayList<Object>();
							list_l5.add(l5.getTemplate());
							}
							break;

						default :
							if ( cnt87 >= 1 ) break loop87;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(87, input);
							throw eee;
						}
						cnt87++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1978:4: -> l_cor(bs=$l5)
					  {
					  	retval.st = templateLib.getInstanceOf("l_cor",new STAttrMap().put("bs", list_l5));
					  }


					}

					}
					break;
				case 13 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1980:2: only= subexpression
					{
					pushFollow(FOLLOW_subexpression_in_expression5451);
					only=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 1981:4: -> {$only.st}
					  {
					  	retval.st = (only!=null?((StringTemplate)only.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

			    if (!suppressRecognitionException)
			      {
			      Dump.it("UnparseBLESS.expression caught RecognitionException");
			      if (n!=null)
			        n.showParseTree(n.getText());
			      }
			    reportError(re);
			    
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class subexpression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1995:1: subexpression : ( ^( UNARY_MINUS a= value ) -> template(a=$a.st) \"-<a>\"| ^( UNARY_MINUS ps= parenthesized_subexpression ) -> template(ps=$ps.st) \"-<ps>\"| ^( LITERAL_not a2= value ) -> not(bt=$a2.st)| ^( LITERAL_not ps= parenthesized_subexpression ) -> not(bt=$ps.st)|ps= parenthesized_subexpression -> {$ps.st}|a3= value -> {$a3.st}|fc= function_call -> {$fc.st}|tc= type_conversion -> {$tc.st});
	public final UnparseBLESS.subexpression_return subexpression() throws RecognitionException {
		UnparseBLESS.subexpression_return retval = new UnparseBLESS.subexpression_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope a =null;
		TreeRuleReturnScope ps =null;
		TreeRuleReturnScope a2 =null;
		TreeRuleReturnScope a3 =null;
		TreeRuleReturnScope fc =null;
		TreeRuleReturnScope tc =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:1996:2: ( ^( UNARY_MINUS a= value ) -> template(a=$a.st) \"-<a>\"| ^( UNARY_MINUS ps= parenthesized_subexpression ) -> template(ps=$ps.st) \"-<ps>\"| ^( LITERAL_not a2= value ) -> not(bt=$a2.st)| ^( LITERAL_not ps= parenthesized_subexpression ) -> not(bt=$ps.st)|ps= parenthesized_subexpression -> {$ps.st}|a3= value -> {$a3.st}|fc= function_call -> {$fc.st}|tc= type_conversion -> {$tc.st})
			int alt89=8;
			switch ( input.LA(1) ) {
			case UNARY_MINUS:
				{
				int LA89_1 = input.LA(2);
				if ( (LA89_1==DOWN) ) {
					int LA89_7 = input.LA(3);
					if ( (LA89_7==AADL_STRING_LITERAL||LA89_7==COMPLEX||LA89_7==DOUBLE_COLON||LA89_7==ID||LA89_7==INMODE||LA89_7==INTEGER_LIT||LA89_7==LITERAL_false||LA89_7==LITERAL_now||LA89_7==LITERAL_null||LA89_7==LITERAL_timeout||LA89_7==LITERAL_tops||LA89_7==LITERAL_true||LA89_7==OCTOTHORPE||LA89_7==PERIOD||LA89_7==QUESTION||LA89_7==RATIONAL||LA89_7==REAL_LIT||LA89_7==TICK) ) {
						alt89=1;
					}
					else if ( (LA89_7==CASE_EXPRESSION||LA89_7==CONDITIONAL||LA89_7==LPAREN) ) {
						alt89=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 89, 7, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 89, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_not:
				{
				int LA89_2 = input.LA(2);
				if ( (LA89_2==DOWN) ) {
					int LA89_8 = input.LA(3);
					if ( (LA89_8==AADL_STRING_LITERAL||LA89_8==COMPLEX||LA89_8==DOUBLE_COLON||LA89_8==ID||LA89_8==INMODE||LA89_8==INTEGER_LIT||LA89_8==LITERAL_false||LA89_8==LITERAL_now||LA89_8==LITERAL_null||LA89_8==LITERAL_timeout||LA89_8==LITERAL_tops||LA89_8==LITERAL_true||LA89_8==OCTOTHORPE||LA89_8==PERIOD||LA89_8==QUESTION||LA89_8==RATIONAL||LA89_8==REAL_LIT||LA89_8==TICK) ) {
						alt89=3;
					}
					else if ( (LA89_8==CASE_EXPRESSION||LA89_8==CONDITIONAL||LA89_8==LPAREN) ) {
						alt89=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 89, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 89, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case CASE_EXPRESSION:
			case CONDITIONAL:
			case LPAREN:
				{
				alt89=5;
				}
				break;
			case AADL_STRING_LITERAL:
			case COMPLEX:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_false:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
				{
				alt89=6;
				}
				break;
			case FUNCTION_CALL:
				{
				alt89=7;
				}
				break;
			case LITERAL_complex:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
				{
				alt89=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 89, 0, input);
				throw nvae;
			}
			switch (alt89) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2000:2: ^( UNARY_MINUS a= value )
					{
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_subexpression5491); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_value_in_subexpression5495);
					a=value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2001:3: -> template(a=$a.st) \"-<a>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "-<a>",new STAttrMap().put("a", (a!=null?((StringTemplate)a.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2003:2: ^( UNARY_MINUS ps= parenthesized_subexpression )
					{
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_subexpression5518); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression5522);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2004:3: -> template(ps=$ps.st) \"-<ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "-<ps>",new STAttrMap().put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2006:2: ^( LITERAL_not a2= value )
					{
					match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subexpression5546); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_value_in_subexpression5550);
					a2=value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2007:4: -> not(bt=$a2.st)
					  {
					  	retval.st = templateLib.getInstanceOf("not",new STAttrMap().put("bt", (a2!=null?((StringTemplate)a2.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2010:2: ^( LITERAL_not ps= parenthesized_subexpression )
					{
					match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subexpression5572); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression5576);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2011:4: -> not(bt=$ps.st)
					  {
					  	retval.st = templateLib.getInstanceOf("not",new STAttrMap().put("bt", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2014:2: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_subexpression5600);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2015:3: -> {$ps.st}
					  {
					  	retval.st = (ps!=null?((StringTemplate)ps.getTemplate()):null);
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2021:2: a3= value
					{
					pushFollow(FOLLOW_value_in_subexpression5620);
					a3=value();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2022:3: -> {$a3.st}
					  {
					  	retval.st = (a3!=null?((StringTemplate)a3.getTemplate()):null);
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2024:3: fc= function_call
					{
					pushFollow(FOLLOW_function_call_in_subexpression5635);
					fc=function_call();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2025:5: -> {$fc.st}
					  {
					  	retval.st = (fc!=null?((StringTemplate)fc.getTemplate()):null);
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2026:5: tc= type_conversion
					{
					pushFollow(FOLLOW_type_conversion_in_subexpression5652);
					tc=type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2027:5: -> {$tc.st}
					  {
					  	retval.st = (tc!=null?((StringTemplate)tc.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subexpression"


	public static class type_conversion_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2032:1: type_conversion : ( ^(n= LITERAL_natural ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_integer ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_rational ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_real ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_complex ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_time ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\");
	public final UnparseBLESS.type_conversion_return type_conversion() throws RecognitionException {
		UnparseBLESS.type_conversion_return retval = new UnparseBLESS.type_conversion_return();
		retval.start = input.LT(1);

		BAST n=null;
		TreeRuleReturnScope ps =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2033:2: ( ^(n= LITERAL_natural ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_integer ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_rational ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_real ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_complex ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_time ps= parenthesized_subexpression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\")
			int alt90=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt90=1;
				}
				break;
			case LITERAL_integer:
				{
				alt90=2;
				}
				break;
			case LITERAL_rational:
				{
				alt90=3;
				}
				break;
			case LITERAL_real:
				{
				alt90=4;
				}
				break;
			case LITERAL_complex:
				{
				alt90=5;
				}
				break;
			case LITERAL_time:
				{
				alt90=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 90, 0, input);
				throw nvae;
			}
			switch (alt90) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2034:3: ^(n= LITERAL_natural ps= parenthesized_subexpression )
					{
					n=(BAST)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_type_conversion5679); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion5683);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2035:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2036:5: ^(n= LITERAL_integer ps= parenthesized_subexpression )
					{
					n=(BAST)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_type_conversion5711); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion5715);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2037:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2038:5: ^(n= LITERAL_rational ps= parenthesized_subexpression )
					{
					n=(BAST)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_type_conversion5743); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion5747);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2039:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2040:5: ^(n= LITERAL_real ps= parenthesized_subexpression )
					{
					n=(BAST)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_type_conversion5775); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion5779);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2041:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2042:5: ^(n= LITERAL_complex ps= parenthesized_subexpression )
					{
					n=(BAST)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_type_conversion5807); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion5811);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2043:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2044:5: ^(n= LITERAL_time ps= parenthesized_subexpression )
					{
					n=(BAST)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_type_conversion5839); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_type_conversion5843);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2045:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_conversion"


	public static class assertion_type_conversion_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_type_conversion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2048:1: assertion_type_conversion : ( ^(n= LITERAL_natural ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_integer ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_rational ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_real ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_complex ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_time ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\");
	public final UnparseBLESS.assertion_type_conversion_return assertion_type_conversion() throws RecognitionException {
		UnparseBLESS.assertion_type_conversion_return retval = new UnparseBLESS.assertion_type_conversion_return();
		retval.start = input.LT(1);

		BAST n=null;
		TreeRuleReturnScope ps =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2049:2: ( ^(n= LITERAL_natural ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_integer ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_rational ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_real ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_complex ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\"| ^(n= LITERAL_time ps= parenthesized_assertion_expression ) -> template(n=$n.textps=$ps.st) \"<n><ps>\")
			int alt91=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt91=1;
				}
				break;
			case LITERAL_integer:
				{
				alt91=2;
				}
				break;
			case LITERAL_rational:
				{
				alt91=3;
				}
				break;
			case LITERAL_real:
				{
				alt91=4;
				}
				break;
			case LITERAL_complex:
				{
				alt91=5;
				}
				break;
			case LITERAL_time:
				{
				alt91=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 91, 0, input);
				throw nvae;
			}
			switch (alt91) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2050:3: ^(n= LITERAL_natural ps= parenthesized_assertion_expression )
					{
					n=(BAST)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type_conversion5879); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5883);
					ps=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2051:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2052:5: ^(n= LITERAL_integer ps= parenthesized_assertion_expression )
					{
					n=(BAST)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type_conversion5911); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5915);
					ps=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2053:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2054:5: ^(n= LITERAL_rational ps= parenthesized_assertion_expression )
					{
					n=(BAST)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type_conversion5943); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5947);
					ps=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2055:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2056:5: ^(n= LITERAL_real ps= parenthesized_assertion_expression )
					{
					n=(BAST)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type_conversion5975); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5979);
					ps=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2057:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2058:5: ^(n= LITERAL_complex ps= parenthesized_assertion_expression )
					{
					n=(BAST)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type_conversion6007); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion6011);
					ps=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2059:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2060:5: ^(n= LITERAL_time ps= parenthesized_assertion_expression )
					{
					n=(BAST)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type_conversion6039); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion6043);
					ps=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2061:5: -> template(n=$n.textps=$ps.st) \"<n><ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<n><ps>",new STAttrMap().put("n", (n!=null?n.getText():null)).put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type_conversion"


	public static class parenthesized_subexpression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "parenthesized_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2065:1: parenthesized_subexpression : ( ^( LPAREN eor= expression_or_relation RPAREN ) -> template(eor=$eor.st) \"(<eor>)\"|ce= conditional_expression -> {$ce.st}|cas= case_expression -> {$cas.st});
	public final UnparseBLESS.parenthesized_subexpression_return parenthesized_subexpression() throws RecognitionException {
		UnparseBLESS.parenthesized_subexpression_return retval = new UnparseBLESS.parenthesized_subexpression_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope eor =null;
		TreeRuleReturnScope ce =null;
		TreeRuleReturnScope cas =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2066:2: ( ^( LPAREN eor= expression_or_relation RPAREN ) -> template(eor=$eor.st) \"(<eor>)\"|ce= conditional_expression -> {$ce.st}|cas= case_expression -> {$cas.st})
			int alt92=3;
			switch ( input.LA(1) ) {
			case LPAREN:
				{
				alt92=1;
				}
				break;
			case CONDITIONAL:
				{
				alt92=2;
				}
				break;
			case CASE_EXPRESSION:
				{
				alt92=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 92, 0, input);
				throw nvae;
			}
			switch (alt92) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2067:2: ^( LPAREN eor= expression_or_relation RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_subexpression6079); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_or_relation_in_parenthesized_subexpression6083);
					eor=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_subexpression6085); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2068:4: -> template(eor=$eor.st) \"(<eor>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<eor>)",new STAttrMap().put("eor", (eor!=null?((StringTemplate)eor.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2070:2: ce= conditional_expression
					{
					pushFollow(FOLLOW_conditional_expression_in_parenthesized_subexpression6110);
					ce=conditional_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2071:4: -> {$ce.st}
					  {
					  	retval.st = (ce!=null?((StringTemplate)ce.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2073:2: cas= case_expression
					{
					pushFollow(FOLLOW_case_expression_in_parenthesized_subexpression6125);
					cas=case_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2074:4: -> {$cas.st}
					  {
					  	retval.st = (cas!=null?((StringTemplate)cas.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_subexpression"


	public static class case_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "case_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2077:1: case_expression : ^( CASE_EXPRESSION (cc+= case_choice )+ ) -> case_expression(cc=$cc);
	public final UnparseBLESS.case_expression_return case_expression() throws RecognitionException {
		UnparseBLESS.case_expression_return retval = new UnparseBLESS.case_expression_return();
		retval.start = input.LT(1);

		List<Object> list_cc=null;
		RuleReturnScope cc = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2078:3: ( ^( CASE_EXPRESSION (cc+= case_choice )+ ) -> case_expression(cc=$cc))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2079:3: ^( CASE_EXPRESSION (cc+= case_choice )+ )
			{
			match(input,CASE_EXPRESSION,FOLLOW_CASE_EXPRESSION_in_case_expression6149); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2079:24: (cc+= case_choice )+
			int cnt93=0;
			loop93:
			while (true) {
				int alt93=2;
				int LA93_0 = input.LA(1);
				if ( (LA93_0==IMP) ) {
					alt93=1;
				}

				switch (alt93) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2079:24: cc+= case_choice
					{
					pushFollow(FOLLOW_case_choice_in_case_expression6153);
					cc=case_choice();
					state._fsp--;
					if (state.failed) return retval;
					if (list_cc==null) list_cc=new ArrayList<Object>();
					list_cc.add(cc.getTemplate());
					}
					break;

				default :
					if ( cnt93 >= 1 ) break loop93;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(93, input);
					throw eee;
				}
				cnt93++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2080:5: -> case_expression(cc=$cc)
			  {
			  	retval.st = templateLib.getInstanceOf("case_expression",new STAttrMap().put("cc", list_cc));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_expression"


	public static class case_choice_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "case_choice"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2083:1: case_choice : ^( IMP be= boolean_expression_or_relation exp= expression ) -> case_choice(be=$be.stexp=$exp.st);
	public final UnparseBLESS.case_choice_return case_choice() throws RecognitionException {
		UnparseBLESS.case_choice_return retval = new UnparseBLESS.case_choice_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope be =null;
		TreeRuleReturnScope exp =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2084:3: ( ^( IMP be= boolean_expression_or_relation exp= expression ) -> case_choice(be=$be.stexp=$exp.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2085:3: ^( IMP be= boolean_expression_or_relation exp= expression )
			{
			match(input,IMP,FOLLOW_IMP_in_case_choice6186); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_boolean_expression_or_relation_in_case_choice6190);
			be=boolean_expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_case_choice6194);
			exp=expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2086:5: -> case_choice(be=$be.stexp=$exp.st)
			  {
			  	retval.st = templateLib.getInstanceOf("case_choice",new STAttrMap().put("be", (be!=null?((StringTemplate)be.getTemplate()):null)).put("exp", (exp!=null?((StringTemplate)exp.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_choice"


	public static class conditional_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "conditional_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2089:1: conditional_expression : ^( CONDITIONAL be= expression_or_relation t= expression f= expression ) -> conditional_expression(be=$be.stt=$t.stf=$f.st);
	public final UnparseBLESS.conditional_expression_return conditional_expression() throws RecognitionException {
		UnparseBLESS.conditional_expression_return retval = new UnparseBLESS.conditional_expression_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope be =null;
		TreeRuleReturnScope t =null;
		TreeRuleReturnScope f =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2090:3: ( ^( CONDITIONAL be= expression_or_relation t= expression f= expression ) -> conditional_expression(be=$be.stt=$t.stf=$f.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2091:2: ^( CONDITIONAL be= expression_or_relation t= expression f= expression )
			{
			match(input,CONDITIONAL,FOLLOW_CONDITIONAL_in_conditional_expression6230); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_or_relation_in_conditional_expression6234);
			be=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_conditional_expression6238);
			t=expression();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_conditional_expression6242);
			f=expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2092:4: -> conditional_expression(be=$be.stt=$t.stf=$f.st)
			  {
			  	retval.st = templateLib.getInstanceOf("conditional_expression",new STAttrMap().put("be", (be!=null?((StringTemplate)be.getTemplate()):null)).put("t", (t!=null?((StringTemplate)t.getTemplate()):null)).put("f", (f!=null?((StringTemplate)f.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_expression"


	public static class value_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2097:1: value : (vc= value_constant -> {$vc.st}|vn= variable_name -> {$vn.st}| ^( QUESTION pn= port_name ) -> in_port_value(pn=$pn.st)| ^( TICK pn= port_name LITERAL_fresh ) -> port_fresh(i=$pn.st)| ^( TICK pn= port_name LITERAL_count ) -> port_count(i=$pn.st)| ^( TICK pn= port_name LITERAL_updated ) -> port_updated(i=$pn.st)| ^( INMODE (m+= ID )+ ) -> template(m=$m) \"in mode (<m; separator=\" \">)\"|to= LITERAL_timeout -> {%{$to.text}}|nu= LITERAL_null -> {%{$nu.text}}|now= LITERAL_now -> now(|tops= LITERAL_tops -> {%{$tops.text}});
	public final UnparseBLESS.value_return value() throws RecognitionException {
		UnparseBLESS.value_return retval = new UnparseBLESS.value_return();
		retval.start = input.LT(1);

		BAST to=null;
		BAST nu=null;
		BAST now=null;
		BAST tops=null;
		BAST m=null;
		List<Object> list_m=null;
		TreeRuleReturnScope vc =null;
		TreeRuleReturnScope vn =null;
		TreeRuleReturnScope pn =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2098:2: (vc= value_constant -> {$vc.st}|vn= variable_name -> {$vn.st}| ^( QUESTION pn= port_name ) -> in_port_value(pn=$pn.st)| ^( TICK pn= port_name LITERAL_fresh ) -> port_fresh(i=$pn.st)| ^( TICK pn= port_name LITERAL_count ) -> port_count(i=$pn.st)| ^( TICK pn= port_name LITERAL_updated ) -> port_updated(i=$pn.st)| ^( INMODE (m+= ID )+ ) -> template(m=$m) \"in mode (<m; separator=\" \">)\"|to= LITERAL_timeout -> {%{$to.text}}|nu= LITERAL_null -> {%{$nu.text}}|now= LITERAL_now -> now(|tops= LITERAL_tops -> {%{$tops.text}})
			int alt95=11;
			alt95 = dfa95.predict(input);
			switch (alt95) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2099:3: vc= value_constant
					{
					pushFollow(FOLLOW_value_constant_in_value6291);
					vc=value_constant();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2099:21: -> {$vc.st}
					  {
					  	retval.st = (vc!=null?((StringTemplate)vc.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2101:2: vn= variable_name
					{
					pushFollow(FOLLOW_variable_name_in_value6303);
					vn=variable_name();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2101:19: -> {$vn.st}
					  {
					  	retval.st = (vn!=null?((StringTemplate)vn.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2103:2: ^( QUESTION pn= port_name )
					{
					match(input,QUESTION,FOLLOW_QUESTION_in_value6314); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_value6318);
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2104:4: -> in_port_value(pn=$pn.st)
					  {
					  	retval.st = templateLib.getInstanceOf("in_port_value",new STAttrMap().put("pn", (pn!=null?((StringTemplate)pn.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2107:2: ^( TICK pn= port_name LITERAL_fresh )
					{
					match(input,TICK,FOLLOW_TICK_in_value6339); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_value6343);
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input,LITERAL_fresh,FOLLOW_LITERAL_fresh_in_value6345); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2108:4: -> port_fresh(i=$pn.st)
					  {
					  	retval.st = templateLib.getInstanceOf("port_fresh",new STAttrMap().put("i", (pn!=null?((StringTemplate)pn.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2111:2: ^( TICK pn= port_name LITERAL_count )
					{
					match(input,TICK,FOLLOW_TICK_in_value6366); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_value6370);
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input,LITERAL_count,FOLLOW_LITERAL_count_in_value6372); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2112:4: -> port_count(i=$pn.st)
					  {
					  	retval.st = templateLib.getInstanceOf("port_count",new STAttrMap().put("i", (pn!=null?((StringTemplate)pn.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2115:2: ^( TICK pn= port_name LITERAL_updated )
					{
					match(input,TICK,FOLLOW_TICK_in_value6393); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_port_name_in_value6397);
					pn=port_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input,LITERAL_updated,FOLLOW_LITERAL_updated_in_value6399); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2116:4: -> port_updated(i=$pn.st)
					  {
					  	retval.st = templateLib.getInstanceOf("port_updated",new STAttrMap().put("i", (pn!=null?((StringTemplate)pn.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2119:2: ^( INMODE (m+= ID )+ )
					{
					match(input,INMODE,FOLLOW_INMODE_in_value6420); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2119:12: (m+= ID )+
					int cnt94=0;
					loop94:
					while (true) {
						int alt94=2;
						int LA94_0 = input.LA(1);
						if ( (LA94_0==ID) ) {
							alt94=1;
						}

						switch (alt94) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2119:12: m+= ID
							{
							m=(BAST)match(input,ID,FOLLOW_ID_in_value6424); if (state.failed) return retval;
							if (list_m==null) list_m=new ArrayList<Object>();
							list_m.add(m);
							}
							break;

						default :
							if ( cnt94 >= 1 ) break loop94;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(94, input);
							throw eee;
						}
						cnt94++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2120:3: -> template(m=$m) \"in mode (<m; separator=\" \">)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "in mode (<m; separator=\" \">)",new STAttrMap().put("m", list_m));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2122:2: to= LITERAL_timeout
					{
					to=(BAST)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_value6446); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2122:21: -> {%{$to.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(to!=null?to.getText():null));
					  }


					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2124:2: nu= LITERAL_null
					{
					nu=(BAST)match(input,LITERAL_null,FOLLOW_LITERAL_null_in_value6458); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2124:18: -> {%{$nu.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(nu!=null?nu.getText():null));
					  }


					}

					}
					break;
				case 10 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2126:2: now= LITERAL_now
					{
					now=(BAST)match(input,LITERAL_now,FOLLOW_LITERAL_now_in_value6470); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2126:18: -> now(
					  {
					  	retval.st = templateLib.getInstanceOf("now");
					  }


					}

					}
					break;
				case 11 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2128:2: tops= LITERAL_tops
					{
					tops=(BAST)match(input,LITERAL_tops,FOLLOW_LITERAL_tops_in_value6485); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2128:20: -> {%{$tops.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(tops!=null?tops.getText():null));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value"


	public static class variable_name_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "variable_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2131:1: variable_name : n= name -> {$n.st};
	public final UnparseBLESS.variable_name_return variable_name() throws RecognitionException {
		UnparseBLESS.variable_name_return retval = new UnparseBLESS.variable_name_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope n =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2132:2: (n= name -> {$n.st})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2133:2: n= name
			{
			pushFollow(FOLLOW_name_in_variable_name6506);
			n=name();
			state._fsp--;
			if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2133:9: -> {$n.st}
			  {
			  	retval.st = (n!=null?((StringTemplate)n.getTemplate()):null);
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variable_name"


	public static class expression_or_relation_or_record_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "expression_or_relation_or_record"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2136:1: expression_or_relation_or_record : eor= expression_or_relation -> {$eor.st};
	public final UnparseBLESS.expression_or_relation_or_record_return expression_or_relation_or_record() throws RecognitionException {
		UnparseBLESS.expression_or_relation_or_record_return retval = new UnparseBLESS.expression_or_relation_or_record_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope eor =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2137:3: (eor= expression_or_relation -> {$eor.st})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2138:3: eor= expression_or_relation
			{
			pushFollow(FOLLOW_expression_or_relation_in_expression_or_relation_or_record6528);
			eor=expression_or_relation();
			state._fsp--;
			if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2139:5: -> {$eor.st}
			  {
			  	retval.st = (eor!=null?((StringTemplate)eor.getTemplate()):null);
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_relation_or_record"


	public static class expression_or_relation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2142:1: expression_or_relation : (rel= relation -> {$rel.st}|e= expression -> {$e.st}|rt= record_term -> {$rt.st});
	public final UnparseBLESS.expression_or_relation_return expression_or_relation() throws RecognitionException {
		UnparseBLESS.expression_or_relation_return retval = new UnparseBLESS.expression_or_relation_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope rel =null;
		TreeRuleReturnScope e =null;
		TreeRuleReturnScope rt =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2143:2: (rel= relation -> {$rel.st}|e= expression -> {$e.st}|rt= record_term -> {$rt.st})
			int alt96=3;
			switch ( input.LA(1) ) {
			case AL:
			case AM:
			case EQ:
			case GT:
			case LT:
			case NEQ:
				{
				alt96=1;
				}
				break;
			case AADL_STRING_LITERAL:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DIVIDE:
			case DOUBLE_COLON:
			case EXP:
			case FUNCTION_CALL:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_and:
			case LITERAL_cand:
			case LITERAL_complex:
			case LITERAL_cor:
			case LITERAL_false:
			case LITERAL_integer:
			case LITERAL_mod:
			case LITERAL_natural:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_or:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_rem:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LITERAL_xor:
			case MINUS:
			case OCTOTHORPE:
			case PERIOD:
			case PLUS:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
			case TIMES:
			case UNARY_MINUS:
				{
				alt96=2;
				}
				break;
			case LPAREN:
				{
				int LA96_3 = input.LA(2);
				if ( (LA96_3==DOWN) ) {
					int LA96_4 = input.LA(3);
					if ( (LA96_4==AADL_STRING_LITERAL||(LA96_4 >= AL && LA96_4 <= AM)||LA96_4==CASE_EXPRESSION||LA96_4==COMPLEX||LA96_4==CONDITIONAL||LA96_4==DIVIDE||LA96_4==DOUBLE_COLON||LA96_4==EQ||LA96_4==EXP||(LA96_4 >= FUNCTION_CALL && LA96_4 <= GT)||LA96_4==ID||LA96_4==INMODE||LA96_4==INTEGER_LIT||LA96_4==LITERAL_and||LA96_4==LITERAL_cand||LA96_4==LITERAL_complex||LA96_4==LITERAL_cor||LA96_4==LITERAL_false||LA96_4==LITERAL_integer||LA96_4==LITERAL_mod||LA96_4==LITERAL_natural||(LA96_4 >= LITERAL_not && LA96_4 <= LITERAL_now)||LA96_4==LITERAL_null||LA96_4==LITERAL_or||(LA96_4 >= LITERAL_rational && LA96_4 <= LITERAL_real)||LA96_4==LITERAL_rem||(LA96_4 >= LITERAL_time && LA96_4 <= LITERAL_timeout)||LA96_4==LITERAL_tops||LA96_4==LITERAL_true||(LA96_4 >= LITERAL_xor && LA96_4 <= LT)||LA96_4==MINUS||LA96_4==NEQ||LA96_4==OCTOTHORPE||(LA96_4 >= PERIOD && LA96_4 <= PLUS)||LA96_4==QUESTION||LA96_4==RATIONAL||LA96_4==REAL_LIT||LA96_4==TICK||LA96_4==TIMES||LA96_4==UNARY_MINUS) ) {
						alt96=2;
					}
					else if ( (LA96_4==ARROW) ) {
						alt96=3;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 96, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 96, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 96, 0, input);
				throw nvae;
			}
			switch (alt96) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2147:3: rel= relation
					{
					pushFollow(FOLLOW_relation_in_expression_or_relation6555);
					rel=relation();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2147:16: -> {$rel.st}
					  {
					  	retval.st = (rel!=null?((StringTemplate)rel.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2149:2: e= expression
					{
					pushFollow(FOLLOW_expression_in_expression_or_relation6567);
					e=expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2149:15: -> {$e.st}
					  {
					  	retval.st = (e!=null?((StringTemplate)e.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2151:3: rt= record_term
					{
					pushFollow(FOLLOW_record_term_in_expression_or_relation6581);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2151:18: -> {$rt.st}
					  {
					  	retval.st = (rt!=null?((StringTemplate)rt.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_relation"


	public static class relation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2154:1: relation : ( ^( EQ lhs= subexpression rhs= subexpression ) -> equal_relation(lhs=$lhs.strhs=$rhs.st)| ^( LT lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\< <rhs>\"| ^( AM lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\<= <rhs>\"| ^( AL lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\>= <rhs>\"| ^( GT lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\> <rhs>\"| ^( NEQ lhs= subexpression rhs= subexpression ) -> not_equal_relation(lhs=$lhs.strhs=$rhs.st));
	public final UnparseBLESS.relation_return relation() throws RecognitionException {
		UnparseBLESS.relation_return retval = new UnparseBLESS.relation_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope lhs =null;
		TreeRuleReturnScope rhs =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2155:3: ( ^( EQ lhs= subexpression rhs= subexpression ) -> equal_relation(lhs=$lhs.strhs=$rhs.st)| ^( LT lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\< <rhs>\"| ^( AM lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\<= <rhs>\"| ^( AL lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\>= <rhs>\"| ^( GT lhs= subexpression rhs= subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\> <rhs>\"| ^( NEQ lhs= subexpression rhs= subexpression ) -> not_equal_relation(lhs=$lhs.strhs=$rhs.st))
			int alt97=6;
			switch ( input.LA(1) ) {
			case EQ:
				{
				alt97=1;
				}
				break;
			case LT:
				{
				alt97=2;
				}
				break;
			case AM:
				{
				alt97=3;
				}
				break;
			case AL:
				{
				alt97=4;
				}
				break;
			case GT:
				{
				alt97=5;
				}
				break;
			case NEQ:
				{
				alt97=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 97, 0, input);
				throw nvae;
			}
			switch (alt97) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2156:3: ^( EQ lhs= subexpression rhs= subexpression )
					{
					match(input,EQ,FOLLOW_EQ_in_relation6603); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6608);
					lhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6612);
					rhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2157:5: -> equal_relation(lhs=$lhs.strhs=$rhs.st)
					  {
					  	retval.st = templateLib.getInstanceOf("equal_relation",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2160:3: ^( LT lhs= subexpression rhs= subexpression )
					{
					match(input,LT,FOLLOW_LT_in_relation6643); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6648);
					lhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6652);
					rhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2161:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\< <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> \\< <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2163:3: ^( AM lhs= subexpression rhs= subexpression )
					{
					match(input,AM,FOLLOW_AM_in_relation6684); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6689);
					lhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6693);
					rhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2164:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\<= <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> \\<= <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2166:3: ^( AL lhs= subexpression rhs= subexpression )
					{
					match(input,AL,FOLLOW_AL_in_relation6725); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6730);
					lhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6734);
					rhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2167:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\>= <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> \\>= <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2169:3: ^( GT lhs= subexpression rhs= subexpression )
					{
					match(input,GT,FOLLOW_GT_in_relation6766); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6771);
					lhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6775);
					rhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2170:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> \\> <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> \\> <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2172:3: ^( NEQ lhs= subexpression rhs= subexpression )
					{
					match(input,NEQ,FOLLOW_NEQ_in_relation6807); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6812);
					lhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subexpression_in_relation6816);
					rhs=subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2173:5: -> not_equal_relation(lhs=$lhs.strhs=$rhs.st)
					  {
					  	retval.st = templateLib.getInstanceOf("not_equal_relation",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relation"


	public static class relation_symbol_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "relation_symbol"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2177:1: relation_symbol : ( (t= EQ |t= LT |t= AM |t= AL |t= GT ) -> template(t=$t.text) \"<t>\"|t= NEQ -> {%{(Global.usingSignalStringTemplateGroup?\"/=\":\"\\\\<\\\\>\")}});
	public final UnparseBLESS.relation_symbol_return relation_symbol() throws RecognitionException {
		UnparseBLESS.relation_symbol_return retval = new UnparseBLESS.relation_symbol_return();
		retval.start = input.LT(1);

		BAST t=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2178:2: ( (t= EQ |t= LT |t= AM |t= AL |t= GT ) -> template(t=$t.text) \"<t>\"|t= NEQ -> {%{(Global.usingSignalStringTemplateGroup?\"/=\":\"\\\\<\\\\>\")}})
			int alt99=2;
			int LA99_0 = input.LA(1);
			if ( ((LA99_0 >= AL && LA99_0 <= AM)||LA99_0==EQ||LA99_0==GT||LA99_0==LT) ) {
				alt99=1;
			}
			else if ( (LA99_0==NEQ) ) {
				alt99=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 99, 0, input);
				throw nvae;
			}

			switch (alt99) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:2: (t= EQ |t= LT |t= AM |t= AL |t= GT )
					{
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:2: (t= EQ |t= LT |t= AM |t= AL |t= GT )
					int alt98=5;
					switch ( input.LA(1) ) {
					case EQ:
						{
						alt98=1;
						}
						break;
					case LT:
						{
						alt98=2;
						}
						break;
					case AM:
						{
						alt98=3;
						}
						break;
					case AL:
						{
						alt98=4;
						}
						break;
					case GT:
						{
						alt98=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 98, 0, input);
						throw nvae;
					}
					switch (alt98) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:4: t= EQ
							{
							t=(BAST)match(input,EQ,FOLLOW_EQ_in_relation_symbol6853); if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:12: t= LT
							{
							t=(BAST)match(input,LT,FOLLOW_LT_in_relation_symbol6860); if (state.failed) return retval;
							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:19: t= AM
							{
							t=(BAST)match(input,AM,FOLLOW_AM_in_relation_symbol6866); if (state.failed) return retval;
							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:26: t= AL
							{
							t=(BAST)match(input,AL,FOLLOW_AL_in_relation_symbol6872); if (state.failed) return retval;
							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2179:33: t= GT
							{
							t=(BAST)match(input,GT,FOLLOW_GT_in_relation_symbol6878); if (state.failed) return retval;
							}
							break;

					}

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2180:3: -> template(t=$t.text) \"<t>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<t>",new STAttrMap().put("t", (t!=null?t.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2183:2: t= NEQ
					{
					t=(BAST)match(input,NEQ,FOLLOW_NEQ_in_relation_symbol6904); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2184:3: -> {%{(Global.usingSignalStringTemplateGroup?\"/=\":\"\\\\<\\\\>\")}}
					  {
					  	retval.st = new StringTemplate(templateLib,(Global.usingSignalStringTemplateGroup?"/=":"\\<\\>"));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relation_symbol"


	public static class function_call_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "function_call"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2189:1: function_call : ( ^( FUNCTION_CALL ^( DOUBLE_COLON (p+= ID )+ ) f= ID (pl= function_parameters )? ) -> {Global.usingSlangStringTemplateGroup}? function_call(f=getSlangFunctionCall($f.text)pl=$pl.stp=$p) -> function_call(f=$f.textpl=$pl.stp=$p)| ^( FUNCTION_CALL f= ID (pl= function_parameters )? ) -> {Global.usingSlangStringTemplateGroup}? function_call(f=getSlangFunctionCall($f.text)pl=$pl.st) -> function_call(f=$f.textpl=$pl.st));
	public final UnparseBLESS.function_call_return function_call() throws RecognitionException {
		UnparseBLESS.function_call_return retval = new UnparseBLESS.function_call_return();
		retval.start = input.LT(1);

		BAST f=null;
		BAST p=null;
		List<Object> list_p=null;
		TreeRuleReturnScope pl =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2190:3: ( ^( FUNCTION_CALL ^( DOUBLE_COLON (p+= ID )+ ) f= ID (pl= function_parameters )? ) -> {Global.usingSlangStringTemplateGroup}? function_call(f=getSlangFunctionCall($f.text)pl=$pl.stp=$p) -> function_call(f=$f.textpl=$pl.stp=$p)| ^( FUNCTION_CALL f= ID (pl= function_parameters )? ) -> {Global.usingSlangStringTemplateGroup}? function_call(f=getSlangFunctionCall($f.text)pl=$pl.st) -> function_call(f=$f.textpl=$pl.st))
			int alt103=2;
			int LA103_0 = input.LA(1);
			if ( (LA103_0==FUNCTION_CALL) ) {
				int LA103_1 = input.LA(2);
				if ( (LA103_1==DOWN) ) {
					int LA103_2 = input.LA(3);
					if ( (LA103_2==DOUBLE_COLON) ) {
						alt103=1;
					}
					else if ( (LA103_2==ID) ) {
						alt103=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 103, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 103, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 103, 0, input);
				throw nvae;
			}

			switch (alt103) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2191:3: ^( FUNCTION_CALL ^( DOUBLE_COLON (p+= ID )+ ) f= ID (pl= function_parameters )? )
					{
					match(input,FUNCTION_CALL,FOLLOW_FUNCTION_CALL_in_function_call6932); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_function_call6935); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2191:35: (p+= ID )+
					int cnt100=0;
					loop100:
					while (true) {
						int alt100=2;
						int LA100_0 = input.LA(1);
						if ( (LA100_0==ID) ) {
							alt100=1;
						}

						switch (alt100) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2191:35: p+= ID
							{
							p=(BAST)match(input,ID,FOLLOW_ID_in_function_call6939); if (state.failed) return retval;
							if (list_p==null) list_p=new ArrayList<Object>();
							list_p.add(p);
							}
							break;

						default :
							if ( cnt100 >= 1 ) break loop100;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(100, input);
							throw eee;
						}
						cnt100++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					f=(BAST)match(input,ID,FOLLOW_ID_in_function_call6946); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2191:50: (pl= function_parameters )?
					int alt101=2;
					int LA101_0 = input.LA(1);
					if ( (LA101_0==ARROW||LA101_0==COMMA) ) {
						alt101=1;
					}
					switch (alt101) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2191:50: pl= function_parameters
							{
							pushFollow(FOLLOW_function_parameters_in_function_call6950);
							pl=function_parameters();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2192:5: -> {Global.usingSlangStringTemplateGroup}? function_call(f=getSlangFunctionCall($f.text)pl=$pl.stp=$p)
					  if (Global.usingSlangStringTemplateGroup) {
					  	retval.st = templateLib.getInstanceOf("function_call",new STAttrMap().put("f", getSlangFunctionCall((f!=null?f.getText():null))).put("pl", (pl!=null?((StringTemplate)pl.getTemplate()):null)).put("p", list_p));
					  }

					  else // 2193:5: -> function_call(f=$f.textpl=$pl.stp=$p)
					  {
					  	retval.st = templateLib.getInstanceOf("function_call",new STAttrMap().put("f", (f!=null?f.getText():null)).put("pl", (pl!=null?((StringTemplate)pl.getTemplate()):null)).put("p", list_p));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2196:3: ^( FUNCTION_CALL f= ID (pl= function_parameters )? )
					{
					match(input,FUNCTION_CALL,FOLLOW_FUNCTION_CALL_in_function_call7011); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					f=(BAST)match(input,ID,FOLLOW_ID_in_function_call7015); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2196:26: (pl= function_parameters )?
					int alt102=2;
					int LA102_0 = input.LA(1);
					if ( (LA102_0==ARROW||LA102_0==COMMA) ) {
						alt102=1;
					}
					switch (alt102) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2196:26: pl= function_parameters
							{
							pushFollow(FOLLOW_function_parameters_in_function_call7019);
							pl=function_parameters();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2197:4: -> {Global.usingSlangStringTemplateGroup}? function_call(f=getSlangFunctionCall($f.text)pl=$pl.st)
					  if (Global.usingSlangStringTemplateGroup) {
					  	retval.st = templateLib.getInstanceOf("function_call",new STAttrMap().put("f", getSlangFunctionCall((f!=null?f.getText():null))).put("pl", (pl!=null?((StringTemplate)pl.getTemplate()):null)));
					  }

					  else // 2198:4: -> function_call(f=$f.textpl=$pl.st)
					  {
					  	retval.st = templateLib.getInstanceOf("function_call",new STAttrMap().put("f", (f!=null?f.getText():null)).put("pl", (pl!=null?((StringTemplate)pl.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_call"


	public static class function_parameters_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "function_parameters"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2203:1: function_parameters : (fpr= formal_expression_pair -> {$fpr.st}| ^( COMMA (param+= formal_expression_pair )+ ) -> template(param=$param) \"<param; separator=\", \">\");
	public final UnparseBLESS.function_parameters_return function_parameters() throws RecognitionException {
		UnparseBLESS.function_parameters_return retval = new UnparseBLESS.function_parameters_return();
		retval.start = input.LT(1);

		List<Object> list_param=null;
		TreeRuleReturnScope fpr =null;
		RuleReturnScope param = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2204:3: (fpr= formal_expression_pair -> {$fpr.st}| ^( COMMA (param+= formal_expression_pair )+ ) -> template(param=$param) \"<param; separator=\", \">\")
			int alt105=2;
			int LA105_0 = input.LA(1);
			if ( (LA105_0==ARROW) ) {
				alt105=1;
			}
			else if ( (LA105_0==COMMA) ) {
				alt105=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 105, 0, input);
				throw nvae;
			}

			switch (alt105) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2205:3: fpr= formal_expression_pair
					{
					pushFollow(FOLLOW_formal_expression_pair_in_function_parameters7078);
					fpr=formal_expression_pair();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2206:5: -> {$fpr.st}
					  {
					  	retval.st = (fpr!=null?((StringTemplate)fpr.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2208:3: ^( COMMA (param+= formal_expression_pair )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_function_parameters7097); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2208:18: (param+= formal_expression_pair )+
					int cnt104=0;
					loop104:
					while (true) {
						int alt104=2;
						int LA104_0 = input.LA(1);
						if ( (LA104_0==ARROW) ) {
							alt104=1;
						}

						switch (alt104) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2208:18: param+= formal_expression_pair
							{
							pushFollow(FOLLOW_formal_expression_pair_in_function_parameters7102);
							param=formal_expression_pair();
							state._fsp--;
							if (state.failed) return retval;
							if (list_param==null) list_param=new ArrayList<Object>();
							list_param.add(param.getTemplate());
							}
							break;

						default :
							if ( cnt104 >= 1 ) break loop104;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(104, input);
							throw eee;
						}
						cnt104++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2209:5: -> template(param=$param) \"<param; separator=\", \">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<param; separator=\", \">",new STAttrMap().put("param", list_param));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_parameters"


	public static class formal_expression_pair_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "formal_expression_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2212:1: formal_expression_pair : ^( ARROW formal= ID actual= expression ) -> formal_expression_pair(f=$formal.texta=$actual.st);
	public final UnparseBLESS.formal_expression_pair_return formal_expression_pair() throws RecognitionException {
		UnparseBLESS.formal_expression_pair_return retval = new UnparseBLESS.formal_expression_pair_return();
		retval.start = input.LT(1);

		BAST formal=null;
		TreeRuleReturnScope actual =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2213:3: ( ^( ARROW formal= ID actual= expression ) -> formal_expression_pair(f=$formal.texta=$actual.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2214:3: ^( ARROW formal= ID actual= expression )
			{
			match(input,ARROW,FOLLOW_ARROW_in_formal_expression_pair7135); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			formal=(BAST)match(input,ID,FOLLOW_ID_in_formal_expression_pair7139); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_formal_expression_pair7144);
			actual=expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2215:5: -> formal_expression_pair(f=$formal.texta=$actual.st)
			  {
			  	retval.st = templateLib.getInstanceOf("formal_expression_pair",new STAttrMap().put("f", (formal!=null?formal.getText():null)).put("a", (actual!=null?((StringTemplate)actual.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_expression_pair"


	public static class type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2220:1: type : (tn= type_name -> {$tn.st}|et= enumeration_type -> {$et.st}|nt= number_type -> {$nt.st}|at= array_type -> {$at.st}|rt= record_type -> {$rt.st}|vt= variant_type -> {$vt.st}|bo= LITERAL_boolean -> boolean(|st= LITERAL_string -> string();
	public final UnparseBLESS.type_return type() throws RecognitionException {
		UnparseBLESS.type_return retval = new UnparseBLESS.type_return();
		retval.start = input.LT(1);

		BAST bo=null;
		BAST st=null;
		TreeRuleReturnScope tn =null;
		TreeRuleReturnScope et =null;
		TreeRuleReturnScope nt =null;
		TreeRuleReturnScope at =null;
		TreeRuleReturnScope rt =null;
		TreeRuleReturnScope vt =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2221:2: (tn= type_name -> {$tn.st}|et= enumeration_type -> {$et.st}|nt= number_type -> {$nt.st}|at= array_type -> {$at.st}|rt= record_type -> {$rt.st}|vt= variant_type -> {$vt.st}|bo= LITERAL_boolean -> boolean(|st= LITERAL_string -> string()
			int alt106=8;
			switch ( input.LA(1) ) {
			case DOUBLE_COLON:
			case ID:
			case PERIOD:
				{
				alt106=1;
				}
				break;
			case LITERAL_enumeration:
				{
				alt106=2;
				}
				break;
			case LITERAL_complex:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
				{
				alt106=3;
				}
				break;
			case LITERAL_array:
				{
				alt106=4;
				}
				break;
			case LITERAL_record:
				{
				alt106=5;
				}
				break;
			case LITERAL_variant:
				{
				alt106=6;
				}
				break;
			case LITERAL_boolean:
				{
				alt106=7;
				}
				break;
			case LITERAL_string:
				{
				alt106=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 106, 0, input);
				throw nvae;
			}
			switch (alt106) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2222:2: tn= type_name
					{
					pushFollow(FOLLOW_type_name_in_type7182);
					tn=type_name();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2223:3: -> {$tn.st}
					  {
					  	retval.st = (tn!=null?((StringTemplate)tn.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2225:2: et= enumeration_type
					{
					pushFollow(FOLLOW_enumeration_type_in_type7195);
					et=enumeration_type();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2226:3: -> {$et.st}
					  {
					  	retval.st = (et!=null?((StringTemplate)et.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2228:2: nt= number_type
					{
					pushFollow(FOLLOW_number_type_in_type7208);
					nt=number_type();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2229:3: -> {$nt.st}
					  {
					  	retval.st = (nt!=null?((StringTemplate)nt.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2231:2: at= array_type
					{
					pushFollow(FOLLOW_array_type_in_type7221);
					at=array_type();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2232:3: -> {$at.st}
					  {
					  	retval.st = (at!=null?((StringTemplate)at.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2234:2: rt= record_type
					{
					pushFollow(FOLLOW_record_type_in_type7234);
					rt=record_type();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2235:3: -> {$rt.st}
					  {
					  	retval.st = (rt!=null?((StringTemplate)rt.getTemplate()):null);
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2237:2: vt= variant_type
					{
					pushFollow(FOLLOW_variant_type_in_type7247);
					vt=variant_type();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2238:3: -> {$vt.st}
					  {
					  	retval.st = (vt!=null?((StringTemplate)vt.getTemplate()):null);
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2243:2: bo= LITERAL_boolean
					{
					bo=(BAST)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_type7263); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2243:21: -> boolean(
					  {
					  	retval.st = templateLib.getInstanceOf("boolean");
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2245:2: st= LITERAL_string
					{
					st=(BAST)match(input,LITERAL_string,FOLLOW_LITERAL_string_in_type7279); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2245:20: -> string(
					  {
					  	retval.st = templateLib.getInstanceOf("string");
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {
			Dump.it("Unparse:type="+((BAST)retval.start).toStringTree()); reportError(re);
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type"


	public static class enumeration_type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "enumeration_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2250:1: enumeration_type : ^( LITERAL_enumeration (id+= ID )+ ) -> enumeration_type(id=$idet=getNextTypeID());
	public final UnparseBLESS.enumeration_type_return enumeration_type() throws RecognitionException {
		UnparseBLESS.enumeration_type_return retval = new UnparseBLESS.enumeration_type_return();
		retval.start = input.LT(1);

		BAST id=null;
		List<Object> list_id=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2251:3: ( ^( LITERAL_enumeration (id+= ID )+ ) -> enumeration_type(id=$idet=getNextTypeID()))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2252:3: ^( LITERAL_enumeration (id+= ID )+ )
			{
			match(input,LITERAL_enumeration,FOLLOW_LITERAL_enumeration_in_enumeration_type7314); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2252:27: (id+= ID )+
			int cnt107=0;
			loop107:
			while (true) {
				int alt107=2;
				int LA107_0 = input.LA(1);
				if ( (LA107_0==ID) ) {
					alt107=1;
				}

				switch (alt107) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2252:27: id+= ID
					{
					id=(BAST)match(input,ID,FOLLOW_ID_in_enumeration_type7318); if (state.failed) return retval;
					if (list_id==null) list_id=new ArrayList<Object>();
					list_id.add(id);
					}
					break;

				default :
					if ( cnt107 >= 1 ) break loop107;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(107, input);
					throw eee;
				}
				cnt107++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2253:5: -> enumeration_type(id=$idet=getNextTypeID())
			  {
			  	retval.st = templateLib.getInstanceOf("enumeration_type",new STAttrMap().put("id", list_id).put("et", getNextTypeID()));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_type"


	public static class number_word_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "number_word"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2290:1: number_word : (n= LITERAL_natural -> natural(|n= LITERAL_integer -> integer(|n= LITERAL_rational -> rational(|n= LITERAL_real -> real(|n= LITERAL_complex -> complex(|n= LITERAL_time -> time();
	public final UnparseBLESS.number_word_return number_word() throws RecognitionException {
		UnparseBLESS.number_word_return retval = new UnparseBLESS.number_word_return();
		retval.start = input.LT(1);

		BAST n=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2291:2: (n= LITERAL_natural -> natural(|n= LITERAL_integer -> integer(|n= LITERAL_rational -> rational(|n= LITERAL_real -> real(|n= LITERAL_complex -> complex(|n= LITERAL_time -> time()
			int alt108=6;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				alt108=1;
				}
				break;
			case LITERAL_integer:
				{
				alt108=2;
				}
				break;
			case LITERAL_rational:
				{
				alt108=3;
				}
				break;
			case LITERAL_real:
				{
				alt108=4;
				}
				break;
			case LITERAL_complex:
				{
				alt108=5;
				}
				break;
			case LITERAL_time:
				{
				alt108=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 108, 0, input);
				throw nvae;
			}
			switch (alt108) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2292:2: n= LITERAL_natural
					{
					n=(BAST)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_number_word7371); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2293:2: -> natural(
					  {
					  	retval.st = templateLib.getInstanceOf("natural");
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2294:4: n= LITERAL_integer
					{
					n=(BAST)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_number_word7386); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2295:2: -> integer(
					  {
					  	retval.st = templateLib.getInstanceOf("integer");
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2296:4: n= LITERAL_rational
					{
					n=(BAST)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_number_word7401); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2297:2: -> rational(
					  {
					  	retval.st = templateLib.getInstanceOf("rational");
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2298:4: n= LITERAL_real
					{
					n=(BAST)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_number_word7416); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2299:2: -> real(
					  {
					  	retval.st = templateLib.getInstanceOf("real");
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2300:4: n= LITERAL_complex
					{
					n=(BAST)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_number_word7431); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2301:2: -> complex(
					  {
					  	retval.st = templateLib.getInstanceOf("complex");
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2302:4: n= LITERAL_time
					{
					n=(BAST)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_number_word7445); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2303:3: -> time(
					  {
					  	retval.st = templateLib.getInstanceOf("time");
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_word"


	public static class number_type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "number_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2306:1: number_type : (nw3= number_word -> {$nw3.st}| ^(nw= number_word ^( LITERAL_units ud= units_designator ) nr= number_range ) -> number_type(nr=$nr.stud=$ud.stnw=$nw.st)| ^(nw= number_word ^( LITERAL_units ud= units_designator ) ) -> number_type(ud=$ud.stnw=$nw.st)| ^(nw2= number_word nr= number_range ) -> number_type(nr=$nr.stnw=$nw2.st));
	public final UnparseBLESS.number_type_return number_type() throws RecognitionException {
		UnparseBLESS.number_type_return retval = new UnparseBLESS.number_type_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope nw3 =null;
		TreeRuleReturnScope nw =null;
		TreeRuleReturnScope ud =null;
		TreeRuleReturnScope nr =null;
		TreeRuleReturnScope nw2 =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2307:2: (nw3= number_word -> {$nw3.st}| ^(nw= number_word ^( LITERAL_units ud= units_designator ) nr= number_range ) -> number_type(nr=$nr.stud=$ud.stnw=$nw.st)| ^(nw= number_word ^( LITERAL_units ud= units_designator ) ) -> number_type(ud=$ud.stnw=$nw.st)| ^(nw2= number_word nr= number_range ) -> number_type(nr=$nr.stnw=$nw2.st))
			int alt109=4;
			switch ( input.LA(1) ) {
			case LITERAL_natural:
				{
				int LA109_1 = input.LA(2);
				if ( (LA109_1==UP) ) {
					alt109=1;
				}
				else if ( (LA109_1==DOWN) ) {
					int LA109_8 = input.LA(3);
					if ( (LA109_8==LITERAL_units) ) {
						int LA109_9 = input.LA(4);
						if ( (LA109_9==DOWN) ) {
							switch ( input.LA(5) ) {
							case ID:
								{
								int LA109_12 = input.LA(6);
								if ( (LA109_12==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 12, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ps:
								{
								int LA109_13 = input.LA(6);
								if ( (LA109_13==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 13, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_us:
								{
								int LA109_14 = input.LA(6);
								if ( (LA109_14==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 14, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ms:
								{
								int LA109_15 = input.LA(6);
								if ( (LA109_15==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 15, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_sec:
								{
								int LA109_16 = input.LA(6);
								if ( (LA109_16==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_min:
								{
								int LA109_17 = input.LA(6);
								if ( (LA109_17==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_hr:
								{
								int LA109_18 = input.LA(6);
								if ( (LA109_18==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 18, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							default:
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 109, 11, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 109, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA109_8==DOTDOT) ) {
						alt109=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 109, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_integer:
				{
				int LA109_2 = input.LA(2);
				if ( (LA109_2==UP) ) {
					alt109=1;
				}
				else if ( (LA109_2==DOWN) ) {
					int LA109_8 = input.LA(3);
					if ( (LA109_8==LITERAL_units) ) {
						int LA109_9 = input.LA(4);
						if ( (LA109_9==DOWN) ) {
							switch ( input.LA(5) ) {
							case ID:
								{
								int LA109_12 = input.LA(6);
								if ( (LA109_12==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 12, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ps:
								{
								int LA109_13 = input.LA(6);
								if ( (LA109_13==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 13, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_us:
								{
								int LA109_14 = input.LA(6);
								if ( (LA109_14==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 14, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ms:
								{
								int LA109_15 = input.LA(6);
								if ( (LA109_15==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 15, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_sec:
								{
								int LA109_16 = input.LA(6);
								if ( (LA109_16==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_min:
								{
								int LA109_17 = input.LA(6);
								if ( (LA109_17==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_hr:
								{
								int LA109_18 = input.LA(6);
								if ( (LA109_18==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 18, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							default:
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 109, 11, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 109, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA109_8==DOTDOT) ) {
						alt109=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 109, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_rational:
				{
				int LA109_3 = input.LA(2);
				if ( (LA109_3==UP) ) {
					alt109=1;
				}
				else if ( (LA109_3==DOWN) ) {
					int LA109_8 = input.LA(3);
					if ( (LA109_8==LITERAL_units) ) {
						int LA109_9 = input.LA(4);
						if ( (LA109_9==DOWN) ) {
							switch ( input.LA(5) ) {
							case ID:
								{
								int LA109_12 = input.LA(6);
								if ( (LA109_12==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 12, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ps:
								{
								int LA109_13 = input.LA(6);
								if ( (LA109_13==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 13, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_us:
								{
								int LA109_14 = input.LA(6);
								if ( (LA109_14==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 14, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ms:
								{
								int LA109_15 = input.LA(6);
								if ( (LA109_15==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 15, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_sec:
								{
								int LA109_16 = input.LA(6);
								if ( (LA109_16==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_min:
								{
								int LA109_17 = input.LA(6);
								if ( (LA109_17==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_hr:
								{
								int LA109_18 = input.LA(6);
								if ( (LA109_18==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 18, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							default:
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 109, 11, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 109, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA109_8==DOTDOT) ) {
						alt109=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 109, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_real:
				{
				int LA109_4 = input.LA(2);
				if ( (LA109_4==UP) ) {
					alt109=1;
				}
				else if ( (LA109_4==DOWN) ) {
					int LA109_8 = input.LA(3);
					if ( (LA109_8==LITERAL_units) ) {
						int LA109_9 = input.LA(4);
						if ( (LA109_9==DOWN) ) {
							switch ( input.LA(5) ) {
							case ID:
								{
								int LA109_12 = input.LA(6);
								if ( (LA109_12==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 12, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ps:
								{
								int LA109_13 = input.LA(6);
								if ( (LA109_13==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 13, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_us:
								{
								int LA109_14 = input.LA(6);
								if ( (LA109_14==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 14, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ms:
								{
								int LA109_15 = input.LA(6);
								if ( (LA109_15==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 15, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_sec:
								{
								int LA109_16 = input.LA(6);
								if ( (LA109_16==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_min:
								{
								int LA109_17 = input.LA(6);
								if ( (LA109_17==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_hr:
								{
								int LA109_18 = input.LA(6);
								if ( (LA109_18==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 18, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							default:
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 109, 11, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 109, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA109_8==DOTDOT) ) {
						alt109=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 109, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 4, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_complex:
				{
				int LA109_5 = input.LA(2);
				if ( (LA109_5==UP) ) {
					alt109=1;
				}
				else if ( (LA109_5==DOWN) ) {
					int LA109_8 = input.LA(3);
					if ( (LA109_8==LITERAL_units) ) {
						int LA109_9 = input.LA(4);
						if ( (LA109_9==DOWN) ) {
							switch ( input.LA(5) ) {
							case ID:
								{
								int LA109_12 = input.LA(6);
								if ( (LA109_12==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 12, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ps:
								{
								int LA109_13 = input.LA(6);
								if ( (LA109_13==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 13, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_us:
								{
								int LA109_14 = input.LA(6);
								if ( (LA109_14==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 14, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ms:
								{
								int LA109_15 = input.LA(6);
								if ( (LA109_15==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 15, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_sec:
								{
								int LA109_16 = input.LA(6);
								if ( (LA109_16==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_min:
								{
								int LA109_17 = input.LA(6);
								if ( (LA109_17==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_hr:
								{
								int LA109_18 = input.LA(6);
								if ( (LA109_18==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 18, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							default:
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 109, 11, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 109, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA109_8==DOTDOT) ) {
						alt109=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 109, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 5, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_time:
				{
				int LA109_6 = input.LA(2);
				if ( (LA109_6==UP) ) {
					alt109=1;
				}
				else if ( (LA109_6==DOWN) ) {
					int LA109_8 = input.LA(3);
					if ( (LA109_8==LITERAL_units) ) {
						int LA109_9 = input.LA(4);
						if ( (LA109_9==DOWN) ) {
							switch ( input.LA(5) ) {
							case ID:
								{
								int LA109_12 = input.LA(6);
								if ( (LA109_12==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 12, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ps:
								{
								int LA109_13 = input.LA(6);
								if ( (LA109_13==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 13, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_us:
								{
								int LA109_14 = input.LA(6);
								if ( (LA109_14==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 14, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_ms:
								{
								int LA109_15 = input.LA(6);
								if ( (LA109_15==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 15, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_sec:
								{
								int LA109_16 = input.LA(6);
								if ( (LA109_16==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_min:
								{
								int LA109_17 = input.LA(6);
								if ( (LA109_17==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							case LITERAL_hr:
								{
								int LA109_18 = input.LA(6);
								if ( (LA109_18==UP) ) {
									int LA109_19 = input.LA(7);
									if ( (LA109_19==UP) ) {
										alt109=3;
									}
									else if ( (LA109_19==DOTDOT) ) {
										alt109=2;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 109, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 109, 18, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

								}
								break;
							default:
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 109, 11, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 109, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA109_8==DOTDOT) ) {
						alt109=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 109, 8, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 6, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 109, 0, input);
				throw nvae;
			}
			switch (alt109) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2308:2: nw3= number_word
					{
					pushFollow(FOLLOW_number_word_in_number_type7471);
					nw3=number_word();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2309:3: -> {$nw3.st}
					  {
					  	retval.st = (nw3!=null?((StringTemplate)nw3.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2311:2: ^(nw= number_word ^( LITERAL_units ud= units_designator ) nr= number_range )
					{
					pushFollow(FOLLOW_number_word_in_number_type7489);
					nw=number_word();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LITERAL_units,FOLLOW_LITERAL_units_in_number_type7494); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_units_designator_in_number_type7498);
					ud=units_designator();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_number_range_in_number_type7503);
					nr=number_range();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2313:3: -> number_type(nr=$nr.stud=$ud.stnw=$nw.st)
					  {
					  	retval.st = templateLib.getInstanceOf("number_type",new STAttrMap().put("nr", (nr!=null?((StringTemplate)nr.getTemplate()):null)).put("ud", (ud!=null?((StringTemplate)ud.getTemplate()):null)).put("nw", (nw!=null?((StringTemplate)nw.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2316:2: ^(nw= number_word ^( LITERAL_units ud= units_designator ) )
					{
					pushFollow(FOLLOW_number_word_in_number_type7537);
					nw=number_word();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LITERAL_units,FOLLOW_LITERAL_units_in_number_type7542); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_units_designator_in_number_type7546);
					ud=units_designator();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2318:3: -> number_type(ud=$ud.stnw=$nw.st)
					  {
					  	retval.st = templateLib.getInstanceOf("number_type",new STAttrMap().put("ud", (ud!=null?((StringTemplate)ud.getTemplate()):null)).put("nw", (nw!=null?((StringTemplate)nw.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2321:2: ^(nw2= number_word nr= number_range )
					{
					pushFollow(FOLLOW_number_word_in_number_type7577);
					nw2=number_word();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_number_range_in_number_type7581);
					nr=number_range();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2322:3: -> number_type(nr=$nr.stnw=$nw2.st)
					  {
					  	retval.st = templateLib.getInstanceOf("number_type",new STAttrMap().put("nr", (nr!=null?((StringTemplate)nr.getTemplate()):null)).put("nw", (nw2!=null?((StringTemplate)nw2.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_type"


	public static class number_range_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2326:1: number_range : cnr= constant_number_range -> template(cnr=$cnr.st) \"<cnr>\";
	public final UnparseBLESS.number_range_return number_range() throws RecognitionException {
		UnparseBLESS.number_range_return retval = new UnparseBLESS.number_range_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope cnr =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2327:3: (cnr= constant_number_range -> template(cnr=$cnr.st) \"<cnr>\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2328:3: cnr= constant_number_range
			{
			pushFollow(FOLLOW_constant_number_range_in_number_range7616);
			cnr=constant_number_range();
			state._fsp--;
			if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2329:5: -> template(cnr=$cnr.st) \"<cnr>\"
			  {
			  	retval.st = new StringTemplate(templateLib, "<cnr>",new STAttrMap().put("cnr", (cnr!=null?((StringTemplate)cnr.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_range"


	public static class constant_number_range_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "constant_number_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2332:1: constant_number_range : ( ^( DOTDOT lb= numeric_constant ub= numeric_constant ) -> template(lb=$lb.stub=$ub.st) \"<lb> .. <ub>\"| ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ub= numeric_constant ) -> template(lb=$lb.stub=$ub.st) \"-<lb> .. <ub>\"| ^( DOTDOT lb= numeric_constant ^( UNARY_MINUS ub= numeric_constant ) ) -> template(lb=$lb.stub=$ub.st) \"<lb> .. -<ub>\"| ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ^( UNARY_MINUS ub= numeric_constant ) ) -> template(lb=$lb.stub=$ub.st) \"-<lb> .. -<ub>\");
	public final UnparseBLESS.constant_number_range_return constant_number_range() throws RecognitionException {
		UnparseBLESS.constant_number_range_return retval = new UnparseBLESS.constant_number_range_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope lb =null;
		TreeRuleReturnScope ub =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2333:3: ( ^( DOTDOT lb= numeric_constant ub= numeric_constant ) -> template(lb=$lb.stub=$ub.st) \"<lb> .. <ub>\"| ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ub= numeric_constant ) -> template(lb=$lb.stub=$ub.st) \"-<lb> .. <ub>\"| ^( DOTDOT lb= numeric_constant ^( UNARY_MINUS ub= numeric_constant ) ) -> template(lb=$lb.stub=$ub.st) \"<lb> .. -<ub>\"| ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ^( UNARY_MINUS ub= numeric_constant ) ) -> template(lb=$lb.stub=$ub.st) \"-<lb> .. -<ub>\")
			int alt110=4;
			alt110 = dfa110.predict(input);
			switch (alt110) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2334:3: ^( DOTDOT lb= numeric_constant ub= numeric_constant )
					{
					match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range7646); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7650);
					lb=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7654);
					ub=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2335:5: -> template(lb=$lb.stub=$ub.st) \"<lb> .. <ub>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lb> .. <ub>",new STAttrMap().put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2337:3: ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ub= numeric_constant )
					{
					match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range7683); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_constant_number_range7686); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7690);
					lb=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7695);
					ub=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2338:5: -> template(lb=$lb.stub=$ub.st) \"-<lb> .. <ub>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "-<lb> .. <ub>",new STAttrMap().put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2340:3: ^( DOTDOT lb= numeric_constant ^( UNARY_MINUS ub= numeric_constant ) )
					{
					match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range7724); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7728);
					lb=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_constant_number_range7731); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7735);
					ub=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2341:5: -> template(lb=$lb.stub=$ub.st) \"<lb> .. -<ub>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lb> .. -<ub>",new STAttrMap().put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2343:3: ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ^( UNARY_MINUS ub= numeric_constant ) )
					{
					match(input,DOTDOT,FOLLOW_DOTDOT_in_constant_number_range7765); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_constant_number_range7768); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7772);
					lb=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_constant_number_range7776); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_numeric_constant_in_constant_number_range7780);
					ub=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2344:5: -> template(lb=$lb.stub=$ub.st) \"-<lb> .. -<ub>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "-<lb> .. -<ub>",new STAttrMap().put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constant_number_range"


	public static class units_designator_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "units_designator"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2347:1: units_designator : (uupt= ID -> {%{$uupt.text}}|tu= time_unit -> {$tu.st});
	public final UnparseBLESS.units_designator_return units_designator() throws RecognitionException {
		UnparseBLESS.units_designator_return retval = new UnparseBLESS.units_designator_return();
		retval.start = input.LT(1);

		BAST uupt=null;
		TreeRuleReturnScope tu =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2348:3: (uupt= ID -> {%{$uupt.text}}|tu= time_unit -> {$tu.st})
			int alt111=2;
			int LA111_0 = input.LA(1);
			if ( (LA111_0==ID) ) {
				alt111=1;
			}
			else if ( (LA111_0==LITERAL_hr||LA111_0==LITERAL_min||LA111_0==LITERAL_ms||LA111_0==LITERAL_ps||LA111_0==LITERAL_sec||LA111_0==LITERAL_us) ) {
				alt111=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 111, 0, input);
				throw nvae;
			}

			switch (alt111) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2349:34: uupt= ID
					{
					uupt=(BAST)match(input,ID,FOLLOW_ID_in_units_designator7819); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2350:5: -> {%{$uupt.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(uupt!=null?uupt.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2351:5: tu= time_unit
					{
					pushFollow(FOLLOW_time_unit_in_units_designator7835);
					tu=time_unit();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2351:18: -> {$tu.st}
					  {
					  	retval.st = (tu!=null?((StringTemplate)tu.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "units_designator"


	public static class record_type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "record_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2363:1: record_type : ({...}? => ^( LITERAL_record ( ^( COLON df+= ID ptd+= type ) )+ ) -> record_type(df=$dfptd=$ptd)| ^( LITERAL_record (rf+= record_field )+ ) -> record_type(rf=$rf));
	public final UnparseBLESS.record_type_return record_type() throws RecognitionException {
		UnparseBLESS.record_type_return retval = new UnparseBLESS.record_type_return();
		retval.start = input.LT(1);

		BAST df=null;
		List<Object> list_df=null;
		List<Object> list_ptd=null;
		List<Object> list_rf=null;
		RuleReturnScope ptd = null;
		RuleReturnScope rf = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2364:2: ({...}? => ^( LITERAL_record ( ^( COLON df+= ID ptd+= type ) )+ ) -> record_type(df=$dfptd=$ptd)| ^( LITERAL_record (rf+= record_field )+ ) -> record_type(rf=$rf))
			int alt114=2;
			int LA114_0 = input.LA(1);
			if ( (LA114_0==LITERAL_record) ) {
				int LA114_1 = input.LA(2);
				if ( ((Global.usingDataModelStringTemplateGroup)) ) {
					alt114=1;
				}
				else if ( (true) ) {
					alt114=2;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 114, 0, input);
				throw nvae;
			}

			switch (alt114) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2366:2: {...}? => ^( LITERAL_record ( ^( COLON df+= ID ptd+= type ) )+ )
					{
					if ( !((Global.usingDataModelStringTemplateGroup)) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "record_type", "Global.usingDataModelStringTemplateGroup");
					}
					match(input,LITERAL_record,FOLLOW_LITERAL_record_in_record_type7869); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2367:19: ( ^( COLON df+= ID ptd+= type ) )+
					int cnt112=0;
					loop112:
					while (true) {
						int alt112=2;
						int LA112_0 = input.LA(1);
						if ( (LA112_0==COLON) ) {
							alt112=1;
						}

						switch (alt112) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2367:21: ^( COLON df+= ID ptd+= type )
							{
							match(input,COLON,FOLLOW_COLON_in_record_type7874); if (state.failed) return retval;
							match(input, Token.DOWN, null); if (state.failed) return retval;
							df=(BAST)match(input,ID,FOLLOW_ID_in_record_type7878); if (state.failed) return retval;
							if (list_df==null) list_df=new ArrayList<Object>();
							list_df.add(df);
							pushFollow(FOLLOW_type_in_record_type7882);
							ptd=type();
							state._fsp--;
							if (state.failed) return retval;
							if (list_ptd==null) list_ptd=new ArrayList<Object>();
							list_ptd.add(ptd.getTemplate());
							match(input, Token.UP, null); if (state.failed) return retval;

							}
							break;

						default :
							if ( cnt112 >= 1 ) break loop112;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(112, input);
							throw eee;
						}
						cnt112++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2368:3: -> record_type(df=$dfptd=$ptd)
					  {
					  	retval.st = templateLib.getInstanceOf("record_type",new STAttrMap().put("df", list_df).put("ptd", list_ptd));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2370:2: ^( LITERAL_record (rf+= record_field )+ )
					{
					match(input,LITERAL_record,FOLLOW_LITERAL_record_in_record_type7909); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2370:21: (rf+= record_field )+
					int cnt113=0;
					loop113:
					while (true) {
						int alt113=2;
						int LA113_0 = input.LA(1);
						if ( (LA113_0==COLON) ) {
							alt113=1;
						}

						switch (alt113) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2370:21: rf+= record_field
							{
							pushFollow(FOLLOW_record_field_in_record_type7913);
							rf=record_field();
							state._fsp--;
							if (state.failed) return retval;
							if (list_rf==null) list_rf=new ArrayList<Object>();
							list_rf.add(rf.getTemplate());
							}
							break;

						default :
							if ( cnt113 >= 1 ) break loop113;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(113, input);
							throw eee;
						}
						cnt113++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2371:3: -> record_type(rf=$rf)
					  {
					  	retval.st = templateLib.getInstanceOf("record_type",new STAttrMap().put("rf", list_rf));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_type"


	public static class record_term_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2375:1: record_term : ^( LPAREN (rv+= record_value )+ RPAREN ) -> template(rv=$rv) \"(<rv; separator=\" \">)\";
	public final UnparseBLESS.record_term_return record_term() throws RecognitionException {
		UnparseBLESS.record_term_return retval = new UnparseBLESS.record_term_return();
		retval.start = input.LT(1);

		List<Object> list_rv=null;
		RuleReturnScope rv = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2376:3: ( ^( LPAREN (rv+= record_value )+ RPAREN ) -> template(rv=$rv) \"(<rv; separator=\" \">)\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2377:3: ^( LPAREN (rv+= record_value )+ RPAREN )
			{
			match(input,LPAREN,FOLLOW_LPAREN_in_record_term7942); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2377:14: (rv+= record_value )+
			int cnt115=0;
			loop115:
			while (true) {
				int alt115=2;
				int LA115_0 = input.LA(1);
				if ( (LA115_0==ARROW) ) {
					alt115=1;
				}

				switch (alt115) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2377:14: rv+= record_value
					{
					pushFollow(FOLLOW_record_value_in_record_term7946);
					rv=record_value();
					state._fsp--;
					if (state.failed) return retval;
					if (list_rv==null) list_rv=new ArrayList<Object>();
					list_rv.add(rv.getTemplate());
					}
					break;

				default :
					if ( cnt115 >= 1 ) break loop115;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(115, input);
					throw eee;
				}
				cnt115++;
			}

			match(input,RPAREN,FOLLOW_RPAREN_in_record_term7949); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2378:5: -> template(rv=$rv) \"(<rv; separator=\" \">)\"
			  {
			  	retval.st = new StringTemplate(templateLib, "(<rv; separator=\" \">)",new STAttrMap().put("rv", list_rv));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_term"


	public static class record_value_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2381:1: record_value : ^( ARROW i= ID v= value ) -> template(i=$i.textv=$v.st) \"<i>=><v>;\";
	public final UnparseBLESS.record_value_return record_value() throws RecognitionException {
		UnparseBLESS.record_value_return retval = new UnparseBLESS.record_value_return();
		retval.start = input.LT(1);

		BAST i=null;
		TreeRuleReturnScope v =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2382:3: ( ^( ARROW i= ID v= value ) -> template(i=$i.textv=$v.st) \"<i>=><v>;\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2383:3: ^( ARROW i= ID v= value )
			{
			match(input,ARROW,FOLLOW_ARROW_in_record_value7980); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			i=(BAST)match(input,ID,FOLLOW_ID_in_record_value7984); if (state.failed) return retval;
			pushFollow(FOLLOW_value_in_record_value7988);
			v=value();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2384:5: -> template(i=$i.textv=$v.st) \"<i>=><v>;\"
			  {
			  	retval.st = new StringTemplate(templateLib, "<i>=><v>;",new STAttrMap().put("i", (i!=null?i.getText():null)).put("v", (v!=null?((StringTemplate)v.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_value"


	public static class record_field_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "record_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2388:1: record_field : ^( COLON df= ID ptd= type ) -> record_field(df=$df.textptd=$ptd.st);
	public final UnparseBLESS.record_field_return record_field() throws RecognitionException {
		UnparseBLESS.record_field_return retval = new UnparseBLESS.record_field_return();
		retval.start = input.LT(1);

		BAST df=null;
		TreeRuleReturnScope ptd =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2389:2: ( ^( COLON df= ID ptd= type ) -> record_field(df=$df.textptd=$ptd.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2390:2: ^( COLON df= ID ptd= type )
			{
			match(input,COLON,FOLLOW_COLON_in_record_field8027); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			df=(BAST)match(input,ID,FOLLOW_ID_in_record_field8031); if (state.failed) return retval;
			pushFollow(FOLLOW_type_in_record_field8035);
			ptd=type();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2391:3: -> record_field(df=$df.textptd=$ptd.st)
			  {
			  	retval.st = templateLib.getInstanceOf("record_field",new STAttrMap().put("df", (df!=null?df.getText():null)).put("ptd", (ptd!=null?((StringTemplate)ptd.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_field"


	public static class unique_component_classifier_reference_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "unique_component_classifier_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2394:1: unique_component_classifier_reference : ( ^( DOUBLE_COLON (p+= ID )+ ) -> unique_component_classifier_reference(p=$p)| ^( DOUBLE_COLON (p+= ID )+ ^( PERIOD ii= ID ) ) -> unique_component_classifier_reference(p=$pii=$ii.text)| ^( PERIOD n= ID imp= ID ) -> local_name(n=$n.textimp=$imp.textpn=getPackageName())|n= ID -> local_name(n=$n.textpn=getPackageName()));
	public final UnparseBLESS.unique_component_classifier_reference_return unique_component_classifier_reference() throws RecognitionException {
		UnparseBLESS.unique_component_classifier_reference_return retval = new UnparseBLESS.unique_component_classifier_reference_return();
		retval.start = input.LT(1);

		BAST ii=null;
		BAST n=null;
		BAST imp=null;
		BAST p=null;
		List<Object> list_p=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2395:3: ( ^( DOUBLE_COLON (p+= ID )+ ) -> unique_component_classifier_reference(p=$p)| ^( DOUBLE_COLON (p+= ID )+ ^( PERIOD ii= ID ) ) -> unique_component_classifier_reference(p=$pii=$ii.text)| ^( PERIOD n= ID imp= ID ) -> local_name(n=$n.textimp=$imp.textpn=getPackageName())|n= ID -> local_name(n=$n.textpn=getPackageName()))
			int alt118=4;
			alt118 = dfa118.predict(input);
			switch (alt118) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2396:3: ^( DOUBLE_COLON (p+= ID )+ )
					{
					match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference8068); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2396:20: (p+= ID )+
					int cnt116=0;
					loop116:
					while (true) {
						int alt116=2;
						int LA116_0 = input.LA(1);
						if ( (LA116_0==ID) ) {
							alt116=1;
						}

						switch (alt116) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2396:20: p+= ID
							{
							p=(BAST)match(input,ID,FOLLOW_ID_in_unique_component_classifier_reference8073); if (state.failed) return retval;
							if (list_p==null) list_p=new ArrayList<Object>();
							list_p.add(p);
							}
							break;

						default :
							if ( cnt116 >= 1 ) break loop116;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(116, input);
							throw eee;
						}
						cnt116++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2397:5: -> unique_component_classifier_reference(p=$p)
					  {
					  	retval.st = templateLib.getInstanceOf("unique_component_classifier_reference",new STAttrMap().put("p", list_p));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2402:3: ^( DOUBLE_COLON (p+= ID )+ ^( PERIOD ii= ID ) )
					{
					match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference8100); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2402:20: (p+= ID )+
					int cnt117=0;
					loop117:
					while (true) {
						int alt117=2;
						int LA117_0 = input.LA(1);
						if ( (LA117_0==ID) ) {
							alt117=1;
						}

						switch (alt117) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2402:20: p+= ID
							{
							p=(BAST)match(input,ID,FOLLOW_ID_in_unique_component_classifier_reference8105); if (state.failed) return retval;
							if (list_p==null) list_p=new ArrayList<Object>();
							list_p.add(p);
							}
							break;

						default :
							if ( cnt117 >= 1 ) break loop117;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(117, input);
							throw eee;
						}
						cnt117++;
					}

					match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference8109); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					ii=(BAST)match(input,ID,FOLLOW_ID_in_unique_component_classifier_reference8113); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2403:5: -> unique_component_classifier_reference(p=$pii=$ii.text)
					  {
					  	retval.st = templateLib.getInstanceOf("unique_component_classifier_reference",new STAttrMap().put("p", list_p).put("ii", (ii!=null?ii.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2405:3: ^( PERIOD n= ID imp= ID )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_unique_component_classifier_reference8141); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					n=(BAST)match(input,ID,FOLLOW_ID_in_unique_component_classifier_reference8145); if (state.failed) return retval;
					imp=(BAST)match(input,ID,FOLLOW_ID_in_unique_component_classifier_reference8149); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2406:5: -> local_name(n=$n.textimp=$imp.textpn=getPackageName())
					  {
					  	retval.st = templateLib.getInstanceOf("local_name",new STAttrMap().put("n", (n!=null?n.getText():null)).put("imp", (imp!=null?imp.getText():null)).put("pn", getPackageName()));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2409:3: n= ID
					{
					n=(BAST)match(input,ID,FOLLOW_ID_in_unique_component_classifier_reference8186); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2410:5: -> local_name(n=$n.textpn=getPackageName())
					  {
					  	retval.st = templateLib.getInstanceOf("local_name",new STAttrMap().put("n", (n!=null?n.getText():null)).put("pn", getPackageName()));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unique_component_classifier_reference"


	public static class type_name_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "type_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2414:1: type_name : d= unique_component_classifier_reference -> {$d.st};
	public final UnparseBLESS.type_name_return type_name() throws RecognitionException {
		UnparseBLESS.type_name_return retval = new UnparseBLESS.type_name_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope d =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2415:2: (d= unique_component_classifier_reference -> {$d.st})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2416:2: d= unique_component_classifier_reference
			{
			pushFollow(FOLLOW_unique_component_classifier_reference_in_type_name8219);
			d=unique_component_classifier_reference();
			state._fsp--;
			if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2417:4: -> {$d.st}
			  {
			  	retval.st = (d!=null?((StringTemplate)d.getTemplate()):null);
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_name"


	public static class array_type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "array_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2421:1: array_type : ^( LITERAL_array arl= array_range_list LITERAL_of t= type ) -> array_type(arl=$arl.stt=$t.stat=getNextTypeID());
	public final UnparseBLESS.array_type_return array_type() throws RecognitionException {
		UnparseBLESS.array_type_return retval = new UnparseBLESS.array_type_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope arl =null;
		TreeRuleReturnScope t =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2422:2: ( ^( LITERAL_array arl= array_range_list LITERAL_of t= type ) -> array_type(arl=$arl.stt=$t.stat=getNextTypeID()))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2423:2: ^( LITERAL_array arl= array_range_list LITERAL_of t= type )
			{
			match(input,LITERAL_array,FOLLOW_LITERAL_array_in_array_type8242); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_array_range_list_in_array_type8246);
			arl=array_range_list();
			state._fsp--;
			if (state.failed) return retval;
			match(input,LITERAL_of,FOLLOW_LITERAL_of_in_array_type8248); if (state.failed) return retval;
			pushFollow(FOLLOW_type_in_array_type8252);
			t=type();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2424:3: -> array_type(arl=$arl.stt=$t.stat=getNextTypeID())
			  {
			  	retval.st = templateLib.getInstanceOf("array_type",new STAttrMap().put("arl", (arl!=null?((StringTemplate)arl.getTemplate()):null)).put("t", (t!=null?((StringTemplate)t.getTemplate()):null)).put("at", getNextTypeID()));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_type"


	public static class array_range_list_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "array_range_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2428:1: array_range_list : (nr= natural_range -> {$nr.st}| ^( COMMA (ranges+= natural_range )+ ) -> array_range_list(r=$ranges));
	public final UnparseBLESS.array_range_list_return array_range_list() throws RecognitionException {
		UnparseBLESS.array_range_list_return retval = new UnparseBLESS.array_range_list_return();
		retval.start = input.LT(1);

		List<Object> list_ranges=null;
		TreeRuleReturnScope nr =null;
		RuleReturnScope ranges = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2429:2: (nr= natural_range -> {$nr.st}| ^( COMMA (ranges+= natural_range )+ ) -> array_range_list(r=$ranges))
			int alt120=2;
			int LA120_0 = input.LA(1);
			if ( ((LA120_0 >= DOTDOT && LA120_0 <= DOUBLE_COLON)||LA120_0==ID||LA120_0==INTEGER_LIT||LA120_0==OCTOTHORPE) ) {
				alt120=1;
			}
			else if ( (LA120_0==COMMA) ) {
				alt120=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 120, 0, input);
				throw nvae;
			}

			switch (alt120) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2430:2: nr= natural_range
					{
					pushFollow(FOLLOW_natural_range_in_array_range_list8288);
					nr=natural_range();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2431:4: -> {$nr.st}
					  {
					  	retval.st = (nr!=null?((StringTemplate)nr.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2433:2: ^( COMMA (ranges+= natural_range )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_array_range_list8302); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2433:16: (ranges+= natural_range )+
					int cnt119=0;
					loop119:
					while (true) {
						int alt119=2;
						int LA119_0 = input.LA(1);
						if ( ((LA119_0 >= DOTDOT && LA119_0 <= DOUBLE_COLON)||LA119_0==ID||LA119_0==INTEGER_LIT||LA119_0==OCTOTHORPE) ) {
							alt119=1;
						}

						switch (alt119) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2433:16: ranges+= natural_range
							{
							pushFollow(FOLLOW_natural_range_in_array_range_list8306);
							ranges=natural_range();
							state._fsp--;
							if (state.failed) return retval;
							if (list_ranges==null) list_ranges=new ArrayList<Object>();
							list_ranges.add(ranges.getTemplate());
							}
							break;

						default :
							if ( cnt119 >= 1 ) break loop119;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(119, input);
							throw eee;
						}
						cnt119++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2434:4: -> array_range_list(r=$ranges)
					  {
					  	retval.st = templateLib.getInstanceOf("array_range_list",new STAttrMap().put("r", list_ranges));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_range_list"


	public static class natural_range_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "natural_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2437:1: natural_range : ( ^( DOTDOT l= id_literal_or_property r= id_literal_or_property ) -> {Global.usingDataModelStringTemplateGroup}? me(i=makeDimensionFromRange($l.st,$r.st)) -> array_range(l=$l.str=$r.st)|il= id_literal_or_property -> {$il.st});
	public final UnparseBLESS.natural_range_return natural_range() throws RecognitionException {
		UnparseBLESS.natural_range_return retval = new UnparseBLESS.natural_range_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope l =null;
		TreeRuleReturnScope r =null;
		TreeRuleReturnScope il =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2438:2: ( ^( DOTDOT l= id_literal_or_property r= id_literal_or_property ) -> {Global.usingDataModelStringTemplateGroup}? me(i=makeDimensionFromRange($l.st,$r.st)) -> array_range(l=$l.str=$r.st)|il= id_literal_or_property -> {$il.st})
			int alt121=2;
			int LA121_0 = input.LA(1);
			if ( (LA121_0==DOTDOT) ) {
				alt121=1;
			}
			else if ( (LA121_0==DOUBLE_COLON||LA121_0==ID||LA121_0==INTEGER_LIT||LA121_0==OCTOTHORPE) ) {
				alt121=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 121, 0, input);
				throw nvae;
			}

			switch (alt121) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2439:2: ^( DOTDOT l= id_literal_or_property r= id_literal_or_property )
					{
					match(input,DOTDOT,FOLLOW_DOTDOT_in_natural_range8336); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_id_literal_or_property_in_natural_range8340);
					l=id_literal_or_property();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_id_literal_or_property_in_natural_range8344);
					r=id_literal_or_property();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2440:3: -> {Global.usingDataModelStringTemplateGroup}? me(i=makeDimensionFromRange($l.st,$r.st))
					  if (Global.usingDataModelStringTemplateGroup) {
					  	retval.st = templateLib.getInstanceOf("me",new STAttrMap().put("i", makeDimensionFromRange((l!=null?((StringTemplate)l.getTemplate()):null),(r!=null?((StringTemplate)r.getTemplate()):null))));
					  }

					  else // 2442:4: -> array_range(l=$l.str=$r.st)
					  {
					  	retval.st = templateLib.getInstanceOf("array_range",new STAttrMap().put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("r", (r!=null?((StringTemplate)r.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2450:3: il= id_literal_or_property
					{
					pushFollow(FOLLOW_id_literal_or_property_in_natural_range8397);
					il=id_literal_or_property();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2451:5: -> {$il.st}
					  {
					  	retval.st = (il!=null?((StringTemplate)il.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "natural_range"


	public static class id_literal_or_property_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "id_literal_or_property"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2455:1: id_literal_or_property : (i= ID -> {%{$i.text}}|il= integer_literal -> {$il.st}|constant= property_constant -> {$constant.st}|reference= property_reference -> {$reference.st});
	public final UnparseBLESS.id_literal_or_property_return id_literal_or_property() throws RecognitionException {
		UnparseBLESS.id_literal_or_property_return retval = new UnparseBLESS.id_literal_or_property_return();
		retval.start = input.LT(1);

		BAST i=null;
		TreeRuleReturnScope il =null;
		TreeRuleReturnScope constant =null;
		TreeRuleReturnScope reference =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2456:2: (i= ID -> {%{$i.text}}|il= integer_literal -> {$il.st}|constant= property_constant -> {$constant.st}|reference= property_reference -> {$reference.st})
			int alt122=4;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt122=1;
				}
				break;
			case INTEGER_LIT:
				{
				alt122=2;
				}
				break;
			case DOUBLE_COLON:
				{
				alt122=3;
				}
				break;
			case OCTOTHORPE:
				{
				alt122=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 122, 0, input);
				throw nvae;
			}
			switch (alt122) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2457:2: i= ID
					{
					i=(BAST)match(input,ID,FOLLOW_ID_in_id_literal_or_property8421); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2458:3: -> {%{$i.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(i!=null?i.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2460:3: il= integer_literal
					{
					pushFollow(FOLLOW_integer_literal_in_id_literal_or_property8435);
					il=integer_literal();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2461:6: -> {$il.st}
					  {
					  	retval.st = (il!=null?((StringTemplate)il.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2463:3: constant= property_constant
					{
					pushFollow(FOLLOW_property_constant_in_id_literal_or_property8454);
					constant=property_constant();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2464:5: -> {$constant.st}
					  {
					  	retval.st = (constant!=null?((StringTemplate)constant.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2466:3: reference= property_reference
					{
					pushFollow(FOLLOW_property_reference_in_id_literal_or_property8471);
					reference=property_reference();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2467:5: -> {$reference.st}
					  {
					  	retval.st = (reference!=null?((StringTemplate)reference.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "id_literal_or_property"


	public static class variant_type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "variant_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2477:1: variant_type : ^( LITERAL_variant (vf+= variant_field )+ ) -> variant_type(vf=$vf);
	public final UnparseBLESS.variant_type_return variant_type() throws RecognitionException {
		UnparseBLESS.variant_type_return retval = new UnparseBLESS.variant_type_return();
		retval.start = input.LT(1);

		List<Object> list_vf=null;
		RuleReturnScope vf = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2478:2: ( ^( LITERAL_variant (vf+= variant_field )+ ) -> variant_type(vf=$vf))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2480:2: ^( LITERAL_variant (vf+= variant_field )+ )
			{
			match(input,LITERAL_variant,FOLLOW_LITERAL_variant_in_variant_type8502); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2480:22: (vf+= variant_field )+
			int cnt123=0;
			loop123:
			while (true) {
				int alt123=2;
				int LA123_0 = input.LA(1);
				if ( (LA123_0==COLON) ) {
					alt123=1;
				}

				switch (alt123) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2480:22: vf+= variant_field
					{
					pushFollow(FOLLOW_variant_field_in_variant_type8506);
					vf=variant_field();
					state._fsp--;
					if (state.failed) return retval;
					if (list_vf==null) list_vf=new ArrayList<Object>();
					list_vf.add(vf.getTemplate());
					}
					break;

				default :
					if ( cnt123 >= 1 ) break loop123;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(123, input);
					throw eee;
				}
				cnt123++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2481:3: -> variant_type(vf=$vf)
			  {
			  	retval.st = templateLib.getInstanceOf("variant_type",new STAttrMap().put("vf", list_vf));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variant_type"


	public static class variant_field_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "variant_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2485:1: variant_field : ^( COLON df= ID ptd= type ) -> variant_field(df=$df.textptd=$ptd.st);
	public final UnparseBLESS.variant_field_return variant_field() throws RecognitionException {
		UnparseBLESS.variant_field_return retval = new UnparseBLESS.variant_field_return();
		retval.start = input.LT(1);

		BAST df=null;
		TreeRuleReturnScope ptd =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2486:2: ( ^( COLON df= ID ptd= type ) -> variant_field(df=$df.textptd=$ptd.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2487:2: ^( COLON df= ID ptd= type )
			{
			match(input,COLON,FOLLOW_COLON_in_variant_field8535); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			df=(BAST)match(input,ID,FOLLOW_ID_in_variant_field8539); if (state.failed) return retval;
			pushFollow(FOLLOW_type_in_variant_field8543);
			ptd=type();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2488:3: -> variant_field(df=$df.textptd=$ptd.st)
			  {
			  	retval.st = templateLib.getInstanceOf("variant_field",new STAttrMap().put("df", (df!=null?df.getText():null)).put("ptd", (ptd!=null?((StringTemplate)ptd.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variant_field"


	public static class assertion_annex_library_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_annex_library"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2493:1: assertion_annex_library : ( ASSERTION_ANNEX | ^( ASSERTION_ANNEX (a+= assertion )+ ) -> template(a=$a) \"<a; separator=\"\\n\">\"| ^( ASSERTION_ANNEX p= predicate ) -> {$p.st});
	public final UnparseBLESS.assertion_annex_library_return assertion_annex_library() throws RecognitionException {
		UnparseBLESS.assertion_annex_library_return retval = new UnparseBLESS.assertion_annex_library_return();
		retval.start = input.LT(1);

		List<Object> list_a=null;
		TreeRuleReturnScope p =null;
		RuleReturnScope a = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2494:2: ( ASSERTION_ANNEX | ^( ASSERTION_ANNEX (a+= assertion )+ ) -> template(a=$a) \"<a; separator=\"\\n\">\"| ^( ASSERTION_ANNEX p= predicate ) -> {$p.st})
			int alt125=3;
			int LA125_0 = input.LA(1);
			if ( (LA125_0==ASSERTION_ANNEX) ) {
				int LA125_1 = input.LA(2);
				if ( (LA125_1==DOWN) ) {
					int LA125_2 = input.LA(3);
					if ( (LA125_2==ASSERTION||(LA125_2 >= ASSERTION_ENUMERATION && LA125_2 <= ASSERTION_FUNCTION)) ) {
						alt125=2;
					}
					else if ( ((LA125_2 >= AL && LA125_2 <= AM)||LA125_2==AT_SIGN||LA125_2==CARET||LA125_2==EQ||LA125_2==GT||(LA125_2 >= ID && LA125_2 <= IMP)||LA125_2==INVOKE||(LA125_2 >= LITERAL_all && LA125_2 <= LITERAL_and)||LA125_2==LITERAL_def||LA125_2==LITERAL_exists||LA125_2==LITERAL_false||LA125_2==LITERAL_iff||(LA125_2 >= LITERAL_implies && LA125_2 <= LITERAL_in)||LA125_2==LITERAL_not||LA125_2==LITERAL_or||LA125_2==LITERAL_stop||LA125_2==LITERAL_true||(LA125_2 >= LITERAL_xor && LA125_2 <= LT)||LA125_2==NEQ||LA125_2==PERIOD||LA125_2==PLUS_EQUALS||LA125_2==TICK||LA125_2==WP) ) {
						alt125=3;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 125, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}
				else if ( (LA125_1==EOF) ) {
					alt125=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 125, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 125, 0, input);
				throw nvae;
			}

			switch (alt125) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2495:4: ASSERTION_ANNEX
					{
					match(input,ASSERTION_ANNEX,FOLLOW_ASSERTION_ANNEX_in_assertion_annex_library8578); if (state.failed) return retval;
					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2497:2: ^( ASSERTION_ANNEX (a+= assertion )+ )
					{
					match(input,ASSERTION_ANNEX,FOLLOW_ASSERTION_ANNEX_in_assertion_annex_library8587); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2497:21: (a+= assertion )+
					int cnt124=0;
					loop124:
					while (true) {
						int alt124=2;
						int LA124_0 = input.LA(1);
						if ( (LA124_0==ASSERTION||(LA124_0 >= ASSERTION_ENUMERATION && LA124_0 <= ASSERTION_FUNCTION)) ) {
							alt124=1;
						}

						switch (alt124) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2497:21: a+= assertion
							{
							pushFollow(FOLLOW_assertion_in_assertion_annex_library8591);
							a=assertion();
							state._fsp--;
							if (state.failed) return retval;
							if (list_a==null) list_a=new ArrayList<Object>();
							list_a.add(a.getTemplate());
							}
							break;

						default :
							if ( cnt124 >= 1 ) break loop124;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(124, input);
							throw eee;
						}
						cnt124++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2498:3: -> template(a=$a) \"<a; separator=\"\\n\">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<a; separator=\"\\n\">",new STAttrMap().put("a", list_a));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2500:2: ^( ASSERTION_ANNEX p= predicate )
					{
					match(input,ASSERTION_ANNEX,FOLLOW_ASSERTION_ANNEX_in_assertion_annex_library8612); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_in_assertion_annex_library8616);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2501:4: -> {$p.st}
					  {
					  	retval.st = (p!=null?((StringTemplate)p.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_annex_library"


	public static class assertion_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2506:1: assertion : ( ^(ass= ASSERTION_ENUMERATION ^( LABEL a= ID ) ^( PARAMETERS lv1= ID ) ae= assertion_enumeration ) -> {Global.unparseAssertions}? assertion_enumeration(a=$a.textlv1=$lv1.textae=$ae.st) -> template( \" \"| ^(ass= ASSERTION_ENUMERATION ae= assertion_enumeration ) -> {Global.unparseAssertions}? assertion_enumeration2(ae=$ae.st) -> template( \" \"| ^(ass= ASSERTION ^( LABEL a= ID ) ^( PARAMETERS lv= formal_assertion_parameter_list ) p= predicate ) -> {Global.unparseAssertions}? assertion(a=$a.textlv=$lv.stp=$p.st) -> template( \" \"| ^(ass= ASSERTION ^( LABEL a= ID ) p= predicate ) -> {Global.unparseAssertions}? assertion(a=$a.textp=$p.st) -> template( \" \"| ^(ass= ASSERTION_FUNCTION ^( LABEL f= ID ) ^( PARAMETERS lv2= formal_assertion_parameter_list ) e= assertion_function_value ) -> {Global.unparseAssertions}? assertion_function(a=$f.textlv=$lv2.ste=$e.st) -> template( \" \"| ^(ass= ASSERTION_FUNCTION ^( LABEL f= ID ) e= assertion_function_value ) -> {Global.unparseAssertions}? assertion_function(a=$f.texte=$e.st) -> template( \" \"| ^(ass= ASSERTION_FUNCTION e= assertion_function_value ) -> {Global.unparseAssertions}? assertion_function(e=$e.st) -> template( \" \"| ^(ass= ASSERTION p2= predicate ) -> {Global.unparseAssertions}? assertion(p=$p2.st) -> template( \" \"| ^(ass= ASSERTION d= DUMMY ) -> template( \" \");
	public final UnparseBLESS.assertion_return assertion() throws RecognitionException {
		UnparseBLESS.assertion_return retval = new UnparseBLESS.assertion_return();
		retval.start = input.LT(1);

		BAST ass=null;
		BAST a=null;
		BAST lv1=null;
		BAST f=null;
		BAST d=null;
		TreeRuleReturnScope ae =null;
		TreeRuleReturnScope lv =null;
		TreeRuleReturnScope p =null;
		TreeRuleReturnScope lv2 =null;
		TreeRuleReturnScope e =null;
		TreeRuleReturnScope p2 =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2507:2: ( ^(ass= ASSERTION_ENUMERATION ^( LABEL a= ID ) ^( PARAMETERS lv1= ID ) ae= assertion_enumeration ) -> {Global.unparseAssertions}? assertion_enumeration(a=$a.textlv1=$lv1.textae=$ae.st) -> template( \" \"| ^(ass= ASSERTION_ENUMERATION ae= assertion_enumeration ) -> {Global.unparseAssertions}? assertion_enumeration2(ae=$ae.st) -> template( \" \"| ^(ass= ASSERTION ^( LABEL a= ID ) ^( PARAMETERS lv= formal_assertion_parameter_list ) p= predicate ) -> {Global.unparseAssertions}? assertion(a=$a.textlv=$lv.stp=$p.st) -> template( \" \"| ^(ass= ASSERTION ^( LABEL a= ID ) p= predicate ) -> {Global.unparseAssertions}? assertion(a=$a.textp=$p.st) -> template( \" \"| ^(ass= ASSERTION_FUNCTION ^( LABEL f= ID ) ^( PARAMETERS lv2= formal_assertion_parameter_list ) e= assertion_function_value ) -> {Global.unparseAssertions}? assertion_function(a=$f.textlv=$lv2.ste=$e.st) -> template( \" \"| ^(ass= ASSERTION_FUNCTION ^( LABEL f= ID ) e= assertion_function_value ) -> {Global.unparseAssertions}? assertion_function(a=$f.texte=$e.st) -> template( \" \"| ^(ass= ASSERTION_FUNCTION e= assertion_function_value ) -> {Global.unparseAssertions}? assertion_function(e=$e.st) -> template( \" \"| ^(ass= ASSERTION p2= predicate ) -> {Global.unparseAssertions}? assertion(p=$p2.st) -> template( \" \"| ^(ass= ASSERTION d= DUMMY ) -> template( \" \")
			int alt126=9;
			switch ( input.LA(1) ) {
			case ASSERTION_ENUMERATION:
				{
				int LA126_1 = input.LA(2);
				if ( (LA126_1==DOWN) ) {
					int LA126_4 = input.LA(3);
					if ( (LA126_4==LABEL) ) {
						alt126=1;
					}
					else if ( (LA126_4==PLUS_ARROW) ) {
						alt126=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 126, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 126, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ASSERTION:
				{
				int LA126_2 = input.LA(2);
				if ( (LA126_2==DOWN) ) {
					switch ( input.LA(3) ) {
					case LABEL:
						{
						int LA126_9 = input.LA(4);
						if ( (LA126_9==DOWN) ) {
							int LA126_14 = input.LA(5);
							if ( (LA126_14==ID) ) {
								int LA126_16 = input.LA(6);
								if ( (LA126_16==UP) ) {
									int LA126_18 = input.LA(7);
									if ( (LA126_18==PARAMETERS) ) {
										alt126=3;
									}
									else if ( ((LA126_18 >= AL && LA126_18 <= AM)||LA126_18==AT_SIGN||LA126_18==CARET||LA126_18==EQ||LA126_18==GT||(LA126_18 >= ID && LA126_18 <= IMP)||LA126_18==INVOKE||(LA126_18 >= LITERAL_all && LA126_18 <= LITERAL_and)||LA126_18==LITERAL_def||LA126_18==LITERAL_exists||LA126_18==LITERAL_false||LA126_18==LITERAL_iff||(LA126_18 >= LITERAL_implies && LA126_18 <= LITERAL_in)||LA126_18==LITERAL_not||LA126_18==LITERAL_or||LA126_18==LITERAL_stop||LA126_18==LITERAL_true||(LA126_18 >= LITERAL_xor && LA126_18 <= LT)||LA126_18==NEQ||LA126_18==PERIOD||LA126_18==PLUS_EQUALS||LA126_18==TICK||LA126_18==WP) ) {
										alt126=4;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 126, 18, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 126, 16, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 126, 14, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 126, 9, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					case DUMMY:
						{
						alt126=9;
						}
						break;
					case AL:
					case AM:
					case AT_SIGN:
					case CARET:
					case EQ:
					case GT:
					case ID:
					case IMP:
					case INVOKE:
					case LITERAL_all:
					case LITERAL_and:
					case LITERAL_def:
					case LITERAL_exists:
					case LITERAL_false:
					case LITERAL_iff:
					case LITERAL_implies:
					case LITERAL_in:
					case LITERAL_not:
					case LITERAL_or:
					case LITERAL_stop:
					case LITERAL_true:
					case LITERAL_xor:
					case LPAREN:
					case LT:
					case NEQ:
					case PERIOD:
					case PLUS_EQUALS:
					case TICK:
					case WP:
						{
						alt126=8;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 126, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 126, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case ASSERTION_FUNCTION:
				{
				int LA126_3 = input.LA(2);
				if ( (LA126_3==DOWN) ) {
					int LA126_6 = input.LA(3);
					if ( (LA126_6==LABEL) ) {
						int LA126_12 = input.LA(4);
						if ( (LA126_12==DOWN) ) {
							int LA126_15 = input.LA(5);
							if ( (LA126_15==ID) ) {
								int LA126_17 = input.LA(6);
								if ( (LA126_17==UP) ) {
									int LA126_19 = input.LA(7);
									if ( (LA126_19==PARAMETERS) ) {
										alt126=5;
									}
									else if ( (LA126_19==AADL_STRING_LITERAL||LA126_19==AT_SIGN||(LA126_19 >= CARET && LA126_19 <= CASE_EXPRESSION)||LA126_19==COMPLEX||(LA126_19 >= CONDITIONAL && LA126_19 <= CONDITIONAL_FUNCTION)||LA126_19==DIVIDE||LA126_19==DOUBLE_COLON||LA126_19==EXP||LA126_19==ID||LA126_19==INMODE||LA126_19==INTEGER_LIT||LA126_19==INVOKE_FUNCTION||LA126_19==LITERAL_abs||LA126_19==LITERAL_complex||LA126_19==LITERAL_def||LA126_19==LITERAL_false||LA126_19==LITERAL_integer||LA126_19==LITERAL_mod||LA126_19==LITERAL_natural||LA126_19==LITERAL_now||(LA126_19 >= LITERAL_null && LA126_19 <= LITERAL_numberof)||LA126_19==LITERAL_product||(LA126_19 >= LITERAL_rational && LA126_19 <= LITERAL_real)||LA126_19==LITERAL_rem||LA126_19==LITERAL_sum||(LA126_19 >= LITERAL_time && LA126_19 <= LITERAL_timeout)||LA126_19==LITERAL_tops||LA126_19==LITERAL_true||LA126_19==LPAREN||LA126_19==MINUS||LA126_19==OCTOTHORPE||(LA126_19 >= PERIOD && LA126_19 <= PLUS)||LA126_19==QUESTION||LA126_19==RATIONAL||LA126_19==REAL_LIT||LA126_19==TICK||LA126_19==TIMES||LA126_19==UNARY_MINUS) ) {
										alt126=6;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 126, 19, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 126, 17, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 126, 15, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 126, 12, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA126_6==AADL_STRING_LITERAL||LA126_6==AT_SIGN||(LA126_6 >= CARET && LA126_6 <= CASE_EXPRESSION)||LA126_6==COMPLEX||(LA126_6 >= CONDITIONAL && LA126_6 <= CONDITIONAL_FUNCTION)||LA126_6==DIVIDE||LA126_6==DOUBLE_COLON||LA126_6==EXP||LA126_6==ID||LA126_6==INMODE||LA126_6==INTEGER_LIT||LA126_6==INVOKE_FUNCTION||LA126_6==LITERAL_abs||LA126_6==LITERAL_complex||LA126_6==LITERAL_def||LA126_6==LITERAL_false||LA126_6==LITERAL_integer||LA126_6==LITERAL_mod||LA126_6==LITERAL_natural||LA126_6==LITERAL_now||(LA126_6 >= LITERAL_null && LA126_6 <= LITERAL_numberof)||LA126_6==LITERAL_product||(LA126_6 >= LITERAL_rational && LA126_6 <= LITERAL_real)||LA126_6==LITERAL_rem||LA126_6==LITERAL_sum||(LA126_6 >= LITERAL_time && LA126_6 <= LITERAL_timeout)||LA126_6==LITERAL_tops||LA126_6==LITERAL_true||LA126_6==LPAREN||LA126_6==MINUS||LA126_6==OCTOTHORPE||(LA126_6 >= PERIOD && LA126_6 <= PLUS)||LA126_6==QUESTION||LA126_6==RATIONAL||LA126_6==REAL_LIT||LA126_6==TICK||LA126_6==TIMES||LA126_6==UNARY_MINUS) ) {
						alt126=7;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 126, 6, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 126, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 126, 0, input);
				throw nvae;
			}
			switch (alt126) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2508:2: ^(ass= ASSERTION_ENUMERATION ^( LABEL a= ID ) ^( PARAMETERS lv1= ID ) ae= assertion_enumeration )
					{
					ass=(BAST)match(input,ASSERTION_ENUMERATION,FOLLOW_ASSERTION_ENUMERATION_in_assertion8645); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LABEL,FOLLOW_LABEL_in_assertion8650); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					a=(BAST)match(input,ID,FOLLOW_ID_in_assertion8654); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,PARAMETERS,FOLLOW_PARAMETERS_in_assertion8659); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					lv1=(BAST)match(input,ID,FOLLOW_ID_in_assertion8663); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_assertion_enumeration_in_assertion8669);
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2509:3: -> {Global.unparseAssertions}? assertion_enumeration(a=$a.textlv1=$lv1.textae=$ae.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion_enumeration",new STAttrMap().put("a", (a!=null?a.getText():null)).put("lv1", (lv1!=null?lv1.getText():null)).put("ae", (ae!=null?((StringTemplate)ae.getTemplate()):null)));
					  }

					  else // 2510:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2512:2: ^(ass= ASSERTION_ENUMERATION ae= assertion_enumeration )
					{
					ass=(BAST)match(input,ASSERTION_ENUMERATION,FOLLOW_ASSERTION_ENUMERATION_in_assertion8713); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_enumeration_in_assertion8717);
					ae=assertion_enumeration();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2513:3: -> {Global.unparseAssertions}? assertion_enumeration2(ae=$ae.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion_enumeration2",new STAttrMap().put("ae", (ae!=null?((StringTemplate)ae.getTemplate()):null)));
					  }

					  else // 2514:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2516:2: ^(ass= ASSERTION ^( LABEL a= ID ) ^( PARAMETERS lv= formal_assertion_parameter_list ) p= predicate )
					{
					ass=(BAST)match(input,ASSERTION,FOLLOW_ASSERTION_in_assertion8755); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LABEL,FOLLOW_LABEL_in_assertion8760); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					a=(BAST)match(input,ID,FOLLOW_ID_in_assertion8764); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,PARAMETERS,FOLLOW_PARAMETERS_in_assertion8769); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion8773);
					lv=formal_assertion_parameter_list();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_predicate_in_assertion8780);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2517:3: -> {Global.unparseAssertions}? assertion(a=$a.textlv=$lv.stp=$p.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion",new STAttrMap().put("a", (a!=null?a.getText():null)).put("lv", (lv!=null?((StringTemplate)lv.getTemplate()):null)).put("p", (p!=null?((StringTemplate)p.getTemplate()):null)));
					  }

					  else // 2518:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2522:2: ^(ass= ASSERTION ^( LABEL a= ID ) p= predicate )
					{
					ass=(BAST)match(input,ASSERTION,FOLLOW_ASSERTION_in_assertion8826); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LABEL,FOLLOW_LABEL_in_assertion8831); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					a=(BAST)match(input,ID,FOLLOW_ID_in_assertion8835); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_predicate_in_assertion8842);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2523:3: -> {Global.unparseAssertions}? assertion(a=$a.textp=$p.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion",new STAttrMap().put("a", (a!=null?a.getText():null)).put("p", (p!=null?((StringTemplate)p.getTemplate()):null)));
					  }

					  else // 2524:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2527:2: ^(ass= ASSERTION_FUNCTION ^( LABEL f= ID ) ^( PARAMETERS lv2= formal_assertion_parameter_list ) e= assertion_function_value )
					{
					ass=(BAST)match(input,ASSERTION_FUNCTION,FOLLOW_ASSERTION_FUNCTION_in_assertion8883); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LABEL,FOLLOW_LABEL_in_assertion8887); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					f=(BAST)match(input,ID,FOLLOW_ID_in_assertion8891); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,PARAMETERS,FOLLOW_PARAMETERS_in_assertion8896); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_formal_assertion_parameter_list_in_assertion8900);
					lv2=formal_assertion_parameter_list();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_assertion_function_value_in_assertion8906);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2528:3: -> {Global.unparseAssertions}? assertion_function(a=$f.textlv=$lv2.ste=$e.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion_function",new STAttrMap().put("a", (f!=null?f.getText():null)).put("lv", (lv2!=null?((StringTemplate)lv2.getTemplate()):null)).put("e", (e!=null?((StringTemplate)e.getTemplate()):null)));
					  }

					  else // 2529:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2533:2: ^(ass= ASSERTION_FUNCTION ^( LABEL f= ID ) e= assertion_function_value )
					{
					ass=(BAST)match(input,ASSERTION_FUNCTION,FOLLOW_ASSERTION_FUNCTION_in_assertion8952); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LABEL,FOLLOW_LABEL_in_assertion8956); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					f=(BAST)match(input,ID,FOLLOW_ID_in_assertion8960); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					pushFollow(FOLLOW_assertion_function_value_in_assertion8966);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2534:3: -> {Global.unparseAssertions}? assertion_function(a=$f.texte=$e.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion_function",new STAttrMap().put("a", (f!=null?f.getText():null)).put("e", (e!=null?((StringTemplate)e.getTemplate()):null)));
					  }

					  else // 2535:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2538:2: ^(ass= ASSERTION_FUNCTION e= assertion_function_value )
					{
					ass=(BAST)match(input,ASSERTION_FUNCTION,FOLLOW_ASSERTION_FUNCTION_in_assertion9007); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_function_value_in_assertion9012);
					e=assertion_function_value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2539:3: -> {Global.unparseAssertions}? assertion_function(e=$e.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion_function",new STAttrMap().put("e", (e!=null?((StringTemplate)e.getTemplate()):null)));
					  }

					  else // 2540:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2543:2: ^(ass= ASSERTION p2= predicate )
					{
					ass=(BAST)match(input,ASSERTION,FOLLOW_ASSERTION_in_assertion9049); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_in_assertion9055);
					p2=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2544:3: -> {Global.unparseAssertions}? assertion(p=$p2.st)
					  if (Global.unparseAssertions) {
					  	retval.st = templateLib.getInstanceOf("assertion",new STAttrMap().put("p", (p2!=null?((StringTemplate)p2.getTemplate()):null)));
					  }

					  else // 2545:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2547:5: ^(ass= ASSERTION d= DUMMY )
					{
					ass=(BAST)match(input,ASSERTION,FOLLOW_ASSERTION_in_assertion9092); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					d=(BAST)match(input,DUMMY,FOLLOW_DUMMY_in_assertion9096); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2549:5: -> template( \" \"
					  {
					  	retval.st = new StringTemplate(templateLib, " ");
					  }


					}

					}
					break;

			}
		}
		catch (NoViableAltException nvae) {
			reportError(nvae); 
				   if (ass!=null)
				     ass.showParseTree("Assertion Error");
				   Dump.it("\nDid you forget to put parentheses after an Assertion label?\n");
				   throw nvae;
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion"


	public static class formal_assertion_parameter_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "formal_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2558:1: formal_assertion_parameter : (p= ID -> formal_assertion_parameter(p=$p.text)| ^( TILDE p= ID t= type_name ) -> formal_assertion_parameter(p=$p.textt=$t.st));
	public final UnparseBLESS.formal_assertion_parameter_return formal_assertion_parameter() throws RecognitionException {
		UnparseBLESS.formal_assertion_parameter_return retval = new UnparseBLESS.formal_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST p=null;
		TreeRuleReturnScope t =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2559:3: (p= ID -> formal_assertion_parameter(p=$p.text)| ^( TILDE p= ID t= type_name ) -> formal_assertion_parameter(p=$p.textt=$t.st))
			int alt127=2;
			int LA127_0 = input.LA(1);
			if ( (LA127_0==ID) ) {
				alt127=1;
			}
			else if ( (LA127_0==TILDE) ) {
				alt127=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 127, 0, input);
				throw nvae;
			}

			switch (alt127) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2560:3: p= ID
					{
					p=(BAST)match(input,ID,FOLLOW_ID_in_formal_assertion_parameter9139); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2561:5: -> formal_assertion_parameter(p=$p.text)
					  {
					  	retval.st = templateLib.getInstanceOf("formal_assertion_parameter",new STAttrMap().put("p", (p!=null?p.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2564:3: ^( TILDE p= ID t= type_name )
					{
					match(input,TILDE,FOLLOW_TILDE_in_formal_assertion_parameter9162); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					p=(BAST)match(input,ID,FOLLOW_ID_in_formal_assertion_parameter9166); if (state.failed) return retval;
					pushFollow(FOLLOW_type_name_in_formal_assertion_parameter9170);
					t=type_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2565:5: -> formal_assertion_parameter(p=$p.textt=$t.st)
					  {
					  	retval.st = templateLib.getInstanceOf("formal_assertion_parameter",new STAttrMap().put("p", (p!=null?p.getText():null)).put("t", (t!=null?((StringTemplate)t.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter"


	public static class formal_assertion_parameter_list_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "formal_assertion_parameter_list"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2569:1: formal_assertion_parameter_list : (fap= formal_assertion_parameter -> {$fap.st}| ^( COMMA (faps+= formal_assertion_parameter )+ ) -> formal_assertion_parameter_list(faps=$faps));
	public final UnparseBLESS.formal_assertion_parameter_list_return formal_assertion_parameter_list() throws RecognitionException {
		UnparseBLESS.formal_assertion_parameter_list_return retval = new UnparseBLESS.formal_assertion_parameter_list_return();
		retval.start = input.LT(1);

		List<Object> list_faps=null;
		TreeRuleReturnScope fap =null;
		RuleReturnScope faps = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2570:3: (fap= formal_assertion_parameter -> {$fap.st}| ^( COMMA (faps+= formal_assertion_parameter )+ ) -> formal_assertion_parameter_list(faps=$faps))
			int alt129=2;
			int LA129_0 = input.LA(1);
			if ( (LA129_0==ID||LA129_0==TILDE) ) {
				alt129=1;
			}
			else if ( (LA129_0==COMMA) ) {
				alt129=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 129, 0, input);
				throw nvae;
			}

			switch (alt129) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2571:3: fap= formal_assertion_parameter
					{
					pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list9206);
					fap=formal_assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2572:5: -> {$fap.st}
					  {
					  	retval.st = (fap!=null?((StringTemplate)fap.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2574:3: ^( COMMA (faps+= formal_assertion_parameter )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_formal_assertion_parameter_list9226); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2574:15: (faps+= formal_assertion_parameter )+
					int cnt128=0;
					loop128:
					while (true) {
						int alt128=2;
						int LA128_0 = input.LA(1);
						if ( (LA128_0==ID||LA128_0==TILDE) ) {
							alt128=1;
						}

						switch (alt128) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2574:15: faps+= formal_assertion_parameter
							{
							pushFollow(FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list9230);
							faps=formal_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if (list_faps==null) list_faps=new ArrayList<Object>();
							list_faps.add(faps.getTemplate());
							}
							break;

						default :
							if ( cnt128 >= 1 ) break loop128;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(128, input);
							throw eee;
						}
						cnt128++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2575:5: -> formal_assertion_parameter_list(faps=$faps)
					  {
					  	retval.st = templateLib.getInstanceOf("formal_assertion_parameter_list",new STAttrMap().put("faps", list_faps));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "formal_assertion_parameter_list"


	public static class assertion_function_value_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_function_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2579:1: assertion_function_value : (cae= conditional_assertion_function -> {$cae.st}|pe= assertion_expression -> {$pe.st});
	public final UnparseBLESS.assertion_function_value_return assertion_function_value() throws RecognitionException {
		UnparseBLESS.assertion_function_value_return retval = new UnparseBLESS.assertion_function_value_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope cae =null;
		TreeRuleReturnScope pe =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2580:2: (cae= conditional_assertion_function -> {$cae.st}|pe= assertion_expression -> {$pe.st})
			int alt130=2;
			int LA130_0 = input.LA(1);
			if ( (LA130_0==CONDITIONAL_FUNCTION) ) {
				alt130=1;
			}
			else if ( (LA130_0==AADL_STRING_LITERAL||LA130_0==AT_SIGN||(LA130_0 >= CARET && LA130_0 <= CASE_EXPRESSION)||LA130_0==COMPLEX||LA130_0==CONDITIONAL||LA130_0==DIVIDE||LA130_0==DOUBLE_COLON||LA130_0==EXP||LA130_0==ID||LA130_0==INMODE||LA130_0==INTEGER_LIT||LA130_0==INVOKE_FUNCTION||LA130_0==LITERAL_abs||LA130_0==LITERAL_complex||LA130_0==LITERAL_def||LA130_0==LITERAL_false||LA130_0==LITERAL_integer||LA130_0==LITERAL_mod||LA130_0==LITERAL_natural||LA130_0==LITERAL_now||(LA130_0 >= LITERAL_null && LA130_0 <= LITERAL_numberof)||LA130_0==LITERAL_product||(LA130_0 >= LITERAL_rational && LA130_0 <= LITERAL_real)||LA130_0==LITERAL_rem||LA130_0==LITERAL_sum||(LA130_0 >= LITERAL_time && LA130_0 <= LITERAL_timeout)||LA130_0==LITERAL_tops||LA130_0==LITERAL_true||LA130_0==LPAREN||LA130_0==MINUS||LA130_0==OCTOTHORPE||(LA130_0 >= PERIOD && LA130_0 <= PLUS)||LA130_0==QUESTION||LA130_0==RATIONAL||LA130_0==REAL_LIT||LA130_0==TICK||LA130_0==TIMES||LA130_0==UNARY_MINUS) ) {
				alt130=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 130, 0, input);
				throw nvae;
			}

			switch (alt130) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2581:2: cae= conditional_assertion_function
					{
					pushFollow(FOLLOW_conditional_assertion_function_in_assertion_function_value9265);
					cae=conditional_assertion_function();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2582:4: -> {$cae.st}
					  {
					  	retval.st = (cae!=null?((StringTemplate)cae.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2584:2: pe= assertion_expression
					{
					pushFollow(FOLLOW_assertion_expression_in_assertion_function_value9280);
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2585:4: -> {$pe.st}
					  {
					  	retval.st = (pe!=null?((StringTemplate)pe.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_value"


	public static class conditional_assertion_function_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "conditional_assertion_function"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2588:1: conditional_assertion_function : ^( CONDITIONAL_FUNCTION (cvp+= condition_value_pair )+ ) -> conditional_assertion_function(cvp=$cvp);
	public final UnparseBLESS.conditional_assertion_function_return conditional_assertion_function() throws RecognitionException {
		UnparseBLESS.conditional_assertion_function_return retval = new UnparseBLESS.conditional_assertion_function_return();
		retval.start = input.LT(1);

		List<Object> list_cvp=null;
		RuleReturnScope cvp = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2589:2: ( ^( CONDITIONAL_FUNCTION (cvp+= condition_value_pair )+ ) -> conditional_assertion_function(cvp=$cvp))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2590:2: ^( CONDITIONAL_FUNCTION (cvp+= condition_value_pair )+ )
			{
			match(input,CONDITIONAL_FUNCTION,FOLLOW_CONDITIONAL_FUNCTION_in_conditional_assertion_function9301); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2590:25: (cvp+= condition_value_pair )+
			int cnt131=0;
			loop131:
			while (true) {
				int alt131=2;
				int LA131_0 = input.LA(1);
				if ( (LA131_0==IMP) ) {
					alt131=1;
				}

				switch (alt131) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2590:27: cvp+= condition_value_pair
					{
					pushFollow(FOLLOW_condition_value_pair_in_conditional_assertion_function9307);
					cvp=condition_value_pair();
					state._fsp--;
					if (state.failed) return retval;
					if (list_cvp==null) list_cvp=new ArrayList<Object>();
					list_cvp.add(cvp.getTemplate());
					}
					break;

				default :
					if ( cnt131 >= 1 ) break loop131;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(131, input);
					throw eee;
				}
				cnt131++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2591:4: -> conditional_assertion_function(cvp=$cvp)
			  {
			  	retval.st = templateLib.getInstanceOf("conditional_assertion_function",new STAttrMap().put("cvp", list_cvp));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_function"


	public static class condition_value_pair_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "condition_value_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2595:1: condition_value_pair : ^( IMP pp= parenthesized_predicate pe= assertion_expression ) -> condition_value_pair(pp=$pp.stpe=$pe.st);
	public final UnparseBLESS.condition_value_pair_return condition_value_pair() throws RecognitionException {
		UnparseBLESS.condition_value_pair_return retval = new UnparseBLESS.condition_value_pair_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope pp =null;
		TreeRuleReturnScope pe =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2596:3: ( ^( IMP pp= parenthesized_predicate pe= assertion_expression ) -> condition_value_pair(pp=$pp.stpe=$pe.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2597:3: ^( IMP pp= parenthesized_predicate pe= assertion_expression )
			{
			match(input,IMP,FOLLOW_IMP_in_condition_value_pair9341); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_parenthesized_predicate_in_condition_value_pair9345);
			pp=parenthesized_predicate();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_expression_in_condition_value_pair9349);
			pe=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2598:5: -> condition_value_pair(pp=$pp.stpe=$pe.st)
			  {
			  	retval.st = templateLib.getInstanceOf("condition_value_pair",new STAttrMap().put("pp", (pp!=null?((StringTemplate)pp.getTemplate()):null)).put("pe", (pe!=null?((StringTemplate)pe.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "condition_value_pair"


	public static class assertion_enumeration_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_enumeration"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2603:1: assertion_enumeration : ( ^( PLUS_ARROW pi= predicate_invocation ) -> assertion_enumeration_predicate_invocation(pi=$pi.st)| ^( PLUS_ARROW (ep+= enumeration_pair )* ) -> assertion_enumeration_pairs(ep=$ep));
	public final UnparseBLESS.assertion_enumeration_return assertion_enumeration() throws RecognitionException {
		UnparseBLESS.assertion_enumeration_return retval = new UnparseBLESS.assertion_enumeration_return();
		retval.start = input.LT(1);

		List<Object> list_ep=null;
		TreeRuleReturnScope pi =null;
		RuleReturnScope ep = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2604:3: ( ^( PLUS_ARROW pi= predicate_invocation ) -> assertion_enumeration_predicate_invocation(pi=$pi.st)| ^( PLUS_ARROW (ep+= enumeration_pair )* ) -> assertion_enumeration_pairs(ep=$ep))
			int alt133=2;
			int LA133_0 = input.LA(1);
			if ( (LA133_0==PLUS_ARROW) ) {
				int LA133_1 = input.LA(2);
				if ( (LA133_1==DOWN) ) {
					int LA133_2 = input.LA(3);
					if ( (LA133_2==INVOKE||LA133_2==WP) ) {
						alt133=1;
					}
					else if ( (LA133_2==UP||LA133_2==ID) ) {
						alt133=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 133, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 133, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 133, 0, input);
				throw nvae;
			}

			switch (alt133) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2605:3: ^( PLUS_ARROW pi= predicate_invocation )
					{
					match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration9386); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_invocation_in_assertion_enumeration9390);
					pi=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2606:5: -> assertion_enumeration_predicate_invocation(pi=$pi.st)
					  {
					  	retval.st = templateLib.getInstanceOf("assertion_enumeration_predicate_invocation",new STAttrMap().put("pi", (pi!=null?((StringTemplate)pi.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2609:3: ^( PLUS_ARROW (ep+= enumeration_pair )* )
					{
					match(input,PLUS_ARROW,FOLLOW_PLUS_ARROW_in_assertion_enumeration9415); if (state.failed) return retval;
					if ( input.LA(1)==Token.DOWN ) {
						match(input, Token.DOWN, null); if (state.failed) return retval;
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2609:19: (ep+= enumeration_pair )*
						loop132:
						while (true) {
							int alt132=2;
							int LA132_0 = input.LA(1);
							if ( (LA132_0==ID) ) {
								alt132=1;
							}

							switch (alt132) {
							case 1 :
								// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2609:19: ep+= enumeration_pair
								{
								pushFollow(FOLLOW_enumeration_pair_in_assertion_enumeration9419);
								ep=enumeration_pair();
								state._fsp--;
								if (state.failed) return retval;
								if (list_ep==null) list_ep=new ArrayList<Object>();
								list_ep.add(ep.getTemplate());
								}
								break;

							default :
								break loop132;
							}
						}

						match(input, Token.UP, null); if (state.failed) return retval;
					}

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2610:5: -> assertion_enumeration_pairs(ep=$ep)
					  {
					  	retval.st = templateLib.getInstanceOf("assertion_enumeration_pairs",new STAttrMap().put("ep", list_ep));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_enumeration"


	public static class enumeration_pair_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "enumeration_pair"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2614:1: enumeration_pair : ^(i= ID pe= predicate ) -> enumeration_pair(i=$i.textpe=$pe.st);
	public final UnparseBLESS.enumeration_pair_return enumeration_pair() throws RecognitionException {
		UnparseBLESS.enumeration_pair_return retval = new UnparseBLESS.enumeration_pair_return();
		retval.start = input.LT(1);

		BAST i=null;
		TreeRuleReturnScope pe =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2615:3: ( ^(i= ID pe= predicate ) -> enumeration_pair(i=$i.textpe=$pe.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2616:3: ^(i= ID pe= predicate )
			{
			i=(BAST)match(input,ID,FOLLOW_ID_in_enumeration_pair9456); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_enumeration_pair9460);
			pe=predicate();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2617:5: -> enumeration_pair(i=$i.textpe=$pe.st)
			  {
			  	retval.st = templateLib.getInstanceOf("enumeration_pair",new STAttrMap().put("i", (i!=null?i.getText():null)).put("pe", (pe!=null?((StringTemplate)pe.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_pair"


	public static class universal_quantification_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "universal_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2623:1: universal_quantification : ^(a= LITERAL_all lv= logic_variables d= logic_variable_domain p= predicate ) -> universal_quantification(a=$a.textlv=$lv.std=$d.stp=$p.st);
	public final UnparseBLESS.universal_quantification_return universal_quantification() throws RecognitionException {
		UnparseBLESS.universal_quantification_return retval = new UnparseBLESS.universal_quantification_return();
		retval.start = input.LT(1);

		BAST a=null;
		TreeRuleReturnScope lv =null;
		TreeRuleReturnScope d =null;
		TreeRuleReturnScope p =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2624:2: ( ^(a= LITERAL_all lv= logic_variables d= logic_variable_domain p= predicate ) -> universal_quantification(a=$a.textlv=$lv.std=$d.stp=$p.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2625:2: ^(a= LITERAL_all lv= logic_variables d= logic_variable_domain p= predicate )
			{
			a=(BAST)match(input,LITERAL_all,FOLLOW_LITERAL_all_in_universal_quantification9500); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_logic_variables_in_universal_quantification9504);
			lv=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_logic_variable_domain_in_universal_quantification9508);
			d=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_universal_quantification9512);
			p=predicate();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2626:3: -> universal_quantification(a=$a.textlv=$lv.std=$d.stp=$p.st)
			  {
			  	retval.st = templateLib.getInstanceOf("universal_quantification",new STAttrMap().put("a", (a!=null?a.getText():null)).put("lv", (lv!=null?((StringTemplate)lv.getTemplate()):null)).put("d", (d!=null?((StringTemplate)d.getTemplate()):null)).put("p", (p!=null?((StringTemplate)p.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "universal_quantification"


	public static class lattice_variables_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "lattice_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2633:1: lattice_variables : ( ^( COMMA (i+= identifier )+ ) -> template(i=$i) \"<i; separator=\",\"> \"|i1= ID -> {%{$i1.text}});
	public final UnparseBLESS.lattice_variables_return lattice_variables() throws RecognitionException {
		UnparseBLESS.lattice_variables_return retval = new UnparseBLESS.lattice_variables_return();
		retval.start = input.LT(1);

		BAST i1=null;
		List<Object> list_i=null;
		RuleReturnScope i = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2634:2: ( ^( COMMA (i+= identifier )+ ) -> template(i=$i) \"<i; separator=\",\"> \"|i1= ID -> {%{$i1.text}})
			int alt135=2;
			int LA135_0 = input.LA(1);
			if ( (LA135_0==COMMA) ) {
				alt135=1;
			}
			else if ( (LA135_0==ID) ) {
				alt135=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 135, 0, input);
				throw nvae;
			}

			switch (alt135) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2635:2: ^( COMMA (i+= identifier )+ )
					{
					match(input,COMMA,FOLLOW_COMMA_in_lattice_variables9561); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2635:12: (i+= identifier )+
					int cnt134=0;
					loop134:
					while (true) {
						int alt134=2;
						int LA134_0 = input.LA(1);
						if ( (LA134_0==ID) ) {
							alt134=1;
						}

						switch (alt134) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2635:12: i+= identifier
							{
							pushFollow(FOLLOW_identifier_in_lattice_variables9565);
							i=identifier();
							state._fsp--;
							if (state.failed) return retval;
							if (list_i==null) list_i=new ArrayList<Object>();
							list_i.add(i.getTemplate());
							}
							break;

						default :
							if ( cnt134 >= 1 ) break loop134;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(134, input);
							throw eee;
						}
						cnt134++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2636:3: -> template(i=$i) \"<i; separator=\",\"> \"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i; separator=\",\"> ",new STAttrMap().put("i", list_i));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2638:3: i1= ID
					{
					i1=(BAST)match(input,ID,FOLLOW_ID_in_lattice_variables9591); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2639:5: -> {%{$i1.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(i1!=null?i1.getText():null));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lattice_variables"


	public static class existential_quantification_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "existential_quantification"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2642:1: existential_quantification : ^(e= LITERAL_exists lv2= logic_variables d2= logic_variable_domain p2= predicate ) -> existential_quantification(e=$e.textlv2=$lv2.std2=$d2.stp2=$p2.st);
	public final UnparseBLESS.existential_quantification_return existential_quantification() throws RecognitionException {
		UnparseBLESS.existential_quantification_return retval = new UnparseBLESS.existential_quantification_return();
		retval.start = input.LT(1);

		BAST e=null;
		TreeRuleReturnScope lv2 =null;
		TreeRuleReturnScope d2 =null;
		TreeRuleReturnScope p2 =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2643:2: ( ^(e= LITERAL_exists lv2= logic_variables d2= logic_variable_domain p2= predicate ) -> existential_quantification(e=$e.textlv2=$lv2.std2=$d2.stp2=$p2.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2644:2: ^(e= LITERAL_exists lv2= logic_variables d2= logic_variable_domain p2= predicate )
			{
			e=(BAST)match(input,LITERAL_exists,FOLLOW_LITERAL_exists_in_existential_quantification9622); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_logic_variables_in_existential_quantification9626);
			lv2=logic_variables();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_logic_variable_domain_in_existential_quantification9630);
			d2=logic_variable_domain();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_existential_quantification9634);
			p2=predicate();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2645:3: -> existential_quantification(e=$e.textlv2=$lv2.std2=$d2.stp2=$p2.st)
			  {
			  	retval.st = templateLib.getInstanceOf("existential_quantification",new STAttrMap().put("e", (e!=null?e.getText():null)).put("lv2", (lv2!=null?((StringTemplate)lv2.getTemplate()):null)).put("d2", (d2!=null?((StringTemplate)d2.getTemplate()):null)).put("p2", (p2!=null?((StringTemplate)p2.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "existential_quantification"


	public static class logic_variables_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "logic_variables"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2652:1: logic_variables : ^( COLON aty= assertion_type (i+= identifier )+ ) -> logic_variables(t=$aty.sti=$i);
	public final UnparseBLESS.logic_variables_return logic_variables() throws RecognitionException {
		UnparseBLESS.logic_variables_return retval = new UnparseBLESS.logic_variables_return();
		retval.start = input.LT(1);

		List<Object> list_i=null;
		TreeRuleReturnScope aty =null;
		RuleReturnScope i = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2653:2: ( ^( COLON aty= assertion_type (i+= identifier )+ ) -> logic_variables(t=$aty.sti=$i))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2654:2: ^( COLON aty= assertion_type (i+= identifier )+ )
			{
			match(input,COLON,FOLLOW_COLON_in_logic_variables9682); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_type_in_logic_variables9686);
			aty=assertion_type();
			state._fsp--;
			if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2654:31: (i+= identifier )+
			int cnt136=0;
			loop136:
			while (true) {
				int alt136=2;
				int LA136_0 = input.LA(1);
				if ( (LA136_0==ID) ) {
					alt136=1;
				}

				switch (alt136) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2654:31: i+= identifier
					{
					pushFollow(FOLLOW_identifier_in_logic_variables9690);
					i=identifier();
					state._fsp--;
					if (state.failed) return retval;
					if (list_i==null) list_i=new ArrayList<Object>();
					list_i.add(i.getTemplate());
					}
					break;

				default :
					if ( cnt136 >= 1 ) break loop136;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(136, input);
					throw eee;
				}
				cnt136++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2655:3: -> logic_variables(t=$aty.sti=$i)
			  {
			  	retval.st = templateLib.getInstanceOf("logic_variables",new STAttrMap().put("t", (aty!=null?((StringTemplate)aty.getTemplate()):null)).put("i", list_i));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variables"


	public static class logic_variable_domain_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "logic_variable_domain"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2659:1: logic_variable_domain : ( ^(i= LITERAL_in ^(rs= range_symbol l= assertion_expression h= assertion_expression ) ) -> logic_variable_domain(i=$i.textl=$l.sth=$h.strs=$rs.st)| ^(i2= LITERAL_in p= predicate ) -> logic_variable_domain2(i2=$i2.textp=$p.st));
	public final UnparseBLESS.logic_variable_domain_return logic_variable_domain() throws RecognitionException {
		UnparseBLESS.logic_variable_domain_return retval = new UnparseBLESS.logic_variable_domain_return();
		retval.start = input.LT(1);

		BAST i=null;
		BAST i2=null;
		TreeRuleReturnScope rs =null;
		TreeRuleReturnScope l =null;
		TreeRuleReturnScope h =null;
		TreeRuleReturnScope p =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2660:2: ( ^(i= LITERAL_in ^(rs= range_symbol l= assertion_expression h= assertion_expression ) ) -> logic_variable_domain(i=$i.textl=$l.sth=$h.strs=$rs.st)| ^(i2= LITERAL_in p= predicate ) -> logic_variable_domain2(i2=$i2.textp=$p.st))
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==LITERAL_in) ) {
				int LA137_1 = input.LA(2);
				if ( (LA137_1==DOWN) ) {
					int LA137_2 = input.LA(3);
					if ( ((LA137_2 >= COMMACOMMA && LA137_2 <= COMMADOT)||(LA137_2 >= DOTCOMMA && LA137_2 <= DOTDOT)) ) {
						alt137=1;
					}
					else if ( ((LA137_2 >= AL && LA137_2 <= AM)||LA137_2==AT_SIGN||LA137_2==CARET||LA137_2==EQ||LA137_2==GT||(LA137_2 >= ID && LA137_2 <= IMP)||LA137_2==INVOKE||(LA137_2 >= LITERAL_all && LA137_2 <= LITERAL_and)||LA137_2==LITERAL_def||LA137_2==LITERAL_exists||LA137_2==LITERAL_false||LA137_2==LITERAL_iff||(LA137_2 >= LITERAL_implies && LA137_2 <= LITERAL_in)||LA137_2==LITERAL_not||LA137_2==LITERAL_or||LA137_2==LITERAL_stop||LA137_2==LITERAL_true||(LA137_2 >= LITERAL_xor && LA137_2 <= LT)||LA137_2==NEQ||LA137_2==PERIOD||LA137_2==PLUS_EQUALS||LA137_2==TICK||LA137_2==WP) ) {
						alt137=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 137, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 137, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 137, 0, input);
				throw nvae;
			}

			switch (alt137) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2661:2: ^(i= LITERAL_in ^(rs= range_symbol l= assertion_expression h= assertion_expression ) )
					{
					i=(BAST)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_logic_variable_domain9735); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_range_symbol_in_logic_variable_domain9741);
					rs=range_symbol();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain9745);
					l=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_logic_variable_domain9749);
					h=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2662:4: -> logic_variable_domain(i=$i.textl=$l.sth=$h.strs=$rs.st)
					  {
					  	retval.st = templateLib.getInstanceOf("logic_variable_domain",new STAttrMap().put("i", (i!=null?i.getText():null)).put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("h", (h!=null?((StringTemplate)h.getTemplate()):null)).put("rs", (rs!=null?((StringTemplate)rs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2669:2: ^(i2= LITERAL_in p= predicate )
					{
					i2=(BAST)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_logic_variable_domain9791); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_in_logic_variable_domain9795);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2670:4: -> logic_variable_domain2(i2=$i2.textp=$p.st)
					  {
					  	retval.st = templateLib.getInstanceOf("logic_variable_domain2",new STAttrMap().put("i2", (i2!=null?i2.getText():null)).put("p", (p!=null?((StringTemplate)p.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logic_variable_domain"


	public static class predicate_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2675:1: predicate : ( ( LITERAL_all )=>u= universal_quantification -> {$u.st}| ( LITERAL_exists )=>e= existential_quantification -> {$e.st}| ^(an= LITERAL_and (pa+= subpredicate )+ ) -> and(terms=$pa)| ^(o= LITERAL_or (pa2+= subpredicate )+ ) -> or(terms=$pa2)| ^(x= LITERAL_xor (pa3+= subpredicate )+ ) -> xor(terms=$pa3)| ^(imp= LITERAL_implies suposition= subpredicate consequence= subpredicate ) -> implies(s=$suposition.stc=$consequence.st)| ^(i= LITERAL_iff ifthis= subpredicate andonlyifthis= subpredicate ) -> iff(l=$ifthis.str=$andonlyifthis.st)| ^(ar= IMP suposition= subpredicate consequence= subpredicate ) -> implies(s=$suposition.stc=$consequence.st)|paonly= subpredicate -> template(paonly=$paonly.st) \"<paonly>\");
	public final UnparseBLESS.predicate_return predicate() throws RecognitionException {
		UnparseBLESS.predicate_return retval = new UnparseBLESS.predicate_return();
		retval.start = input.LT(1);

		BAST an=null;
		BAST o=null;
		BAST x=null;
		BAST imp=null;
		BAST i=null;
		BAST ar=null;
		List<Object> list_pa=null;
		List<Object> list_pa2=null;
		List<Object> list_pa3=null;
		TreeRuleReturnScope u =null;
		TreeRuleReturnScope e =null;
		TreeRuleReturnScope suposition =null;
		TreeRuleReturnScope consequence =null;
		TreeRuleReturnScope ifthis =null;
		TreeRuleReturnScope andonlyifthis =null;
		TreeRuleReturnScope paonly =null;
		RuleReturnScope pa = null;
		RuleReturnScope pa2 = null;
		RuleReturnScope pa3 = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2676:2: ( ( LITERAL_all )=>u= universal_quantification -> {$u.st}| ( LITERAL_exists )=>e= existential_quantification -> {$e.st}| ^(an= LITERAL_and (pa+= subpredicate )+ ) -> and(terms=$pa)| ^(o= LITERAL_or (pa2+= subpredicate )+ ) -> or(terms=$pa2)| ^(x= LITERAL_xor (pa3+= subpredicate )+ ) -> xor(terms=$pa3)| ^(imp= LITERAL_implies suposition= subpredicate consequence= subpredicate ) -> implies(s=$suposition.stc=$consequence.st)| ^(i= LITERAL_iff ifthis= subpredicate andonlyifthis= subpredicate ) -> iff(l=$ifthis.str=$andonlyifthis.st)| ^(ar= IMP suposition= subpredicate consequence= subpredicate ) -> implies(s=$suposition.stc=$consequence.st)|paonly= subpredicate -> template(paonly=$paonly.st) \"<paonly>\")
			int alt141=9;
			int LA141_0 = input.LA(1);
			if ( (LA141_0==LITERAL_all) && (synpred1_UnparseBLESS())) {
				alt141=1;
			}
			else if ( (LA141_0==LITERAL_exists) && (synpred2_UnparseBLESS())) {
				alt141=2;
			}
			else if ( (LA141_0==LITERAL_and) ) {
				alt141=3;
			}
			else if ( (LA141_0==LITERAL_or) ) {
				alt141=4;
			}
			else if ( (LA141_0==LITERAL_xor) ) {
				alt141=5;
			}
			else if ( (LA141_0==LITERAL_implies) ) {
				alt141=6;
			}
			else if ( (LA141_0==LITERAL_iff) ) {
				alt141=7;
			}
			else if ( (LA141_0==IMP) ) {
				alt141=8;
			}
			else if ( ((LA141_0 >= AL && LA141_0 <= AM)||LA141_0==AT_SIGN||LA141_0==CARET||LA141_0==EQ||LA141_0==GT||LA141_0==ID||LA141_0==INVOKE||LA141_0==LITERAL_def||LA141_0==LITERAL_false||LA141_0==LITERAL_in||LA141_0==LITERAL_not||LA141_0==LITERAL_stop||LA141_0==LITERAL_true||(LA141_0 >= LPAREN && LA141_0 <= LT)||LA141_0==NEQ||LA141_0==PERIOD||LA141_0==PLUS_EQUALS||LA141_0==TICK||LA141_0==WP) ) {
				alt141=9;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 141, 0, input);
				throw nvae;
			}

			switch (alt141) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2677:2: ( LITERAL_all )=>u= universal_quantification
					{
					pushFollow(FOLLOW_universal_quantification_in_predicate9841);
					u=universal_quantification();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2679:3: -> {$u.st}
					  {
					  	retval.st = (u!=null?((StringTemplate)u.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2682:2: ( LITERAL_exists )=>e= existential_quantification
					{
					pushFollow(FOLLOW_existential_quantification_in_predicate9862);
					e=existential_quantification();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2684:3: -> {$e.st}
					  {
					  	retval.st = (e!=null?((StringTemplate)e.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2687:2: ^(an= LITERAL_and (pa+= subpredicate )+ )
					{
					an=(BAST)match(input,LITERAL_and,FOLLOW_LITERAL_and_in_predicate9879); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2687:22: (pa+= subpredicate )+
					int cnt138=0;
					loop138:
					while (true) {
						int alt138=2;
						int LA138_0 = input.LA(1);
						if ( ((LA138_0 >= AL && LA138_0 <= AM)||LA138_0==AT_SIGN||LA138_0==CARET||LA138_0==EQ||LA138_0==GT||LA138_0==ID||LA138_0==INVOKE||LA138_0==LITERAL_def||LA138_0==LITERAL_false||LA138_0==LITERAL_in||LA138_0==LITERAL_not||LA138_0==LITERAL_stop||LA138_0==LITERAL_true||(LA138_0 >= LPAREN && LA138_0 <= LT)||LA138_0==NEQ||LA138_0==PERIOD||LA138_0==PLUS_EQUALS||LA138_0==TICK||LA138_0==WP) ) {
							alt138=1;
						}

						switch (alt138) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2687:22: pa+= subpredicate
							{
							pushFollow(FOLLOW_subpredicate_in_predicate9883);
							pa=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if (list_pa==null) list_pa=new ArrayList<Object>();
							list_pa.add(pa.getTemplate());
							}
							break;

						default :
							if ( cnt138 >= 1 ) break loop138;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(138, input);
							throw eee;
						}
						cnt138++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2689:3: -> and(terms=$pa)
					  {
					  	retval.st = templateLib.getInstanceOf("and",new STAttrMap().put("terms", list_pa));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2691:2: ^(o= LITERAL_or (pa2+= subpredicate )+ )
					{
					o=(BAST)match(input,LITERAL_or,FOLLOW_LITERAL_or_in_predicate9908); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2691:21: (pa2+= subpredicate )+
					int cnt139=0;
					loop139:
					while (true) {
						int alt139=2;
						int LA139_0 = input.LA(1);
						if ( ((LA139_0 >= AL && LA139_0 <= AM)||LA139_0==AT_SIGN||LA139_0==CARET||LA139_0==EQ||LA139_0==GT||LA139_0==ID||LA139_0==INVOKE||LA139_0==LITERAL_def||LA139_0==LITERAL_false||LA139_0==LITERAL_in||LA139_0==LITERAL_not||LA139_0==LITERAL_stop||LA139_0==LITERAL_true||(LA139_0 >= LPAREN && LA139_0 <= LT)||LA139_0==NEQ||LA139_0==PERIOD||LA139_0==PLUS_EQUALS||LA139_0==TICK||LA139_0==WP) ) {
							alt139=1;
						}

						switch (alt139) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2691:21: pa2+= subpredicate
							{
							pushFollow(FOLLOW_subpredicate_in_predicate9912);
							pa2=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if (list_pa2==null) list_pa2=new ArrayList<Object>();
							list_pa2.add(pa2.getTemplate());
							}
							break;

						default :
							if ( cnt139 >= 1 ) break loop139;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(139, input);
							throw eee;
						}
						cnt139++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2693:3: -> or(terms=$pa2)
					  {
					  	retval.st = templateLib.getInstanceOf("or",new STAttrMap().put("terms", list_pa2));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2695:2: ^(x= LITERAL_xor (pa3+= subpredicate )+ )
					{
					x=(BAST)match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_predicate9937); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2695:22: (pa3+= subpredicate )+
					int cnt140=0;
					loop140:
					while (true) {
						int alt140=2;
						int LA140_0 = input.LA(1);
						if ( ((LA140_0 >= AL && LA140_0 <= AM)||LA140_0==AT_SIGN||LA140_0==CARET||LA140_0==EQ||LA140_0==GT||LA140_0==ID||LA140_0==INVOKE||LA140_0==LITERAL_def||LA140_0==LITERAL_false||LA140_0==LITERAL_in||LA140_0==LITERAL_not||LA140_0==LITERAL_stop||LA140_0==LITERAL_true||(LA140_0 >= LPAREN && LA140_0 <= LT)||LA140_0==NEQ||LA140_0==PERIOD||LA140_0==PLUS_EQUALS||LA140_0==TICK||LA140_0==WP) ) {
							alt140=1;
						}

						switch (alt140) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2695:22: pa3+= subpredicate
							{
							pushFollow(FOLLOW_subpredicate_in_predicate9941);
							pa3=subpredicate();
							state._fsp--;
							if (state.failed) return retval;
							if (list_pa3==null) list_pa3=new ArrayList<Object>();
							list_pa3.add(pa3.getTemplate());
							}
							break;

						default :
							if ( cnt140 >= 1 ) break loop140;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(140, input);
							throw eee;
						}
						cnt140++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2697:3: -> xor(terms=$pa3)
					  {
					  	retval.st = templateLib.getInstanceOf("xor",new STAttrMap().put("terms", list_pa3));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2699:2: ^(imp= LITERAL_implies suposition= subpredicate consequence= subpredicate )
					{
					imp=(BAST)match(input,LITERAL_implies,FOLLOW_LITERAL_implies_in_predicate9966); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_predicate9970);
					suposition=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_predicate9974);
					consequence=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2701:6: -> implies(s=$suposition.stc=$consequence.st)
					  {
					  	retval.st = templateLib.getInstanceOf("implies",new STAttrMap().put("s", (suposition!=null?((StringTemplate)suposition.getTemplate()):null)).put("c", (consequence!=null?((StringTemplate)consequence.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2704:2: ^(i= LITERAL_iff ifthis= subpredicate andonlyifthis= subpredicate )
					{
					i=(BAST)match(input,LITERAL_iff,FOLLOW_LITERAL_iff_in_predicate10005); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_predicate10009);
					ifthis=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_predicate10013);
					andonlyifthis=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2706:6: -> iff(l=$ifthis.str=$andonlyifthis.st)
					  {
					  	retval.st = templateLib.getInstanceOf("iff",new STAttrMap().put("l", (ifthis!=null?((StringTemplate)ifthis.getTemplate()):null)).put("r", (andonlyifthis!=null?((StringTemplate)andonlyifthis.getTemplate()):null)));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2709:2: ^(ar= IMP suposition= subpredicate consequence= subpredicate )
					{
					ar=(BAST)match(input,IMP,FOLLOW_IMP_in_predicate10044); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_predicate10048);
					suposition=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_predicate10052);
					consequence=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2711:6: -> implies(s=$suposition.stc=$consequence.st)
					  {
					  	retval.st = templateLib.getInstanceOf("implies",new STAttrMap().put("s", (suposition!=null?((StringTemplate)suposition.getTemplate()):null)).put("c", (consequence!=null?((StringTemplate)consequence.getTemplate()):null)));
					  }


					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2714:2: paonly= subpredicate
					{
					pushFollow(FOLLOW_subpredicate_in_predicate10081);
					paonly=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2715:3: -> template(paonly=$paonly.st) \"<paonly>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<paonly>",new STAttrMap().put("paonly", (paonly!=null?((StringTemplate)paonly.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.predicate caught RecognitionException");
				  if (an!=null)
				  	an.showParseTree(an.getText());
				 else  if (o!=null)
				  	o.showParseTree(o.getText());
				 else  if (x!=null)
				  	x.showParseTree(x.getText());
				 else  if (imp!=null)
				  	imp.showParseTree(imp.getText());
				 else  if (i!=null)
				  	i.showParseTree(i.getText());
				 else  if (ar!=null)
				  	ar.showParseTree(ar.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate"


	public static class subpredicate_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "subpredicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2735:1: subpredicate : ( ^(n= LITERAL_not pas= predicate_atom_stub ) -> not(bt=$pas.st)|pas= predicate_atom_stub -> {$pas.st});
	public final UnparseBLESS.subpredicate_return subpredicate() throws RecognitionException {
		UnparseBLESS.subpredicate_return retval = new UnparseBLESS.subpredicate_return();
		retval.start = input.LT(1);

		BAST n=null;
		TreeRuleReturnScope pas =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2736:2: ( ^(n= LITERAL_not pas= predicate_atom_stub ) -> not(bt=$pas.st)|pas= predicate_atom_stub -> {$pas.st})
			int alt142=2;
			int LA142_0 = input.LA(1);
			if ( (LA142_0==LITERAL_not) ) {
				alt142=1;
			}
			else if ( ((LA142_0 >= AL && LA142_0 <= AM)||LA142_0==AT_SIGN||LA142_0==CARET||LA142_0==EQ||LA142_0==GT||LA142_0==ID||LA142_0==INVOKE||LA142_0==LITERAL_def||LA142_0==LITERAL_false||LA142_0==LITERAL_in||LA142_0==LITERAL_stop||LA142_0==LITERAL_true||(LA142_0 >= LPAREN && LA142_0 <= LT)||LA142_0==NEQ||LA142_0==PERIOD||LA142_0==PLUS_EQUALS||LA142_0==TICK||LA142_0==WP) ) {
				alt142=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 142, 0, input);
				throw nvae;
			}

			switch (alt142) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2737:2: ^(n= LITERAL_not pas= predicate_atom_stub )
					{
					n=(BAST)match(input,LITERAL_not,FOLLOW_LITERAL_not_in_subpredicate10125); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_atom_stub_in_subpredicate10129);
					pas=predicate_atom_stub();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2738:4: -> not(bt=$pas.st)
					  {
					  	retval.st = templateLib.getInstanceOf("not",new STAttrMap().put("bt", (pas!=null?((StringTemplate)pas.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2741:2: pas= predicate_atom_stub
					{
					pushFollow(FOLLOW_predicate_atom_stub_in_subpredicate10153);
					pas=predicate_atom_stub();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2742:4: -> {$pas.st}
					  {
					  	retval.st = (pas!=null?((StringTemplate)pas.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.subpredicate caught RecognitionException");
				  if (n!=null)
				  	n.showParseTree(n.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subpredicate"


	public static class predicate_atom_stub_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "predicate_atom_stub"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2753:1: predicate_atom_stub : (t= LITERAL_true -> true(|f= LITERAL_false -> false(|s= LITERAL_stop -> stop(|ta= timed_predicate -> {$ta.st}| ^(r= relation_symbol lhs= assertion_subexpression rhs= assertion_subexpression ) -> relation(r=$r.stlhs=$lhs.strhs=$rhs.st)| ^(i= LITERAL_in p= assertion_subexpression ra= assertion_range ) -> in_range(p=$p.stra=$ra.st)| ^( PLUS_EQUALS target= name parameter= assertion_subexpression ) -> template(target=$target.stparameter=$parameter.st) \" <target> += <parameter> \"| ^( LITERAL_def lv= assertion_parameter ) -> template(lv=$lv.st) \" def <lv> \");
	public final UnparseBLESS.predicate_atom_stub_return predicate_atom_stub() throws RecognitionException {
		UnparseBLESS.predicate_atom_stub_return retval = new UnparseBLESS.predicate_atom_stub_return();
		retval.start = input.LT(1);

		BAST t=null;
		BAST f=null;
		BAST s=null;
		BAST i=null;
		TreeRuleReturnScope ta =null;
		TreeRuleReturnScope r =null;
		TreeRuleReturnScope lhs =null;
		TreeRuleReturnScope rhs =null;
		TreeRuleReturnScope p =null;
		TreeRuleReturnScope ra =null;
		TreeRuleReturnScope target =null;
		TreeRuleReturnScope parameter =null;
		TreeRuleReturnScope lv =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2754:2: (t= LITERAL_true -> true(|f= LITERAL_false -> false(|s= LITERAL_stop -> stop(|ta= timed_predicate -> {$ta.st}| ^(r= relation_symbol lhs= assertion_subexpression rhs= assertion_subexpression ) -> relation(r=$r.stlhs=$lhs.strhs=$rhs.st)| ^(i= LITERAL_in p= assertion_subexpression ra= assertion_range ) -> in_range(p=$p.stra=$ra.st)| ^( PLUS_EQUALS target= name parameter= assertion_subexpression ) -> template(target=$target.stparameter=$parameter.st) \" <target> += <parameter> \"| ^( LITERAL_def lv= assertion_parameter ) -> template(lv=$lv.st) \" def <lv> \")
			int alt143=8;
			switch ( input.LA(1) ) {
			case LITERAL_true:
				{
				alt143=1;
				}
				break;
			case LITERAL_false:
				{
				alt143=2;
				}
				break;
			case LITERAL_stop:
				{
				alt143=3;
				}
				break;
			case AT_SIGN:
			case CARET:
			case ID:
			case INVOKE:
			case LPAREN:
			case PERIOD:
			case TICK:
			case WP:
				{
				alt143=4;
				}
				break;
			case AL:
			case AM:
			case EQ:
			case GT:
			case LT:
			case NEQ:
				{
				alt143=5;
				}
				break;
			case LITERAL_in:
				{
				alt143=6;
				}
				break;
			case PLUS_EQUALS:
				{
				alt143=7;
				}
				break;
			case LITERAL_def:
				{
				alt143=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 143, 0, input);
				throw nvae;
			}
			switch (alt143) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2755:2: t= LITERAL_true
					{
					t=(BAST)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_predicate_atom_stub10187); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2756:4: -> true(
					  {
					  	retval.st = templateLib.getInstanceOf("true");
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2758:4: f= LITERAL_false
					{
					f=(BAST)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_predicate_atom_stub10205); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2759:4: -> false(
					  {
					  	retval.st = templateLib.getInstanceOf("false");
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2761:4: s= LITERAL_stop
					{
					s=(BAST)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_predicate_atom_stub10223); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2762:4: -> stop(
					  {
					  	retval.st = templateLib.getInstanceOf("stop");
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2764:4: ta= timed_predicate
					{
					pushFollow(FOLLOW_timed_predicate_in_predicate_atom_stub10240);
					ta=timed_predicate();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2765:4: -> {$ta.st}
					  {
					  	retval.st = (ta!=null?((StringTemplate)ta.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2768:4: ^(r= relation_symbol lhs= assertion_subexpression rhs= assertion_subexpression )
					{
					pushFollow(FOLLOW_relation_symbol_in_predicate_atom_stub10259);
					r=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_predicate_atom_stub10264);
					lhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_predicate_atom_stub10268);
					rhs=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2769:4: -> relation(r=$r.stlhs=$lhs.strhs=$rhs.st)
					  {
					  	retval.st = templateLib.getInstanceOf("relation",new STAttrMap().put("r", (r!=null?((StringTemplate)r.getTemplate()):null)).put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2772:4: ^(i= LITERAL_in p= assertion_subexpression ra= assertion_range )
					{
					i=(BAST)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_predicate_atom_stub10300); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_predicate_atom_stub10304);
					p=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_range_in_predicate_atom_stub10308);
					ra=assertion_range();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2773:3: -> in_range(p=$p.stra=$ra.st)
					  {
					  	retval.st = templateLib.getInstanceOf("in_range",new STAttrMap().put("p", (p!=null?((StringTemplate)p.getTemplate()):null)).put("ra", (ra!=null?((StringTemplate)ra.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2776:4: ^( PLUS_EQUALS target= name parameter= assertion_subexpression )
					{
					match(input,PLUS_EQUALS,FOLLOW_PLUS_EQUALS_in_predicate_atom_stub10332); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_name_in_predicate_atom_stub10338);
					target=name();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_predicate_atom_stub10342);
					parameter=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2777:3: -> template(target=$target.stparameter=$parameter.st) \" <target> += <parameter> \"
					  {
					  	retval.st = new StringTemplate(templateLib, " <target> += <parameter> ",new STAttrMap().put("target", (target!=null?((StringTemplate)target.getTemplate()):null)).put("parameter", (parameter!=null?((StringTemplate)parameter.getTemplate()):null)));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2781:4: ^( LITERAL_def lv= assertion_parameter )
					{
					match(input,LITERAL_def,FOLLOW_LITERAL_def_in_predicate_atom_stub10370); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_parameter_in_predicate_atom_stub10374);
					lv=assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2782:4: -> template(lv=$lv.st) \" def <lv> \"
					  {
					  	retval.st = new StringTemplate(templateLib, " def <lv> ",new STAttrMap().put("lv", (lv!=null?((StringTemplate)lv.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate_atom_stub"


	public static class assertion_range_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2788:1: assertion_range : ^(rs= range_symbol lb= assertion_expression ub= assertion_expression ) -> range(rs=$rs.stlb=$lb.stub=$ub.st);
	public final UnparseBLESS.assertion_range_return assertion_range() throws RecognitionException {
		UnparseBLESS.assertion_range_return retval = new UnparseBLESS.assertion_range_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope rs =null;
		TreeRuleReturnScope lb =null;
		TreeRuleReturnScope ub =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2789:3: ( ^(rs= range_symbol lb= assertion_expression ub= assertion_expression ) -> range(rs=$rs.stlb=$lb.stub=$ub.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2790:2: ^(rs= range_symbol lb= assertion_expression ub= assertion_expression )
			{
			pushFollow(FOLLOW_range_symbol_in_assertion_range10411);
			rs=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_expression_in_assertion_range10415);
			lb=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_expression_in_assertion_range10419);
			ub=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2791:3: -> range(rs=$rs.stlb=$lb.stub=$ub.st)
			  {
			  	retval.st = templateLib.getInstanceOf("range",new STAttrMap().put("rs", (rs!=null?((StringTemplate)rs.getTemplate()):null)).put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_range"


	public static class assertion_parameter_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2795:1: assertion_parameter : (par= ID -> {%{$par.text}}| ^( TILDE par= ID at= assertion_type ) -> template(par=$par.textat=$at.st) \"<par>~<at>\");
	public final UnparseBLESS.assertion_parameter_return assertion_parameter() throws RecognitionException {
		UnparseBLESS.assertion_parameter_return retval = new UnparseBLESS.assertion_parameter_return();
		retval.start = input.LT(1);

		BAST par=null;
		TreeRuleReturnScope at =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2796:3: (par= ID -> {%{$par.text}}| ^( TILDE par= ID at= assertion_type ) -> template(par=$par.textat=$at.st) \"<par>~<at>\")
			int alt144=2;
			int LA144_0 = input.LA(1);
			if ( (LA144_0==ID) ) {
				alt144=1;
			}
			else if ( (LA144_0==TILDE) ) {
				alt144=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 144, 0, input);
				throw nvae;
			}

			switch (alt144) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2797:3: par= ID
					{
					par=(BAST)match(input,ID,FOLLOW_ID_in_assertion_parameter10458); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2798:5: -> {%{$par.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(par!=null?par.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2800:3: ^( TILDE par= ID at= assertion_type )
					{
					match(input,TILDE,FOLLOW_TILDE_in_assertion_parameter10475); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					par=(BAST)match(input,ID,FOLLOW_ID_in_assertion_parameter10479); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_type_in_assertion_parameter10483);
					at=assertion_type();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2801:5: -> template(par=$par.textat=$at.st) \"<par>~<at>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<par>~<at>",new STAttrMap().put("par", (par!=null?par.getText():null)).put("at", (at!=null?((StringTemplate)at.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_parameter"


	public static class assertion_type_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_type"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2804:1: assertion_type : (b= LITERAL_boolean -> {%{$b.text}}|n= LITERAL_natural -> natural(|n= LITERAL_integer -> integer(|n= LITERAL_rational -> rational(|n= LITERAL_real -> real(|n= LITERAL_complex -> complex(|n= LITERAL_time -> time(|uccr= unique_component_classifier_reference -> {$uccr.st});
	public final UnparseBLESS.assertion_type_return assertion_type() throws RecognitionException {
		UnparseBLESS.assertion_type_return retval = new UnparseBLESS.assertion_type_return();
		retval.start = input.LT(1);

		BAST b=null;
		BAST n=null;
		TreeRuleReturnScope uccr =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2805:3: (b= LITERAL_boolean -> {%{$b.text}}|n= LITERAL_natural -> natural(|n= LITERAL_integer -> integer(|n= LITERAL_rational -> rational(|n= LITERAL_real -> real(|n= LITERAL_complex -> complex(|n= LITERAL_time -> time(|uccr= unique_component_classifier_reference -> {$uccr.st})
			int alt145=8;
			switch ( input.LA(1) ) {
			case LITERAL_boolean:
				{
				alt145=1;
				}
				break;
			case LITERAL_natural:
				{
				alt145=2;
				}
				break;
			case LITERAL_integer:
				{
				alt145=3;
				}
				break;
			case LITERAL_rational:
				{
				alt145=4;
				}
				break;
			case LITERAL_real:
				{
				alt145=5;
				}
				break;
			case LITERAL_complex:
				{
				alt145=6;
				}
				break;
			case LITERAL_time:
				{
				alt145=7;
				}
				break;
			case DOUBLE_COLON:
			case ID:
			case PERIOD:
				{
				alt145=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 145, 0, input);
				throw nvae;
			}
			switch (alt145) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2806:3: b= LITERAL_boolean
					{
					b=(BAST)match(input,LITERAL_boolean,FOLLOW_LITERAL_boolean_in_assertion_type10520); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2807:5: -> {%{$b.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(b!=null?b.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2808:5: n= LITERAL_natural
					{
					n=(BAST)match(input,LITERAL_natural,FOLLOW_LITERAL_natural_in_assertion_type10537); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2809:2: -> natural(
					  {
					  	retval.st = templateLib.getInstanceOf("natural");
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2810:4: n= LITERAL_integer
					{
					n=(BAST)match(input,LITERAL_integer,FOLLOW_LITERAL_integer_in_assertion_type10552); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2811:2: -> integer(
					  {
					  	retval.st = templateLib.getInstanceOf("integer");
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2812:4: n= LITERAL_rational
					{
					n=(BAST)match(input,LITERAL_rational,FOLLOW_LITERAL_rational_in_assertion_type10567); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2813:2: -> rational(
					  {
					  	retval.st = templateLib.getInstanceOf("rational");
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2814:4: n= LITERAL_real
					{
					n=(BAST)match(input,LITERAL_real,FOLLOW_LITERAL_real_in_assertion_type10582); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2815:2: -> real(
					  {
					  	retval.st = templateLib.getInstanceOf("real");
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2816:4: n= LITERAL_complex
					{
					n=(BAST)match(input,LITERAL_complex,FOLLOW_LITERAL_complex_in_assertion_type10597); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2817:2: -> complex(
					  {
					  	retval.st = templateLib.getInstanceOf("complex");
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2818:4: n= LITERAL_time
					{
					n=(BAST)match(input,LITERAL_time,FOLLOW_LITERAL_time_in_assertion_type10611); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2819:3: -> time(
					  {
					  	retval.st = templateLib.getInstanceOf("time");
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2820:5: uccr= unique_component_classifier_reference
					{
					pushFollow(FOLLOW_unique_component_classifier_reference_in_assertion_type10629);
					uccr=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2821:5: -> {$uccr.st}
					  {
					  	retval.st = (uccr!=null?((StringTemplate)uccr.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_type"


	public static class timed_predicate_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "timed_predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2824:1: timed_predicate : (n= name -> {$n.st}|p= parenthesized_predicate -> {$p.st}|pi= predicate_invocation -> {$pi.st}| ^(tk= TICK tp= parenthesized_predicate ) -> tick(tp=$tp.st)| ^(tk= TICK tn= name ) -> tick(tp=$tn.st)| ^( AT_SIGN (atn= name |atp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi= predicate_invocation ) te= time_subexpression ) -> {atn!=null}? at(p=$atn.stt=$te.st) -> {stp!=null}? at(p=$stp.textt=$te.st) -> {tru!=null}? at(p=$tru.textt=$te.st) -> {pi!=null}? at(p=$pi.stt=$te.st) -> at(p=$atp.stt=$te.st)| ^( CARET (cn= name |cp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi2= predicate_invocation ) cv= period_shift ) -> {cn!=null}? caret(p=$cn.stcv=$cv.st) -> {pi2!=null}? caret(p=$pi2.stcv=$cv.st) -> {stp!=null}? caret(p=$stp.textcv=$cv.st) -> {tru!=null}? caret(p=$tru.textcv=$cv.st) -> caret(p=$cp.stcv=$cv.st));
	public final UnparseBLESS.timed_predicate_return timed_predicate() throws RecognitionException {
		UnparseBLESS.timed_predicate_return retval = new UnparseBLESS.timed_predicate_return();
		retval.start = input.LT(1);

		BAST tk=null;
		BAST stp=null;
		BAST tru=null;
		TreeRuleReturnScope n =null;
		TreeRuleReturnScope p =null;
		TreeRuleReturnScope pi =null;
		TreeRuleReturnScope tp =null;
		TreeRuleReturnScope tn =null;
		TreeRuleReturnScope atn =null;
		TreeRuleReturnScope atp =null;
		TreeRuleReturnScope te =null;
		TreeRuleReturnScope cn =null;
		TreeRuleReturnScope cp =null;
		TreeRuleReturnScope pi2 =null;
		TreeRuleReturnScope cv =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2826:2: (n= name -> {$n.st}|p= parenthesized_predicate -> {$p.st}|pi= predicate_invocation -> {$pi.st}| ^(tk= TICK tp= parenthesized_predicate ) -> tick(tp=$tp.st)| ^(tk= TICK tn= name ) -> tick(tp=$tn.st)| ^( AT_SIGN (atn= name |atp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi= predicate_invocation ) te= time_subexpression ) -> {atn!=null}? at(p=$atn.stt=$te.st) -> {stp!=null}? at(p=$stp.textt=$te.st) -> {tru!=null}? at(p=$tru.textt=$te.st) -> {pi!=null}? at(p=$pi.stt=$te.st) -> at(p=$atp.stt=$te.st)| ^( CARET (cn= name |cp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi2= predicate_invocation ) cv= period_shift ) -> {cn!=null}? caret(p=$cn.stcv=$cv.st) -> {pi2!=null}? caret(p=$pi2.stcv=$cv.st) -> {stp!=null}? caret(p=$stp.textcv=$cv.st) -> {tru!=null}? caret(p=$tru.textcv=$cv.st) -> caret(p=$cp.stcv=$cv.st))
			int alt148=7;
			switch ( input.LA(1) ) {
			case ID:
			case PERIOD:
				{
				alt148=1;
				}
				break;
			case LPAREN:
				{
				alt148=2;
				}
				break;
			case INVOKE:
			case WP:
				{
				alt148=3;
				}
				break;
			case TICK:
				{
				int LA148_4 = input.LA(2);
				if ( (LA148_4==DOWN) ) {
					int LA148_7 = input.LA(3);
					if ( (LA148_7==LPAREN) ) {
						alt148=4;
					}
					else if ( (LA148_7==ID||LA148_7==PERIOD) ) {
						alt148=5;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 148, 7, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 148, 4, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AT_SIGN:
				{
				alt148=6;
				}
				break;
			case CARET:
				{
				alt148=7;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 148, 0, input);
				throw nvae;
			}
			switch (alt148) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2827:2: n= name
					{
					pushFollow(FOLLOW_name_in_timed_predicate10653);
					n=name();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2828:4: -> {$n.st}
					  {
					  	retval.st = (n!=null?((StringTemplate)n.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2831:2: p= parenthesized_predicate
					{
					pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate10671);
					p=parenthesized_predicate();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2832:3: -> {$p.st}
					  {
					  	retval.st = (p!=null?((StringTemplate)p.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2834:2: pi= predicate_invocation
					{
					pushFollow(FOLLOW_predicate_invocation_in_timed_predicate10686);
					pi=predicate_invocation();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2835:4: -> {$pi.st}
					  {
					  	retval.st = (pi!=null?((StringTemplate)pi.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2837:2: ^(tk= TICK tp= parenthesized_predicate )
					{
					tk=(BAST)match(input,TICK,FOLLOW_TICK_in_timed_predicate10702); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate10706);
					tp=parenthesized_predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2838:4: -> tick(tp=$tp.st)
					  {
					  	retval.st = templateLib.getInstanceOf("tick",new STAttrMap().put("tp", (tp!=null?((StringTemplate)tp.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2841:2: ^(tk= TICK tn= name )
					{
					tk=(BAST)match(input,TICK,FOLLOW_TICK_in_timed_predicate10730); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_name_in_timed_predicate10734);
					tn=name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2842:4: -> tick(tp=$tn.st)
					  {
					  	retval.st = templateLib.getInstanceOf("tick",new STAttrMap().put("tp", (tn!=null?((StringTemplate)tn.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2845:2: ^( AT_SIGN (atn= name |atp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi= predicate_invocation ) te= time_subexpression )
					{
					match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_predicate10756); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2846:4: (atn= name |atp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi= predicate_invocation )
					int alt146=5;
					switch ( input.LA(1) ) {
					case ID:
					case PERIOD:
						{
						alt146=1;
						}
						break;
					case LPAREN:
						{
						alt146=2;
						}
						break;
					case LITERAL_stop:
						{
						alt146=3;
						}
						break;
					case LITERAL_true:
						{
						alt146=4;
						}
						break;
					case INVOKE:
					case WP:
						{
						alt146=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 146, 0, input);
						throw nvae;
					}
					switch (alt146) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2846:5: atn= name
							{
							pushFollow(FOLLOW_name_in_timed_predicate10766);
							atn=name();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2848:4: atp= parenthesized_predicate
							{
							pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate10780);
							atp=parenthesized_predicate();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2850:4: stp= LITERAL_stop
							{
							stp=(BAST)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_timed_predicate10794); if (state.failed) return retval;
							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2852:11: tru= LITERAL_true
							{
							tru=(BAST)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_timed_predicate10821); if (state.failed) return retval;
							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2854:4: pi= predicate_invocation
							{
							pushFollow(FOLLOW_predicate_invocation_in_timed_predicate10834);
							pi=predicate_invocation();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					pushFollow(FOLLOW_time_subexpression_in_timed_predicate10848);
					te=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2857:2: -> {atn!=null}? at(p=$atn.stt=$te.st)
					  if (atn!=null) {
					  	retval.st = templateLib.getInstanceOf("at",new STAttrMap().put("p", (atn!=null?((StringTemplate)atn.getTemplate()):null)).put("t", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }

					  else // 2858:9: -> {stp!=null}? at(p=$stp.textt=$te.st)
					  if (stp!=null) {
					  	retval.st = templateLib.getInstanceOf("at",new STAttrMap().put("p", (stp!=null?stp.getText():null)).put("t", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }

					  else // 2859:9: -> {tru!=null}? at(p=$tru.textt=$te.st)
					  if (tru!=null) {
					  	retval.st = templateLib.getInstanceOf("at",new STAttrMap().put("p", (tru!=null?tru.getText():null)).put("t", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }

					  else // 2860:2: -> {pi!=null}? at(p=$pi.stt=$te.st)
					  if (pi!=null) {
					  	retval.st = templateLib.getInstanceOf("at",new STAttrMap().put("p", (pi!=null?((StringTemplate)pi.getTemplate()):null)).put("t", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }

					  else // 2861:2: -> at(p=$atp.stt=$te.st)
					  {
					  	retval.st = templateLib.getInstanceOf("at",new STAttrMap().put("p", (atp!=null?((StringTemplate)atp.getTemplate()):null)).put("t", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2867:2: ^( CARET (cn= name |cp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi2= predicate_invocation ) cv= period_shift )
					{
					match(input,CARET,FOLLOW_CARET_in_timed_predicate10964); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2868:4: (cn= name |cp= parenthesized_predicate |stp= LITERAL_stop |tru= LITERAL_true |pi2= predicate_invocation )
					int alt147=5;
					switch ( input.LA(1) ) {
					case ID:
					case PERIOD:
						{
						alt147=1;
						}
						break;
					case LPAREN:
						{
						alt147=2;
						}
						break;
					case LITERAL_stop:
						{
						alt147=3;
						}
						break;
					case LITERAL_true:
						{
						alt147=4;
						}
						break;
					case INVOKE:
					case WP:
						{
						alt147=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 147, 0, input);
						throw nvae;
					}
					switch (alt147) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2868:5: cn= name
							{
							pushFollow(FOLLOW_name_in_timed_predicate10974);
							cn=name();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2869:6: cp= parenthesized_predicate
							{
							pushFollow(FOLLOW_parenthesized_predicate_in_timed_predicate10984);
							cp=parenthesized_predicate();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2870:6: stp= LITERAL_stop
							{
							stp=(BAST)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_timed_predicate10994); if (state.failed) return retval;
							}
							break;
						case 4 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2871:12: tru= LITERAL_true
							{
							tru=(BAST)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_timed_predicate11009); if (state.failed) return retval;
							}
							break;
						case 5 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2872:6: pi2= predicate_invocation
							{
							pushFollow(FOLLOW_predicate_invocation_in_timed_predicate11018);
							pi2=predicate_invocation();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					pushFollow(FOLLOW_period_shift_in_timed_predicate11033);
					cv=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2875:2: -> {cn!=null}? caret(p=$cn.stcv=$cv.st)
					  if (cn!=null) {
					  	retval.st = templateLib.getInstanceOf("caret",new STAttrMap().put("p", (cn!=null?((StringTemplate)cn.getTemplate()):null)).put("cv", (cv!=null?((StringTemplate)cv.getTemplate()):null)));
					  }

					  else // 2876:2: -> {pi2!=null}? caret(p=$pi2.stcv=$cv.st)
					  if (pi2!=null) {
					  	retval.st = templateLib.getInstanceOf("caret",new STAttrMap().put("p", (pi2!=null?((StringTemplate)pi2.getTemplate()):null)).put("cv", (cv!=null?((StringTemplate)cv.getTemplate()):null)));
					  }

					  else // 2877:9: -> {stp!=null}? caret(p=$stp.textcv=$cv.st)
					  if (stp!=null) {
					  	retval.st = templateLib.getInstanceOf("caret",new STAttrMap().put("p", (stp!=null?stp.getText():null)).put("cv", (cv!=null?((StringTemplate)cv.getTemplate()):null)));
					  }

					  else // 2878:9: -> {tru!=null}? caret(p=$tru.textcv=$cv.st)
					  if (tru!=null) {
					  	retval.st = templateLib.getInstanceOf("caret",new STAttrMap().put("p", (tru!=null?tru.getText():null)).put("cv", (cv!=null?((StringTemplate)cv.getTemplate()):null)));
					  }

					  else // 2879:2: -> caret(p=$cp.stcv=$cv.st)
					  {
					  	retval.st = templateLib.getInstanceOf("caret",new STAttrMap().put("p", (cp!=null?((StringTemplate)cp.getTemplate()):null)).put("cv", (cv!=null?((StringTemplate)cv.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_predicate"


	public static class parenthesized_predicate_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "parenthesized_predicate"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2886:1: parenthesized_predicate : ^(lb= LPAREN p= predicate rb= RPAREN ) -> parenthesized_predicate(p=$p.st);
	public final UnparseBLESS.parenthesized_predicate_return parenthesized_predicate() throws RecognitionException {
		UnparseBLESS.parenthesized_predicate_return retval = new UnparseBLESS.parenthesized_predicate_return();
		retval.start = input.LT(1);

		BAST lb=null;
		BAST rb=null;
		TreeRuleReturnScope p =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2887:2: ( ^(lb= LPAREN p= predicate rb= RPAREN ) -> parenthesized_predicate(p=$p.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2888:2: ^(lb= LPAREN p= predicate rb= RPAREN )
			{
			lb=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_predicate11159); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_parenthesized_predicate11163);
			p=predicate();
			state._fsp--;
			if (state.failed) return retval;
			rb=(BAST)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_predicate11167); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2889:4: -> parenthesized_predicate(p=$p.st)
			  {
			  	retval.st = templateLib.getInstanceOf("parenthesized_predicate",new STAttrMap().put("p", (p!=null?((StringTemplate)p.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_predicate"


	public static class predicate_invocation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "predicate_invocation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2893:1: predicate_invocation : ( ^( INVOKE ^(p= ID (exp+= actual_assertion_parameter )+ ) ) -> predicate_invocation(p=$p.textip=$exp)| ^( INVOKE p= ID ) -> predicate_invocation(p=$p.text)| ^( INVOKE ^(p= ID actual= assertion_expression ) ) -> predicate_invocation(p=$p.texta=$actual.st)| ^( WP ba= behavior_actions pr= predicate ) -> template(ba=$ba.stpr=$pr.st) \"WP(<ba>,<pr>)\");
	public final UnparseBLESS.predicate_invocation_return predicate_invocation() throws RecognitionException {
		UnparseBLESS.predicate_invocation_return retval = new UnparseBLESS.predicate_invocation_return();
		retval.start = input.LT(1);

		BAST p=null;
		List<Object> list_exp=null;
		TreeRuleReturnScope actual =null;
		TreeRuleReturnScope ba =null;
		TreeRuleReturnScope pr =null;
		RuleReturnScope exp = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2894:2: ( ^( INVOKE ^(p= ID (exp+= actual_assertion_parameter )+ ) ) -> predicate_invocation(p=$p.textip=$exp)| ^( INVOKE p= ID ) -> predicate_invocation(p=$p.text)| ^( INVOKE ^(p= ID actual= assertion_expression ) ) -> predicate_invocation(p=$p.texta=$actual.st)| ^( WP ba= behavior_actions pr= predicate ) -> template(ba=$ba.stpr=$pr.st) \"WP(<ba>,<pr>)\")
			int alt150=4;
			int LA150_0 = input.LA(1);
			if ( (LA150_0==INVOKE) ) {
				int LA150_1 = input.LA(2);
				if ( (LA150_1==DOWN) ) {
					int LA150_3 = input.LA(3);
					if ( (LA150_3==ID) ) {
						int LA150_4 = input.LA(4);
						if ( (LA150_4==DOWN) ) {
							int LA150_5 = input.LA(5);
							if ( (LA150_5==PARAMETER) ) {
								alt150=1;
							}
							else if ( (LA150_5==AADL_STRING_LITERAL||LA150_5==AT_SIGN||(LA150_5 >= CARET && LA150_5 <= CASE_EXPRESSION)||LA150_5==COMPLEX||LA150_5==CONDITIONAL||LA150_5==DIVIDE||LA150_5==DOUBLE_COLON||LA150_5==EXP||LA150_5==ID||LA150_5==INMODE||LA150_5==INTEGER_LIT||LA150_5==INVOKE_FUNCTION||LA150_5==LITERAL_abs||LA150_5==LITERAL_complex||LA150_5==LITERAL_def||LA150_5==LITERAL_false||LA150_5==LITERAL_integer||LA150_5==LITERAL_mod||LA150_5==LITERAL_natural||LA150_5==LITERAL_now||(LA150_5 >= LITERAL_null && LA150_5 <= LITERAL_numberof)||LA150_5==LITERAL_product||(LA150_5 >= LITERAL_rational && LA150_5 <= LITERAL_real)||LA150_5==LITERAL_rem||LA150_5==LITERAL_sum||(LA150_5 >= LITERAL_time && LA150_5 <= LITERAL_timeout)||LA150_5==LITERAL_tops||LA150_5==LITERAL_true||LA150_5==LPAREN||LA150_5==MINUS||LA150_5==OCTOTHORPE||(LA150_5 >= PERIOD && LA150_5 <= PLUS)||LA150_5==QUESTION||LA150_5==RATIONAL||LA150_5==REAL_LIT||LA150_5==TICK||LA150_5==TIMES||LA150_5==UNARY_MINUS) ) {
								alt150=3;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 150, 5, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}
						else if ( (LA150_4==UP) ) {
							alt150=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 150, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 150, 3, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 150, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA150_0==WP) ) {
				alt150=4;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 150, 0, input);
				throw nvae;
			}

			switch (alt150) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2895:2: ^( INVOKE ^(p= ID (exp+= actual_assertion_parameter )+ ) )
					{
					match(input,INVOKE,FOLLOW_INVOKE_in_predicate_invocation11198); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					p=(BAST)match(input,ID,FOLLOW_ID_in_predicate_invocation11204); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2895:23: (exp+= actual_assertion_parameter )+
					int cnt149=0;
					loop149:
					while (true) {
						int alt149=2;
						int LA149_0 = input.LA(1);
						if ( (LA149_0==PARAMETER) ) {
							alt149=1;
						}

						switch (alt149) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2895:23: exp+= actual_assertion_parameter
							{
							pushFollow(FOLLOW_actual_assertion_parameter_in_predicate_invocation11208);
							exp=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if (list_exp==null) list_exp=new ArrayList<Object>();
							list_exp.add(exp.getTemplate());
							}
							break;

						default :
							if ( cnt149 >= 1 ) break loop149;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(149, input);
							throw eee;
						}
						cnt149++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2896:3: -> predicate_invocation(p=$p.textip=$exp)
					  {
					  	retval.st = templateLib.getInstanceOf("predicate_invocation",new STAttrMap().put("p", (p!=null?p.getText():null)).put("ip", list_exp));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2900:2: ^( INVOKE p= ID )
					{
					match(input,INVOKE,FOLLOW_INVOKE_in_predicate_invocation11239); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					p=(BAST)match(input,ID,FOLLOW_ID_in_predicate_invocation11243); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2901:3: -> predicate_invocation(p=$p.text)
					  {
					  	retval.st = templateLib.getInstanceOf("predicate_invocation",new STAttrMap().put("p", (p!=null?p.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2904:2: ^( INVOKE ^(p= ID actual= assertion_expression ) )
					{
					match(input,INVOKE,FOLLOW_INVOKE_in_predicate_invocation11266); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					p=(BAST)match(input,ID,FOLLOW_ID_in_predicate_invocation11272); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_predicate_invocation11276);
					actual=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2905:3: -> predicate_invocation(p=$p.texta=$actual.st)
					  {
					  	retval.st = templateLib.getInstanceOf("predicate_invocation",new STAttrMap().put("p", (p!=null?p.getText():null)).put("a", (actual!=null?((StringTemplate)actual.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2908:2: ^( WP ba= behavior_actions pr= predicate )
					{
					match(input,WP,FOLLOW_WP_in_predicate_invocation11307); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_actions_in_predicate_invocation11311);
					ba=behavior_actions();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_in_predicate_invocation11315);
					pr=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2909:3: -> template(ba=$ba.stpr=$pr.st) \"WP(<ba>,<pr>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "WP(<ba>,<pr>)",new STAttrMap().put("ba", (ba!=null?((StringTemplate)ba.getTemplate()):null)).put("pr", (pr!=null?((StringTemplate)pr.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate_invocation"


	public static class actual_assertion_parameter_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "actual_assertion_parameter"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2916:1: actual_assertion_parameter : ( ^( PARAMETER formal= ID actual= assertion_expression ) -> template(formal=$formal.textactual=$actual.st) \"<formal>:<actual>\"| ^( PARAMETER COLON_TILDE formal= ID pred= predicate ) -> template(formal=$formal.textpred=$pred.st) \"<formal>:~<pred>\");
	public final UnparseBLESS.actual_assertion_parameter_return actual_assertion_parameter() throws RecognitionException {
		UnparseBLESS.actual_assertion_parameter_return retval = new UnparseBLESS.actual_assertion_parameter_return();
		retval.start = input.LT(1);

		BAST formal=null;
		TreeRuleReturnScope actual =null;
		TreeRuleReturnScope pred =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2917:3: ( ^( PARAMETER formal= ID actual= assertion_expression ) -> template(formal=$formal.textactual=$actual.st) \"<formal>:<actual>\"| ^( PARAMETER COLON_TILDE formal= ID pred= predicate ) -> template(formal=$formal.textpred=$pred.st) \"<formal>:~<pred>\")
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==PARAMETER) ) {
				int LA151_1 = input.LA(2);
				if ( (LA151_1==DOWN) ) {
					int LA151_2 = input.LA(3);
					if ( (LA151_2==ID) ) {
						alt151=1;
					}
					else if ( (LA151_2==COLON_TILDE) ) {
						alt151=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 151, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 151, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 151, 0, input);
				throw nvae;
			}

			switch (alt151) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2918:3: ^( PARAMETER formal= ID actual= assertion_expression )
					{
					match(input,PARAMETER,FOLLOW_PARAMETER_in_actual_assertion_parameter11356); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					formal=(BAST)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter11360); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_actual_assertion_parameter11364);
					actual=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2919:3: -> template(formal=$formal.textactual=$actual.st) \"<formal>:<actual>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<formal>:<actual>",new STAttrMap().put("formal", (formal!=null?formal.getText():null)).put("actual", (actual!=null?((StringTemplate)actual.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2921:3: ^( PARAMETER COLON_TILDE formal= ID pred= predicate )
					{
					match(input,PARAMETER,FOLLOW_PARAMETER_in_actual_assertion_parameter11391); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,COLON_TILDE,FOLLOW_COLON_TILDE_in_actual_assertion_parameter11393); if (state.failed) return retval;
					formal=(BAST)match(input,ID,FOLLOW_ID_in_actual_assertion_parameter11397); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_in_actual_assertion_parameter11401);
					pred=predicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2922:4: -> template(formal=$formal.textpred=$pred.st) \"<formal>:~<pred>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<formal>:~<pred>",new STAttrMap().put("formal", (formal!=null?formal.getText():null)).put("pred", (pred!=null?((StringTemplate)pred.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "actual_assertion_parameter"


	public static class predicate_relation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "predicate_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2927:1: predicate_relation : ( ^(r= relation_symbol lhs= assertion_expression rhs= assertion_expression ) -> template(r=$r.stlhs=$lhs.strhs=$ra.st) \"<lhs> <r> <rhs>\"| ^(in= LITERAL_in lhs= assertion_expression ra= range ) -> template(lhs=$lhs.strhs=$ra.st) \"<lhs> in <rhs>\");
	public final UnparseBLESS.predicate_relation_return predicate_relation() throws RecognitionException {
		UnparseBLESS.predicate_relation_return retval = new UnparseBLESS.predicate_relation_return();
		retval.start = input.LT(1);

		BAST in=null;
		TreeRuleReturnScope r =null;
		TreeRuleReturnScope lhs =null;
		TreeRuleReturnScope rhs =null;
		TreeRuleReturnScope ra =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2928:2: ( ^(r= relation_symbol lhs= assertion_expression rhs= assertion_expression ) -> template(r=$r.stlhs=$lhs.strhs=$ra.st) \"<lhs> <r> <rhs>\"| ^(in= LITERAL_in lhs= assertion_expression ra= range ) -> template(lhs=$lhs.strhs=$ra.st) \"<lhs> in <rhs>\")
			int alt152=2;
			int LA152_0 = input.LA(1);
			if ( ((LA152_0 >= AL && LA152_0 <= AM)||LA152_0==EQ||LA152_0==GT||LA152_0==LT||LA152_0==NEQ) ) {
				alt152=1;
			}
			else if ( (LA152_0==LITERAL_in) ) {
				alt152=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 152, 0, input);
				throw nvae;
			}

			switch (alt152) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2929:2: ^(r= relation_symbol lhs= assertion_expression rhs= assertion_expression )
					{
					pushFollow(FOLLOW_relation_symbol_in_predicate_relation11440);
					r=relation_symbol();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_predicate_relation11444);
					lhs=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_predicate_relation11448);
					rhs=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2932:3: -> template(r=$r.stlhs=$lhs.strhs=$ra.st) \"<lhs> <r> <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> <r> <rhs>",new STAttrMap().put("r", (r!=null?((StringTemplate)r.getTemplate()):null)).put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (ra!=null?((StringTemplate)ra.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2934:9: ^(in= LITERAL_in lhs= assertion_expression ra= range )
					{
					in=(BAST)match(input,LITERAL_in,FOLLOW_LITERAL_in_in_predicate_relation11490); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_predicate_relation11494);
					lhs=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_range_in_predicate_relation11498);
					ra=range();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2935:3: -> template(lhs=$lhs.strhs=$ra.st) \"<lhs> in <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> in <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (ra!=null?((StringTemplate)ra.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "predicate_relation"


	public static class range_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "range"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2938:1: range : ^(rs= range_symbol lb= expression ub= expression ) -> range(lb=$lb.stub=$ub.strs=$rs.st);
	public final UnparseBLESS.range_return range() throws RecognitionException {
		UnparseBLESS.range_return retval = new UnparseBLESS.range_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope rs =null;
		TreeRuleReturnScope lb =null;
		TreeRuleReturnScope ub =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2939:2: ( ^(rs= range_symbol lb= expression ub= expression ) -> range(lb=$lb.stub=$ub.strs=$rs.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2940:2: ^(rs= range_symbol lb= expression ub= expression )
			{
			pushFollow(FOLLOW_range_symbol_in_range11532);
			rs=range_symbol();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_range11536);
			lb=expression();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_expression_in_range11540);
			ub=expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 2941:4: -> range(lb=$lb.stub=$ub.strs=$rs.st)
			  {
			  	retval.st = templateLib.getInstanceOf("range",new STAttrMap().put("lb", (lb!=null?((StringTemplate)lb.getTemplate()):null)).put("ub", (ub!=null?((StringTemplate)ub.getTemplate()):null)).put("rs", (rs!=null?((StringTemplate)rs.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range"


	public static class assertion_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2950:1: assertion_expression : ( ^(s= LITERAL_sum lv= logic_variables (lvd= logic_variable_domain )? LITERAL_of pe= assertion_expression ) -> sum(s=$s.textlv=$lv.std=$lvd.stpe=$pe.st)| ^(p= LITERAL_product lv2= logic_variables (d2= logic_variable_domain )? LITERAL_of pe2= assertion_expression ) -> product(p=$p.textlv=$lv2.std=$d2.stpe=$pe2.st)| ^(no= LITERAL_numberof lv3= logic_variables (d3= logic_variable_domain )? LITERAL_that pa= subpredicate ) -> numberof(lv=$lv3.std=$d3.stpe=$pa.st)| ^(op= PLUS (pse+= assertion_subexpression )+ ) -> add(terms=$pse)| ^(op= TIMES (pset+= assertion_subexpression )+ ) -> multiply(terms=$pset)| ^(op= MINUS l= assertion_subexpression r= assertion_subexpression ) -> two_element_expression(op=$op.textl=$l.str=$r.st)| ^(op= DIVIDE n= assertion_subexpression d= assertion_subexpression ) -> two_element_expression(op=$op.textl=$n.str=$d.st)| ^(op= EXP b= assertion_subexpression exp= assertion_subexpression ) -> two_element_expression(op=$op.textl=$b.str=$exp.st)| ^(op= LITERAL_mod l= assertion_subexpression r= assertion_subexpression ) -> two_element_expression_spaced(op=$op.textl=$l.str=$r.st)| ^(op= LITERAL_rem l= assertion_subexpression r= assertion_subexpression ) -> two_element_expression_spaced(op=$op.textl=$l.str=$r.st)|pse3= assertion_subexpression -> {$pse3.st});
	public final UnparseBLESS.assertion_expression_return assertion_expression() throws RecognitionException {
		UnparseBLESS.assertion_expression_return retval = new UnparseBLESS.assertion_expression_return();
		retval.start = input.LT(1);

		BAST s=null;
		BAST p=null;
		BAST no=null;
		BAST op=null;
		List<Object> list_pse=null;
		List<Object> list_pset=null;
		TreeRuleReturnScope lv =null;
		TreeRuleReturnScope lvd =null;
		TreeRuleReturnScope pe =null;
		TreeRuleReturnScope lv2 =null;
		TreeRuleReturnScope d2 =null;
		TreeRuleReturnScope pe2 =null;
		TreeRuleReturnScope lv3 =null;
		TreeRuleReturnScope d3 =null;
		TreeRuleReturnScope pa =null;
		TreeRuleReturnScope l =null;
		TreeRuleReturnScope r =null;
		TreeRuleReturnScope n =null;
		TreeRuleReturnScope d =null;
		TreeRuleReturnScope b =null;
		TreeRuleReturnScope exp =null;
		TreeRuleReturnScope pse3 =null;
		RuleReturnScope pse = null;
		RuleReturnScope pset = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2951:2: ( ^(s= LITERAL_sum lv= logic_variables (lvd= logic_variable_domain )? LITERAL_of pe= assertion_expression ) -> sum(s=$s.textlv=$lv.std=$lvd.stpe=$pe.st)| ^(p= LITERAL_product lv2= logic_variables (d2= logic_variable_domain )? LITERAL_of pe2= assertion_expression ) -> product(p=$p.textlv=$lv2.std=$d2.stpe=$pe2.st)| ^(no= LITERAL_numberof lv3= logic_variables (d3= logic_variable_domain )? LITERAL_that pa= subpredicate ) -> numberof(lv=$lv3.std=$d3.stpe=$pa.st)| ^(op= PLUS (pse+= assertion_subexpression )+ ) -> add(terms=$pse)| ^(op= TIMES (pset+= assertion_subexpression )+ ) -> multiply(terms=$pset)| ^(op= MINUS l= assertion_subexpression r= assertion_subexpression ) -> two_element_expression(op=$op.textl=$l.str=$r.st)| ^(op= DIVIDE n= assertion_subexpression d= assertion_subexpression ) -> two_element_expression(op=$op.textl=$n.str=$d.st)| ^(op= EXP b= assertion_subexpression exp= assertion_subexpression ) -> two_element_expression(op=$op.textl=$b.str=$exp.st)| ^(op= LITERAL_mod l= assertion_subexpression r= assertion_subexpression ) -> two_element_expression_spaced(op=$op.textl=$l.str=$r.st)| ^(op= LITERAL_rem l= assertion_subexpression r= assertion_subexpression ) -> two_element_expression_spaced(op=$op.textl=$l.str=$r.st)|pse3= assertion_subexpression -> {$pse3.st})
			int alt158=11;
			switch ( input.LA(1) ) {
			case LITERAL_sum:
				{
				alt158=1;
				}
				break;
			case LITERAL_product:
				{
				alt158=2;
				}
				break;
			case LITERAL_numberof:
				{
				alt158=3;
				}
				break;
			case PLUS:
				{
				alt158=4;
				}
				break;
			case TIMES:
				{
				alt158=5;
				}
				break;
			case MINUS:
				{
				alt158=6;
				}
				break;
			case DIVIDE:
				{
				alt158=7;
				}
				break;
			case EXP:
				{
				alt158=8;
				}
				break;
			case LITERAL_mod:
				{
				alt158=9;
				}
				break;
			case LITERAL_rem:
				{
				alt158=10;
				}
				break;
			case AADL_STRING_LITERAL:
			case AT_SIGN:
			case CARET:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case INVOKE_FUNCTION:
			case LITERAL_abs:
			case LITERAL_complex:
			case LITERAL_def:
			case LITERAL_false:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
			case UNARY_MINUS:
				{
				alt158=11;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 158, 0, input);
				throw nvae;
			}
			switch (alt158) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2952:2: ^(s= LITERAL_sum lv= logic_variables (lvd= logic_variable_domain )? LITERAL_of pe= assertion_expression )
					{
					s=(BAST)match(input,LITERAL_sum,FOLLOW_LITERAL_sum_in_assertion_expression11589); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_logic_variables_in_assertion_expression11593);
					lv=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2952:41: (lvd= logic_variable_domain )?
					int alt153=2;
					int LA153_0 = input.LA(1);
					if ( (LA153_0==LITERAL_in) ) {
						alt153=1;
					}
					switch (alt153) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2952:41: lvd= logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression11597);
							lvd=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression11601); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_assertion_expression11605);
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2953:3: -> sum(s=$s.textlv=$lv.std=$lvd.stpe=$pe.st)
					  {
					  	retval.st = templateLib.getInstanceOf("sum",new STAttrMap().put("s", (s!=null?s.getText():null)).put("lv", (lv!=null?((StringTemplate)lv.getTemplate()):null)).put("d", (lvd!=null?((StringTemplate)lvd.getTemplate()):null)).put("pe", (pe!=null?((StringTemplate)pe.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2956:2: ^(p= LITERAL_product lv2= logic_variables (d2= logic_variable_domain )? LITERAL_of pe2= assertion_expression )
					{
					p=(BAST)match(input,LITERAL_product,FOLLOW_LITERAL_product_in_assertion_expression11641); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_logic_variables_in_assertion_expression11645);
					lv2=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2956:45: (d2= logic_variable_domain )?
					int alt154=2;
					int LA154_0 = input.LA(1);
					if ( (LA154_0==LITERAL_in) ) {
						alt154=1;
					}
					switch (alt154) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2956:45: d2= logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression11649);
							d2=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					match(input,LITERAL_of,FOLLOW_LITERAL_of_in_assertion_expression11653); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_assertion_expression11657);
					pe2=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2957:3: -> product(p=$p.textlv=$lv2.std=$d2.stpe=$pe2.st)
					  {
					  	retval.st = templateLib.getInstanceOf("product",new STAttrMap().put("p", (p!=null?p.getText():null)).put("lv", (lv2!=null?((StringTemplate)lv2.getTemplate()):null)).put("d", (d2!=null?((StringTemplate)d2.getTemplate()):null)).put("pe", (pe2!=null?((StringTemplate)pe2.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2960:2: ^(no= LITERAL_numberof lv3= logic_variables (d3= logic_variable_domain )? LITERAL_that pa= subpredicate )
					{
					no=(BAST)match(input,LITERAL_numberof,FOLLOW_LITERAL_numberof_in_assertion_expression11694); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_logic_variables_in_assertion_expression11698);
					lv3=logic_variables();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2960:47: (d3= logic_variable_domain )?
					int alt155=2;
					int LA155_0 = input.LA(1);
					if ( (LA155_0==LITERAL_in) ) {
						alt155=1;
					}
					switch (alt155) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2960:47: d3= logic_variable_domain
							{
							pushFollow(FOLLOW_logic_variable_domain_in_assertion_expression11702);
							d3=logic_variable_domain();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					match(input,LITERAL_that,FOLLOW_LITERAL_that_in_assertion_expression11705); if (state.failed) return retval;
					pushFollow(FOLLOW_subpredicate_in_assertion_expression11709);
					pa=subpredicate();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2961:4: -> numberof(lv=$lv3.std=$d3.stpe=$pa.st)
					  {
					  	retval.st = templateLib.getInstanceOf("numberof",new STAttrMap().put("lv", (lv3!=null?((StringTemplate)lv3.getTemplate()):null)).put("d", (d3!=null?((StringTemplate)d3.getTemplate()):null)).put("pe", (pa!=null?((StringTemplate)pa.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2964:2: ^(op= PLUS (pse+= assertion_subexpression )+ )
					{
					op=(BAST)match(input,PLUS,FOLLOW_PLUS_in_assertion_expression11744); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2964:16: (pse+= assertion_subexpression )+
					int cnt156=0;
					loop156:
					while (true) {
						int alt156=2;
						int LA156_0 = input.LA(1);
						if ( (LA156_0==AADL_STRING_LITERAL||LA156_0==AT_SIGN||(LA156_0 >= CARET && LA156_0 <= CASE_EXPRESSION)||LA156_0==COMPLEX||LA156_0==CONDITIONAL||LA156_0==DOUBLE_COLON||LA156_0==ID||LA156_0==INMODE||LA156_0==INTEGER_LIT||LA156_0==INVOKE_FUNCTION||LA156_0==LITERAL_abs||LA156_0==LITERAL_complex||LA156_0==LITERAL_def||LA156_0==LITERAL_false||LA156_0==LITERAL_integer||LA156_0==LITERAL_natural||LA156_0==LITERAL_now||LA156_0==LITERAL_null||(LA156_0 >= LITERAL_rational && LA156_0 <= LITERAL_real)||(LA156_0 >= LITERAL_time && LA156_0 <= LITERAL_timeout)||LA156_0==LITERAL_tops||LA156_0==LITERAL_true||LA156_0==LPAREN||LA156_0==OCTOTHORPE||LA156_0==PERIOD||LA156_0==QUESTION||LA156_0==RATIONAL||LA156_0==REAL_LIT||LA156_0==TICK||LA156_0==UNARY_MINUS) ) {
							alt156=1;
						}

						switch (alt156) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2964:16: pse+= assertion_subexpression
							{
							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11748);
							pse=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_pse==null) list_pse=new ArrayList<Object>();
							list_pse.add(pse.getTemplate());
							}
							break;

						default :
							if ( cnt156 >= 1 ) break loop156;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(156, input);
							throw eee;
						}
						cnt156++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2965:3: -> add(terms=$pse)
					  {
					  	retval.st = templateLib.getInstanceOf("add",new STAttrMap().put("terms", list_pse));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2968:2: ^(op= TIMES (pset+= assertion_subexpression )+ )
					{
					op=(BAST)match(input,TIMES,FOLLOW_TIMES_in_assertion_expression11776); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2968:18: (pset+= assertion_subexpression )+
					int cnt157=0;
					loop157:
					while (true) {
						int alt157=2;
						int LA157_0 = input.LA(1);
						if ( (LA157_0==AADL_STRING_LITERAL||LA157_0==AT_SIGN||(LA157_0 >= CARET && LA157_0 <= CASE_EXPRESSION)||LA157_0==COMPLEX||LA157_0==CONDITIONAL||LA157_0==DOUBLE_COLON||LA157_0==ID||LA157_0==INMODE||LA157_0==INTEGER_LIT||LA157_0==INVOKE_FUNCTION||LA157_0==LITERAL_abs||LA157_0==LITERAL_complex||LA157_0==LITERAL_def||LA157_0==LITERAL_false||LA157_0==LITERAL_integer||LA157_0==LITERAL_natural||LA157_0==LITERAL_now||LA157_0==LITERAL_null||(LA157_0 >= LITERAL_rational && LA157_0 <= LITERAL_real)||(LA157_0 >= LITERAL_time && LA157_0 <= LITERAL_timeout)||LA157_0==LITERAL_tops||LA157_0==LITERAL_true||LA157_0==LPAREN||LA157_0==OCTOTHORPE||LA157_0==PERIOD||LA157_0==QUESTION||LA157_0==RATIONAL||LA157_0==REAL_LIT||LA157_0==TICK||LA157_0==UNARY_MINUS) ) {
							alt157=1;
						}

						switch (alt157) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2968:18: pset+= assertion_subexpression
							{
							pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11780);
							pset=assertion_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_pset==null) list_pset=new ArrayList<Object>();
							list_pset.add(pset.getTemplate());
							}
							break;

						default :
							if ( cnt157 >= 1 ) break loop157;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(157, input);
							throw eee;
						}
						cnt157++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2969:3: -> multiply(terms=$pset)
					  {
					  	retval.st = templateLib.getInstanceOf("multiply",new STAttrMap().put("terms", list_pset));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2972:2: ^(op= MINUS l= assertion_subexpression r= assertion_subexpression )
					{
					op=(BAST)match(input,MINUS,FOLLOW_MINUS_in_assertion_expression11810); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11814);
					l=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11818);
					r=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2973:4: -> two_element_expression(op=$op.textl=$l.str=$r.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression",new STAttrMap().put("op", (op!=null?op.getText():null)).put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("r", (r!=null?((StringTemplate)r.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2976:2: ^(op= DIVIDE n= assertion_subexpression d= assertion_subexpression )
					{
					op=(BAST)match(input,DIVIDE,FOLLOW_DIVIDE_in_assertion_expression11856); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11860);
					n=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11864);
					d=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2977:4: -> two_element_expression(op=$op.textl=$n.str=$d.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression",new STAttrMap().put("op", (op!=null?op.getText():null)).put("l", (n!=null?((StringTemplate)n.getTemplate()):null)).put("r", (d!=null?((StringTemplate)d.getTemplate()):null)));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2980:2: ^(op= EXP b= assertion_subexpression exp= assertion_subexpression )
					{
					op=(BAST)match(input,EXP,FOLLOW_EXP_in_assertion_expression11903); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11907);
					b=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11911);
					exp=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2981:4: -> two_element_expression(op=$op.textl=$b.str=$exp.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression",new STAttrMap().put("op", (op!=null?op.getText():null)).put("l", (b!=null?((StringTemplate)b.getTemplate()):null)).put("r", (exp!=null?((StringTemplate)exp.getTemplate()):null)));
					  }


					}

					}
					break;
				case 9 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2984:2: ^(op= LITERAL_mod l= assertion_subexpression r= assertion_subexpression )
					{
					op=(BAST)match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_assertion_expression11950); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11954);
					l=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11958);
					r=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2985:4: -> two_element_expression_spaced(op=$op.textl=$l.str=$r.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression_spaced",new STAttrMap().put("op", (op!=null?op.getText():null)).put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("r", (r!=null?((StringTemplate)r.getTemplate()):null)));
					  }


					}

					}
					break;
				case 10 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2988:2: ^(op= LITERAL_rem l= assertion_subexpression r= assertion_subexpression )
					{
					op=(BAST)match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_assertion_expression11993); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression11997);
					l=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression12001);
					r=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2989:4: -> two_element_expression_spaced(op=$op.textl=$l.str=$r.st)
					  {
					  	retval.st = templateLib.getInstanceOf("two_element_expression_spaced",new STAttrMap().put("op", (op!=null?op.getText():null)).put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("r", (r!=null?((StringTemplate)r.getTemplate()):null)));
					  }


					}

					}
					break;
				case 11 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2992:2: pse3= assertion_subexpression
					{
					pushFollow(FOLLOW_assertion_subexpression_in_assertion_expression12034);
					pse3=assertion_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 2993:3: -> {$pse3.st}
					  {
					  	retval.st = (pse3!=null?((StringTemplate)pse3.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.assertion_expression caught RecognitionException");
				  if (op!=null)
				  	((BAST)op).showParseTree(op.getText());
				  else if (s!=null)
				  	((BAST)s).showParseTree(s.getText());
				  else if (p!=null)
				  	((BAST)p).showParseTree(p.getText());
				  else if (no!=null)
				  	((BAST)no).showParseTree(no.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_expression"


	public static class assertion_subexpression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3009:1: assertion_subexpression : (ts= timed_expression -> {$ts.st}| ^(um= UNARY_MINUS ts2= timed_expression ) -> template(ts2=$ts2.st) \" -<ts2>\"| ^(abs= LITERAL_abs ts3= timed_expression ) -> template(ts3=$ts3.st) \" abs <ts3>\"| ^(def= LITERAL_def lv= assertion_parameter ) -> template(lv=$lv.st) \" def <lv> \"|atc= assertion_type_conversion -> {$atc.st});
	public final UnparseBLESS.assertion_subexpression_return assertion_subexpression() throws RecognitionException {
		UnparseBLESS.assertion_subexpression_return retval = new UnparseBLESS.assertion_subexpression_return();
		retval.start = input.LT(1);

		BAST um=null;
		BAST abs=null;
		BAST def=null;
		TreeRuleReturnScope ts =null;
		TreeRuleReturnScope ts2 =null;
		TreeRuleReturnScope ts3 =null;
		TreeRuleReturnScope lv =null;
		TreeRuleReturnScope atc =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3010:2: (ts= timed_expression -> {$ts.st}| ^(um= UNARY_MINUS ts2= timed_expression ) -> template(ts2=$ts2.st) \" -<ts2>\"| ^(abs= LITERAL_abs ts3= timed_expression ) -> template(ts3=$ts3.st) \" abs <ts3>\"| ^(def= LITERAL_def lv= assertion_parameter ) -> template(lv=$lv.st) \" def <lv> \"|atc= assertion_type_conversion -> {$atc.st})
			int alt159=5;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case AT_SIGN:
			case CARET:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case INVOKE_FUNCTION:
			case LITERAL_false:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
				{
				alt159=1;
				}
				break;
			case UNARY_MINUS:
				{
				alt159=2;
				}
				break;
			case LITERAL_abs:
				{
				alt159=3;
				}
				break;
			case LITERAL_def:
				{
				alt159=4;
				}
				break;
			case LITERAL_complex:
			case LITERAL_integer:
			case LITERAL_natural:
			case LITERAL_rational:
			case LITERAL_real:
			case LITERAL_time:
				{
				alt159=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 159, 0, input);
				throw nvae;
			}
			switch (alt159) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3048:2: ts= timed_expression
					{
					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression12071);
					ts=timed_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3049:4: -> {$ts.st}
					  {
					  	retval.st = (ts!=null?((StringTemplate)ts.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3051:2: ^(um= UNARY_MINUS ts2= timed_expression )
					{
					um=(BAST)match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_assertion_subexpression12088); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression12092);
					ts2=timed_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3052:3: -> template(ts2=$ts2.st) \" -<ts2>\"
					  {
					  	retval.st = new StringTemplate(templateLib, " -<ts2>",new STAttrMap().put("ts2", (ts2!=null?((StringTemplate)ts2.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3054:2: ^(abs= LITERAL_abs ts3= timed_expression )
					{
					abs=(BAST)match(input,LITERAL_abs,FOLLOW_LITERAL_abs_in_assertion_subexpression12115); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_timed_expression_in_assertion_subexpression12119);
					ts3=timed_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3055:3: -> template(ts3=$ts3.st) \" abs <ts3>\"
					  {
					  	retval.st = new StringTemplate(templateLib, " abs <ts3>",new STAttrMap().put("ts3", (ts3!=null?((StringTemplate)ts3.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3060:2: ^(def= LITERAL_def lv= assertion_parameter )
					{
					def=(BAST)match(input,LITERAL_def,FOLLOW_LITERAL_def_in_assertion_subexpression12146); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_parameter_in_assertion_subexpression12150);
					lv=assertion_parameter();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3061:4: -> template(lv=$lv.st) \" def <lv> \"
					  {
					  	retval.st = new StringTemplate(templateLib, " def <lv> ",new STAttrMap().put("lv", (lv!=null?((StringTemplate)lv.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3063:6: atc= assertion_type_conversion
					{
					pushFollow(FOLLOW_assertion_type_conversion_in_assertion_subexpression12178);
					atc=assertion_type_conversion();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3064:5: -> {$atc.st}
					  {
					  	retval.st = (atc!=null?((StringTemplate)atc.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.assertion_subexpression caught RecognitionException");
				  if (um!=null)
				  	((BAST)um).showParseTree(um.getText());
				  else if (def!=null)
				  	((BAST)def).showParseTree(def.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_subexpression"


	public static class timed_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "timed_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3078:1: timed_expression : (n= value -> {$n.st}|ppe= parenthesized_assertion_expression -> {$ppe.st}|afi= assertion_function_invocation -> {$afi.st}| ^(tic= TICK (tv= value |ppe= parenthesized_assertion_expression ) ) -> {tv!=null}? template(tv=$tv.st) \"<tv>'\" -> template(ppe=$ppe.st) \"<ppe>'\"| ^(ats= AT_SIGN (av= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) te= time_subexpression ) -> {av!=null}? template(av=$av.stte=$te.st) \"<av>@<te>\" -> {pi!=null}? template(pi=$pi.stte=$te.st) \"<pi>@<te>\" -> template(ppe=$ppe.stte=$te.st) \"<ppe>@<te>\"| ^(crt= CARET (cv= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) val= period_shift ) -> {cv!=null}? template(cv=$cv.stval=$val.st) \"<cv>^<val>\" -> {pi!=null}? template(pi=$pi.stval=$val.st) \"<pi>^<val>\" -> template(ppe=$ppe.stval=$val.st) \"<ppe>^<val>\");
	public final UnparseBLESS.timed_expression_return timed_expression() throws RecognitionException {
		UnparseBLESS.timed_expression_return retval = new UnparseBLESS.timed_expression_return();
		retval.start = input.LT(1);

		BAST tic=null;
		BAST ats=null;
		BAST crt=null;
		TreeRuleReturnScope n =null;
		TreeRuleReturnScope ppe =null;
		TreeRuleReturnScope afi =null;
		TreeRuleReturnScope tv =null;
		TreeRuleReturnScope av =null;
		TreeRuleReturnScope pi =null;
		TreeRuleReturnScope te =null;
		TreeRuleReturnScope cv =null;
		TreeRuleReturnScope val =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3079:2: (n= value -> {$n.st}|ppe= parenthesized_assertion_expression -> {$ppe.st}|afi= assertion_function_invocation -> {$afi.st}| ^(tic= TICK (tv= value |ppe= parenthesized_assertion_expression ) ) -> {tv!=null}? template(tv=$tv.st) \"<tv>'\" -> template(ppe=$ppe.st) \"<ppe>'\"| ^(ats= AT_SIGN (av= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) te= time_subexpression ) -> {av!=null}? template(av=$av.stte=$te.st) \"<av>@<te>\" -> {pi!=null}? template(pi=$pi.stte=$te.st) \"<pi>@<te>\" -> template(ppe=$ppe.stte=$te.st) \"<ppe>@<te>\"| ^(crt= CARET (cv= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) val= period_shift ) -> {cv!=null}? template(cv=$cv.stval=$val.st) \"<cv>^<val>\" -> {pi!=null}? template(pi=$pi.stval=$val.st) \"<pi>^<val>\" -> template(ppe=$ppe.stval=$val.st) \"<ppe>^<val>\")
			int alt163=6;
			alt163 = dfa163.predict(input);
			switch (alt163) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3080:2: n= value
					{
					pushFollow(FOLLOW_value_in_timed_expression12215);
					n=value();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3081:4: -> {$n.st}
					  {
					  	retval.st = (n!=null?((StringTemplate)n.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3088:2: ppe= parenthesized_assertion_expression
					{
					pushFollow(FOLLOW_parenthesized_assertion_expression_in_timed_expression12239);
					ppe=parenthesized_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3089:3: -> {$ppe.st}
					  {
					  	retval.st = (ppe!=null?((StringTemplate)ppe.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3091:2: afi= assertion_function_invocation
					{
					pushFollow(FOLLOW_assertion_function_invocation_in_timed_expression12253);
					afi=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3092:4: -> {$afi.st}
					  {
					  	retval.st = (afi!=null?((StringTemplate)afi.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3094:2: ^(tic= TICK (tv= value |ppe= parenthesized_assertion_expression ) )
					{
					tic=(BAST)match(input,TICK,FOLLOW_TICK_in_timed_expression12269); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3094:13: (tv= value |ppe= parenthesized_assertion_expression )
					int alt160=2;
					int LA160_0 = input.LA(1);
					if ( (LA160_0==AADL_STRING_LITERAL||LA160_0==COMPLEX||LA160_0==DOUBLE_COLON||LA160_0==ID||LA160_0==INMODE||LA160_0==INTEGER_LIT||LA160_0==LITERAL_false||LA160_0==LITERAL_now||LA160_0==LITERAL_null||LA160_0==LITERAL_timeout||LA160_0==LITERAL_tops||LA160_0==LITERAL_true||LA160_0==OCTOTHORPE||LA160_0==PERIOD||LA160_0==QUESTION||LA160_0==RATIONAL||LA160_0==REAL_LIT||LA160_0==TICK) ) {
						alt160=1;
					}
					else if ( (LA160_0==CASE_EXPRESSION||LA160_0==CONDITIONAL||LA160_0==LPAREN) ) {
						alt160=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 160, 0, input);
						throw nvae;
					}

					switch (alt160) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3094:14: tv= value
							{
							pushFollow(FOLLOW_value_in_timed_expression12274);
							tv=value();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3094:25: ppe= parenthesized_assertion_expression
							{
							pushFollow(FOLLOW_parenthesized_assertion_expression_in_timed_expression12280);
							ppe=parenthesized_assertion_expression();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3095:3: -> {tv!=null}? template(tv=$tv.st) \"<tv>'\"
					  if (tv!=null) {
					  	retval.st = new StringTemplate(templateLib, "<tv>'",new STAttrMap().put("tv", (tv!=null?((StringTemplate)tv.getTemplate()):null)));
					  }

					  else // 3096:3: -> template(ppe=$ppe.st) \"<ppe>'\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<ppe>'",new STAttrMap().put("ppe", (ppe!=null?((StringTemplate)ppe.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3098:2: ^(ats= AT_SIGN (av= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) te= time_subexpression )
					{
					ats=(BAST)match(input,AT_SIGN,FOLLOW_AT_SIGN_in_timed_expression12320); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3098:17: (av= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation )
					int alt161=3;
					switch ( input.LA(1) ) {
					case AADL_STRING_LITERAL:
					case COMPLEX:
					case DOUBLE_COLON:
					case ID:
					case INMODE:
					case INTEGER_LIT:
					case LITERAL_false:
					case LITERAL_now:
					case LITERAL_null:
					case LITERAL_timeout:
					case LITERAL_tops:
					case LITERAL_true:
					case OCTOTHORPE:
					case PERIOD:
					case QUESTION:
					case RATIONAL:
					case REAL_LIT:
					case TICK:
						{
						alt161=1;
						}
						break;
					case CASE_EXPRESSION:
					case CONDITIONAL:
					case LPAREN:
						{
						alt161=2;
						}
						break;
					case INVOKE_FUNCTION:
						{
						alt161=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 161, 0, input);
						throw nvae;
					}
					switch (alt161) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3098:18: av= value
							{
							pushFollow(FOLLOW_value_in_timed_expression12326);
							av=value();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3098:30: ppe= parenthesized_assertion_expression
							{
							pushFollow(FOLLOW_parenthesized_assertion_expression_in_timed_expression12333);
							ppe=parenthesized_assertion_expression();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3098:71: pi= assertion_function_invocation
							{
							pushFollow(FOLLOW_assertion_function_invocation_in_timed_expression12339);
							pi=assertion_function_invocation();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					pushFollow(FOLLOW_time_subexpression_in_timed_expression12346);
					te=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3099:3: -> {av!=null}? template(av=$av.stte=$te.st) \"<av>@<te>\"
					  if (av!=null) {
					  	retval.st = new StringTemplate(templateLib, "<av>@<te>",new STAttrMap().put("av", (av!=null?((StringTemplate)av.getTemplate()):null)).put("te", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }

					  else // 3100:3: -> {pi!=null}? template(pi=$pi.stte=$te.st) \"<pi>@<te>\"
					  if (pi!=null) {
					  	retval.st = new StringTemplate(templateLib, "<pi>@<te>",new STAttrMap().put("pi", (pi!=null?((StringTemplate)pi.getTemplate()):null)).put("te", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }

					  else // 3101:3: -> template(ppe=$ppe.stte=$te.st) \"<ppe>@<te>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<ppe>@<te>",new STAttrMap().put("ppe", (ppe!=null?((StringTemplate)ppe.getTemplate()):null)).put("te", (te!=null?((StringTemplate)te.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3103:2: ^(crt= CARET (cv= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) val= period_shift )
					{
					crt=(BAST)match(input,CARET,FOLLOW_CARET_in_timed_expression12408); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3103:15: (cv= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation )
					int alt162=3;
					switch ( input.LA(1) ) {
					case AADL_STRING_LITERAL:
					case COMPLEX:
					case DOUBLE_COLON:
					case ID:
					case INMODE:
					case INTEGER_LIT:
					case LITERAL_false:
					case LITERAL_now:
					case LITERAL_null:
					case LITERAL_timeout:
					case LITERAL_tops:
					case LITERAL_true:
					case OCTOTHORPE:
					case PERIOD:
					case QUESTION:
					case RATIONAL:
					case REAL_LIT:
					case TICK:
						{
						alt162=1;
						}
						break;
					case CASE_EXPRESSION:
					case CONDITIONAL:
					case LPAREN:
						{
						alt162=2;
						}
						break;
					case INVOKE_FUNCTION:
						{
						alt162=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 162, 0, input);
						throw nvae;
					}
					switch (alt162) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3103:16: cv= value
							{
							pushFollow(FOLLOW_value_in_timed_expression12414);
							cv=value();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 2 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3103:28: ppe= parenthesized_assertion_expression
							{
							pushFollow(FOLLOW_parenthesized_assertion_expression_in_timed_expression12421);
							ppe=parenthesized_assertion_expression();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;
						case 3 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3103:69: pi= assertion_function_invocation
							{
							pushFollow(FOLLOW_assertion_function_invocation_in_timed_expression12427);
							pi=assertion_function_invocation();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					pushFollow(FOLLOW_period_shift_in_timed_expression12434);
					val=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3104:3: -> {cv!=null}? template(cv=$cv.stval=$val.st) \"<cv>^<val>\"
					  if (cv!=null) {
					  	retval.st = new StringTemplate(templateLib, "<cv>^<val>",new STAttrMap().put("cv", (cv!=null?((StringTemplate)cv.getTemplate()):null)).put("val", (val!=null?((StringTemplate)val.getTemplate()):null)));
					  }

					  else // 3105:3: -> {pi!=null}? template(pi=$pi.stval=$val.st) \"<pi>^<val>\"
					  if (pi!=null) {
					  	retval.st = new StringTemplate(templateLib, "<pi>^<val>",new STAttrMap().put("pi", (pi!=null?((StringTemplate)pi.getTemplate()):null)).put("val", (val!=null?((StringTemplate)val.getTemplate()):null)));
					  }

					  else // 3106:3: -> template(ppe=$ppe.stval=$val.st) \"<ppe>^<val>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<ppe>^<val>",new STAttrMap().put("ppe", (ppe!=null?((StringTemplate)ppe.getTemplate()):null)).put("val", (val!=null?((StringTemplate)val.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.timed_expression caught RecognitionException");
				  if (tic!=null)
				  	((BAST)tic).showParseTree(tic.getText());
				  else if (ats!=null)
				  	((BAST)ats).showParseTree(ats.getText());
				  else if (crt!=null)
				  	((BAST)crt).showParseTree(crt.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timed_expression"


	public static class time_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "time_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3121:1: time_expression : (lhs= time_subexpression -> {$lhs.st}| ^( PLUS (ts+= time_subexpression )+ ) -> template(ts=$ts) \"<ts; separator=\"+\">\"| ^( TIMES (ts+= time_subexpression )+ ) -> template(ts=$ts) \"<ts; separator=\"*\">\"| ^( MINUS lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>-<rhs>\"| ^( DIVIDE lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>/<rhs>\"| ^( EXP lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>**<rhs>\"| ^( LITERAL_mod lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> mod <rhs>\"| ^( LITERAL_rem lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> rem <rhs>\");
	public final UnparseBLESS.time_expression_return time_expression() throws RecognitionException {
		UnparseBLESS.time_expression_return retval = new UnparseBLESS.time_expression_return();
		retval.start = input.LT(1);

		List<Object> list_ts=null;
		TreeRuleReturnScope lhs =null;
		TreeRuleReturnScope rhs =null;
		RuleReturnScope ts = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3122:3: (lhs= time_subexpression -> {$lhs.st}| ^( PLUS (ts+= time_subexpression )+ ) -> template(ts=$ts) \"<ts; separator=\"+\">\"| ^( TIMES (ts+= time_subexpression )+ ) -> template(ts=$ts) \"<ts; separator=\"*\">\"| ^( MINUS lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>-<rhs>\"| ^( DIVIDE lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>/<rhs>\"| ^( EXP lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>**<rhs>\"| ^( LITERAL_mod lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> mod <rhs>\"| ^( LITERAL_rem lhs= time_subexpression rhs= time_subexpression ) -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> rem <rhs>\")
			int alt166=8;
			switch ( input.LA(1) ) {
			case AADL_STRING_LITERAL:
			case COMPLEX:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case INVOKE_FUNCTION:
			case LITERAL_false:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
			case UNARY_MINUS:
				{
				alt166=1;
				}
				break;
			case PLUS:
				{
				alt166=2;
				}
				break;
			case TIMES:
				{
				alt166=3;
				}
				break;
			case MINUS:
				{
				alt166=4;
				}
				break;
			case DIVIDE:
				{
				alt166=5;
				}
				break;
			case EXP:
				{
				alt166=6;
				}
				break;
			case LITERAL_mod:
				{
				alt166=7;
				}
				break;
			case LITERAL_rem:
				{
				alt166=8;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 166, 0, input);
				throw nvae;
			}
			switch (alt166) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3123:3: lhs= time_subexpression
					{
					pushFollow(FOLLOW_time_subexpression_in_time_expression12514);
					lhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3124:5: -> {$lhs.st}
					  {
					  	retval.st = (lhs!=null?((StringTemplate)lhs.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3126:3: ^( PLUS (ts+= time_subexpression )+ )
					{
					match(input,PLUS,FOLLOW_PLUS_in_time_expression12533); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3126:12: (ts+= time_subexpression )+
					int cnt164=0;
					loop164:
					while (true) {
						int alt164=2;
						int LA164_0 = input.LA(1);
						if ( (LA164_0==AADL_STRING_LITERAL||LA164_0==COMPLEX||LA164_0==DOUBLE_COLON||LA164_0==ID||LA164_0==INMODE||LA164_0==INTEGER_LIT||LA164_0==INVOKE_FUNCTION||LA164_0==LITERAL_false||LA164_0==LITERAL_now||LA164_0==LITERAL_null||LA164_0==LITERAL_timeout||LA164_0==LITERAL_tops||LA164_0==LITERAL_true||LA164_0==LPAREN||LA164_0==OCTOTHORPE||LA164_0==PERIOD||LA164_0==QUESTION||LA164_0==RATIONAL||LA164_0==REAL_LIT||LA164_0==TICK||LA164_0==UNARY_MINUS) ) {
							alt164=1;
						}

						switch (alt164) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3126:12: ts+= time_subexpression
							{
							pushFollow(FOLLOW_time_subexpression_in_time_expression12537);
							ts=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_ts==null) list_ts=new ArrayList<Object>();
							list_ts.add(ts.getTemplate());
							}
							break;

						default :
							if ( cnt164 >= 1 ) break loop164;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(164, input);
							throw eee;
						}
						cnt164++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3127:5: -> template(ts=$ts) \"<ts; separator=\"+\">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<ts; separator=\"+\">",new STAttrMap().put("ts", list_ts));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3129:3: ^( TIMES (ts+= time_subexpression )+ )
					{
					match(input,TIMES,FOLLOW_TIMES_in_time_expression12564); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3129:13: (ts+= time_subexpression )+
					int cnt165=0;
					loop165:
					while (true) {
						int alt165=2;
						int LA165_0 = input.LA(1);
						if ( (LA165_0==AADL_STRING_LITERAL||LA165_0==COMPLEX||LA165_0==DOUBLE_COLON||LA165_0==ID||LA165_0==INMODE||LA165_0==INTEGER_LIT||LA165_0==INVOKE_FUNCTION||LA165_0==LITERAL_false||LA165_0==LITERAL_now||LA165_0==LITERAL_null||LA165_0==LITERAL_timeout||LA165_0==LITERAL_tops||LA165_0==LITERAL_true||LA165_0==LPAREN||LA165_0==OCTOTHORPE||LA165_0==PERIOD||LA165_0==QUESTION||LA165_0==RATIONAL||LA165_0==REAL_LIT||LA165_0==TICK||LA165_0==UNARY_MINUS) ) {
							alt165=1;
						}

						switch (alt165) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3129:13: ts+= time_subexpression
							{
							pushFollow(FOLLOW_time_subexpression_in_time_expression12568);
							ts=time_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_ts==null) list_ts=new ArrayList<Object>();
							list_ts.add(ts.getTemplate());
							}
							break;

						default :
							if ( cnt165 >= 1 ) break loop165;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(165, input);
							throw eee;
						}
						cnt165++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3130:5: -> template(ts=$ts) \"<ts; separator=\"*\">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<ts; separator=\"*\">",new STAttrMap().put("ts", list_ts));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3132:3: ^( MINUS lhs= time_subexpression rhs= time_subexpression )
					{
					match(input,MINUS,FOLLOW_MINUS_in_time_expression12595); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12599);
					lhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12603);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3133:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>-<rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs>-<rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3135:3: ^( DIVIDE lhs= time_subexpression rhs= time_subexpression )
					{
					match(input,DIVIDE,FOLLOW_DIVIDE_in_time_expression12633); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12637);
					lhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12641);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3136:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>/<rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs>/<rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3138:3: ^( EXP lhs= time_subexpression rhs= time_subexpression )
					{
					match(input,EXP,FOLLOW_EXP_in_time_expression12671); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12675);
					lhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12679);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3139:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs>**<rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs>**<rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3141:3: ^( LITERAL_mod lhs= time_subexpression rhs= time_subexpression )
					{
					match(input,LITERAL_mod,FOLLOW_LITERAL_mod_in_time_expression12709); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12713);
					lhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12717);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3142:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> mod <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> mod <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3144:3: ^( LITERAL_rem lhs= time_subexpression rhs= time_subexpression )
					{
					match(input,LITERAL_rem,FOLLOW_LITERAL_rem_in_time_expression12747); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12751);
					lhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_time_subexpression_in_time_expression12755);
					rhs=time_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3145:5: -> template(lhs=$lhs.strhs=$rhs.st) \"<lhs> rem <rhs>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lhs> rem <rhs>",new STAttrMap().put("lhs", (lhs!=null?((StringTemplate)lhs.getTemplate()):null)).put("rhs", (rhs!=null?((StringTemplate)rhs.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_expression"


	public static class time_subexpression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "time_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3148:1: time_subexpression : ( ^( UNARY_MINUS val= value ) -> template(val=$val.st) \" -<val>\"| ^( UNARY_MINUS afi= assertion_function_invocation ) -> template(afi=$afi.st) \" -<afi>\"| ^( UNARY_MINUS ^(lp= LPAREN exp= time_expression rp= RPAREN ) ) -> template(exp=$exp.st) \" -(<exp>)\"|val= value -> {$val.st}|afi= assertion_function_invocation -> {$afi.st}| ^(lp= LPAREN exp= time_expression rp= RPAREN ) -> template(exp=$exp.st) \"(<exp>)\");
	public final UnparseBLESS.time_subexpression_return time_subexpression() throws RecognitionException {
		UnparseBLESS.time_subexpression_return retval = new UnparseBLESS.time_subexpression_return();
		retval.start = input.LT(1);

		BAST lp=null;
		BAST rp=null;
		TreeRuleReturnScope val =null;
		TreeRuleReturnScope afi =null;
		TreeRuleReturnScope exp =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3149:3: ( ^( UNARY_MINUS val= value ) -> template(val=$val.st) \" -<val>\"| ^( UNARY_MINUS afi= assertion_function_invocation ) -> template(afi=$afi.st) \" -<afi>\"| ^( UNARY_MINUS ^(lp= LPAREN exp= time_expression rp= RPAREN ) ) -> template(exp=$exp.st) \" -(<exp>)\"|val= value -> {$val.st}|afi= assertion_function_invocation -> {$afi.st}| ^(lp= LPAREN exp= time_expression rp= RPAREN ) -> template(exp=$exp.st) \"(<exp>)\")
			int alt167=6;
			switch ( input.LA(1) ) {
			case UNARY_MINUS:
				{
				int LA167_1 = input.LA(2);
				if ( (LA167_1==DOWN) ) {
					switch ( input.LA(3) ) {
					case LPAREN:
						{
						alt167=3;
						}
						break;
					case AADL_STRING_LITERAL:
					case COMPLEX:
					case DOUBLE_COLON:
					case ID:
					case INMODE:
					case INTEGER_LIT:
					case LITERAL_false:
					case LITERAL_now:
					case LITERAL_null:
					case LITERAL_timeout:
					case LITERAL_tops:
					case LITERAL_true:
					case OCTOTHORPE:
					case PERIOD:
					case QUESTION:
					case RATIONAL:
					case REAL_LIT:
					case TICK:
						{
						alt167=1;
						}
						break;
					case INVOKE_FUNCTION:
						{
						alt167=2;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 167, 5, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 167, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
			case COMPLEX:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_false:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
				{
				alt167=4;
				}
				break;
			case INVOKE_FUNCTION:
				{
				alt167=5;
				}
				break;
			case LPAREN:
				{
				alt167=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 167, 0, input);
				throw nvae;
			}
			switch (alt167) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3150:3: ^( UNARY_MINUS val= value )
					{
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_time_subexpression12794); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_value_in_time_subexpression12798);
					val=value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3151:5: -> template(val=$val.st) \" -<val>\"
					  {
					  	retval.st = new StringTemplate(templateLib, " -<val>",new STAttrMap().put("val", (val!=null?((StringTemplate)val.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3153:3: ^( UNARY_MINUS afi= assertion_function_invocation )
					{
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_time_subexpression12822); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_function_invocation_in_time_subexpression12826);
					afi=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3154:5: -> template(afi=$afi.st) \" -<afi>\"
					  {
					  	retval.st = new StringTemplate(templateLib, " -<afi>",new STAttrMap().put("afi", (afi!=null?((StringTemplate)afi.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3156:3: ^( UNARY_MINUS ^(lp= LPAREN exp= time_expression rp= RPAREN ) )
					{
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_time_subexpression12850); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					lp=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_time_subexpression12855); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_expression_in_time_subexpression12859);
					exp=time_expression();
					state._fsp--;
					if (state.failed) return retval;
					rp=(BAST)match(input,RPAREN,FOLLOW_RPAREN_in_time_subexpression12863); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3157:5: -> template(exp=$exp.st) \" -(<exp>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, " -(<exp>)",new STAttrMap().put("exp", (exp!=null?((StringTemplate)exp.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3158:5: val= value
					{
					pushFollow(FOLLOW_value_in_time_subexpression12888);
					val=value();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3159:5: -> {$val.st}
					  {
					  	retval.st = (val!=null?((StringTemplate)val.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3160:5: afi= assertion_function_invocation
					{
					pushFollow(FOLLOW_assertion_function_invocation_in_time_subexpression12904);
					afi=assertion_function_invocation();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3161:5: -> {$afi.st}
					  {
					  	retval.st = (afi!=null?((StringTemplate)afi.getTemplate()):null);
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3162:5: ^(lp= LPAREN exp= time_expression rp= RPAREN )
					{
					lp=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_time_subexpression12921); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_time_expression_in_time_subexpression12925);
					exp=time_expression();
					state._fsp--;
					if (state.failed) return retval;
					rp=(BAST)match(input,RPAREN,FOLLOW_RPAREN_in_time_subexpression12929); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3163:5: -> template(exp=$exp.st) \"(<exp>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<exp>)",new STAttrMap().put("exp", (exp!=null?((StringTemplate)exp.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_subexpression"


	public static class assertion_function_invocation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_function_invocation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3166:1: assertion_function_invocation : ( ^( INVOKE_FUNCTION assertion_function_identifier= ID ) -> template(i=$assertion_function_identifier.text) \"<i>()\"| ^( INVOKE_FUNCTION ^(assertion_function_identifier= ID actual= assertion_expression ) ) -> template(i=$assertion_function_identifier.textactual=$actual.st) \"<i>(<actual>)\"| ^( INVOKE_FUNCTION ^(assertion_function_identifier= ID (params+= actual_assertion_parameter )+ ) ) -> template(i=$assertion_function_identifier.textparams=$params) \"<i>(<params; separator=\", \">)\");
	public final UnparseBLESS.assertion_function_invocation_return assertion_function_invocation() throws RecognitionException {
		UnparseBLESS.assertion_function_invocation_return retval = new UnparseBLESS.assertion_function_invocation_return();
		retval.start = input.LT(1);

		BAST assertion_function_identifier=null;
		List<Object> list_params=null;
		TreeRuleReturnScope actual =null;
		RuleReturnScope params = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3167:3: ( ^( INVOKE_FUNCTION assertion_function_identifier= ID ) -> template(i=$assertion_function_identifier.text) \"<i>()\"| ^( INVOKE_FUNCTION ^(assertion_function_identifier= ID actual= assertion_expression ) ) -> template(i=$assertion_function_identifier.textactual=$actual.st) \"<i>(<actual>)\"| ^( INVOKE_FUNCTION ^(assertion_function_identifier= ID (params+= actual_assertion_parameter )+ ) ) -> template(i=$assertion_function_identifier.textparams=$params) \"<i>(<params; separator=\", \">)\")
			int alt169=3;
			int LA169_0 = input.LA(1);
			if ( (LA169_0==INVOKE_FUNCTION) ) {
				int LA169_1 = input.LA(2);
				if ( (LA169_1==DOWN) ) {
					int LA169_2 = input.LA(3);
					if ( (LA169_2==ID) ) {
						int LA169_3 = input.LA(4);
						if ( (LA169_3==UP) ) {
							alt169=1;
						}
						else if ( (LA169_3==DOWN) ) {
							int LA169_5 = input.LA(5);
							if ( (LA169_5==AADL_STRING_LITERAL||LA169_5==AT_SIGN||(LA169_5 >= CARET && LA169_5 <= CASE_EXPRESSION)||LA169_5==COMPLEX||LA169_5==CONDITIONAL||LA169_5==DIVIDE||LA169_5==DOUBLE_COLON||LA169_5==EXP||LA169_5==ID||LA169_5==INMODE||LA169_5==INTEGER_LIT||LA169_5==INVOKE_FUNCTION||LA169_5==LITERAL_abs||LA169_5==LITERAL_complex||LA169_5==LITERAL_def||LA169_5==LITERAL_false||LA169_5==LITERAL_integer||LA169_5==LITERAL_mod||LA169_5==LITERAL_natural||LA169_5==LITERAL_now||(LA169_5 >= LITERAL_null && LA169_5 <= LITERAL_numberof)||LA169_5==LITERAL_product||(LA169_5 >= LITERAL_rational && LA169_5 <= LITERAL_real)||LA169_5==LITERAL_rem||LA169_5==LITERAL_sum||(LA169_5 >= LITERAL_time && LA169_5 <= LITERAL_timeout)||LA169_5==LITERAL_tops||LA169_5==LITERAL_true||LA169_5==LPAREN||LA169_5==MINUS||LA169_5==OCTOTHORPE||(LA169_5 >= PERIOD && LA169_5 <= PLUS)||LA169_5==QUESTION||LA169_5==RATIONAL||LA169_5==REAL_LIT||LA169_5==TICK||LA169_5==TIMES||LA169_5==UNARY_MINUS) ) {
								alt169=2;
							}
							else if ( (LA169_5==PARAMETER) ) {
								alt169=3;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 169, 5, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 169, 3, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 169, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 169, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 169, 0, input);
				throw nvae;
			}

			switch (alt169) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3168:3: ^( INVOKE_FUNCTION assertion_function_identifier= ID )
					{
					match(input,INVOKE_FUNCTION,FOLLOW_INVOKE_FUNCTION_in_assertion_function_invocation12961); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					assertion_function_identifier=(BAST)match(input,ID,FOLLOW_ID_in_assertion_function_invocation12965); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3169:5: -> template(i=$assertion_function_identifier.text) \"<i>()\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i>()",new STAttrMap().put("i", (assertion_function_identifier!=null?assertion_function_identifier.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3171:3: ^( INVOKE_FUNCTION ^(assertion_function_identifier= ID actual= assertion_expression ) )
					{
					match(input,INVOKE_FUNCTION,FOLLOW_INVOKE_FUNCTION_in_assertion_function_invocation12990); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					assertion_function_identifier=(BAST)match(input,ID,FOLLOW_ID_in_assertion_function_invocation12995); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_assertion_function_invocation12999);
					actual=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3172:5: -> template(i=$assertion_function_identifier.textactual=$actual.st) \"<i>(<actual>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i>(<actual>)",new STAttrMap().put("i", (assertion_function_identifier!=null?assertion_function_identifier.getText():null)).put("actual", (actual!=null?((StringTemplate)actual.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3174:3: ^( INVOKE_FUNCTION ^(assertion_function_identifier= ID (params+= actual_assertion_parameter )+ ) )
					{
					match(input,INVOKE_FUNCTION,FOLLOW_INVOKE_FUNCTION_in_assertion_function_invocation13030); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					assertion_function_identifier=(BAST)match(input,ID,FOLLOW_ID_in_assertion_function_invocation13035); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3174:56: (params+= actual_assertion_parameter )+
					int cnt168=0;
					loop168:
					while (true) {
						int alt168=2;
						int LA168_0 = input.LA(1);
						if ( (LA168_0==PARAMETER) ) {
							alt168=1;
						}

						switch (alt168) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3174:57: params+= actual_assertion_parameter
							{
							pushFollow(FOLLOW_actual_assertion_parameter_in_assertion_function_invocation13040);
							params=actual_assertion_parameter();
							state._fsp--;
							if (state.failed) return retval;
							if (list_params==null) list_params=new ArrayList<Object>();
							list_params.add(params.getTemplate());
							}
							break;

						default :
							if ( cnt168 >= 1 ) break loop168;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(168, input);
							throw eee;
						}
						cnt168++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3175:5: -> template(i=$assertion_function_identifier.textparams=$params) \"<i>(<params; separator=\", \">)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<i>(<params; separator=\", \">)",new STAttrMap().put("i", (assertion_function_identifier!=null?assertion_function_identifier.getText():null)).put("params", list_params));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_function_invocation"


	public static class parenthesized_assertion_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "parenthesized_assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3180:1: parenthesized_assertion_expression : ( ^(lp= LPAREN pe= assertion_expression RPAREN ) -> template(pe=$pe.st) \"(<pe>)\"|cpe= conditional_assertion_expression -> {$cpe.st}|art= assertion_record_term -> {$art.st}|cas= case_expression -> {$cas.st});
	public final UnparseBLESS.parenthesized_assertion_expression_return parenthesized_assertion_expression() throws RecognitionException {
		UnparseBLESS.parenthesized_assertion_expression_return retval = new UnparseBLESS.parenthesized_assertion_expression_return();
		retval.start = input.LT(1);

		BAST lp=null;
		TreeRuleReturnScope pe =null;
		TreeRuleReturnScope cpe =null;
		TreeRuleReturnScope art =null;
		TreeRuleReturnScope cas =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3181:3: ( ^(lp= LPAREN pe= assertion_expression RPAREN ) -> template(pe=$pe.st) \"(<pe>)\"|cpe= conditional_assertion_expression -> {$cpe.st}|art= assertion_record_term -> {$art.st}|cas= case_expression -> {$cas.st})
			int alt170=4;
			switch ( input.LA(1) ) {
			case LPAREN:
				{
				int LA170_1 = input.LA(2);
				if ( (LA170_1==DOWN) ) {
					int LA170_4 = input.LA(3);
					if ( (LA170_4==AADL_STRING_LITERAL||LA170_4==AT_SIGN||(LA170_4 >= CARET && LA170_4 <= CASE_EXPRESSION)||LA170_4==COMPLEX||LA170_4==CONDITIONAL||LA170_4==DIVIDE||LA170_4==DOUBLE_COLON||LA170_4==EXP||LA170_4==ID||LA170_4==INMODE||LA170_4==INTEGER_LIT||LA170_4==INVOKE_FUNCTION||LA170_4==LITERAL_abs||LA170_4==LITERAL_complex||LA170_4==LITERAL_def||LA170_4==LITERAL_false||LA170_4==LITERAL_integer||LA170_4==LITERAL_mod||LA170_4==LITERAL_natural||LA170_4==LITERAL_now||(LA170_4 >= LITERAL_null && LA170_4 <= LITERAL_numberof)||LA170_4==LITERAL_product||(LA170_4 >= LITERAL_rational && LA170_4 <= LITERAL_real)||LA170_4==LITERAL_rem||LA170_4==LITERAL_sum||(LA170_4 >= LITERAL_time && LA170_4 <= LITERAL_timeout)||LA170_4==LITERAL_tops||LA170_4==LITERAL_true||LA170_4==LPAREN||LA170_4==MINUS||LA170_4==OCTOTHORPE||(LA170_4 >= PERIOD && LA170_4 <= PLUS)||LA170_4==QUESTION||LA170_4==RATIONAL||LA170_4==REAL_LIT||LA170_4==TICK||LA170_4==TIMES||LA170_4==UNARY_MINUS) ) {
						alt170=1;
					}
					else if ( (LA170_4==ARROW) ) {
						alt170=3;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 170, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 170, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case CONDITIONAL:
				{
				alt170=2;
				}
				break;
			case CASE_EXPRESSION:
				{
				alt170=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 170, 0, input);
				throw nvae;
			}
			switch (alt170) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3182:3: ^(lp= LPAREN pe= assertion_expression RPAREN )
					{
					lp=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_assertion_expression13092); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_parenthesized_assertion_expression13096);
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_assertion_expression13098); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3183:5: -> template(pe=$pe.st) \"(<pe>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<pe>)",new STAttrMap().put("pe", (pe!=null?((StringTemplate)pe.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3185:3: cpe= conditional_assertion_expression
					{
					pushFollow(FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression13124);
					cpe=conditional_assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3186:5: -> {$cpe.st}
					  {
					  	retval.st = (cpe!=null?((StringTemplate)cpe.getTemplate()):null);
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3191:3: art= assertion_record_term
					{
					pushFollow(FOLLOW_assertion_record_term_in_parenthesized_assertion_expression13149);
					art=assertion_record_term();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3192:5: -> {$art.st}
					  {
					  	retval.st = (art!=null?((StringTemplate)art.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3194:2: cas= case_expression
					{
					pushFollow(FOLLOW_case_expression_in_parenthesized_assertion_expression13167);
					cas=case_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3195:4: -> {$cas.st}
					  {
					  	retval.st = (cas!=null?((StringTemplate)cas.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.parenthesized_assertion_expression caught RecognitionException");
				  if (lp!=null)
				  	((BAST)lp).showParseTree(lp.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_assertion_expression"


	public static class conditional_assertion_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "conditional_assertion_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3205:1: conditional_assertion_expression : ^(qq= CONDITIONAL p= predicate t= assertion_expression f= assertion_expression ) -> conditional_expression(be=$p.stt=$t.stf=$f.st);
	public final UnparseBLESS.conditional_assertion_expression_return conditional_assertion_expression() throws RecognitionException {
		UnparseBLESS.conditional_assertion_expression_return retval = new UnparseBLESS.conditional_assertion_expression_return();
		retval.start = input.LT(1);

		BAST qq=null;
		TreeRuleReturnScope p =null;
		TreeRuleReturnScope t =null;
		TreeRuleReturnScope f =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3206:2: ( ^(qq= CONDITIONAL p= predicate t= assertion_expression f= assertion_expression ) -> conditional_expression(be=$p.stt=$t.stf=$f.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3207:3: ^(qq= CONDITIONAL p= predicate t= assertion_expression f= assertion_expression )
			{
			qq=(BAST)match(input,CONDITIONAL,FOLLOW_CONDITIONAL_in_conditional_assertion_expression13204); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_predicate_in_conditional_assertion_expression13208);
			p=predicate();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression13212);
			t=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_assertion_expression_in_conditional_assertion_expression13216);
			f=assertion_expression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3208:4: -> conditional_expression(be=$p.stt=$t.stf=$f.st)
			  {
			  	retval.st = templateLib.getInstanceOf("conditional_expression",new STAttrMap().put("be", (p!=null?((StringTemplate)p.getTemplate()):null)).put("t", (t!=null?((StringTemplate)t.getTemplate()):null)).put("f", (f!=null?((StringTemplate)f.getTemplate()):null)));
			  }


			}

			}

		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.conditional_assertion_expression caught RecognitionException");
				  if (qq!=null)
				  	((BAST)qq).showParseTree(qq.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_assertion_expression"


	public static class assertion_record_term_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_record_term"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3220:1: assertion_record_term : ^( LPAREN (arv+= assertion_record_value )+ RPAREN ) -> template(arv=$arv) \"(<arv; wrap>)\";
	public final UnparseBLESS.assertion_record_term_return assertion_record_term() throws RecognitionException {
		UnparseBLESS.assertion_record_term_return retval = new UnparseBLESS.assertion_record_term_return();
		retval.start = input.LT(1);

		List<Object> list_arv=null;
		RuleReturnScope arv = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3221:3: ( ^( LPAREN (arv+= assertion_record_value )+ RPAREN ) -> template(arv=$arv) \"(<arv; wrap>)\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3222:3: ^( LPAREN (arv+= assertion_record_value )+ RPAREN )
			{
			match(input,LPAREN,FOLLOW_LPAREN_in_assertion_record_term13265); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3222:15: (arv+= assertion_record_value )+
			int cnt171=0;
			loop171:
			while (true) {
				int alt171=2;
				int LA171_0 = input.LA(1);
				if ( (LA171_0==ARROW) ) {
					alt171=1;
				}

				switch (alt171) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3222:15: arv+= assertion_record_value
					{
					pushFollow(FOLLOW_assertion_record_value_in_assertion_record_term13269);
					arv=assertion_record_value();
					state._fsp--;
					if (state.failed) return retval;
					if (list_arv==null) list_arv=new ArrayList<Object>();
					list_arv.add(arv.getTemplate());
					}
					break;

				default :
					if ( cnt171 >= 1 ) break loop171;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(171, input);
					throw eee;
				}
				cnt171++;
			}

			match(input,RPAREN,FOLLOW_RPAREN_in_assertion_record_term13272); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3223:5: -> template(arv=$arv) \"(<arv; wrap>)\"
			  {
			  	retval.st = new StringTemplate(templateLib, "(<arv; wrap>)",new STAttrMap().put("arv", list_arv));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_term"


	public static class assertion_record_value_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "assertion_record_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3226:1: assertion_record_value : ^( ARROW field= ID v= value ) -> template(f=$field.textv=$v.st) \"<f>=\\><v>;\";
	public final UnparseBLESS.assertion_record_value_return assertion_record_value() throws RecognitionException {
		UnparseBLESS.assertion_record_value_return retval = new UnparseBLESS.assertion_record_value_return();
		retval.start = input.LT(1);

		BAST field=null;
		TreeRuleReturnScope v =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3227:3: ( ^( ARROW field= ID v= value ) -> template(f=$field.textv=$v.st) \"<f>=\\><v>;\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3228:3: ^( ARROW field= ID v= value )
			{
			match(input,ARROW,FOLLOW_ARROW_in_assertion_record_value13308); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			field=(BAST)match(input,ID,FOLLOW_ID_in_assertion_record_value13312); if (state.failed) return retval;
			pushFollow(FOLLOW_value_in_assertion_record_value13316);
			v=value();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3229:5: -> template(f=$field.textv=$v.st) \"<f>=\\><v>;\"
			  {
			  	retval.st = new StringTemplate(templateLib, "<f>=\\><v>;",new STAttrMap().put("f", (field!=null?field.getText():null)).put("v", (v!=null?((StringTemplate)v.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assertion_record_value"


	public static class period_shift_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "period_shift"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3232:1: period_shift : (v= value -> {$v.st}| ^(t= TICK n= name ) -> template(n=$n.st) \"$n' \"| ^( UNARY_MINUS ia= period_shift ) -> template(ia=$ia.st) \"-<ia>\"| ^( LPAREN ia= period_shift RPAREN ) -> template(ia=$ia.st) \"(<ia>)\"| ^( LPAREN ^( MINUS l= period_shift r= period_shift ) RPAREN ) -> template(l=$l.str=$r.st) \"(<l> - <r>)\"| ^( LPAREN ^( DIVIDE ld= period_shift rd= period_shift ) RPAREN ) -> template(l=$ld.str=$rd.st) \"(<l> / <r>)\"| ^( LPAREN ^( PLUS (iap+= period_shift )+ ) RPAREN ) -> template(ias=$iap) \"(<ias; separator=\" + \">)\"| ^( LPAREN ^( TIMES (iat+= period_shift )+ ) RPAREN ) -> template(ias=$iat) \"(<ias; separator=\" * \">)\");
	public final UnparseBLESS.period_shift_return period_shift() throws RecognitionException {
		UnparseBLESS.period_shift_return retval = new UnparseBLESS.period_shift_return();
		retval.start = input.LT(1);

		BAST t=null;
		List<Object> list_iap=null;
		List<Object> list_iat=null;
		TreeRuleReturnScope v =null;
		TreeRuleReturnScope n =null;
		TreeRuleReturnScope ia =null;
		TreeRuleReturnScope l =null;
		TreeRuleReturnScope r =null;
		TreeRuleReturnScope ld =null;
		TreeRuleReturnScope rd =null;
		RuleReturnScope iap = null;
		RuleReturnScope iat = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3233:2: (v= value -> {$v.st}| ^(t= TICK n= name ) -> template(n=$n.st) \"$n' \"| ^( UNARY_MINUS ia= period_shift ) -> template(ia=$ia.st) \"-<ia>\"| ^( LPAREN ia= period_shift RPAREN ) -> template(ia=$ia.st) \"(<ia>)\"| ^( LPAREN ^( MINUS l= period_shift r= period_shift ) RPAREN ) -> template(l=$l.str=$r.st) \"(<l> - <r>)\"| ^( LPAREN ^( DIVIDE ld= period_shift rd= period_shift ) RPAREN ) -> template(l=$ld.str=$rd.st) \"(<l> / <r>)\"| ^( LPAREN ^( PLUS (iap+= period_shift )+ ) RPAREN ) -> template(ias=$iap) \"(<ias; separator=\" + \">)\"| ^( LPAREN ^( TIMES (iat+= period_shift )+ ) RPAREN ) -> template(ias=$iat) \"(<ias; separator=\" * \">)\")
			int alt174=8;
			alt174 = dfa174.predict(input);
			switch (alt174) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3234:2: v= value
					{
					pushFollow(FOLLOW_value_in_period_shift13352);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3235:4: -> {$v.st}
					  {
					  	retval.st = (v!=null?((StringTemplate)v.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3240:3: ^(t= TICK n= name )
					{
					t=(BAST)match(input,TICK,FOLLOW_TICK_in_period_shift13373); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_name_in_period_shift13377);
					n=name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3241:5: -> template(n=$n.st) \"$n' \"
					  {
					  	retval.st = new StringTemplate(templateLib, "$n' ",new STAttrMap().put("n", (n!=null?((StringTemplate)n.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3243:2: ^( UNARY_MINUS ia= period_shift )
					{
					match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_period_shift13399); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_period_shift_in_period_shift13403);
					ia=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3244:4: -> template(ia=$ia.st) \"-<ia>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "-<ia>",new STAttrMap().put("ia", (ia!=null?((StringTemplate)ia.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3246:2: ^( LPAREN ia= period_shift RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_period_shift13426); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_period_shift_in_period_shift13430);
					ia=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					match(input,RPAREN,FOLLOW_RPAREN_in_period_shift13432); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3247:4: -> template(ia=$ia.st) \"(<ia>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<ia>)",new STAttrMap().put("ia", (ia!=null?((StringTemplate)ia.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3249:2: ^( LPAREN ^( MINUS l= period_shift r= period_shift ) RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_period_shift13454); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_period_shift13457); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_period_shift_in_period_shift13461);
					l=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_period_shift_in_period_shift13465);
					r=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,RPAREN,FOLLOW_RPAREN_in_period_shift13468); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3250:4: -> template(l=$l.str=$r.st) \"(<l> - <r>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<l> - <r>)",new STAttrMap().put("l", (l!=null?((StringTemplate)l.getTemplate()):null)).put("r", (r!=null?((StringTemplate)r.getTemplate()):null)));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3252:2: ^( LPAREN ^( DIVIDE ld= period_shift rd= period_shift ) RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_period_shift13494); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,DIVIDE,FOLLOW_DIVIDE_in_period_shift13497); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_period_shift_in_period_shift13501);
					ld=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_period_shift_in_period_shift13505);
					rd=period_shift();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,RPAREN,FOLLOW_RPAREN_in_period_shift13508); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3253:4: -> template(l=$ld.str=$rd.st) \"(<l> / <r>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<l> / <r>)",new STAttrMap().put("l", (ld!=null?((StringTemplate)ld.getTemplate()):null)).put("r", (rd!=null?((StringTemplate)rd.getTemplate()):null)));
					  }


					}

					}
					break;
				case 7 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3255:2: ^( LPAREN ^( PLUS (iap+= period_shift )+ ) RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_period_shift13534); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,PLUS,FOLLOW_PLUS_in_period_shift13537); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3255:21: (iap+= period_shift )+
					int cnt172=0;
					loop172:
					while (true) {
						int alt172=2;
						int LA172_0 = input.LA(1);
						if ( (LA172_0==AADL_STRING_LITERAL||LA172_0==COMPLEX||LA172_0==DOUBLE_COLON||LA172_0==ID||LA172_0==INMODE||LA172_0==INTEGER_LIT||LA172_0==LITERAL_false||LA172_0==LITERAL_now||LA172_0==LITERAL_null||LA172_0==LITERAL_timeout||LA172_0==LITERAL_tops||LA172_0==LITERAL_true||LA172_0==LPAREN||LA172_0==OCTOTHORPE||LA172_0==PERIOD||LA172_0==QUESTION||LA172_0==RATIONAL||LA172_0==REAL_LIT||LA172_0==TICK||LA172_0==UNARY_MINUS) ) {
							alt172=1;
						}

						switch (alt172) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3255:21: iap+= period_shift
							{
							pushFollow(FOLLOW_period_shift_in_period_shift13541);
							iap=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if (list_iap==null) list_iap=new ArrayList<Object>();
							list_iap.add(iap.getTemplate());
							}
							break;

						default :
							if ( cnt172 >= 1 ) break loop172;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(172, input);
							throw eee;
						}
						cnt172++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,RPAREN,FOLLOW_RPAREN_in_period_shift13545); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3256:4: -> template(ias=$iap) \"(<ias; separator=\" + \">)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<ias; separator=\" + \">)",new STAttrMap().put("ias", list_iap));
					  }


					}

					}
					break;
				case 8 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3258:2: ^( LPAREN ^( TIMES (iat+= period_shift )+ ) RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_period_shift13567); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,TIMES,FOLLOW_TIMES_in_period_shift13570); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3258:22: (iat+= period_shift )+
					int cnt173=0;
					loop173:
					while (true) {
						int alt173=2;
						int LA173_0 = input.LA(1);
						if ( (LA173_0==AADL_STRING_LITERAL||LA173_0==COMPLEX||LA173_0==DOUBLE_COLON||LA173_0==ID||LA173_0==INMODE||LA173_0==INTEGER_LIT||LA173_0==LITERAL_false||LA173_0==LITERAL_now||LA173_0==LITERAL_null||LA173_0==LITERAL_timeout||LA173_0==LITERAL_tops||LA173_0==LITERAL_true||LA173_0==LPAREN||LA173_0==OCTOTHORPE||LA173_0==PERIOD||LA173_0==QUESTION||LA173_0==RATIONAL||LA173_0==REAL_LIT||LA173_0==TICK||LA173_0==UNARY_MINUS) ) {
							alt173=1;
						}

						switch (alt173) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3258:22: iat+= period_shift
							{
							pushFollow(FOLLOW_period_shift_in_period_shift13574);
							iat=period_shift();
							state._fsp--;
							if (state.failed) return retval;
							if (list_iat==null) list_iat=new ArrayList<Object>();
							list_iat.add(iat.getTemplate());
							}
							break;

						default :
							if ( cnt173 >= 1 ) break loop173;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(173, input);
							throw eee;
						}
						cnt173++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,RPAREN,FOLLOW_RPAREN_in_period_shift13578); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3259:4: -> template(ias=$iat) \"(<ias; separator=\" * \">)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<ias; separator=\" * \">)",new STAttrMap().put("ias", list_iat));
					  }


					}

					}
					break;

			}
		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.period_shift caught RecognitionException");
				//  if (t!=null) Dump.it("is this ("+t.getText()+
				 //   ") something other than a *name* having a tick being used in the time shift of a ^?");
				//  ((BAST)t).showParseTree(t.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "period_shift"


	public static class availability_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "availability"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3272:1: availability : ^( LITERAL_availability avs= availability_subexpression ) -> template(avs=$avs.st) \"availability <avs><\\n>\";
	public final UnparseBLESS.availability_return availability() throws RecognitionException {
		UnparseBLESS.availability_return retval = new UnparseBLESS.availability_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope avs =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3273:2: ( ^( LITERAL_availability avs= availability_subexpression ) -> template(avs=$avs.st) \"availability <avs><\\n>\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3274:2: ^( LITERAL_availability avs= availability_subexpression )
			{
			match(input,LITERAL_availability,FOLLOW_LITERAL_availability_in_availability13627); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			pushFollow(FOLLOW_availability_subexpression_in_availability13631);
			avs=availability_subexpression();
			state._fsp--;
			if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3275:3: -> template(avs=$avs.st) \"availability <avs><\\n>\"
			  {
			  	retval.st = new StringTemplate(templateLib, "availability <avs><\\n>",new STAttrMap().put("avs", (avs!=null?((StringTemplate)avs.getTemplate()):null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability"


	public static class availability_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "availability_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3279:1: availability_expression : ( ^( LITERAL_and (asa+= availability_subexpression )+ ) -> template(asa=$asa) \"<asa; wrap, separator=\" and \">\"| ^( LITERAL_or (aso+= availability_subexpression )+ ) -> template(aso=$aso) \"<aso; wrap, separator=\" or \">\"| ^( LITERAL_xor (asx+= availability_subexpression )+ ) -> template(asx=$asx) \"<asx; wrap, separator=\" xor \">\"|as= availability_subexpression -> {$as.st});
	public final UnparseBLESS.availability_expression_return availability_expression() throws RecognitionException {
		UnparseBLESS.availability_expression_return retval = new UnparseBLESS.availability_expression_return();
		retval.start = input.LT(1);

		List<Object> list_asa=null;
		List<Object> list_aso=null;
		List<Object> list_asx=null;
		TreeRuleReturnScope as =null;
		RuleReturnScope asa = null;
		RuleReturnScope aso = null;
		RuleReturnScope asx = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3280:2: ( ^( LITERAL_and (asa+= availability_subexpression )+ ) -> template(asa=$asa) \"<asa; wrap, separator=\" and \">\"| ^( LITERAL_or (aso+= availability_subexpression )+ ) -> template(aso=$aso) \"<aso; wrap, separator=\" or \">\"| ^( LITERAL_xor (asx+= availability_subexpression )+ ) -> template(asx=$asx) \"<asx; wrap, separator=\" xor \">\"|as= availability_subexpression -> {$as.st})
			int alt178=4;
			switch ( input.LA(1) ) {
			case LITERAL_and:
				{
				alt178=1;
				}
				break;
			case LITERAL_or:
				{
				alt178=2;
				}
				break;
			case LITERAL_xor:
				{
				alt178=3;
				}
				break;
			case ID:
			case LITERAL_not:
			case LPAREN:
				{
				alt178=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 178, 0, input);
				throw nvae;
			}
			switch (alt178) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3281:2: ^( LITERAL_and (asa+= availability_subexpression )+ )
					{
					match(input,LITERAL_and,FOLLOW_LITERAL_and_in_availability_expression13661); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3281:19: (asa+= availability_subexpression )+
					int cnt175=0;
					loop175:
					while (true) {
						int alt175=2;
						int LA175_0 = input.LA(1);
						if ( (LA175_0==ID||LA175_0==LITERAL_not||LA175_0==LPAREN) ) {
							alt175=1;
						}

						switch (alt175) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3281:19: asa+= availability_subexpression
							{
							pushFollow(FOLLOW_availability_subexpression_in_availability_expression13665);
							asa=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_asa==null) list_asa=new ArrayList<Object>();
							list_asa.add(asa.getTemplate());
							}
							break;

						default :
							if ( cnt175 >= 1 ) break loop175;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(175, input);
							throw eee;
						}
						cnt175++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3282:3: -> template(asa=$asa) \"<asa; wrap, separator=\" and \">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<asa; wrap, separator=\" and \">",new STAttrMap().put("asa", list_asa));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3284:2: ^( LITERAL_or (aso+= availability_subexpression )+ )
					{
					match(input,LITERAL_or,FOLLOW_LITERAL_or_in_availability_expression13685); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3284:18: (aso+= availability_subexpression )+
					int cnt176=0;
					loop176:
					while (true) {
						int alt176=2;
						int LA176_0 = input.LA(1);
						if ( (LA176_0==ID||LA176_0==LITERAL_not||LA176_0==LPAREN) ) {
							alt176=1;
						}

						switch (alt176) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3284:18: aso+= availability_subexpression
							{
							pushFollow(FOLLOW_availability_subexpression_in_availability_expression13689);
							aso=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_aso==null) list_aso=new ArrayList<Object>();
							list_aso.add(aso.getTemplate());
							}
							break;

						default :
							if ( cnt176 >= 1 ) break loop176;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(176, input);
							throw eee;
						}
						cnt176++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3285:3: -> template(aso=$aso) \"<aso; wrap, separator=\" or \">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<aso; wrap, separator=\" or \">",new STAttrMap().put("aso", list_aso));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3287:2: ^( LITERAL_xor (asx+= availability_subexpression )+ )
					{
					match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_availability_expression13709); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3287:19: (asx+= availability_subexpression )+
					int cnt177=0;
					loop177:
					while (true) {
						int alt177=2;
						int LA177_0 = input.LA(1);
						if ( (LA177_0==ID||LA177_0==LITERAL_not||LA177_0==LPAREN) ) {
							alt177=1;
						}

						switch (alt177) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3287:19: asx+= availability_subexpression
							{
							pushFollow(FOLLOW_availability_subexpression_in_availability_expression13713);
							asx=availability_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_asx==null) list_asx=new ArrayList<Object>();
							list_asx.add(asx.getTemplate());
							}
							break;

						default :
							if ( cnt177 >= 1 ) break loop177;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(177, input);
							throw eee;
						}
						cnt177++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3288:3: -> template(asx=$asx) \"<asx; wrap, separator=\" xor \">\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<asx; wrap, separator=\" xor \">",new STAttrMap().put("asx", list_asx));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3290:2: as= availability_subexpression
					{
					pushFollow(FOLLOW_availability_subexpression_in_availability_expression13734);
					as=availability_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3291:4: -> {$as.st}
					  {
					  	retval.st = (as!=null?((StringTemplate)as.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_expression"


	public static class availability_subexpression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "availability_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3295:1: availability_subexpression : ( ^( LITERAL_not ^( LPAREN nae= availability_expression ) ) -> template(nae=$nae.st) \"not (<nae>)\"| ^( LITERAL_not ni= ID ) -> template(i=$ni.text) \"not <ni>\"| ^( LPAREN ae= availability_expression ) -> template(ae=$ae.st) \"(<ae>)\"|i= ID -> {%{$i.text}});
	public final UnparseBLESS.availability_subexpression_return availability_subexpression() throws RecognitionException {
		UnparseBLESS.availability_subexpression_return retval = new UnparseBLESS.availability_subexpression_return();
		retval.start = input.LT(1);

		BAST ni=null;
		BAST i=null;
		TreeRuleReturnScope nae =null;
		TreeRuleReturnScope ae =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3296:2: ( ^( LITERAL_not ^( LPAREN nae= availability_expression ) ) -> template(nae=$nae.st) \"not (<nae>)\"| ^( LITERAL_not ni= ID ) -> template(i=$ni.text) \"not <ni>\"| ^( LPAREN ae= availability_expression ) -> template(ae=$ae.st) \"(<ae>)\"|i= ID -> {%{$i.text}})
			int alt179=4;
			switch ( input.LA(1) ) {
			case LITERAL_not:
				{
				int LA179_1 = input.LA(2);
				if ( (LA179_1==DOWN) ) {
					int LA179_4 = input.LA(3);
					if ( (LA179_4==LPAREN) ) {
						alt179=1;
					}
					else if ( (LA179_4==ID) ) {
						alt179=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 179, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 179, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LPAREN:
				{
				alt179=3;
				}
				break;
			case ID:
				{
				alt179=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 179, 0, input);
				throw nvae;
			}
			switch (alt179) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3297:2: ^( LITERAL_not ^( LPAREN nae= availability_expression ) )
					{
					match(input,LITERAL_not,FOLLOW_LITERAL_not_in_availability_subexpression13757); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LPAREN,FOLLOW_LPAREN_in_availability_subexpression13760); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_availability_expression_in_availability_subexpression13764);
					nae=availability_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3298:3: -> template(nae=$nae.st) \"not (<nae>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "not (<nae>)",new STAttrMap().put("nae", (nae!=null?((StringTemplate)nae.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3300:2: ^( LITERAL_not ni= ID )
					{
					match(input,LITERAL_not,FOLLOW_LITERAL_not_in_availability_subexpression13785); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					ni=(BAST)match(input,ID,FOLLOW_ID_in_availability_subexpression13789); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3301:3: -> template(i=$ni.text) \"not <ni>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "not <ni>",new STAttrMap().put("i", (ni!=null?ni.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3303:2: ^( LPAREN ae= availability_expression )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_availability_subexpression13809); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_availability_expression_in_availability_subexpression13813);
					ae=availability_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3304:3: -> template(ae=$ae.st) \"(<ae>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<ae>)",new STAttrMap().put("ae", (ae!=null?((StringTemplate)ae.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3306:2: i= ID
					{
					i=(BAST)match(input,ID,FOLLOW_ID_in_availability_subexpression13834); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3307:3: -> {%{$i.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(i!=null?i.getText():null));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "availability_subexpression"


	public static class dispatch_condition_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "dispatch_condition"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3312:1: dispatch_condition : ^(d= LITERAL_dispatch (dle= dispatch_expression )? ) -> dispatch_condition(dle=$dle.st);
	public final UnparseBLESS.dispatch_condition_return dispatch_condition() throws RecognitionException {
		UnparseBLESS.dispatch_condition_return retval = new UnparseBLESS.dispatch_condition_return();
		retval.start = input.LT(1);

		BAST d=null;
		TreeRuleReturnScope dle =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3313:2: ( ^(d= LITERAL_dispatch (dle= dispatch_expression )? ) -> dispatch_condition(dle=$dle.st))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3314:2: ^(d= LITERAL_dispatch (dle= dispatch_expression )? )
			{
			d=(BAST)match(input,LITERAL_dispatch,FOLLOW_LITERAL_dispatch_in_dispatch_condition13859); if (state.failed) return retval;
			if ( input.LA(1)==Token.DOWN ) {
				match(input, Token.DOWN, null); if (state.failed) return retval;
				// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3314:27: (dle= dispatch_expression )?
				int alt180=2;
				int LA180_0 = input.LA(1);
				if ( (LA180_0==ID||LA180_0==LITERAL_and||LA180_0==LITERAL_or||LA180_0==LITERAL_stop||LA180_0==LITERAL_timeout) ) {
					alt180=1;
				}
				switch (alt180) {
					case 1 :
						// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3314:27: dle= dispatch_expression
						{
						pushFollow(FOLLOW_dispatch_expression_in_dispatch_condition13864);
						dle=dispatch_expression();
						state._fsp--;
						if (state.failed) return retval;
						}
						break;

				}

				match(input, Token.UP, null); if (state.failed) return retval;
			}

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3315:7: -> dispatch_condition(dle=$dle.st)
			  {
			  	retval.st = templateLib.getInstanceOf("dispatch_condition",new STAttrMap().put("dle", (dle!=null?((StringTemplate)dle.getTemplate()):null)));
			  }


			}

			}

		}
		catch (RecognitionException re) {

				  Dump.it("UnparseBLESS.dispatch_condition caught RecognitionException");
				  if (d!=null)
				  	d.showParseTree(d.getText());
				  reportError(re);
				  
		}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_condition"


	public static class dispatch_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "dispatch_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3326:1: dispatch_expression : ( ^( LITERAL_or (odt+= dispatch_conjunction )+ ) -> or(terms=$odt)|dt= dispatch_conjunction -> template(dt=$dt.st) \"<dt>\");
	public final UnparseBLESS.dispatch_expression_return dispatch_expression() throws RecognitionException {
		UnparseBLESS.dispatch_expression_return retval = new UnparseBLESS.dispatch_expression_return();
		retval.start = input.LT(1);

		List<Object> list_odt=null;
		TreeRuleReturnScope dt =null;
		RuleReturnScope odt = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3327:2: ( ^( LITERAL_or (odt+= dispatch_conjunction )+ ) -> or(terms=$odt)|dt= dispatch_conjunction -> template(dt=$dt.st) \"<dt>\")
			int alt182=2;
			int LA182_0 = input.LA(1);
			if ( (LA182_0==LITERAL_or) ) {
				alt182=1;
			}
			else if ( (LA182_0==ID||LA182_0==LITERAL_and||LA182_0==LITERAL_stop||LA182_0==LITERAL_timeout) ) {
				alt182=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 182, 0, input);
				throw nvae;
			}

			switch (alt182) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3328:2: ^( LITERAL_or (odt+= dispatch_conjunction )+ )
					{
					match(input,LITERAL_or,FOLLOW_LITERAL_or_in_dispatch_expression13908); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3328:18: (odt+= dispatch_conjunction )+
					int cnt181=0;
					loop181:
					while (true) {
						int alt181=2;
						int LA181_0 = input.LA(1);
						if ( (LA181_0==ID||LA181_0==LITERAL_and||LA181_0==LITERAL_stop||LA181_0==LITERAL_timeout) ) {
							alt181=1;
						}

						switch (alt181) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3328:18: odt+= dispatch_conjunction
							{
							pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression13912);
							odt=dispatch_conjunction();
							state._fsp--;
							if (state.failed) return retval;
							if (list_odt==null) list_odt=new ArrayList<Object>();
							list_odt.add(odt.getTemplate());
							}
							break;

						default :
							if ( cnt181 >= 1 ) break loop181;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(181, input);
							throw eee;
						}
						cnt181++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3329:4: -> or(terms=$odt)
					  {
					  	retval.st = templateLib.getInstanceOf("or",new STAttrMap().put("terms", list_odt));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3332:2: dt= dispatch_conjunction
					{
					pushFollow(FOLLOW_dispatch_conjunction_in_dispatch_expression13935);
					dt=dispatch_conjunction();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3333:3: -> template(dt=$dt.st) \"<dt>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<dt>",new STAttrMap().put("dt", (dt!=null?((StringTemplate)dt.getTemplate()):null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_expression"


	public static class dispatch_conjunction_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "dispatch_conjunction"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3336:1: dispatch_conjunction : (d= dispatch_trigger -> {$d.st}| ^( LITERAL_and (dt+= dispatch_trigger )+ ) -> and(terms=$dt));
	public final UnparseBLESS.dispatch_conjunction_return dispatch_conjunction() throws RecognitionException {
		UnparseBLESS.dispatch_conjunction_return retval = new UnparseBLESS.dispatch_conjunction_return();
		retval.start = input.LT(1);

		List<Object> list_dt=null;
		TreeRuleReturnScope d =null;
		RuleReturnScope dt = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3337:2: (d= dispatch_trigger -> {$d.st}| ^( LITERAL_and (dt+= dispatch_trigger )+ ) -> and(terms=$dt))
			int alt184=2;
			int LA184_0 = input.LA(1);
			if ( (LA184_0==ID||LA184_0==LITERAL_stop||LA184_0==LITERAL_timeout) ) {
				alt184=1;
			}
			else if ( (LA184_0==LITERAL_and) ) {
				alt184=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 184, 0, input);
				throw nvae;
			}

			switch (alt184) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3338:2: d= dispatch_trigger
					{
					pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction13961);
					d=dispatch_trigger();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3339:3: -> {$d.st}
					  {
					  	retval.st = (d!=null?((StringTemplate)d.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3341:2: ^( LITERAL_and (dt+= dispatch_trigger )+ )
					{
					match(input,LITERAL_and,FOLLOW_LITERAL_and_in_dispatch_conjunction13973); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3341:18: (dt+= dispatch_trigger )+
					int cnt183=0;
					loop183:
					while (true) {
						int alt183=2;
						int LA183_0 = input.LA(1);
						if ( (LA183_0==ID||LA183_0==LITERAL_stop||LA183_0==LITERAL_timeout) ) {
							alt183=1;
						}

						switch (alt183) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3341:18: dt+= dispatch_trigger
							{
							pushFollow(FOLLOW_dispatch_trigger_in_dispatch_conjunction13977);
							dt=dispatch_trigger();
							state._fsp--;
							if (state.failed) return retval;
							if (list_dt==null) list_dt=new ArrayList<Object>();
							list_dt.add(dt.getTemplate());
							}
							break;

						default :
							if ( cnt183 >= 1 ) break loop183;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(183, input);
							throw eee;
						}
						cnt183++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3342:4: -> and(terms=$dt)
					  {
					  	retval.st = templateLib.getInstanceOf("and",new STAttrMap().put("terms", list_dt));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_conjunction"


	public static class dispatch_trigger_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "dispatch_trigger"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3348:1: dispatch_trigger : (i= ID -> dispatch_trigger(i=$i.text)| ^( LITERAL_timeout LPAREN (ports+= ID )+ RPAREN bt= behavior_time ) -> timeout(bt=$bt.stp=$ports)|t= LITERAL_timeout -> {%{$t.text}}| ^( LITERAL_timeout bt= behavior_time ) -> timeout(bt=$bt.st)|s= LITERAL_stop -> dispatch_trigger(i=$s.text));
	public final UnparseBLESS.dispatch_trigger_return dispatch_trigger() throws RecognitionException {
		UnparseBLESS.dispatch_trigger_return retval = new UnparseBLESS.dispatch_trigger_return();
		retval.start = input.LT(1);

		BAST i=null;
		BAST t=null;
		BAST s=null;
		BAST ports=null;
		List<Object> list_ports=null;
		TreeRuleReturnScope bt =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3349:2: (i= ID -> dispatch_trigger(i=$i.text)| ^( LITERAL_timeout LPAREN (ports+= ID )+ RPAREN bt= behavior_time ) -> timeout(bt=$bt.stp=$ports)|t= LITERAL_timeout -> {%{$t.text}}| ^( LITERAL_timeout bt= behavior_time ) -> timeout(bt=$bt.st)|s= LITERAL_stop -> dispatch_trigger(i=$s.text))
			int alt186=5;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt186=1;
				}
				break;
			case LITERAL_timeout:
				{
				int LA186_2 = input.LA(2);
				if ( (LA186_2==DOWN) ) {
					int LA186_4 = input.LA(3);
					if ( (LA186_4==LPAREN) ) {
						alt186=2;
					}
					else if ( (LA186_4==BEHAVIOR_TIME) ) {
						alt186=4;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 186, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}
				else if ( (LA186_2==UP||LA186_2==ID||LA186_2==LITERAL_and||LA186_2==LITERAL_stop||LA186_2==LITERAL_timeout) ) {
					alt186=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 186, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LITERAL_stop:
				{
				alt186=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 186, 0, input);
				throw nvae;
			}
			switch (alt186) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3350:4: i= ID
					{
					i=(BAST)match(input,ID,FOLLOW_ID_in_dispatch_trigger14012); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3351:6: -> dispatch_trigger(i=$i.text)
					  {
					  	retval.st = templateLib.getInstanceOf("dispatch_trigger",new STAttrMap().put("i", (i!=null?i.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3354:4: ^( LITERAL_timeout LPAREN (ports+= ID )+ RPAREN bt= behavior_time )
					{
					match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger14037); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LPAREN,FOLLOW_LPAREN_in_dispatch_trigger14039); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3354:29: (ports+= ID )+
					int cnt185=0;
					loop185:
					while (true) {
						int alt185=2;
						int LA185_0 = input.LA(1);
						if ( (LA185_0==ID) ) {
							alt185=1;
						}

						switch (alt185) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3354:30: ports+= ID
							{
							ports=(BAST)match(input,ID,FOLLOW_ID_in_dispatch_trigger14044); if (state.failed) return retval;
							if (list_ports==null) list_ports=new ArrayList<Object>();
							list_ports.add(ports);
							}
							break;

						default :
							if ( cnt185 >= 1 ) break loop185;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(185, input);
							throw eee;
						}
						cnt185++;
					}

					match(input,RPAREN,FOLLOW_RPAREN_in_dispatch_trigger14048); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_time_in_dispatch_trigger14052);
					bt=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3355:6: -> timeout(bt=$bt.stp=$ports)
					  {
					  	retval.st = templateLib.getInstanceOf("timeout",new STAttrMap().put("bt", (bt!=null?((StringTemplate)bt.getTemplate()):null)).put("p", list_ports));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3361:4: t= LITERAL_timeout
					{
					t=(BAST)match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger14087); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3362:6: -> {%{$t.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(t!=null?t.getText():null));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3364:4: ^( LITERAL_timeout bt= behavior_time )
					{
					match(input,LITERAL_timeout,FOLLOW_LITERAL_timeout_in_dispatch_trigger14106); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_behavior_time_in_dispatch_trigger14110);
					bt=behavior_time();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3365:6: -> timeout(bt=$bt.st)
					  {
					  	retval.st = templateLib.getInstanceOf("timeout",new STAttrMap().put("bt", (bt!=null?((StringTemplate)bt.getTemplate()):null)));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3367:2: s= LITERAL_stop
					{
					s=(BAST)match(input,LITERAL_stop,FOLLOW_LITERAL_stop_in_dispatch_trigger14133); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3368:3: -> dispatch_trigger(i=$s.text)
					  {
					  	retval.st = templateLib.getInstanceOf("dispatch_trigger",new STAttrMap().put("i", (s!=null?s.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dispatch_trigger"


	public static class integer_literal_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "integer_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3371:1: integer_literal : nl= INTEGER_LIT -> {%{$nl.text}};
	public final UnparseBLESS.integer_literal_return integer_literal() throws RecognitionException {
		UnparseBLESS.integer_literal_return retval = new UnparseBLESS.integer_literal_return();
		retval.start = input.LT(1);

		BAST nl=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3372:2: (nl= INTEGER_LIT -> {%{$nl.text}})
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3372:4: nl= INTEGER_LIT
			{
			nl=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_integer_literal14158); if (state.failed) return retval;
			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3373:6: -> {%{$nl.text}}
			  {
			  	retval.st = new StringTemplate(templateLib,(nl!=null?nl.getText():null));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "integer_literal"


	public static class value_constant_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "value_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3377:1: value_constant : (t= LITERAL_true -> {%{$t.text}}|f= LITERAL_false -> {%{$f.text}}|sl= AADL_STRING_LITERAL -> {%{$sl.text}}|nc= numeric_constant -> {$nc.st}|ev= enumeration_value -> {$ev.st});
	public final UnparseBLESS.value_constant_return value_constant() throws RecognitionException {
		UnparseBLESS.value_constant_return retval = new UnparseBLESS.value_constant_return();
		retval.start = input.LT(1);

		BAST t=null;
		BAST f=null;
		BAST sl=null;
		TreeRuleReturnScope nc =null;
		TreeRuleReturnScope ev =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3378:3: (t= LITERAL_true -> {%{$t.text}}|f= LITERAL_false -> {%{$f.text}}|sl= AADL_STRING_LITERAL -> {%{$sl.text}}|nc= numeric_constant -> {$nc.st}|ev= enumeration_value -> {$ev.st})
			int alt187=5;
			switch ( input.LA(1) ) {
			case LITERAL_true:
				{
				alt187=1;
				}
				break;
			case LITERAL_false:
				{
				alt187=2;
				}
				break;
			case AADL_STRING_LITERAL:
				{
				alt187=3;
				}
				break;
			case COMPLEX:
			case DOUBLE_COLON:
			case INTEGER_LIT:
			case OCTOTHORPE:
			case RATIONAL:
			case REAL_LIT:
				{
				alt187=4;
				}
				break;
			case TICK:
				{
				alt187=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 187, 0, input);
				throw nvae;
			}
			switch (alt187) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3379:3: t= LITERAL_true
					{
					t=(BAST)match(input,LITERAL_true,FOLLOW_LITERAL_true_in_value_constant14185); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3380:5: -> {%{$t.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(t!=null?t.getText():null));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3381:5: f= LITERAL_false
					{
					f=(BAST)match(input,LITERAL_false,FOLLOW_LITERAL_false_in_value_constant14202); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3382:5: -> {%{$f.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(f!=null?f.getText():null));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3383:5: sl= AADL_STRING_LITERAL
					{
					sl=(BAST)match(input,AADL_STRING_LITERAL,FOLLOW_AADL_STRING_LITERAL_in_value_constant14218); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3384:5: -> {%{$sl.text}}
					  {
					  	retval.st = new StringTemplate(templateLib,(sl!=null?sl.getText():null));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3385:5: nc= numeric_constant
					{
					pushFollow(FOLLOW_numeric_constant_in_value_constant14234);
					nc=numeric_constant();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3386:5: -> {$nc.st}
					  {
					  	retval.st = (nc!=null?((StringTemplate)nc.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3387:5: ev= enumeration_value
					{
					pushFollow(FOLLOW_enumeration_value_in_value_constant14250);
					ev=enumeration_value();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3388:5: -> {$ev.st}
					  {
					  	retval.st = (ev!=null?((StringTemplate)ev.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value_constant"


	public static class enumeration_value_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "enumeration_value"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3398:1: enumeration_value : ^( TICK enum_type= ID enum_value= ID ) -> {Global.usingSlangStringTemplateGroup && BlessMaps.dataComponentMapContainsKey($enum_type.text)}? enumeration_value(t=BlessMaps.dataComponentMapGet($enum_type.text)v=$enum_value.text) -> enumeration_value(t=$enum_type.textv=$enum_value.text);
	public final UnparseBLESS.enumeration_value_return enumeration_value() throws RecognitionException {
		UnparseBLESS.enumeration_value_return retval = new UnparseBLESS.enumeration_value_return();
		retval.start = input.LT(1);

		BAST enum_type=null;
		BAST enum_value=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3399:3: ( ^( TICK enum_type= ID enum_value= ID ) -> {Global.usingSlangStringTemplateGroup && BlessMaps.dataComponentMapContainsKey($enum_type.text)}? enumeration_value(t=BlessMaps.dataComponentMapGet($enum_type.text)v=$enum_value.text) -> enumeration_value(t=$enum_type.textv=$enum_value.text))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3400:3: ^( TICK enum_type= ID enum_value= ID )
			{
			match(input,TICK,FOLLOW_TICK_in_enumeration_value14283); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			enum_type=(BAST)match(input,ID,FOLLOW_ID_in_enumeration_value14287); if (state.failed) return retval;
			enum_value=(BAST)match(input,ID,FOLLOW_ID_in_enumeration_value14291); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3402:5: -> {Global.usingSlangStringTemplateGroup && BlessMaps.dataComponentMapContainsKey($enum_type.text)}? enumeration_value(t=BlessMaps.dataComponentMapGet($enum_type.text)v=$enum_value.text)
			  if (Global.usingSlangStringTemplateGroup && BlessMaps.dataComponentMapContainsKey((enum_type!=null?enum_type.getText():null))) {
			  	retval.st = templateLib.getInstanceOf("enumeration_value",new STAttrMap().put("t", BlessMaps.dataComponentMapGet((enum_type!=null?enum_type.getText():null))).put("v", (enum_value!=null?enum_value.getText():null)));
			  }

			  else // 3404:5: -> enumeration_value(t=$enum_type.textv=$enum_value.text)
			  {
			  	retval.st = templateLib.getInstanceOf("enumeration_value",new STAttrMap().put("t", (enum_type!=null?enum_type.getText():null)).put("v", (enum_value!=null?enum_value.getText():null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration_value"


	public static class property_constant_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "property_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3407:1: property_constant : ^( DOUBLE_COLON ps= ID p= ID ) -> property_name(ps=$ps.textp=$p.text);
	public final UnparseBLESS.property_constant_return property_constant() throws RecognitionException {
		UnparseBLESS.property_constant_return retval = new UnparseBLESS.property_constant_return();
		retval.start = input.LT(1);

		BAST ps=null;
		BAST p=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3408:3: ( ^( DOUBLE_COLON ps= ID p= ID ) -> property_name(ps=$ps.textp=$p.text))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3410:3: ^( DOUBLE_COLON ps= ID p= ID )
			{
			match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_constant14359); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			ps=(BAST)match(input,ID,FOLLOW_ID_in_property_constant14363); if (state.failed) return retval;
			p=(BAST)match(input,ID,FOLLOW_ID_in_property_constant14367); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3411:5: -> property_name(ps=$ps.textp=$p.text)
			  {
			  	retval.st = templateLib.getInstanceOf("property_name",new STAttrMap().put("ps", (ps!=null?ps.getText():null)).put("p", (p!=null?p.getText():null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_constant"


	public static class property_reference_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "property_reference"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3415:1: property_reference : ( ^(oct= OCTOTHORPE pname= property_name ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))} -> property_reference(pname=$pname.st)| ^(oct= OCTOTHORPE pname= property_name (field+= property_field )+ ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))} -> property_reference(pname=$pname.stf=$field)| ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))} -> property_reference(component=$self.textpname=$pname.st)| ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name (field+= property_field )+ ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))} -> property_reference(component=$self.textpname=$pname.stf=$field)| ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name ) -> property_reference(component=$component.stpname=$pname.stf=$field)| ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name (field+= property_field )+ ) -> property_reference(component=$component.stpname=$pname.stf=$field));
	public final UnparseBLESS.property_reference_return property_reference() throws RecognitionException {
		UnparseBLESS.property_reference_return retval = new UnparseBLESS.property_reference_return();
		retval.start = input.LT(1);

		BAST oct=null;
		BAST self=null;
		List<Object> list_field=null;
		TreeRuleReturnScope pname =null;
		TreeRuleReturnScope component =null;
		RuleReturnScope field = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3416:3: ( ^(oct= OCTOTHORPE pname= property_name ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))} -> property_reference(pname=$pname.st)| ^(oct= OCTOTHORPE pname= property_name (field+= property_field )+ ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))} -> property_reference(pname=$pname.stf=$field)| ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))} -> property_reference(component=$self.textpname=$pname.st)| ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name (field+= property_field )+ ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))} -> property_reference(component=$self.textpname=$pname.stf=$field)| ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name ) -> property_reference(component=$component.stpname=$pname.stf=$field)| ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name (field+= property_field )+ ) -> property_reference(component=$component.stpname=$pname.stf=$field))
			int alt191=6;
			alt191 = dfa191.predict(input);
			switch (alt191) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3418:3: ^(oct= OCTOTHORPE pname= property_name )
					{
					oct=(BAST)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference14408); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_property_name_in_property_reference14412);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3419:5: -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))}
					  if (lookUpPropertyValues) {
					  	retval.st = getAadlPropertyValue((BAST)oct.getChild(0));
					  }

					  else // 3420:5: -> property_reference(pname=$pname.st)
					  {
					  	retval.st = templateLib.getInstanceOf("property_reference",new STAttrMap().put("pname", (pname!=null?((StringTemplate)pname.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3423:3: ^(oct= OCTOTHORPE pname= property_name (field+= property_field )+ )
					{
					oct=(BAST)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference14450); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_property_name_in_property_reference14454);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3423:45: (field+= property_field )+
					int cnt188=0;
					loop188:
					while (true) {
						int alt188=2;
						int LA188_0 = input.LA(1);
						if ( (LA188_0==LBRACKET||LA188_0==PERIOD) ) {
							alt188=1;
						}

						switch (alt188) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3423:45: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference14458);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTemplate());
							}
							break;

						default :
							if ( cnt188 >= 1 ) break loop188;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(188, input);
							throw eee;
						}
						cnt188++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3424:5: -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))}
					  if (lookUpPropertyValues) {
					  	retval.st = getAadlPropertyValue((BAST)oct.getChild(0));
					  }

					  else // 3425:5: -> property_reference(pname=$pname.stf=$field)
					  {
					  	retval.st = templateLib.getInstanceOf("property_reference",new STAttrMap().put("pname", (pname!=null?((StringTemplate)pname.getTemplate()):null)).put("f", list_field));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3428:3: ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name )
					{
					oct=(BAST)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference14501); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					self=(BAST)match(input,LITERAL_self,FOLLOW_LITERAL_self_in_property_reference14505); if (state.failed) return retval;
					pushFollow(FOLLOW_property_name_in_property_reference14509);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3429:5: -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))}
					  if (lookUpPropertyValues) {
					  	retval.st = getAadlPropertyValue((BAST)oct.getChild(1));
					  }

					  else // 3430:5: -> property_reference(component=$self.textpname=$pname.st)
					  {
					  	retval.st = templateLib.getInstanceOf("property_reference",new STAttrMap().put("component", (self!=null?self.getText():null)).put("pname", (pname!=null?((StringTemplate)pname.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3433:3: ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name (field+= property_field )+ )
					{
					oct=(BAST)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference14552); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					self=(BAST)match(input,LITERAL_self,FOLLOW_LITERAL_self_in_property_reference14556); if (state.failed) return retval;
					pushFollow(FOLLOW_property_name_in_property_reference14560);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3433:63: (field+= property_field )+
					int cnt189=0;
					loop189:
					while (true) {
						int alt189=2;
						int LA189_0 = input.LA(1);
						if ( (LA189_0==LBRACKET||LA189_0==PERIOD) ) {
							alt189=1;
						}

						switch (alt189) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3433:63: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference14564);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTemplate());
							}
							break;

						default :
							if ( cnt189 >= 1 ) break loop189;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(189, input);
							throw eee;
						}
						cnt189++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3434:5: -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))}
					  if (lookUpPropertyValues) {
					  	retval.st = getAadlPropertyValue((BAST)oct.getChild(1));
					  }

					  else // 3435:5: -> property_reference(component=$self.textpname=$pname.stf=$field)
					  {
					  	retval.st = templateLib.getInstanceOf("property_reference",new STAttrMap().put("component", (self!=null?self.getText():null)).put("pname", (pname!=null?((StringTemplate)pname.getTemplate()):null)).put("f", list_field));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3441:3: ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name )
					{
					oct=(BAST)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference14614); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_unique_component_classifier_reference_in_property_reference14618);
					component=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_property_name_in_property_reference14622);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3442:5: -> property_reference(component=$component.stpname=$pname.stf=$field)
					  {
					  	retval.st = templateLib.getInstanceOf("property_reference",new STAttrMap().put("component", (component!=null?((StringTemplate)component.getTemplate()):null)).put("pname", (pname!=null?((StringTemplate)pname.getTemplate()):null)).put("f", list_field));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3445:3: ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name (field+= property_field )+ )
					{
					oct=(BAST)match(input,OCTOTHORPE,FOLLOW_OCTOTHORPE_in_property_reference14658); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_unique_component_classifier_reference_in_property_reference14662);
					component=unique_component_classifier_reference();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_property_name_in_property_reference14666);
					pname=property_name();
					state._fsp--;
					if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3445:93: (field+= property_field )+
					int cnt190=0;
					loop190:
					while (true) {
						int alt190=2;
						int LA190_0 = input.LA(1);
						if ( (LA190_0==LBRACKET||LA190_0==PERIOD) ) {
							alt190=1;
						}

						switch (alt190) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3445:93: field+= property_field
							{
							pushFollow(FOLLOW_property_field_in_property_reference14670);
							field=property_field();
							state._fsp--;
							if (state.failed) return retval;
							if (list_field==null) list_field=new ArrayList<Object>();
							list_field.add(field.getTemplate());
							}
							break;

						default :
							if ( cnt190 >= 1 ) break loop190;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(190, input);
							throw eee;
						}
						cnt190++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3446:5: -> property_reference(component=$component.stpname=$pname.stf=$field)
					  {
					  	retval.st = templateLib.getInstanceOf("property_reference",new STAttrMap().put("component", (component!=null?((StringTemplate)component.getTemplate()):null)).put("pname", (pname!=null?((StringTemplate)pname.getTemplate()):null)).put("f", list_field));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_reference"


	public static class property_name_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "property_name"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3450:1: property_name : ^( DOUBLE_COLON ps= ID p= ID ) -> property_name(ps=$ps.textp=$p.text);
	public final UnparseBLESS.property_name_return property_name() throws RecognitionException {
		UnparseBLESS.property_name_return retval = new UnparseBLESS.property_name_return();
		retval.start = input.LT(1);

		BAST ps=null;
		BAST p=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3451:3: ( ^( DOUBLE_COLON ps= ID p= ID ) -> property_name(ps=$ps.textp=$p.text))
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3452:3: ^( DOUBLE_COLON ps= ID p= ID )
			{
			match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_property_name14710); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			ps=(BAST)match(input,ID,FOLLOW_ID_in_property_name14714); if (state.failed) return retval;
			p=(BAST)match(input,ID,FOLLOW_ID_in_property_name14718); if (state.failed) return retval;
			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3453:5: -> property_name(ps=$ps.textp=$p.text)
			  {
			  	retval.st = templateLib.getInstanceOf("property_name",new STAttrMap().put("ps", (ps!=null?ps.getText():null)).put("p", (p!=null?p.getText():null)));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_name"


	public static class property_field_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "property_field"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3457:1: property_field : ( ^( LBRACKET lit= INTEGER_LIT RBRACKET ) -> template(lit=$lit.text) \"[<lit>]\"| ^( LBRACKET id= ID RBRACKET ) -> template(id=$id.text) \"[<id>]\"| ^( PERIOD id= ID ) -> template(id=$id.text) \".<id>\"| ^( PERIOD LITERAL_upper_bound ) -> template( \".upper_bound\"| ^( PERIOD LITERAL_lower_bound ) -> template( \".lower_bound\");
	public final UnparseBLESS.property_field_return property_field() throws RecognitionException {
		UnparseBLESS.property_field_return retval = new UnparseBLESS.property_field_return();
		retval.start = input.LT(1);

		BAST lit=null;
		BAST id=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3458:3: ( ^( LBRACKET lit= INTEGER_LIT RBRACKET ) -> template(lit=$lit.text) \"[<lit>]\"| ^( LBRACKET id= ID RBRACKET ) -> template(id=$id.text) \"[<id>]\"| ^( PERIOD id= ID ) -> template(id=$id.text) \".<id>\"| ^( PERIOD LITERAL_upper_bound ) -> template( \".upper_bound\"| ^( PERIOD LITERAL_lower_bound ) -> template( \".lower_bound\")
			int alt192=5;
			int LA192_0 = input.LA(1);
			if ( (LA192_0==LBRACKET) ) {
				int LA192_1 = input.LA(2);
				if ( (LA192_1==DOWN) ) {
					int LA192_3 = input.LA(3);
					if ( (LA192_3==INTEGER_LIT) ) {
						alt192=1;
					}
					else if ( (LA192_3==ID) ) {
						alt192=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 192, 3, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 192, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA192_0==PERIOD) ) {
				int LA192_2 = input.LA(2);
				if ( (LA192_2==DOWN) ) {
					switch ( input.LA(3) ) {
					case ID:
						{
						alt192=3;
						}
						break;
					case LITERAL_upper_bound:
						{
						alt192=4;
						}
						break;
					case LITERAL_lower_bound:
						{
						alt192=5;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 192, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 192, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 192, 0, input);
				throw nvae;
			}

			switch (alt192) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3459:3: ^( LBRACKET lit= INTEGER_LIT RBRACKET )
					{
					match(input,LBRACKET,FOLLOW_LBRACKET_in_property_field14755); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					lit=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_property_field14759); if (state.failed) return retval;
					match(input,RBRACKET,FOLLOW_RBRACKET_in_property_field14761); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3460:5: -> template(lit=$lit.text) \"[<lit>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[<lit>]",new STAttrMap().put("lit", (lit!=null?lit.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3462:3: ^( LBRACKET id= ID RBRACKET )
					{
					match(input,LBRACKET,FOLLOW_LBRACKET_in_property_field14785); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					id=(BAST)match(input,ID,FOLLOW_ID_in_property_field14789); if (state.failed) return retval;
					match(input,RBRACKET,FOLLOW_RBRACKET_in_property_field14791); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3463:5: -> template(id=$id.text) \"[<id>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[<id>]",new STAttrMap().put("id", (id!=null?id.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3465:3: ^( PERIOD id= ID )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_property_field14815); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					id=(BAST)match(input,ID,FOLLOW_ID_in_property_field14819); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3466:5: -> template(id=$id.text) \".<id>\"
					  {
					  	retval.st = new StringTemplate(templateLib, ".<id>",new STAttrMap().put("id", (id!=null?id.getText():null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3468:3: ^( PERIOD LITERAL_upper_bound )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_property_field14843); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LITERAL_upper_bound,FOLLOW_LITERAL_upper_bound_in_property_field14845); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3469:5: -> template( \".upper_bound\"
					  {
					  	retval.st = new StringTemplate(templateLib, ".upper_bound");
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3471:3: ^( PERIOD LITERAL_lower_bound )
					{
					match(input,PERIOD,FOLLOW_PERIOD_in_property_field14866); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,LITERAL_lower_bound,FOLLOW_LITERAL_lower_bound_in_property_field14868); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3472:5: -> template( \".lower_bound\"
					  {
					  	retval.st = new StringTemplate(templateLib, ".lower_bound");
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property_field"


	public static class numeric_constant_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "numeric_constant"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3476:1: numeric_constant : (il= INTEGER_LIT -> integer_literal(i=$il.text)|rl= REAL_LIT -> real_literal(r=$rl.text)|rat= rational_literal -> {$rat.st}|com= complex_literal -> {$com.st}|constant= property_constant -> {$constant.st}|reference= property_reference -> {$reference.st});
	public final UnparseBLESS.numeric_constant_return numeric_constant() throws RecognitionException {
		UnparseBLESS.numeric_constant_return retval = new UnparseBLESS.numeric_constant_return();
		retval.start = input.LT(1);

		BAST il=null;
		BAST rl=null;
		TreeRuleReturnScope rat =null;
		TreeRuleReturnScope com =null;
		TreeRuleReturnScope constant =null;
		TreeRuleReturnScope reference =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3477:3: (il= INTEGER_LIT -> integer_literal(i=$il.text)|rl= REAL_LIT -> real_literal(r=$rl.text)|rat= rational_literal -> {$rat.st}|com= complex_literal -> {$com.st}|constant= property_constant -> {$constant.st}|reference= property_reference -> {$reference.st})
			int alt193=6;
			switch ( input.LA(1) ) {
			case INTEGER_LIT:
				{
				alt193=1;
				}
				break;
			case REAL_LIT:
				{
				alt193=2;
				}
				break;
			case RATIONAL:
				{
				alt193=3;
				}
				break;
			case COMPLEX:
				{
				alt193=4;
				}
				break;
			case DOUBLE_COLON:
				{
				alt193=5;
				}
				break;
			case OCTOTHORPE:
				{
				alt193=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 193, 0, input);
				throw nvae;
			}
			switch (alt193) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3478:3: il= INTEGER_LIT
					{
					il=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_numeric_constant14899); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3479:5: -> integer_literal(i=$il.text)
					  {
					  	retval.st = templateLib.getInstanceOf("integer_literal",new STAttrMap().put("i", (il!=null?il.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3480:5: rl= REAL_LIT
					{
					rl=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_numeric_constant14922); if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3481:5: -> real_literal(r=$rl.text)
					  {
					  	retval.st = templateLib.getInstanceOf("real_literal",new STAttrMap().put("r", (rl!=null?rl.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3484:5: rat= rational_literal
					{
					pushFollow(FOLLOW_rational_literal_in_numeric_constant14947);
					rat=rational_literal();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3485:5: -> {$rat.st}
					  {
					  	retval.st = (rat!=null?((StringTemplate)rat.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3486:6: com= complex_literal
					{
					pushFollow(FOLLOW_complex_literal_in_numeric_constant14964);
					com=complex_literal();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3487:5: -> {$com.st}
					  {
					  	retval.st = (com!=null?((StringTemplate)com.getTemplate()):null);
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3489:3: constant= property_constant
					{
					pushFollow(FOLLOW_property_constant_in_numeric_constant14982);
					constant=property_constant();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3490:5: -> {$constant.st}
					  {
					  	retval.st = (constant!=null?((StringTemplate)constant.getTemplate()):null);
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3492:3: reference= property_reference
					{
					pushFollow(FOLLOW_property_reference_in_numeric_constant14999);
					reference=property_reference();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3493:5: -> {$reference.st}
					  {
					  	retval.st = (reference!=null?((StringTemplate)reference.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_constant"


	public static class rational_literal_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "rational_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3496:1: rational_literal : ( ^( RATIONAL dividend= INTEGER_LIT divisor= INTEGER_LIT ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[<dividend>|<divisor>]\"| ^( RATIONAL ^( MINUS dividend= INTEGER_LIT ) divisor= INTEGER_LIT ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[-<dividend>|<divisor>]\"| ^( RATIONAL dividend= INTEGER_LIT ^( MINUS divisor= INTEGER_LIT ) ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[<dividend>|-<divisor>]\"| ^( RATIONAL ^( MINUS dividend= INTEGER_LIT ) ^( MINUS divisor= INTEGER_LIT ) ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[-<dividend>|-<divisor>]\");
	public final UnparseBLESS.rational_literal_return rational_literal() throws RecognitionException {
		UnparseBLESS.rational_literal_return retval = new UnparseBLESS.rational_literal_return();
		retval.start = input.LT(1);

		BAST dividend=null;
		BAST divisor=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3497:3: ( ^( RATIONAL dividend= INTEGER_LIT divisor= INTEGER_LIT ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[<dividend>|<divisor>]\"| ^( RATIONAL ^( MINUS dividend= INTEGER_LIT ) divisor= INTEGER_LIT ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[-<dividend>|<divisor>]\"| ^( RATIONAL dividend= INTEGER_LIT ^( MINUS divisor= INTEGER_LIT ) ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[<dividend>|-<divisor>]\"| ^( RATIONAL ^( MINUS dividend= INTEGER_LIT ) ^( MINUS divisor= INTEGER_LIT ) ) -> template(dividend=$dividend.textdivisor=$divisor.text) \"[-<dividend>|-<divisor>]\")
			int alt194=4;
			int LA194_0 = input.LA(1);
			if ( (LA194_0==RATIONAL) ) {
				int LA194_1 = input.LA(2);
				if ( (LA194_1==DOWN) ) {
					int LA194_2 = input.LA(3);
					if ( (LA194_2==INTEGER_LIT) ) {
						int LA194_3 = input.LA(4);
						if ( (LA194_3==INTEGER_LIT) ) {
							alt194=1;
						}
						else if ( (LA194_3==MINUS) ) {
							alt194=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 194, 3, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA194_2==MINUS) ) {
						int LA194_4 = input.LA(4);
						if ( (LA194_4==DOWN) ) {
							int LA194_7 = input.LA(5);
							if ( (LA194_7==INTEGER_LIT) ) {
								int LA194_8 = input.LA(6);
								if ( (LA194_8==UP) ) {
									int LA194_9 = input.LA(7);
									if ( (LA194_9==INTEGER_LIT) ) {
										alt194=2;
									}
									else if ( (LA194_9==MINUS) ) {
										alt194=4;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 194, 9, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 194, 8, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 194, 7, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 194, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 194, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 194, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 194, 0, input);
				throw nvae;
			}

			switch (alt194) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3498:3: ^( RATIONAL dividend= INTEGER_LIT divisor= INTEGER_LIT )
					{
					match(input,RATIONAL,FOLLOW_RATIONAL_in_rational_literal15022); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					dividend=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15026); if (state.failed) return retval;
					divisor=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15030); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3499:5: -> template(dividend=$dividend.textdivisor=$divisor.text) \"[<dividend>|<divisor>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[<dividend>|<divisor>]",new STAttrMap().put("dividend", (dividend!=null?dividend.getText():null)).put("divisor", (divisor!=null?divisor.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3500:5: ^( RATIONAL ^( MINUS dividend= INTEGER_LIT ) divisor= INTEGER_LIT )
					{
					match(input,RATIONAL,FOLLOW_RATIONAL_in_rational_literal15056); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_rational_literal15059); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					dividend=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15063); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					divisor=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15068); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3501:5: -> template(dividend=$dividend.textdivisor=$divisor.text) \"[-<dividend>|<divisor>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[-<dividend>|<divisor>]",new STAttrMap().put("dividend", (dividend!=null?dividend.getText():null)).put("divisor", (divisor!=null?divisor.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3502:5: ^( RATIONAL dividend= INTEGER_LIT ^( MINUS divisor= INTEGER_LIT ) )
					{
					match(input,RATIONAL,FOLLOW_RATIONAL_in_rational_literal15094); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					dividend=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15098); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_rational_literal15101); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					divisor=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15105); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3503:5: -> template(dividend=$dividend.textdivisor=$divisor.text) \"[<dividend>|-<divisor>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[<dividend>|-<divisor>]",new STAttrMap().put("dividend", (dividend!=null?dividend.getText():null)).put("divisor", (divisor!=null?divisor.getText():null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3504:5: ^( RATIONAL ^( MINUS dividend= INTEGER_LIT ) ^( MINUS divisor= INTEGER_LIT ) )
					{
					match(input,RATIONAL,FOLLOW_RATIONAL_in_rational_literal15132); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_rational_literal15135); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					dividend=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15139); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,MINUS,FOLLOW_MINUS_in_rational_literal15143); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					divisor=(BAST)match(input,INTEGER_LIT,FOLLOW_INTEGER_LIT_in_rational_literal15147); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3505:5: -> template(dividend=$dividend.textdivisor=$divisor.text) \"[-<dividend>|-<divisor>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[-<dividend>|-<divisor>]",new STAttrMap().put("dividend", (dividend!=null?dividend.getText():null)).put("divisor", (divisor!=null?divisor.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rational_literal"


	public static class complex_literal_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "complex_literal"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3508:1: complex_literal : ( ^( COMPLEX real= REAL_LIT im= REAL_LIT ) -> template(real=$real.textim=$im.text) \"[<real>:<im>]\"| ^( COMPLEX ^( MINUS real= REAL_LIT ) im= REAL_LIT ) -> template(real=$real.textim=$im.text) \"[-<real>:<im>]\"| ^( COMPLEX real= REAL_LIT ^( MINUS im= REAL_LIT ) ) -> template(real=$real.textim=$im.text) \"[<real>:-<im>]\"| ^( COMPLEX ^( MINUS real= REAL_LIT ) ^( MINUS im= REAL_LIT ) ) -> template(real=$real.textim=$im.text) \"[-<real>:-<im>]\");
	public final UnparseBLESS.complex_literal_return complex_literal() throws RecognitionException {
		UnparseBLESS.complex_literal_return retval = new UnparseBLESS.complex_literal_return();
		retval.start = input.LT(1);

		BAST real=null;
		BAST im=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3509:3: ( ^( COMPLEX real= REAL_LIT im= REAL_LIT ) -> template(real=$real.textim=$im.text) \"[<real>:<im>]\"| ^( COMPLEX ^( MINUS real= REAL_LIT ) im= REAL_LIT ) -> template(real=$real.textim=$im.text) \"[-<real>:<im>]\"| ^( COMPLEX real= REAL_LIT ^( MINUS im= REAL_LIT ) ) -> template(real=$real.textim=$im.text) \"[<real>:-<im>]\"| ^( COMPLEX ^( MINUS real= REAL_LIT ) ^( MINUS im= REAL_LIT ) ) -> template(real=$real.textim=$im.text) \"[-<real>:-<im>]\")
			int alt195=4;
			int LA195_0 = input.LA(1);
			if ( (LA195_0==COMPLEX) ) {
				int LA195_1 = input.LA(2);
				if ( (LA195_1==DOWN) ) {
					int LA195_2 = input.LA(3);
					if ( (LA195_2==REAL_LIT) ) {
						int LA195_3 = input.LA(4);
						if ( (LA195_3==REAL_LIT) ) {
							alt195=1;
						}
						else if ( (LA195_3==MINUS) ) {
							alt195=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 195, 3, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA195_2==MINUS) ) {
						int LA195_4 = input.LA(4);
						if ( (LA195_4==DOWN) ) {
							int LA195_7 = input.LA(5);
							if ( (LA195_7==REAL_LIT) ) {
								int LA195_8 = input.LA(6);
								if ( (LA195_8==UP) ) {
									int LA195_9 = input.LA(7);
									if ( (LA195_9==REAL_LIT) ) {
										alt195=2;
									}
									else if ( (LA195_9==MINUS) ) {
										alt195=4;
									}

									else {
										if (state.backtracking>0) {state.failed=true; return retval;}
										int nvaeMark = input.mark();
										try {
											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
												input.consume();
											}
											NoViableAltException nvae =
												new NoViableAltException("", 195, 9, input);
											throw nvae;
										} finally {
											input.rewind(nvaeMark);
										}
									}

								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
											input.consume();
										}
										NoViableAltException nvae =
											new NoViableAltException("", 195, 8, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 195, 7, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
									input.consume();
								}
								NoViableAltException nvae =
									new NoViableAltException("", 195, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 195, 2, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 195, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 195, 0, input);
				throw nvae;
			}

			switch (alt195) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3510:3: ^( COMPLEX real= REAL_LIT im= REAL_LIT )
					{
					match(input,COMPLEX,FOLLOW_COMPLEX_in_complex_literal15183); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					real=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15187); if (state.failed) return retval;
					im=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15191); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3511:5: -> template(real=$real.textim=$im.text) \"[<real>:<im>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[<real>:<im>]",new STAttrMap().put("real", (real!=null?real.getText():null)).put("im", (im!=null?im.getText():null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3512:5: ^( COMPLEX ^( MINUS real= REAL_LIT ) im= REAL_LIT )
					{
					match(input,COMPLEX,FOLLOW_COMPLEX_in_complex_literal15217); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_complex_literal15220); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					real=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15224); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					im=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15229); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3513:5: -> template(real=$real.textim=$im.text) \"[-<real>:<im>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[-<real>:<im>]",new STAttrMap().put("real", (real!=null?real.getText():null)).put("im", (im!=null?im.getText():null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3514:5: ^( COMPLEX real= REAL_LIT ^( MINUS im= REAL_LIT ) )
					{
					match(input,COMPLEX,FOLLOW_COMPLEX_in_complex_literal15255); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					real=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15259); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_complex_literal15262); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					im=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15266); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3515:5: -> template(real=$real.textim=$im.text) \"[<real>:-<im>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[<real>:-<im>]",new STAttrMap().put("real", (real!=null?real.getText():null)).put("im", (im!=null?im.getText():null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3516:5: ^( COMPLEX ^( MINUS real= REAL_LIT ) ^( MINUS im= REAL_LIT ) )
					{
					match(input,COMPLEX,FOLLOW_COMPLEX_in_complex_literal15293); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					match(input,MINUS,FOLLOW_MINUS_in_complex_literal15296); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					real=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15300); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input,MINUS,FOLLOW_MINUS_in_complex_literal15304); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					im=(BAST)match(input,REAL_LIT,FOLLOW_REAL_LIT_in_complex_literal15308); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3517:5: -> template(real=$real.textim=$im.text) \"[-<real>:-<im>]\"
					  {
					  	retval.st = new StringTemplate(templateLib, "[-<real>:-<im>]",new STAttrMap().put("real", (real!=null?real.getText():null)).put("im", (im!=null?im.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "complex_literal"


	public static class in_modes_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "in_modes"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3527:1: in_modes : ^( LITERAL_in LITERAL_modes (m+= ID )+ ) -> template(m=$m) \"in modes (<m; separator=\",\">)\";
	public final UnparseBLESS.in_modes_return in_modes() throws RecognitionException {
		UnparseBLESS.in_modes_return retval = new UnparseBLESS.in_modes_return();
		retval.start = input.LT(1);

		BAST m=null;
		List<Object> list_m=null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3528:3: ( ^( LITERAL_in LITERAL_modes (m+= ID )+ ) -> template(m=$m) \"in modes (<m; separator=\",\">)\")
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3529:3: ^( LITERAL_in LITERAL_modes (m+= ID )+ )
			{
			match(input,LITERAL_in,FOLLOW_LITERAL_in_in_in_modes15355); if (state.failed) return retval;
			match(input, Token.DOWN, null); if (state.failed) return retval;
			match(input,LITERAL_modes,FOLLOW_LITERAL_modes_in_in_modes15357); if (state.failed) return retval;
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3529:31: (m+= ID )+
			int cnt196=0;
			loop196:
			while (true) {
				int alt196=2;
				int LA196_0 = input.LA(1);
				if ( (LA196_0==ID) ) {
					alt196=1;
				}

				switch (alt196) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3529:31: m+= ID
					{
					m=(BAST)match(input,ID,FOLLOW_ID_in_in_modes15361); if (state.failed) return retval;
					if (list_m==null) list_m=new ArrayList<Object>();
					list_m.add(m);
					}
					break;

				default :
					if ( cnt196 >= 1 ) break loop196;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(196, input);
					throw eee;
				}
				cnt196++;
			}

			match(input, Token.UP, null); if (state.failed) return retval;

			// TEMPLATE REWRITE
			if ( state.backtracking==0 ) {
			  // 3530:3: -> template(m=$m) \"in modes (<m; separator=\",\">)\"
			  {
			  	retval.st = new StringTemplate(templateLib, "in modes (<m; separator=\",\">)",new STAttrMap().put("m", list_m));
			  }


			}

			}

		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "in_modes"


	public static class parenthesized_xxx_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "parenthesized_xxx"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3545:1: parenthesized_xxx options {backtrack=true; } : (rt= record_term -> {$rt.st}| ^( LPAREN eor= expression_or_relation RPAREN ) -> template(eor=$eor.st) \"(<eor>)\"| ^(lp= LPAREN pe= assertion_expression RPAREN ) -> template(pe=$pe.st) \"(<pe>)\"| ^(lb= LPAREN p= predicate rb= RPAREN ) -> template(lb=$lb.textp=$p.strb=$rb.text) \"<lb><p><rb>\");
	public final UnparseBLESS.parenthesized_xxx_return parenthesized_xxx() throws RecognitionException {
		UnparseBLESS.parenthesized_xxx_return retval = new UnparseBLESS.parenthesized_xxx_return();
		retval.start = input.LT(1);

		BAST lp=null;
		BAST lb=null;
		BAST rb=null;
		TreeRuleReturnScope rt =null;
		TreeRuleReturnScope eor =null;
		TreeRuleReturnScope pe =null;
		TreeRuleReturnScope p =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3547:2: (rt= record_term -> {$rt.st}| ^( LPAREN eor= expression_or_relation RPAREN ) -> template(eor=$eor.st) \"(<eor>)\"| ^(lp= LPAREN pe= assertion_expression RPAREN ) -> template(pe=$pe.st) \"(<pe>)\"| ^(lb= LPAREN p= predicate rb= RPAREN ) -> template(lb=$lb.textp=$p.strb=$rb.text) \"<lb><p><rb>\")
			int alt197=4;
			int LA197_0 = input.LA(1);
			if ( (LA197_0==LPAREN) ) {
				int LA197_1 = input.LA(2);
				if ( (synpred3_UnparseBLESS()) ) {
					alt197=1;
				}
				else if ( (synpred4_UnparseBLESS()) ) {
					alt197=2;
				}
				else if ( (synpred5_UnparseBLESS()) ) {
					alt197=3;
				}
				else if ( (true) ) {
					alt197=4;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 197, 0, input);
				throw nvae;
			}

			switch (alt197) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3548:2: rt= record_term
					{
					pushFollow(FOLLOW_record_term_in_parenthesized_xxx15413);
					rt=record_term();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3548:17: -> {$rt.st}
					  {
					  	retval.st = (rt!=null?((StringTemplate)rt.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3550:2: ^( LPAREN eor= expression_or_relation RPAREN )
					{
					match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_xxx15427); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_or_relation_in_parenthesized_xxx15431);
					eor=expression_or_relation();
					state._fsp--;
					if (state.failed) return retval;
					match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_xxx15433); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3551:4: -> template(eor=$eor.st) \"(<eor>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<eor>)",new STAttrMap().put("eor", (eor!=null?((StringTemplate)eor.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3553:3: ^(lp= LPAREN pe= assertion_expression RPAREN )
					{
					lp=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_xxx15460); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_assertion_expression_in_parenthesized_xxx15464);
					pe=assertion_expression();
					state._fsp--;
					if (state.failed) return retval;
					match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_xxx15466); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3554:5: -> template(pe=$pe.st) \"(<pe>)\"
					  {
					  	retval.st = new StringTemplate(templateLib, "(<pe>)",new STAttrMap().put("pe", (pe!=null?((StringTemplate)pe.getTemplate()):null)));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3556:2: ^(lb= LPAREN p= predicate rb= RPAREN )
					{
					lb=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized_xxx15492); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_predicate_in_parenthesized_xxx15496);
					p=predicate();
					state._fsp--;
					if (state.failed) return retval;
					rb=(BAST)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized_xxx15500); if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3557:3: -> template(lb=$lb.textp=$p.strb=$rb.text) \"<lb><p><rb>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "<lb><p><rb>",new STAttrMap().put("lb", (lb!=null?lb.getText():null)).put("p", (p!=null?((StringTemplate)p.getTemplate()):null)).put("rb", (rb!=null?rb.getText():null)));
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parenthesized_xxx"


	public static class boolean_expression_or_relation_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "boolean_expression_or_relation"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3562:1: boolean_expression_or_relation : (rel= relation -> {$rel.st}|be= boolean_expression -> {$be.st});
	public final UnparseBLESS.boolean_expression_or_relation_return boolean_expression_or_relation() throws RecognitionException {
		UnparseBLESS.boolean_expression_or_relation_return retval = new UnparseBLESS.boolean_expression_or_relation_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope rel =null;
		TreeRuleReturnScope be =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3563:3: (rel= relation -> {$rel.st}|be= boolean_expression -> {$be.st})
			int alt198=2;
			int LA198_0 = input.LA(1);
			if ( ((LA198_0 >= AL && LA198_0 <= AM)||LA198_0==EQ||LA198_0==GT||LA198_0==LT||LA198_0==NEQ) ) {
				alt198=1;
			}
			else if ( (LA198_0==AADL_STRING_LITERAL||LA198_0==CASE_EXPRESSION||LA198_0==COMPLEX||LA198_0==CONDITIONAL||LA198_0==DOUBLE_COLON||LA198_0==ID||LA198_0==INMODE||LA198_0==INTEGER_LIT||LA198_0==LITERAL_and||LA198_0==LITERAL_cand||LA198_0==LITERAL_cor||LA198_0==LITERAL_false||(LA198_0 >= LITERAL_not && LA198_0 <= LITERAL_now)||LA198_0==LITERAL_null||LA198_0==LITERAL_or||LA198_0==LITERAL_timeout||LA198_0==LITERAL_tops||LA198_0==LITERAL_true||(LA198_0 >= LITERAL_xor && LA198_0 <= LPAREN)||LA198_0==OCTOTHORPE||LA198_0==PERIOD||LA198_0==QUESTION||LA198_0==RATIONAL||LA198_0==REAL_LIT||LA198_0==TICK) ) {
				alt198=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 198, 0, input);
				throw nvae;
			}

			switch (alt198) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3567:3: rel= relation
					{
					pushFollow(FOLLOW_relation_in_boolean_expression_or_relation15546);
					rel=relation();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3567:16: -> {$rel.st}
					  {
					  	retval.st = (rel!=null?((StringTemplate)rel.getTemplate()):null);
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3569:3: be= boolean_expression
					{
					pushFollow(FOLLOW_boolean_expression_in_boolean_expression_or_relation15560);
					be=boolean_expression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3570:5: -> {$be.st}
					  {
					  	retval.st = (be!=null?((StringTemplate)be.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression_or_relation"


	public static class boolean_expression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "boolean_expression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3573:1: boolean_expression : ( ^( LITERAL_and (bs+= boolean_subexpression )+ ) -> l_and(bs=$bs)| ^( LITERAL_or (bs+= boolean_subexpression )+ ) -> l_or(bs=$bs)| ^( LITERAL_xor (bs+= boolean_subexpression )+ ) -> l_and(bs=$bs)| ^( LITERAL_cand (bs+= boolean_subexpression )+ ) -> l_cand(bs=$bs)| ^( LITERAL_cor (bs+= boolean_subexpression )+ ) -> l_cor(bs=$bs)|sub= boolean_subexpression -> {$sub.st});
	public final UnparseBLESS.boolean_expression_return boolean_expression() throws RecognitionException {
		UnparseBLESS.boolean_expression_return retval = new UnparseBLESS.boolean_expression_return();
		retval.start = input.LT(1);

		List<Object> list_bs=null;
		TreeRuleReturnScope sub =null;
		RuleReturnScope bs = null;
		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3574:3: ( ^( LITERAL_and (bs+= boolean_subexpression )+ ) -> l_and(bs=$bs)| ^( LITERAL_or (bs+= boolean_subexpression )+ ) -> l_or(bs=$bs)| ^( LITERAL_xor (bs+= boolean_subexpression )+ ) -> l_and(bs=$bs)| ^( LITERAL_cand (bs+= boolean_subexpression )+ ) -> l_cand(bs=$bs)| ^( LITERAL_cor (bs+= boolean_subexpression )+ ) -> l_cor(bs=$bs)|sub= boolean_subexpression -> {$sub.st})
			int alt204=6;
			switch ( input.LA(1) ) {
			case LITERAL_and:
				{
				alt204=1;
				}
				break;
			case LITERAL_or:
				{
				alt204=2;
				}
				break;
			case LITERAL_xor:
				{
				alt204=3;
				}
				break;
			case LITERAL_cand:
				{
				alt204=4;
				}
				break;
			case LITERAL_cor:
				{
				alt204=5;
				}
				break;
			case AADL_STRING_LITERAL:
			case CASE_EXPRESSION:
			case COMPLEX:
			case CONDITIONAL:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_false:
			case LITERAL_not:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case LPAREN:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
				{
				alt204=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 204, 0, input);
				throw nvae;
			}
			switch (alt204) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3577:3: ^( LITERAL_and (bs+= boolean_subexpression )+ )
					{
					match(input,LITERAL_and,FOLLOW_LITERAL_and_in_boolean_expression15589); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3577:20: (bs+= boolean_subexpression )+
					int cnt199=0;
					loop199:
					while (true) {
						int alt199=2;
						int LA199_0 = input.LA(1);
						if ( (LA199_0==AADL_STRING_LITERAL||LA199_0==CASE_EXPRESSION||LA199_0==COMPLEX||LA199_0==CONDITIONAL||LA199_0==DOUBLE_COLON||LA199_0==ID||LA199_0==INMODE||LA199_0==INTEGER_LIT||LA199_0==LITERAL_false||(LA199_0 >= LITERAL_not && LA199_0 <= LITERAL_now)||LA199_0==LITERAL_null||LA199_0==LITERAL_timeout||LA199_0==LITERAL_tops||LA199_0==LITERAL_true||LA199_0==LPAREN||LA199_0==OCTOTHORPE||LA199_0==PERIOD||LA199_0==QUESTION||LA199_0==RATIONAL||LA199_0==REAL_LIT||LA199_0==TICK) ) {
							alt199=1;
						}

						switch (alt199) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3577:20: bs+= boolean_subexpression
							{
							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression15593);
							bs=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bs==null) list_bs=new ArrayList<Object>();
							list_bs.add(bs.getTemplate());
							}
							break;

						default :
							if ( cnt199 >= 1 ) break loop199;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(199, input);
							throw eee;
						}
						cnt199++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3578:5: -> l_and(bs=$bs)
					  {
					  	retval.st = templateLib.getInstanceOf("l_and",new STAttrMap().put("bs", list_bs));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3580:3: ^( LITERAL_or (bs+= boolean_subexpression )+ )
					{
					match(input,LITERAL_or,FOLLOW_LITERAL_or_in_boolean_expression15619); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3580:19: (bs+= boolean_subexpression )+
					int cnt200=0;
					loop200:
					while (true) {
						int alt200=2;
						int LA200_0 = input.LA(1);
						if ( (LA200_0==AADL_STRING_LITERAL||LA200_0==CASE_EXPRESSION||LA200_0==COMPLEX||LA200_0==CONDITIONAL||LA200_0==DOUBLE_COLON||LA200_0==ID||LA200_0==INMODE||LA200_0==INTEGER_LIT||LA200_0==LITERAL_false||(LA200_0 >= LITERAL_not && LA200_0 <= LITERAL_now)||LA200_0==LITERAL_null||LA200_0==LITERAL_timeout||LA200_0==LITERAL_tops||LA200_0==LITERAL_true||LA200_0==LPAREN||LA200_0==OCTOTHORPE||LA200_0==PERIOD||LA200_0==QUESTION||LA200_0==RATIONAL||LA200_0==REAL_LIT||LA200_0==TICK) ) {
							alt200=1;
						}

						switch (alt200) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3580:19: bs+= boolean_subexpression
							{
							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression15623);
							bs=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bs==null) list_bs=new ArrayList<Object>();
							list_bs.add(bs.getTemplate());
							}
							break;

						default :
							if ( cnt200 >= 1 ) break loop200;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(200, input);
							throw eee;
						}
						cnt200++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3581:5: -> l_or(bs=$bs)
					  {
					  	retval.st = templateLib.getInstanceOf("l_or",new STAttrMap().put("bs", list_bs));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3583:3: ^( LITERAL_xor (bs+= boolean_subexpression )+ )
					{
					match(input,LITERAL_xor,FOLLOW_LITERAL_xor_in_boolean_expression15649); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3583:20: (bs+= boolean_subexpression )+
					int cnt201=0;
					loop201:
					while (true) {
						int alt201=2;
						int LA201_0 = input.LA(1);
						if ( (LA201_0==AADL_STRING_LITERAL||LA201_0==CASE_EXPRESSION||LA201_0==COMPLEX||LA201_0==CONDITIONAL||LA201_0==DOUBLE_COLON||LA201_0==ID||LA201_0==INMODE||LA201_0==INTEGER_LIT||LA201_0==LITERAL_false||(LA201_0 >= LITERAL_not && LA201_0 <= LITERAL_now)||LA201_0==LITERAL_null||LA201_0==LITERAL_timeout||LA201_0==LITERAL_tops||LA201_0==LITERAL_true||LA201_0==LPAREN||LA201_0==OCTOTHORPE||LA201_0==PERIOD||LA201_0==QUESTION||LA201_0==RATIONAL||LA201_0==REAL_LIT||LA201_0==TICK) ) {
							alt201=1;
						}

						switch (alt201) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3583:20: bs+= boolean_subexpression
							{
							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression15653);
							bs=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bs==null) list_bs=new ArrayList<Object>();
							list_bs.add(bs.getTemplate());
							}
							break;

						default :
							if ( cnt201 >= 1 ) break loop201;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(201, input);
							throw eee;
						}
						cnt201++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3584:5: -> l_and(bs=$bs)
					  {
					  	retval.st = templateLib.getInstanceOf("l_and",new STAttrMap().put("bs", list_bs));
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3586:3: ^( LITERAL_cand (bs+= boolean_subexpression )+ )
					{
					match(input,LITERAL_cand,FOLLOW_LITERAL_cand_in_boolean_expression15679); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3586:21: (bs+= boolean_subexpression )+
					int cnt202=0;
					loop202:
					while (true) {
						int alt202=2;
						int LA202_0 = input.LA(1);
						if ( (LA202_0==AADL_STRING_LITERAL||LA202_0==CASE_EXPRESSION||LA202_0==COMPLEX||LA202_0==CONDITIONAL||LA202_0==DOUBLE_COLON||LA202_0==ID||LA202_0==INMODE||LA202_0==INTEGER_LIT||LA202_0==LITERAL_false||(LA202_0 >= LITERAL_not && LA202_0 <= LITERAL_now)||LA202_0==LITERAL_null||LA202_0==LITERAL_timeout||LA202_0==LITERAL_tops||LA202_0==LITERAL_true||LA202_0==LPAREN||LA202_0==OCTOTHORPE||LA202_0==PERIOD||LA202_0==QUESTION||LA202_0==RATIONAL||LA202_0==REAL_LIT||LA202_0==TICK) ) {
							alt202=1;
						}

						switch (alt202) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3586:21: bs+= boolean_subexpression
							{
							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression15683);
							bs=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bs==null) list_bs=new ArrayList<Object>();
							list_bs.add(bs.getTemplate());
							}
							break;

						default :
							if ( cnt202 >= 1 ) break loop202;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(202, input);
							throw eee;
						}
						cnt202++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3587:5: -> l_cand(bs=$bs)
					  {
					  	retval.st = templateLib.getInstanceOf("l_cand",new STAttrMap().put("bs", list_bs));
					  }


					}

					}
					break;
				case 5 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3589:3: ^( LITERAL_cor (bs+= boolean_subexpression )+ )
					{
					match(input,LITERAL_cor,FOLLOW_LITERAL_cor_in_boolean_expression15709); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3589:20: (bs+= boolean_subexpression )+
					int cnt203=0;
					loop203:
					while (true) {
						int alt203=2;
						int LA203_0 = input.LA(1);
						if ( (LA203_0==AADL_STRING_LITERAL||LA203_0==CASE_EXPRESSION||LA203_0==COMPLEX||LA203_0==CONDITIONAL||LA203_0==DOUBLE_COLON||LA203_0==ID||LA203_0==INMODE||LA203_0==INTEGER_LIT||LA203_0==LITERAL_false||(LA203_0 >= LITERAL_not && LA203_0 <= LITERAL_now)||LA203_0==LITERAL_null||LA203_0==LITERAL_timeout||LA203_0==LITERAL_tops||LA203_0==LITERAL_true||LA203_0==LPAREN||LA203_0==OCTOTHORPE||LA203_0==PERIOD||LA203_0==QUESTION||LA203_0==RATIONAL||LA203_0==REAL_LIT||LA203_0==TICK) ) {
							alt203=1;
						}

						switch (alt203) {
						case 1 :
							// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3589:20: bs+= boolean_subexpression
							{
							pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression15713);
							bs=boolean_subexpression();
							state._fsp--;
							if (state.failed) return retval;
							if (list_bs==null) list_bs=new ArrayList<Object>();
							list_bs.add(bs.getTemplate());
							}
							break;

						default :
							if ( cnt203 >= 1 ) break loop203;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(203, input);
							throw eee;
						}
						cnt203++;
					}

					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3590:5: -> l_cor(bs=$bs)
					  {
					  	retval.st = templateLib.getInstanceOf("l_cor",new STAttrMap().put("bs", list_bs));
					  }


					}

					}
					break;
				case 6 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3592:3: sub= boolean_subexpression
					{
					pushFollow(FOLLOW_boolean_subexpression_in_boolean_expression15739);
					sub=boolean_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3593:5: -> {$sub.st}
					  {
					  	retval.st = (sub!=null?((StringTemplate)sub.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_expression"


	public static class boolean_subexpression_return extends TreeRuleReturnScope {
		public StringTemplate st;
		public Object getTemplate() { return st; }
		public String toString() { return st==null?null:st.toString(); }
	};


	// $ANTLR start "boolean_subexpression"
	// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3612:1: boolean_subexpression : ( ^( LITERAL_not v= value ) -> template(v=$v.st) \"not <v>\"| ^( LITERAL_not ps= parenthesized_subexpression ) -> template(ps=$ps.st) \"not <ps>\"|v= value -> {$v.st}|ps= parenthesized_subexpression -> {$ps.st});
	public final UnparseBLESS.boolean_subexpression_return boolean_subexpression() throws RecognitionException {
		UnparseBLESS.boolean_subexpression_return retval = new UnparseBLESS.boolean_subexpression_return();
		retval.start = input.LT(1);

		TreeRuleReturnScope v =null;
		TreeRuleReturnScope ps =null;

		try {
			// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3613:3: ( ^( LITERAL_not v= value ) -> template(v=$v.st) \"not <v>\"| ^( LITERAL_not ps= parenthesized_subexpression ) -> template(ps=$ps.st) \"not <ps>\"|v= value -> {$v.st}|ps= parenthesized_subexpression -> {$ps.st})
			int alt205=4;
			switch ( input.LA(1) ) {
			case LITERAL_not:
				{
				int LA205_1 = input.LA(2);
				if ( (LA205_1==DOWN) ) {
					int LA205_4 = input.LA(3);
					if ( (LA205_4==AADL_STRING_LITERAL||LA205_4==COMPLEX||LA205_4==DOUBLE_COLON||LA205_4==ID||LA205_4==INMODE||LA205_4==INTEGER_LIT||LA205_4==LITERAL_false||LA205_4==LITERAL_now||LA205_4==LITERAL_null||LA205_4==LITERAL_timeout||LA205_4==LITERAL_tops||LA205_4==LITERAL_true||LA205_4==OCTOTHORPE||LA205_4==PERIOD||LA205_4==QUESTION||LA205_4==RATIONAL||LA205_4==REAL_LIT||LA205_4==TICK) ) {
						alt205=1;
					}
					else if ( (LA205_4==CASE_EXPRESSION||LA205_4==CONDITIONAL||LA205_4==LPAREN) ) {
						alt205=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 205, 4, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 205, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case AADL_STRING_LITERAL:
			case COMPLEX:
			case DOUBLE_COLON:
			case ID:
			case INMODE:
			case INTEGER_LIT:
			case LITERAL_false:
			case LITERAL_now:
			case LITERAL_null:
			case LITERAL_timeout:
			case LITERAL_tops:
			case LITERAL_true:
			case OCTOTHORPE:
			case PERIOD:
			case QUESTION:
			case RATIONAL:
			case REAL_LIT:
			case TICK:
				{
				alt205=3;
				}
				break;
			case CASE_EXPRESSION:
			case CONDITIONAL:
			case LPAREN:
				{
				alt205=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 205, 0, input);
				throw nvae;
			}
			switch (alt205) {
				case 1 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3614:3: ^( LITERAL_not v= value )
					{
					match(input,LITERAL_not,FOLLOW_LITERAL_not_in_boolean_subexpression15766); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_value_in_boolean_subexpression15770);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3615:5: -> template(v=$v.st) \"not <v>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "not <v>",new STAttrMap().put("v", (v!=null?((StringTemplate)v.getTemplate()):null)));
					  }


					}

					}
					break;
				case 2 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3617:3: ^( LITERAL_not ps= parenthesized_subexpression )
					{
					match(input,LITERAL_not,FOLLOW_LITERAL_not_in_boolean_subexpression15794); if (state.failed) return retval;
					match(input, Token.DOWN, null); if (state.failed) return retval;
					pushFollow(FOLLOW_parenthesized_subexpression_in_boolean_subexpression15798);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					match(input, Token.UP, null); if (state.failed) return retval;

					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3618:5: -> template(ps=$ps.st) \"not <ps>\"
					  {
					  	retval.st = new StringTemplate(templateLib, "not <ps>",new STAttrMap().put("ps", (ps!=null?((StringTemplate)ps.getTemplate()):null)));
					  }


					}

					}
					break;
				case 3 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3620:3: v= value
					{
					pushFollow(FOLLOW_value_in_boolean_subexpression15823);
					v=value();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3621:5: -> {$v.st}
					  {
					  	retval.st = (v!=null?((StringTemplate)v.getTemplate()):null);
					  }


					}

					}
					break;
				case 4 :
					// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3623:3: ps= parenthesized_subexpression
					{
					pushFollow(FOLLOW_parenthesized_subexpression_in_boolean_subexpression15841);
					ps=parenthesized_subexpression();
					state._fsp--;
					if (state.failed) return retval;
					// TEMPLATE REWRITE
					if ( state.backtracking==0 ) {
					  // 3624:5: -> {$ps.st}
					  {
					  	retval.st = (ps!=null?((StringTemplate)ps.getTemplate()):null);
					  }


					}

					}
					break;

			}
		}

		catch (RecognitionException re) 
			{
			countRecognitionErrors++;
			Dump.it("recognition error #"+countRecognitionErrors);
			recognitionErrorOccurred=true;
		  if (retval==null)
		    Dump.it("null retval");
		  else 
		  {
		  Dump.it("retval.getClass()="+retval.getClass());
		  if (retval.start==null)
		    Dump.it("null retval.start");
		  else if (retval.start instanceof BAST)
			BLESSmarker.setWarningMarker("UnparseBLESS recognition error:  "+
			  ((BAST)retval.start).toStringTree(),(BAST)retval.start);
			else
			  {
			  Dump.it("retval.start not instanceof BAST:  "+retval.toString());
			  }
			}
		  reportError(re);
			}

		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_subexpression"

	// $ANTLR start synpred1_UnparseBLESS
	public final void synpred1_UnparseBLESS_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2677:2: ( LITERAL_all )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2677:3: LITERAL_all
		{
		match(input,LITERAL_all,FOLLOW_LITERAL_all_in_synpred1_UnparseBLESS9834); if (state.failed) return;
		}

	}
	// $ANTLR end synpred1_UnparseBLESS

	// $ANTLR start synpred2_UnparseBLESS
	public final void synpred2_UnparseBLESS_fragment() throws RecognitionException {
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2682:2: ( LITERAL_exists )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:2682:3: LITERAL_exists
		{
		match(input,LITERAL_exists,FOLLOW_LITERAL_exists_in_synpred2_UnparseBLESS9855); if (state.failed) return;
		}

	}
	// $ANTLR end synpred2_UnparseBLESS

	// $ANTLR start synpred3_UnparseBLESS
	public final void synpred3_UnparseBLESS_fragment() throws RecognitionException {
		TreeRuleReturnScope rt =null;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3548:2: (rt= record_term )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3548:2: rt= record_term
		{
		pushFollow(FOLLOW_record_term_in_synpred3_UnparseBLESS15413);
		rt=record_term();
		state._fsp--;
		if (state.failed) return;
		}

	}
	// $ANTLR end synpred3_UnparseBLESS

	// $ANTLR start synpred4_UnparseBLESS
	public final void synpred4_UnparseBLESS_fragment() throws RecognitionException {
		TreeRuleReturnScope eor =null;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3550:2: ( ^( LPAREN eor= expression_or_relation RPAREN ) )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3550:2: ^( LPAREN eor= expression_or_relation RPAREN )
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred4_UnparseBLESS15427); if (state.failed) return;
		match(input, Token.DOWN, null); if (state.failed) return;
		pushFollow(FOLLOW_expression_or_relation_in_synpred4_UnparseBLESS15431);
		eor=expression_or_relation();
		state._fsp--;
		if (state.failed) return;
		match(input,RPAREN,FOLLOW_RPAREN_in_synpred4_UnparseBLESS15433); if (state.failed) return;
		match(input, Token.UP, null); if (state.failed) return;

		}

	}
	// $ANTLR end synpred4_UnparseBLESS

	// $ANTLR start synpred5_UnparseBLESS
	public final void synpred5_UnparseBLESS_fragment() throws RecognitionException {
		BAST lp=null;
		TreeRuleReturnScope pe =null;

		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3553:3: ( ^(lp= LPAREN pe= assertion_expression RPAREN ) )
		// /Users/brianlarson/git2/BLESS-IDE/bless/Grammars/UnparseBLESS.g:3553:3: ^(lp= LPAREN pe= assertion_expression RPAREN )
		{
		lp=(BAST)match(input,LPAREN,FOLLOW_LPAREN_in_synpred5_UnparseBLESS15460); if (state.failed) return;
		match(input, Token.DOWN, null); if (state.failed) return;
		pushFollow(FOLLOW_assertion_expression_in_synpred5_UnparseBLESS15464);
		pe=assertion_expression();
		state._fsp--;
		if (state.failed) return;
		match(input,RPAREN,FOLLOW_RPAREN_in_synpred5_UnparseBLESS15466); if (state.failed) return;
		match(input, Token.UP, null); if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_UnparseBLESS

	// Delegated rules

	public final boolean synpred2_UnparseBLESS() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_UnparseBLESS_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_UnparseBLESS() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_UnparseBLESS_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred3_UnparseBLESS() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_UnparseBLESS_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred5_UnparseBLESS() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_UnparseBLESS_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_UnparseBLESS() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_UnparseBLESS_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA54 dfa54 = new DFA54(this);
	protected DFA95 dfa95 = new DFA95(this);
	protected DFA110 dfa110 = new DFA110(this);
	protected DFA118 dfa118 = new DFA118(this);
	protected DFA163 dfa163 = new DFA163(this);
	protected DFA174 dfa174 = new DFA174(this);
	protected DFA191 dfa191 = new DFA191(this);
	static final String DFA54_eotS =
		"\27\uffff";
	static final String DFA54_eofS =
		"\27\uffff";
	static final String DFA54_minS =
		"\1\u00b6\2\2\2\uffff\2\77\2\3\2\2\4\uffff\2\77\1\3\1\103\1\3\1\u0113\2"+
		"\3";
	static final String DFA54_maxS =
		"\1\u010c\2\2\2\uffff\1\77\1\u0103\1\u0124\1\u012c\2\2\4\uffff\3\77\1\103"+
		"\1\u012c\1\u0113\1\3\1\u012c";
	static final String DFA54_acceptS =
		"\3\uffff\1\5\1\6\6\uffff\1\2\1\1\1\3\1\4\10\uffff";
	static final String DFA54_specialS =
		"\27\uffff}>";
	static final String[] DFA54_transitionS = {
			"\1\4\121\uffff\1\3\1\2\2\uffff\1\1",
			"\1\5",
			"\1\6",
			"",
			"",
			"\1\7",
			"\1\10\15\uffff\1\12\u00b5\uffff\1\11",
			"\1\13\1\14\26\uffff\2\14\1\uffff\1\14\2\uffff\1\14\2\uffff\1\14\11\uffff"+
			"\1\14\20\uffff\1\14\3\uffff\1\14\100\uffff\1\14\143\uffff\1\14\15\uffff"+
			"\1\14\7\uffff\1\14\4\uffff\1\14\16\uffff\1\14\3\uffff\1\14\15\uffff\1"+
			"\14",
			"\1\16\1\15\2\uffff\2\15\22\uffff\1\15\5\uffff\1\15\2\uffff\1\15\5\uffff"+
			"\1\15\3\uffff\1\15\5\uffff\1\15\1\uffff\1\15\4\uffff\2\15\2\uffff\1\15"+
			"\1\uffff\1\15\1\uffff\1\15\31\uffff\1\15\14\uffff\1\15\3\uffff\1\15\5"+
			"\uffff\1\15\17\uffff\1\15\27\uffff\1\15\7\uffff\1\15\3\uffff\1\15\2\uffff"+
			"\2\15\1\uffff\1\15\3\uffff\1\15\23\uffff\2\15\2\uffff\1\15\27\uffff\2"+
			"\15\1\uffff\1\15\2\uffff\1\15\14\uffff\3\15\2\uffff\1\15\1\uffff\1\15"+
			"\1\uffff\1\15\4\uffff\2\15\13\uffff\1\15\1\uffff\1\15\3\uffff\1\15\15"+
			"\uffff\1\15\1\uffff\1\15\5\uffff\1\15",
			"\1\17",
			"\1\20",
			"",
			"",
			"",
			"",
			"\1\21",
			"\1\22",
			"\1\23\73\uffff\1\21",
			"\1\24",
			"\1\16\1\15\2\uffff\2\15\22\uffff\1\15\5\uffff\1\15\2\uffff\1\15\5\uffff"+
			"\1\15\3\uffff\1\15\5\uffff\1\15\1\uffff\1\15\4\uffff\2\15\2\uffff\1\15"+
			"\1\uffff\1\15\1\uffff\1\15\31\uffff\1\15\14\uffff\1\15\3\uffff\1\15\5"+
			"\uffff\1\15\17\uffff\1\15\27\uffff\1\15\7\uffff\1\15\3\uffff\1\15\2\uffff"+
			"\2\15\1\uffff\1\15\3\uffff\1\15\23\uffff\2\15\2\uffff\1\15\27\uffff\2"+
			"\15\1\uffff\1\15\2\uffff\1\15\14\uffff\3\15\2\uffff\1\15\1\uffff\1\15"+
			"\1\uffff\1\15\4\uffff\2\15\13\uffff\1\15\1\uffff\1\15\3\uffff\1\15\15"+
			"\uffff\1\15\1\uffff\1\15\5\uffff\1\15",
			"\1\25",
			"\1\26",
			"\1\16\1\15\2\uffff\2\15\22\uffff\1\15\5\uffff\1\15\2\uffff\1\15\5\uffff"+
			"\1\15\3\uffff\1\15\5\uffff\1\15\1\uffff\1\15\4\uffff\2\15\2\uffff\1\15"+
			"\1\uffff\1\15\1\uffff\1\15\31\uffff\1\15\14\uffff\1\15\3\uffff\1\15\5"+
			"\uffff\1\15\17\uffff\1\15\27\uffff\1\15\7\uffff\1\15\3\uffff\1\15\2\uffff"+
			"\2\15\1\uffff\1\15\3\uffff\1\15\23\uffff\2\15\2\uffff\1\15\27\uffff\2"+
			"\15\1\uffff\1\15\2\uffff\1\15\14\uffff\3\15\2\uffff\1\15\1\uffff\1\15"+
			"\1\uffff\1\15\4\uffff\2\15\13\uffff\1\15\1\uffff\1\15\3\uffff\1\15\15"+
			"\uffff\1\15\1\uffff\1\15\5\uffff\1\15"
	};

	static final short[] DFA54_eot = DFA.unpackEncodedString(DFA54_eotS);
	static final short[] DFA54_eof = DFA.unpackEncodedString(DFA54_eofS);
	static final char[] DFA54_min = DFA.unpackEncodedStringToUnsignedChars(DFA54_minS);
	static final char[] DFA54_max = DFA.unpackEncodedStringToUnsignedChars(DFA54_maxS);
	static final short[] DFA54_accept = DFA.unpackEncodedString(DFA54_acceptS);
	static final short[] DFA54_special = DFA.unpackEncodedString(DFA54_specialS);
	static final short[][] DFA54_transition;

	static {
		int numStates = DFA54_transitionS.length;
		DFA54_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA54_transition[i] = DFA.unpackEncodedString(DFA54_transitionS[i]);
		}
	}

	protected class DFA54 extends DFA {

		public DFA54(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 54;
			this.eot = DFA54_eot;
			this.eof = DFA54_eof;
			this.min = DFA54_min;
			this.max = DFA54_max;
			this.accept = DFA54_accept;
			this.special = DFA54_special;
			this.transition = DFA54_transition;
		}
		@Override
		public String getDescription() {
			return "1703:1: communication : ( ^( PROCEDURE_CALL p= ID spb= formal_actual_list ) -> procedure_call(p=$p.textspb=$spb.st)| ^( PROCEDURE_CALL p= ID ) -> procedure_call(p=$p.text)| ^( PORT_OUTPUT o= port_name be= expression_or_relation ) -> port_output(o=$o.stbe=$be.st)| ^( PORT_OUTPUT o= port_name ) -> event_port_output(o=$o.st)| ^( PORT_INPUT i= port_name n= name ) -> port_input(i=$i.stn=$n.st)|pause= LITERAL_pause -> {%{$pause.text}});";
		}
	}

	static final String DFA95_eotS =
		"\31\uffff";
	static final String DFA95_eofS =
		"\31\uffff";
	static final String DFA95_minS =
		"\1\4\1\uffff\1\2\7\uffff\2\77\2\2\3\uffff\2\77\1\3\1\103\1\165\1\u0113"+
		"\1\3\1\165";
	static final String DFA95_maxS =
		"\1\u0124\1\uffff\1\2\7\uffff\1\u0103\1\u00ec\2\2\3\uffff\3\77\1\103\1"+
		"\u00ec\1\u0113\1\3\1\u00ec";
	static final String DFA95_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\1\3\1\7\1\10\1\11\1\12\1\13\4\uffff\1\4\1\5\1"+
		"\6\10\uffff";
	static final String DFA95_specialS =
		"\31\uffff}>";
	static final String[] DFA95_transitionS = {
			"\1\1\34\uffff\1\1\14\uffff\1\1\20\uffff\1\3\1\uffff\1\5\1\uffff\1\1\100"+
			"\uffff\1\1\47\uffff\1\10\1\uffff\1\7\64\uffff\1\6\1\uffff\1\11\2\uffff"+
			"\1\1\25\uffff\1\1\4\uffff\1\3\14\uffff\1\4\1\uffff\1\1\3\uffff\1\1\15"+
			"\uffff\1\2",
			"",
			"\1\12",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\13\15\uffff\1\15\u00b5\uffff\1\14",
			"\1\1\65\uffff\1\17\33\uffff\1\16\132\uffff\1\20",
			"\1\21",
			"\1\22",
			"",
			"",
			"",
			"\1\23",
			"\1\24",
			"\1\25\73\uffff\1\23",
			"\1\26",
			"\1\17\33\uffff\1\16\132\uffff\1\20",
			"\1\27",
			"\1\30",
			"\1\17\33\uffff\1\16\132\uffff\1\20"
	};

	static final short[] DFA95_eot = DFA.unpackEncodedString(DFA95_eotS);
	static final short[] DFA95_eof = DFA.unpackEncodedString(DFA95_eofS);
	static final char[] DFA95_min = DFA.unpackEncodedStringToUnsignedChars(DFA95_minS);
	static final char[] DFA95_max = DFA.unpackEncodedStringToUnsignedChars(DFA95_maxS);
	static final short[] DFA95_accept = DFA.unpackEncodedString(DFA95_acceptS);
	static final short[] DFA95_special = DFA.unpackEncodedString(DFA95_specialS);
	static final short[][] DFA95_transition;

	static {
		int numStates = DFA95_transitionS.length;
		DFA95_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA95_transition[i] = DFA.unpackEncodedString(DFA95_transitionS[i]);
		}
	}

	protected class DFA95 extends DFA {

		public DFA95(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 95;
			this.eot = DFA95_eot;
			this.eof = DFA95_eof;
			this.min = DFA95_min;
			this.max = DFA95_max;
			this.accept = DFA95_accept;
			this.special = DFA95_special;
			this.transition = DFA95_transition;
		}
		@Override
		public String getDescription() {
			return "2097:1: value : (vc= value_constant -> {$vc.st}|vn= variable_name -> {$vn.st}| ^( QUESTION pn= port_name ) -> in_port_value(pn=$pn.st)| ^( TICK pn= port_name LITERAL_fresh ) -> port_fresh(i=$pn.st)| ^( TICK pn= port_name LITERAL_count ) -> port_count(i=$pn.st)| ^( TICK pn= port_name LITERAL_updated ) -> port_updated(i=$pn.st)| ^( INMODE (m+= ID )+ ) -> template(m=$m) \"in mode (<m; separator=\" \">)\"|to= LITERAL_timeout -> {%{$to.text}}|nu= LITERAL_null -> {%{$nu.text}}|now= LITERAL_now -> now(|tops= LITERAL_tops -> {%{$tops.text}});";
		}
	}

	static final String DFA110_eotS =
		"\u0116\uffff";
	static final String DFA110_eofS =
		"\u0116\uffff";
	static final String DFA110_minS =
		"\1\55\1\2\1\41\1\2\2\41\4\2\1\41\2\uffff\1\103\1\u00fa\1\77\1\56\2\3\4"+
		"\2\1\103\1\2\1\u00fa\1\2\1\77\1\56\2\2\1\56\1\41\1\103\1\u00fa\1\77\1"+
		"\56\1\3\1\2\1\103\1\3\1\2\1\u0116\1\3\1\2\2\77\1\2\2\uffff\1\103\1\2\1"+
		"\u00fa\1\2\1\77\1\56\2\2\1\56\1\41\1\103\1\3\1\41\1\u0116\1\3\1\41\1\77"+
		"\1\3\2\77\1\3\1\2\1\103\1\3\1\2\1\u0116\1\3\1\2\2\77\1\2\1\3\1\103\1\3"+
		"\1\u00fa\1\77\1\3\1\56\1\2\1\3\1\77\1\3\1\103\2\3\1\u0116\2\3\1\77\1\3"+
		"\2\77\2\3\1\2\2\3\1\2\3\3\1\77\1\56\2\3\1\103\1\3\1\u00fa\1\77\1\3\1\56"+
		"\1\2\1\3\1\77\2\41\1\103\2\41\1\u0116\1\3\1\41\2\2\4\3\1\2\2\3\1\2\3\3"+
		"\1\77\1\56\3\3\1\41\2\2\2\77\1\3\1\41\2\2\2\3\1\103\2\3\1\u0116\2\3\2"+
		"\2\4\3\2\77\2\u0113\3\3\1\56\2\77\3\3\2\2\2\77\2\3\2\2\2\41\2\u0113\10"+
		"\3\2\u0113\5\3\2\77\2\u0113\3\3\1\56\2\77\7\3\1\41\7\3\2\u0113\10\3\2"+
		"\u0113\5\3\1\41\2\3\1\41\23\3";
	static final String DFA110_maxS =
		"\1\55\1\2\1\u012c\1\2\2\u012c\4\2\1\u0116\2\uffff\1\u00fa\1\u0116\1\77"+
		"\1\u0103\2\3\4\2\1\u00fa\1\2\1\u0116\1\2\1\77\1\56\2\2\1\56\1\u012c\1"+
		"\u00fa\1\u0116\1\77\1\u0103\1\3\1\2\1\103\1\3\1\2\1\u0116\1\3\1\2\2\77"+
		"\1\2\2\uffff\1\u00fa\1\2\1\u0116\1\2\1\77\1\56\2\2\1\56\1\u012c\1\103"+
		"\1\3\1\u012c\1\u0116\1\3\1\u012c\1\77\1\u0103\2\77\1\3\1\2\1\103\1\3\1"+
		"\2\1\u0116\1\3\1\2\2\77\1\2\1\3\1\u00fa\1\3\1\u0116\1\77\1\u0103\1\56"+
		"\1\2\1\3\1\77\1\3\1\103\2\3\1\u0116\2\3\1\77\1\u0103\2\77\2\3\1\2\2\3"+
		"\1\2\1\3\2\u0103\1\77\1\56\2\3\1\u00fa\1\3\1\u0116\1\77\1\u0103\1\56\1"+
		"\2\1\3\1\77\2\u012c\1\103\2\u012c\1\u0116\1\u0103\1\u012c\2\2\1\3\1\u0103"+
		"\2\3\1\2\2\3\1\2\1\3\2\u0103\1\77\1\56\3\3\1\u012c\2\2\1\103\1\u00ed\1"+
		"\3\1\u012c\2\2\2\3\1\103\2\3\1\u0116\1\u0103\1\3\2\2\1\3\1\u0103\2\3\1"+
		"\103\1\u00ed\2\u0113\3\3\1\56\1\103\1\u00ed\3\3\2\2\1\103\1\u00ed\2\3"+
		"\2\2\2\u012c\2\u0113\5\3\3\u0103\2\u0113\5\3\1\103\1\u00ed\2\u0113\3\3"+
		"\1\56\1\103\1\u00ed\2\3\5\u0103\1\u012c\2\3\3\u0103\2\3\2\u0113\5\3\3"+
		"\u0103\2\u0113\3\3\2\u0103\1\u012c\2\u0103\1\u012c\2\3\5\u0103\3\3\5\u0103"+
		"\1\3\2\u0103\1\3";
	static final String DFA110_acceptS =
		"\13\uffff\1\1\1\3\43\uffff\1\4\1\2\u00e4\uffff";
	static final String DFA110_specialS =
		"\u0116\uffff}>";
	static final String[] DFA110_transitionS = {
			"\1\1",
			"\1\2",
			"\1\7\14\uffff\1\10\24\uffff\1\4\u00ba\uffff\1\11\23\uffff\1\6\3\uffff"+
			"\1\5\25\uffff\1\3",
			"\1\12",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\15",
			"\1\16",
			"\1\17",
			"\1\20",
			"\1\24\14\uffff\1\25\24\uffff\1\21\u00ba\uffff\1\26\23\uffff\1\23\3\uffff"+
			"\1\22",
			"",
			"",
			"\1\27\u00b6\uffff\1\30",
			"\1\32\33\uffff\1\31",
			"\1\33",
			"\1\35\20\uffff\1\37\u008e\uffff\1\34\64\uffff\1\36",
			"\1\40",
			"\1\40",
			"\1\41",
			"\1\42",
			"\1\43",
			"\1\44",
			"\1\45\u00b6\uffff\1\46",
			"\1\47",
			"\1\51\33\uffff\1\50",
			"\1\52",
			"\1\53",
			"\1\54",
			"\1\55",
			"\1\56",
			"\1\57",
			"\1\61\14\uffff\1\61\24\uffff\1\61\u00ba\uffff\1\61\23\uffff\1\61\3\uffff"+
			"\1\61\25\uffff\1\60",
			"\1\62\u00b6\uffff\1\63",
			"\1\65\33\uffff\1\64",
			"\1\66",
			"\1\70\20\uffff\1\72\u008e\uffff\1\67\64\uffff\1\71",
			"\1\73",
			"\1\74",
			"\1\75",
			"\1\76",
			"\1\77",
			"\1\100",
			"\1\101",
			"\1\102",
			"\1\103",
			"\1\104",
			"\1\105",
			"",
			"",
			"\1\106\u00b6\uffff\1\107",
			"\1\110",
			"\1\112\33\uffff\1\111",
			"\1\113",
			"\1\114",
			"\1\115",
			"\1\116",
			"\1\117",
			"\1\120",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\121",
			"\1\122",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\123",
			"\1\124",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\125",
			"\1\127\73\uffff\1\126\u00c3\uffff\1\130",
			"\1\131",
			"\1\132",
			"\1\133",
			"\1\134",
			"\1\135",
			"\1\136",
			"\1\137",
			"\1\140",
			"\1\141",
			"\1\142",
			"\1\143",
			"\1\144",
			"\1\145",
			"\1\146",
			"\1\147\u00b6\uffff\1\150",
			"\1\151",
			"\1\153\33\uffff\1\152",
			"\1\154",
			"\1\155\73\uffff\1\156\u00c3\uffff\1\130",
			"\1\57",
			"\1\157",
			"\1\160",
			"\1\161",
			"\1\40",
			"\1\162",
			"\1\163",
			"\1\40",
			"\1\164",
			"\1\165",
			"\1\40",
			"\1\166",
			"\1\170\73\uffff\1\167\u00c3\uffff\1\171",
			"\1\172",
			"\1\173",
			"\1\174",
			"\1\175",
			"\1\176",
			"\1\177",
			"\1\u0080",
			"\1\u0081",
			"\1\u0082",
			"\1\u0083\52\uffff\1\57\36\uffff\1\u0084\u00b5\uffff\1\u0085",
			"\1\127\73\uffff\1\156\u00c3\uffff\1\130",
			"\1\u0086",
			"\1\57",
			"\1\u0087",
			"\1\u0088",
			"\1\u0089\u00b6\uffff\1\u008a",
			"\1\u008b",
			"\1\u008d\33\uffff\1\u008c",
			"\1\u008e",
			"\1\u008f\73\uffff\1\u0090\u00c3\uffff\1\171",
			"\1\120",
			"\1\u0091",
			"\1\u0092",
			"\1\u0093",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u0094",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u0095",
			"\1\u0096\111\uffff\1\u0097\u00b5\uffff\1\u0098",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u0099",
			"\1\u009a",
			"\1\u009b",
			"\1\u009c\111\uffff\1\u009d\u00b5\uffff\1\u009e",
			"\1\u009f",
			"\1\u00a0",
			"\1\u00a1",
			"\1\u00a2",
			"\1\u00a3",
			"\1\u00a4",
			"\1\u00a5",
			"\1\u00a6\52\uffff\1\120\36\uffff\1\u00a7\u00b5\uffff\1\u00a8",
			"\1\170\73\uffff\1\u0090\u00c3\uffff\1\171",
			"\1\u00a9",
			"\1\120",
			"\1\u00aa",
			"\1\u00ab",
			"\1\u00ac",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u00ad",
			"\1\u00ae",
			"\1\u00b0\3\uffff\1\u00af",
			"\1\u00b1\141\uffff\1\u00b3\113\uffff\1\u00b2",
			"\1\u00b4",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u00b5",
			"\1\u00b6",
			"\1\40",
			"\1\40",
			"\1\u00b7",
			"\1\40",
			"\1\40",
			"\1\u00b8",
			"\1\u00b9\111\uffff\1\u00ba\u00b5\uffff\1\u00bb",
			"\1\40",
			"\1\u00bc",
			"\1\u00bd",
			"\1\u00be",
			"\1\u00bf\111\uffff\1\u00c0\u00b5\uffff\1\u00c1",
			"\1\u00c2",
			"\1\u00c3",
			"\1\u00c5\3\uffff\1\u00c4",
			"\1\u00c6\141\uffff\1\u00c8\113\uffff\1\u00c7",
			"\1\u00c9",
			"\1\u00ca",
			"\1\u00cb",
			"\1\u00cc",
			"\1\u00cd",
			"\1\57",
			"\1\u00cf\3\uffff\1\u00ce",
			"\1\u00d0\141\uffff\1\u00d2\113\uffff\1\u00d1",
			"\1\u00d3",
			"\1\u00d4",
			"\1\40",
			"\1\u00d5",
			"\1\u00d6",
			"\1\u00d8\3\uffff\1\u00d7",
			"\1\u00d9\141\uffff\1\u00db\113\uffff\1\u00da",
			"\1\u00dc",
			"\1\40",
			"\1\u00dd",
			"\1\u00de",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u00df",
			"\1\u00e0",
			"\1\u00e1",
			"\1\u00e2",
			"\1\u00e3",
			"\1\u00e4",
			"\1\u00e5",
			"\1\u00e6\111\uffff\1\u0084\u00b5\uffff\1\u0085",
			"\1\u00e6\111\uffff\1\u0084\u00b5\uffff\1\u0085",
			"\1\u00e6\111\uffff\1\u0084\u00b5\uffff\1\u0085",
			"\1\u00e7",
			"\1\u00e8",
			"\1\u00e9",
			"\1\u00ea",
			"\1\u00eb",
			"\1\u00ec",
			"\1\u00ed",
			"\1\u00ef\3\uffff\1\u00ee",
			"\1\u00f0\141\uffff\1\u00f2\113\uffff\1\u00f1",
			"\1\u00f3",
			"\1\u00f4",
			"\1\u00f5",
			"\1\u00f6",
			"\1\u00f7",
			"\1\120",
			"\1\u00f9\3\uffff\1\u00f8",
			"\1\u00fa\141\uffff\1\u00fc\113\uffff\1\u00fb",
			"\1\u00fd",
			"\1\u00fe",
			"\1\u00ff\111\uffff\1\u0097\u00b5\uffff\1\u0098",
			"\1\u00ff\111\uffff\1\u0097\u00b5\uffff\1\u0098",
			"\1\u00ff\111\uffff\1\u0097\u00b5\uffff\1\u0098",
			"\1\u00e6\111\uffff\1\u0084\u00b5\uffff\1\u0085",
			"\1\u00e6\111\uffff\1\u0084\u00b5\uffff\1\u0085",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u0100",
			"\1\u0101",
			"\1\u0102\111\uffff\1\u009d\u00b5\uffff\1\u009e",
			"\1\u0102\111\uffff\1\u009d\u00b5\uffff\1\u009e",
			"\1\u0102\111\uffff\1\u009d\u00b5\uffff\1\u009e",
			"\1\40",
			"\1\40",
			"\1\u0103",
			"\1\u0104",
			"\1\u0105",
			"\1\u0106",
			"\1\u0107",
			"\1\u0108",
			"\1\u0109",
			"\1\u010a\111\uffff\1\u00a7\u00b5\uffff\1\u00a8",
			"\1\u010a\111\uffff\1\u00a7\u00b5\uffff\1\u00a8",
			"\1\u010a\111\uffff\1\u00a7\u00b5\uffff\1\u00a8",
			"\1\u010b",
			"\1\u010c",
			"\1\u010d",
			"\1\u010e",
			"\1\u010f",
			"\1\u00ff\111\uffff\1\u0097\u00b5\uffff\1\u0098",
			"\1\u00ff\111\uffff\1\u0097\u00b5\uffff\1\u0098",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u0102\111\uffff\1\u009d\u00b5\uffff\1\u009e",
			"\1\u0102\111\uffff\1\u009d\u00b5\uffff\1\u009e",
			"\1\13\14\uffff\1\13\24\uffff\1\13\u00ba\uffff\1\13\23\uffff\1\13\3\uffff"+
			"\1\13\25\uffff\1\14",
			"\1\u0110",
			"\1\u0111",
			"\1\u0112\111\uffff\1\u00ba\u00b5\uffff\1\u00bb",
			"\1\u0112\111\uffff\1\u00ba\u00b5\uffff\1\u00bb",
			"\1\u0112\111\uffff\1\u00ba\u00b5\uffff\1\u00bb",
			"\1\u010a\111\uffff\1\u00a7\u00b5\uffff\1\u00a8",
			"\1\u010a\111\uffff\1\u00a7\u00b5\uffff\1\u00a8",
			"\1\40",
			"\1\u0113",
			"\1\u0114",
			"\1\u0115\111\uffff\1\u00c0\u00b5\uffff\1\u00c1",
			"\1\u0115\111\uffff\1\u00c0\u00b5\uffff\1\u00c1",
			"\1\u0115\111\uffff\1\u00c0\u00b5\uffff\1\u00c1",
			"\1\u0112\111\uffff\1\u00ba\u00b5\uffff\1\u00bb",
			"\1\u0112\111\uffff\1\u00ba\u00b5\uffff\1\u00bb",
			"\1\40",
			"\1\u0115\111\uffff\1\u00c0\u00b5\uffff\1\u00c1",
			"\1\u0115\111\uffff\1\u00c0\u00b5\uffff\1\u00c1",
			"\1\40"
	};

	static final short[] DFA110_eot = DFA.unpackEncodedString(DFA110_eotS);
	static final short[] DFA110_eof = DFA.unpackEncodedString(DFA110_eofS);
	static final char[] DFA110_min = DFA.unpackEncodedStringToUnsignedChars(DFA110_minS);
	static final char[] DFA110_max = DFA.unpackEncodedStringToUnsignedChars(DFA110_maxS);
	static final short[] DFA110_accept = DFA.unpackEncodedString(DFA110_acceptS);
	static final short[] DFA110_special = DFA.unpackEncodedString(DFA110_specialS);
	static final short[][] DFA110_transition;

	static {
		int numStates = DFA110_transitionS.length;
		DFA110_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA110_transition[i] = DFA.unpackEncodedString(DFA110_transitionS[i]);
		}
	}

	protected class DFA110 extends DFA {

		public DFA110(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 110;
			this.eot = DFA110_eot;
			this.eof = DFA110_eof;
			this.min = DFA110_min;
			this.max = DFA110_max;
			this.accept = DFA110_accept;
			this.special = DFA110_special;
			this.transition = DFA110_transition;
		}
		@Override
		public String getDescription() {
			return "2332:1: constant_number_range : ( ^( DOTDOT lb= numeric_constant ub= numeric_constant ) -> template(lb=$lb.stub=$ub.st) \"<lb> .. <ub>\"| ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ub= numeric_constant ) -> template(lb=$lb.stub=$ub.st) \"-<lb> .. <ub>\"| ^( DOTDOT lb= numeric_constant ^( UNARY_MINUS ub= numeric_constant ) ) -> template(lb=$lb.stub=$ub.st) \"<lb> .. -<ub>\"| ^( DOTDOT ^( UNARY_MINUS lb= numeric_constant ) ^( UNARY_MINUS ub= numeric_constant ) ) -> template(lb=$lb.stub=$ub.st) \"-<lb> .. -<ub>\");";
		}
	}

	static final String DFA118_eotS =
		"\10\uffff";
	static final String DFA118_eofS =
		"\10\uffff";
	static final String DFA118_minS =
		"\1\56\1\2\2\uffff\1\77\1\3\2\uffff";
	static final String DFA118_maxS =
		"\1\u0103\1\2\2\uffff\1\77\1\u0103\2\uffff";
	static final String DFA118_acceptS =
		"\2\uffff\1\3\1\4\2\uffff\1\1\1\2";
	static final String DFA118_specialS =
		"\10\uffff}>";
	static final String[] DFA118_transitionS = {
			"\1\1\20\uffff\1\3\u00c3\uffff\1\2",
			"\1\4",
			"",
			"",
			"\1\5",
			"\1\6\73\uffff\1\5\u00c3\uffff\1\7",
			"",
			""
	};

	static final short[] DFA118_eot = DFA.unpackEncodedString(DFA118_eotS);
	static final short[] DFA118_eof = DFA.unpackEncodedString(DFA118_eofS);
	static final char[] DFA118_min = DFA.unpackEncodedStringToUnsignedChars(DFA118_minS);
	static final char[] DFA118_max = DFA.unpackEncodedStringToUnsignedChars(DFA118_maxS);
	static final short[] DFA118_accept = DFA.unpackEncodedString(DFA118_acceptS);
	static final short[] DFA118_special = DFA.unpackEncodedString(DFA118_specialS);
	static final short[][] DFA118_transition;

	static {
		int numStates = DFA118_transitionS.length;
		DFA118_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA118_transition[i] = DFA.unpackEncodedString(DFA118_transitionS[i]);
		}
	}

	protected class DFA118 extends DFA {

		public DFA118(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 118;
			this.eot = DFA118_eot;
			this.eof = DFA118_eof;
			this.min = DFA118_min;
			this.max = DFA118_max;
			this.accept = DFA118_accept;
			this.special = DFA118_special;
			this.transition = DFA118_transition;
		}
		@Override
		public String getDescription() {
			return "2394:1: unique_component_classifier_reference : ( ^( DOUBLE_COLON (p+= ID )+ ) -> unique_component_classifier_reference(p=$p)| ^( DOUBLE_COLON (p+= ID )+ ^( PERIOD ii= ID ) ) -> unique_component_classifier_reference(p=$pii=$ii.text)| ^( PERIOD n= ID imp= ID ) -> local_name(n=$n.textimp=$imp.textpn=getPackageName())|n= ID -> local_name(n=$n.textpn=getPackageName()));";
		}
	}

	static final String DFA163_eotS =
		"\16\uffff";
	static final String DFA163_eofS =
		"\16\uffff";
	static final String DFA163_minS =
		"\1\4\1\uffff\1\2\4\uffff\1\4\2\2\1\uffff\1\77\1\2\1\3";
	static final String DFA163_maxS =
		"\1\u0124\1\uffff\1\2\4\uffff\1\u0124\1\u00ec\1\2\1\uffff\2\77\1\u00ec";
	static final String DFA163_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\1\3\1\5\1\6\3\uffff\1\4\3\uffff";
	static final String DFA163_specialS =
		"\16\uffff}>";
	static final String[] DFA163_transitionS = {
			"\1\1\15\uffff\1\5\7\uffff\1\6\1\3\5\uffff\1\1\2\uffff\1\3\11\uffff\1"+
			"\1\20\uffff\1\1\1\uffff\1\1\1\uffff\1\1\3\uffff\1\4\74\uffff\1\1\47\uffff"+
			"\1\1\1\uffff\1\1\64\uffff\1\1\1\uffff\1\1\2\uffff\1\1\15\uffff\1\3\7"+
			"\uffff\1\1\4\uffff\1\1\14\uffff\1\1\1\uffff\1\1\3\uffff\1\1\15\uffff"+
			"\1\2",
			"",
			"\1\7",
			"",
			"",
			"",
			"",
			"\1\12\26\uffff\1\12\5\uffff\1\12\2\uffff\1\12\11\uffff\1\12\20\uffff"+
			"\1\10\1\uffff\1\12\1\uffff\1\12\11\uffff\1\1\66\uffff\1\12\47\uffff\1"+
			"\12\1\uffff\1\12\64\uffff\1\12\1\uffff\1\12\2\uffff\1\12\15\uffff\1\12"+
			"\7\uffff\1\12\4\uffff\1\11\14\uffff\1\12\1\uffff\1\12\3\uffff\1\12\15"+
			"\uffff\1\12",
			"\2\12\73\uffff\1\1\65\uffff\1\1\33\uffff\1\1\132\uffff\1\1",
			"\1\13",
			"",
			"\1\14",
			"\1\12\1\15\73\uffff\1\14",
			"\1\12\161\uffff\1\1\33\uffff\1\1\132\uffff\1\1"
	};

	static final short[] DFA163_eot = DFA.unpackEncodedString(DFA163_eotS);
	static final short[] DFA163_eof = DFA.unpackEncodedString(DFA163_eofS);
	static final char[] DFA163_min = DFA.unpackEncodedStringToUnsignedChars(DFA163_minS);
	static final char[] DFA163_max = DFA.unpackEncodedStringToUnsignedChars(DFA163_maxS);
	static final short[] DFA163_accept = DFA.unpackEncodedString(DFA163_acceptS);
	static final short[] DFA163_special = DFA.unpackEncodedString(DFA163_specialS);
	static final short[][] DFA163_transition;

	static {
		int numStates = DFA163_transitionS.length;
		DFA163_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA163_transition[i] = DFA.unpackEncodedString(DFA163_transitionS[i]);
		}
	}

	protected class DFA163 extends DFA {

		public DFA163(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 163;
			this.eot = DFA163_eot;
			this.eof = DFA163_eof;
			this.min = DFA163_min;
			this.max = DFA163_max;
			this.accept = DFA163_accept;
			this.special = DFA163_special;
			this.transition = DFA163_transition;
		}
		@Override
		public String getDescription() {
			return "3078:1: timed_expression : (n= value -> {$n.st}|ppe= parenthesized_assertion_expression -> {$ppe.st}|afi= assertion_function_invocation -> {$afi.st}| ^(tic= TICK (tv= value |ppe= parenthesized_assertion_expression ) ) -> {tv!=null}? template(tv=$tv.st) \"<tv>'\" -> template(ppe=$ppe.st) \"<ppe>'\"| ^(ats= AT_SIGN (av= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) te= time_subexpression ) -> {av!=null}? template(av=$av.stte=$te.st) \"<av>@<te>\" -> {pi!=null}? template(pi=$pi.stte=$te.st) \"<pi>@<te>\" -> template(ppe=$ppe.stte=$te.st) \"<ppe>@<te>\"| ^(crt= CARET (cv= value |ppe= parenthesized_assertion_expression |pi= assertion_function_invocation ) val= period_shift ) -> {cv!=null}? template(cv=$cv.stval=$val.st) \"<cv>^<val>\" -> {pi!=null}? template(pi=$pi.stval=$val.st) \"<pi>^<val>\" -> template(ppe=$ppe.stval=$val.st) \"<ppe>^<val>\");";
		}
	}

	static final String DFA174_eotS =
		"\22\uffff";
	static final String DFA174_eofS =
		"\22\uffff";
	static final String DFA174_minS =
		"\1\4\1\uffff\1\2\1\uffff\1\2\1\77\1\4\2\2\6\uffff\1\77\1\2\1\3";
	static final String DFA174_maxS =
		"\1\u012c\1\uffff\1\2\1\uffff\1\2\1\u0103\1\u012c\1\u00ec\1\2\6\uffff\2"+
		"\77\1\u00ec";
	static final String DFA174_acceptS =
		"\1\uffff\1\1\1\uffff\1\3\5\uffff\1\5\1\6\1\7\1\10\1\4\1\2\3\uffff";
	static final String DFA174_specialS =
		"\22\uffff}>";
	static final String[] DFA174_transitionS = {
			"\1\1\34\uffff\1\1\14\uffff\1\1\20\uffff\1\1\1\uffff\1\1\1\uffff\1\1\100"+
			"\uffff\1\1\47\uffff\1\1\1\uffff\1\1\64\uffff\1\1\1\uffff\1\1\2\uffff"+
			"\1\1\15\uffff\1\4\7\uffff\1\1\4\uffff\1\1\14\uffff\1\1\1\uffff\1\1\3"+
			"\uffff\1\1\15\uffff\1\2\7\uffff\1\3",
			"",
			"\1\5",
			"",
			"\1\6",
			"\1\7\15\uffff\1\1\u00b5\uffff\1\10",
			"\1\15\34\uffff\1\15\10\uffff\1\12\3\uffff\1\15\20\uffff\1\15\1\uffff"+
			"\1\15\1\uffff\1\15\100\uffff\1\15\47\uffff\1\15\1\uffff\1\15\64\uffff"+
			"\1\15\1\uffff\1\15\2\uffff\1\15\15\uffff\1\15\3\uffff\1\11\3\uffff\1"+
			"\15\4\uffff\1\15\1\13\13\uffff\1\15\1\uffff\1\15\3\uffff\1\15\15\uffff"+
			"\1\15\1\uffff\1\14\5\uffff\1\15",
			"\2\16\73\uffff\1\1\65\uffff\1\1\33\uffff\1\1\132\uffff\1\1",
			"\1\17",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\20",
			"\1\16\1\21\73\uffff\1\20",
			"\1\16\161\uffff\1\1\33\uffff\1\1\132\uffff\1\1"
	};

	static final short[] DFA174_eot = DFA.unpackEncodedString(DFA174_eotS);
	static final short[] DFA174_eof = DFA.unpackEncodedString(DFA174_eofS);
	static final char[] DFA174_min = DFA.unpackEncodedStringToUnsignedChars(DFA174_minS);
	static final char[] DFA174_max = DFA.unpackEncodedStringToUnsignedChars(DFA174_maxS);
	static final short[] DFA174_accept = DFA.unpackEncodedString(DFA174_acceptS);
	static final short[] DFA174_special = DFA.unpackEncodedString(DFA174_specialS);
	static final short[][] DFA174_transition;

	static {
		int numStates = DFA174_transitionS.length;
		DFA174_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA174_transition[i] = DFA.unpackEncodedString(DFA174_transitionS[i]);
		}
	}

	protected class DFA174 extends DFA {

		public DFA174(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 174;
			this.eot = DFA174_eot;
			this.eof = DFA174_eof;
			this.min = DFA174_min;
			this.max = DFA174_max;
			this.accept = DFA174_accept;
			this.special = DFA174_special;
			this.transition = DFA174_transition;
		}
		@Override
		public String getDescription() {
			return "3232:1: period_shift : (v= value -> {$v.st}| ^(t= TICK n= name ) -> template(n=$n.st) \"$n' \"| ^( UNARY_MINUS ia= period_shift ) -> template(ia=$ia.st) \"-<ia>\"| ^( LPAREN ia= period_shift RPAREN ) -> template(ia=$ia.st) \"(<ia>)\"| ^( LPAREN ^( MINUS l= period_shift r= period_shift ) RPAREN ) -> template(l=$l.str=$r.st) \"(<l> - <r>)\"| ^( LPAREN ^( DIVIDE ld= period_shift rd= period_shift ) RPAREN ) -> template(l=$ld.str=$rd.st) \"(<l> / <r>)\"| ^( LPAREN ^( PLUS (iap+= period_shift )+ ) RPAREN ) -> template(ias=$iap) \"(<ias; separator=\" + \">)\"| ^( LPAREN ^( TIMES (iat+= period_shift )+ ) RPAREN ) -> template(ias=$iat) \"(<ias; separator=\" * \">)\");";
		}
	}

	static final String DFA191_eotS =
		"\46\uffff";
	static final String DFA191_eofS =
		"\46\uffff";
	static final String DFA191_minS =
		"\1\u00fe\1\2\2\56\2\2\1\56\1\2\2\77\1\2\1\77\1\3\3\77\1\3\1\56\1\2\1\3"+
		"\1\77\3\3\1\77\1\56\2\3\2\uffff\2\3\2\uffff\1\3\2\uffff\1\56";
	static final String DFA191_maxS =
		"\1\u00fe\1\2\1\u0103\1\56\2\2\1\56\1\2\2\77\1\2\1\77\1\u0103\3\77\1\u0103"+
		"\1\56\1\2\1\3\1\77\1\3\2\u0103\1\77\1\56\1\3\1\u0103\2\uffff\1\3\1\u0103"+
		"\2\uffff\1\3\2\uffff\1\56";
	static final String DFA191_acceptS =
		"\34\uffff\1\1\1\2\2\uffff\1\3\1\4\1\uffff\1\5\1\6\1\uffff";
	static final String DFA191_specialS =
		"\46\uffff}>";
	static final String[] DFA191_transitionS = {
			"\1\1",
			"\1\2",
			"\1\4\20\uffff\1\6\u008e\uffff\1\3\64\uffff\1\5",
			"\1\7",
			"\1\10",
			"\1\11",
			"\1\12",
			"\1\13",
			"\1\14",
			"\1\15",
			"\1\16",
			"\1\17",
			"\1\21\73\uffff\1\20\u00c3\uffff\1\22",
			"\1\23",
			"\1\24",
			"\1\25",
			"\1\26\73\uffff\1\27\u00c3\uffff\1\22",
			"\1\12",
			"\1\30",
			"\1\31",
			"\1\32",
			"\1\33",
			"\1\34\52\uffff\1\12\36\uffff\1\35\u00b5\uffff\1\35",
			"\1\21\73\uffff\1\27\u00c3\uffff\1\22",
			"\1\36",
			"\1\12",
			"\1\37",
			"\1\40\111\uffff\1\41\u00b5\uffff\1\41",
			"",
			"",
			"\1\42",
			"\1\43\111\uffff\1\44\u00b5\uffff\1\44",
			"",
			"",
			"\1\45",
			"",
			"",
			"\1\12"
	};

	static final short[] DFA191_eot = DFA.unpackEncodedString(DFA191_eotS);
	static final short[] DFA191_eof = DFA.unpackEncodedString(DFA191_eofS);
	static final char[] DFA191_min = DFA.unpackEncodedStringToUnsignedChars(DFA191_minS);
	static final char[] DFA191_max = DFA.unpackEncodedStringToUnsignedChars(DFA191_maxS);
	static final short[] DFA191_accept = DFA.unpackEncodedString(DFA191_acceptS);
	static final short[] DFA191_special = DFA.unpackEncodedString(DFA191_specialS);
	static final short[][] DFA191_transition;

	static {
		int numStates = DFA191_transitionS.length;
		DFA191_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA191_transition[i] = DFA.unpackEncodedString(DFA191_transitionS[i]);
		}
	}

	protected class DFA191 extends DFA {

		public DFA191(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 191;
			this.eot = DFA191_eot;
			this.eof = DFA191_eof;
			this.min = DFA191_min;
			this.max = DFA191_max;
			this.accept = DFA191_accept;
			this.special = DFA191_special;
			this.transition = DFA191_transition;
		}
		@Override
		public String getDescription() {
			return "3415:1: property_reference : ( ^(oct= OCTOTHORPE pname= property_name ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))} -> property_reference(pname=$pname.st)| ^(oct= OCTOTHORPE pname= property_name (field+= property_field )+ ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(0))} -> property_reference(pname=$pname.stf=$field)| ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))} -> property_reference(component=$self.textpname=$pname.st)| ^(oct= OCTOTHORPE self= LITERAL_self pname= property_name (field+= property_field )+ ) -> {lookUpPropertyValues}? {getAadlPropertyValue((BAST)$oct.getChild(1))} -> property_reference(component=$self.textpname=$pname.stf=$field)| ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name ) -> property_reference(component=$component.stpname=$pname.stf=$field)| ^(oct= OCTOTHORPE component= unique_component_classifier_reference pname= property_name (field+= property_field )+ ) -> property_reference(component=$component.stpname=$pname.stf=$field));";
		}
	}

	public static final BitSet FOLLOW_ID_in_identifier66 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSERTION_ANNEX_in_annex_library466 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_annex_library470 = new BitSet(new long[]{0x000000000001A008L});
	public static final BitSet FOLLOW_THREAD_ANNEX_in_thread_behavior1257 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_states_in_thread_behavior1261 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_state_in_thread_behavior1265 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_assert_clause_in_thread_behavior1277 = new BitSet(new long[]{0x0001000000000000L,0x0000000000000000L,0x0000000020000000L,0x0000808000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_invariant_clause_in_thread_behavior1285 = new BitSet(new long[]{0x0001000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000808000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_variables_in_thread_behavior1292 = new BitSet(new long[]{0x0001000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000008000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_transitions_in_thread_behavior1300 = new BitSet(new long[]{0x0001000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_thread_behavior1309 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_STOP_in_thread_behavior1314 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_assert_in_assert_clause1376 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_assert_clause1380 = new BitSet(new long[]{0x000000000001A008L});
	public static final BitSet FOLLOW_LITERAL_invariant_in_invariant_clause1412 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_invariant_clause1416 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_variables_in_variables1448 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_variable_in_variables1452 = new BitSet(new long[]{0x0000000010000008L});
	public static final BitSet FOLLOW_COLON_in_behavior_variable1485 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_COMMA_in_behavior_variable1495 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_behavior_variable1499 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_ID_in_behavior_variable1507 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_TYPE_in_behavior_variable1514 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_type_in_behavior_variable1518 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSIGN_in_behavior_variable1530 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_behavior_variable1534 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_in_behavior_variable1548 = new BitSet(new long[]{0x0000000000000000L,0x0008000000000000L,0x0000040000001000L,0x0000000000140000L,0x0000000004000000L});
	public static final BitSet FOLLOW_LITERAL_nonvolatile_in_behavior_variable1563 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_LITERAL_shared_in_behavior_variable1575 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_LITERAL_constant_in_behavior_variable1581 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_LITERAL_spread_in_behavior_variable1593 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_variable1599 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_variable1609 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_state_in_behavior_state1686 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_initial_in_behavior_state1690 = new BitSet(new long[]{0x8000000000000000L,0x0000200000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_LITERAL_complete_in_behavior_state1695 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_LITERAL_final_in_behavior_state1700 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_behavior_state1705 = new BitSet(new long[]{0x000000000001A008L});
	public static final BitSet FOLLOW_assertion_in_behavior_state1709 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_transitions_in_transitions1760 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_transition_in_transitions1764 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000010000000000L});
	public static final BitSet FOLLOW_TRANSITION_in_behavior_transition1799 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LABEL_in_behavior_transition1803 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_transition_label_in_behavior_transition1807 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_SOURCE_in_behavior_transition1814 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_behavior_transition1818 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_CONDITION_in_behavior_transition1829 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_condition_in_behavior_transition1833 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DESTINATION_in_behavior_transition1843 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_behavior_transition1847 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ACTION_in_behavior_transition1853 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_actions_in_behavior_transition1857 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_Q_in_behavior_transition1864 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_behavior_transition1868 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_behavior_transition_label1923 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_behavior_transition_label1927 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_behavior_transition_label1952 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_condition_in_behavior_condition1981 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_execute_condition_in_behavior_condition1996 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_mode_condition_in_behavior_condition2009 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_or_relation_in_execute_condition2033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_on_in_mode_condition2057 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_mode_condition2061 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression2094 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_trigger_logical_expression2111 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression2115 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_or_in_trigger_logical_expression2139 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression2143 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_xor_in_trigger_logical_expression2167 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression2171 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_cand_in_trigger_logical_expression2195 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression2199 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_cor_in_trigger_logical_expression2223 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_event_trigger_in_trigger_logical_expression2227 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_event_trigger2261 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_event_trigger2278 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_event_trigger2282 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_event_trigger2308 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_trigger_logical_expression_in_event_trigger2312 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_event_trigger2314 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_SUBPROGRAM_ANNEX_in_subprogram_behavior2349 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assert_clause_in_subprogram_behavior2357 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L,0x0300000000000000L});
	public static final BitSet FOLLOW_LITERAL_pre_in_subprogram_behavior2365 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior2369 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_post_in_subprogram_behavior2381 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_subprogram_behavior2385 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_subprogram_behavior2395 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DO_NOT_PROVE_in_subprogram_behavior2405 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_asserted_action_stub_in_asserted_action2447 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ACTION_in_asserted_action_stub2472 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_P_in_asserted_action_stub2478 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_asserted_action_stub2483 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_S_in_asserted_action_stub2496 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_action_in_asserted_action_stub2500 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_Q_in_asserted_action_stub2509 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_asserted_action_stub2514 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_basic_action_in_action2539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_alternative_in_action2555 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_universal_lattice_quantification_in_action2569 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_while_loop_in_action2583 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_do_until_loop_in_action2597 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_loop_in_action2611 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_action2625 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_if_in_alternative2647 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_guarded_action_in_alternative2655 = new BitSet(new long[]{0x2000000000000008L});
	public static final BitSet FOLLOW_GUARD_in_guarded_action2688 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_guarded_action2692 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_asserted_action_in_guarded_action2696 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_forall_in_universal_lattice_quantification2729 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_lattice_variables_in_universal_lattice_quantification2735 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_universal_lattice_quantification2740 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_range_in_universal_lattice_quantification2744 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_universal_lattice_quantification2753 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_while_in_while_loop2792 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_while_loop2796 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_INVARIANT_in_while_loop2799 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_while_loop2803 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_BOUND_in_while_loop2811 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_while_loop2815 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_existential_lattice_quantification_in_while_loop2821 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_for_in_for_loop2862 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_for_loop2866 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_LITERAL_in_in_for_loop2872 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_for_loop2876 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_for_loop2880 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVARIANT_in_for_loop2888 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_for_loop2892 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_behavior_actions_in_for_loop2901 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_do_in_do_until_loop2947 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_until_in_do_until_loop2950 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_do_until_loop2954 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVARIANT_in_do_until_loop2958 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_do_until_loop2962 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_BOUND_in_do_until_loop2970 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_do_until_loop2974 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_behavior_actions_in_do_until_loop2980 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_skip_in_basic_action3022 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simultaneous_assignment_in_basic_action3036 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_basic_action3052 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_communication_in_basic_action3072 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_actions_in_basic_action3093 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_setmode_in_basic_action3111 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_basic_action3115 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_throw_in_basic_action3133 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_combinable_operation_in_basic_action3154 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_issue_exception_in_basic_action3176 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSIGN_in_assignment3200 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_tick_in_assignment3204 = new BitSet(new long[]{0x8840441208000010L,0x00104400A000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_or_record_term_in_assignment3208 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_TICK_in_name_tick3242 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_in_name_tick3247 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_name_in_name_tick3275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_record_term3305 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_record_term3325 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_any_in_expression_or_record_term3341 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSIGN_in_simultaneous_assignment3366 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment3370 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_tick_in_simultaneous_assignment3374 = new BitSet(new long[]{0x8000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000001000000008L});
	public static final BitSet FOLLOW_COMMA_in_simultaneous_assignment3381 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_record_term_in_simultaneous_assignment3385 = new BitSet(new long[]{0x8840441208000018L,0x00104400A000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_LITERAL_exception_in_issue_exception3434 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_issue_exception3438 = new BitSet(new long[]{0x0000000000000010L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_issue_exception3442 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_exception_in_issue_exception3477 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_issue_exception3481 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_computation_in_timed_actions3521 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_time_in_timed_actions3525 = new BitSet(new long[]{0x0000000000400008L});
	public static final BitSet FOLLOW_LITERAL_delay_in_timed_actions3548 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_time_in_timed_actions3552 = new BitSet(new long[]{0x0000000000400008L});
	public static final BitSet FOLLOW_BEHAVIOR_TIME_in_behavior_time3584 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_behavior_time3588 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000000L,0x0000008800100000L,0x0000400000002008L});
	public static final BitSet FOLLOW_time_unit_in_behavior_time3592 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_ps_in_time_unit3633 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_us_in_time_unit3641 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_ms_in_time_unit3650 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_sec_in_time_unit3659 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_min_in_time_unit3668 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_hr_in_time_unit3681 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PROCEDURE_CALL_in_communication3711 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_communication3715 = new BitSet(new long[]{0x8000401258000010L,0x0000000000000008L,0x0000000000000010L,0x4040010000000000L,0x0000001000440008L});
	public static final BitSet FOLLOW_formal_actual_list_in_communication3719 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PROCEDURE_CALL_in_communication3742 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_communication3746 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PORT_OUTPUT_in_communication3765 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_communication3769 = new BitSet(new long[]{0x9850441208000190L,0x001044002000000AL,0x0004591010000010L,0x54E0012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_or_relation_in_communication3773 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PORT_OUTPUT_in_communication3798 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_communication3802 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PORT_INPUT_in_communication3823 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_communication3827 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_name_in_communication3832 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_pause_in_communication3859 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_port_name3881 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_port_name3895 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_port_name3899 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_LBRACKET_in_port_name3924 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_port_name3928 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_port_name3932 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_port_name3934 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COMMA_in_formal_actual_list3970 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list3974 = new BitSet(new long[]{0x8000401218000018L,0x0000000000000008L,0x0000000000000010L,0x4040010000000000L,0x0000001000440008L});
	public static final BitSet FOLLOW_formal_actual_in_formal_actual_list3996 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COLON_in_formal_actual4019 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_formal_actual4023 = new BitSet(new long[]{0x8000401208000010L,0x0000000000000008L,0x0000000000000010L,0x4040010000000000L,0x0000001000440008L});
	public static final BitSet FOLLOW_actual_parameter_in_formal_actual4027 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_actual_parameter_in_formal_actual4058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_constant_in_actual_parameter4085 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_actual_parameter4105 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_actual_parameter4123 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_declare_in_quantified_variables4154 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_variable_in_quantified_variables4160 = new BitSet(new long[]{0x0000000010000008L});
	public static final BitSet FOLLOW_LCURLY_in_existential_lattice_quantification4203 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_quantified_variables_in_existential_lattice_quantification4207 = new BitSet(new long[]{0x0000000000000240L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_behavior_actions_in_existential_lattice_quantification4212 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_RCURLY_in_existential_lattice_quantification4214 = new BitSet(new long[]{0x0000000000000008L,0x0000080000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_timeout_clause_in_existential_lattice_quantification4224 = new BitSet(new long[]{0x0000000000000008L,0x0000080000000000L});
	public static final BitSet FOLLOW_catch_clause_in_existential_lattice_quantification4234 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_timeout_clause4278 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_time_in_timeout_clause4282 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_catch_in_catch_clause4312 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_catch_clause_term_in_catch_clause4316 = new BitSet(new long[]{0x0000000010000008L});
	public static final BitSet FOLLOW_COLON_in_catch_clause_term4350 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_all_in_catch_clause_term4352 = new BitSet(new long[]{0x0000000000020000L,0x0201000000000000L,0x0040000000000782L,0x00040000100A0000L,0x0000000000001300L});
	public static final BitSet FOLLOW_basic_action_in_catch_clause_term4356 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COLON_in_catch_clause_term4380 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_catch_clause_term4384 = new BitSet(new long[]{0x0000000000020000L,0x0201000000000000L,0x0040000000000782L,0x00040000100A0000L,0x0000000000001300L});
	public static final BitSet FOLLOW_basic_action_in_catch_clause_term4388 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_when_in_when_throw4421 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_when_throw4425 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_LITERAL_throw_in_when_throw4427 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_when_throw4431 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_combinable_literal_in_combinable_operation4466 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation4470 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_combinable_operation4474 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_ID_in_combinable_operation4478 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_swap_in_combinable_operation4556 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation4560 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_variable_name_in_combinable_operation4564 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_combinable_operation4568 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_fetchadd_in_combinable_literal4624 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchor_in_combinable_literal4636 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchand_in_combinable_literal4648 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_fetchxor_in_combinable_literal4661 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions4691 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SEMICOLON_in_behavior_actions4709 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions4713 = new BitSet(new long[]{0x0000000000000048L});
	public static final BitSet FOLLOW_AMPERSAND_in_behavior_actions4737 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_asserted_action_in_behavior_actions4741 = new BitSet(new long[]{0x0000000000000048L});
	public static final BitSet FOLLOW_PERIOD_in_name4774 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_partial_name_in_name4778 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_partial_name_in_name4802 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_partial_name4831 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_partial_name4845 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expressionOrRange_in_partial_name4849 = new BitSet(new long[]{0x8840741388000018L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_COMMA_in_parameter_list4887 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expressionOrRange_in_parameter_list4891 = new BitSet(new long[]{0x8840741388000018L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expressionOrRange_in_parameter_list4914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_range_symbol4942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMADOT_in_range_symbol4948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOTCOMMA_in_range_symbol4954 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMACOMMA_in_range_symbol4960 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_range_symbol_in_expressionOrRange4993 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_expressionOrRange4997 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_expressionOrRange5001 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_expression_in_expressionOrRange5035 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_expression5065 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5069 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_TIMES_in_expression5093 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5097 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_MINUS_in_expression5121 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5125 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_expression5129 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DIVIDE_in_expression5161 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5165 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_expression5169 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_mod_in_expression5201 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5205 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_expression5209 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_rem_in_expression5237 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5241 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_expression5245 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_EXP_in_expression5273 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5277 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_expression5281 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_and_in_expression5309 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5313 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_or_in_expression5337 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5341 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_xor_in_expression5365 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5369 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_cand_in_expression5394 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5398 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_cor_in_expression5423 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_expression5427 = new BitSet(new long[]{0x8800401208000018L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_expression5451 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_subexpression5491 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_subexpression5495 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_subexpression5518 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression5522 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_not_in_subexpression5546 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_subexpression5550 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_not_in_subexpression5572 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression5576 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_subexpression5600 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_subexpression5620 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_function_call_in_subexpression5635 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_conversion_in_subexpression5652 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_type_conversion5679 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion5683 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_integer_in_type_conversion5711 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion5715 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_rational_in_type_conversion5743 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion5747 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_real_in_type_conversion5775 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion5779 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_complex_in_type_conversion5807 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion5811 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_time_in_type_conversion5839 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_type_conversion5843 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type_conversion5879 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5883 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type_conversion5911 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5915 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type_conversion5943 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5947 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type_conversion5975 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion5979 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type_conversion6007 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion6011 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type_conversion6039 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_assertion_type_conversion6043 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_subexpression6079 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_parenthesized_subexpression6083 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_subexpression6085 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_conditional_expression_in_parenthesized_subexpression6110 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_expression_in_parenthesized_subexpression6125 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CASE_EXPRESSION_in_case_expression6149 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_case_choice_in_case_expression6153 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_case_choice6186 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_boolean_expression_or_relation_in_case_choice6190 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_case_choice6194 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_CONDITIONAL_in_conditional_expression6230 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_conditional_expression6234 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_conditional_expression6238 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_conditional_expression6242 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_value_constant_in_value6291 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_variable_name_in_value6303 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_QUESTION_in_value6314 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_value6318 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_TICK_in_value6339 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_value6343 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_LITERAL_fresh_in_value6345 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_TICK_in_value6366 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_value6370 = new BitSet(new long[]{0x0000000000000000L,0x0020000000000000L});
	public static final BitSet FOLLOW_LITERAL_count_in_value6372 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_TICK_in_value6393 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_port_name_in_value6397 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_LITERAL_updated_in_value6399 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INMODE_in_value6420 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_value6424 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_value6446 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_null_in_value6458 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_now_in_value6470 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_tops_in_value6485 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_variable_name6506 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_or_relation_in_expression_or_relation_or_record6528 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_relation_in_expression_or_relation6555 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_relation6567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_expression_or_relation6581 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EQ_in_relation6603 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_relation6608 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_relation6612 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LT_in_relation6643 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_relation6648 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_relation6652 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_AM_in_relation6684 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_relation6689 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_relation6693 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_AL_in_relation6725 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_relation6730 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_relation6734 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_GT_in_relation6766 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_relation6771 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_relation6775 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_NEQ_in_relation6807 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subexpression_in_relation6812 = new BitSet(new long[]{0x8800401208000010L,0x000040000000000AL,0x0000590010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_subexpression_in_relation6816 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_EQ_in_relation_symbol6853 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LT_in_relation_symbol6860 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AM_in_relation_symbol6866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AL_in_relation_symbol6872 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GT_in_relation_symbol6878 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NEQ_in_relation_symbol6904 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_CALL_in_function_call6932 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_function_call6935 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_function_call6939 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_ID_in_function_call6946 = new BitSet(new long[]{0x0000000040001008L});
	public static final BitSet FOLLOW_function_parameters_in_function_call6950 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_FUNCTION_CALL_in_function_call7011 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_function_call7015 = new BitSet(new long[]{0x0000000040001008L});
	public static final BitSet FOLLOW_function_parameters_in_function_call7019 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters7078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_function_parameters7097 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_formal_expression_pair_in_function_parameters7102 = new BitSet(new long[]{0x0000000000001008L});
	public static final BitSet FOLLOW_ARROW_in_formal_expression_pair7135 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_formal_expression_pair7139 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_formal_expression_pair7144 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_type_name_in_type7182 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_type_in_type7195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_type_in_type7208 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_type_in_type7221 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_type_in_type7234 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_variant_type_in_type7247 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_type7263 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_string_in_type7279 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_enumeration_in_enumeration_type7314 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_enumeration_type7318 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_LITERAL_natural_in_number_word7371 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_integer_in_number_word7386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rational_in_number_word7401 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_real_in_number_word7416 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_complex_in_number_word7431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_time_in_number_word7445 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_word_in_number_type7471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_number_word_in_number_type7489 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_units_in_number_type7494 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_units_designator_in_number_type7498 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_number_range_in_number_type7503 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_number_word_in_number_type7537 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_units_in_number_type7542 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_units_designator_in_number_type7546 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_number_word_in_number_type7577 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_number_range_in_number_type7581 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_constant_number_range_in_number_range7616 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range7646 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7650 = new BitSet(new long[]{0x0000400200000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000000000L,0x0000000000440000L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7654 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range7683 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_constant_number_range7686 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7690 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7695 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range7724 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7728 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_constant_number_range7731 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7735 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DOTDOT_in_constant_number_range7765 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_constant_number_range7768 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7772 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_constant_number_range7776 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_numeric_constant_in_constant_number_range7780 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_units_designator7819 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_unit_in_units_designator7835 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_record_in_record_type7869 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_COLON_in_record_type7874 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_record_type7878 = new BitSet(new long[]{0x8000400000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L,0x0000000000000008L});
	public static final BitSet FOLLOW_type_in_record_type7882 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_record_in_record_type7909 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_record_field_in_record_type7913 = new BitSet(new long[]{0x0000000010000008L});
	public static final BitSet FOLLOW_LPAREN_in_record_term7942 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_record_value_in_record_term7946 = new BitSet(new long[]{0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_record_term7949 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ARROW_in_record_value7980 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_record_value7984 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4000012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_value_in_record_value7988 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COLON_in_record_field8027 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_record_field8031 = new BitSet(new long[]{0x8000400000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L,0x0000000000000008L});
	public static final BitSet FOLLOW_type_in_record_field8035 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference8068 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_unique_component_classifier_reference8073 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_unique_component_classifier_reference8100 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_unique_component_classifier_reference8105 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference8109 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_unique_component_classifier_reference8113 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_unique_component_classifier_reference8141 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_unique_component_classifier_reference8145 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_unique_component_classifier_reference8149 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_unique_component_classifier_reference8186 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_type_name8219 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_array_in_array_type8242 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_array_range_list_in_array_type8246 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_array_type8248 = new BitSet(new long[]{0x8000400000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L,0x0000000000000008L});
	public static final BitSet FOLLOW_type_in_array_type8252 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list8288 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_array_range_list8302 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_natural_range_in_array_range_list8306 = new BitSet(new long[]{0x8000600000000008L,0x0000000000000008L,0x0000000000000000L,0x4000000000000000L});
	public static final BitSet FOLLOW_DOTDOT_in_natural_range8336 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_id_literal_or_property_in_natural_range8340 = new BitSet(new long[]{0x8000400000000000L,0x0000000000000008L,0x0000000000000000L,0x4000000000000000L});
	public static final BitSet FOLLOW_id_literal_or_property_in_natural_range8344 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_id_literal_or_property_in_natural_range8397 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_id_literal_or_property8421 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_integer_literal_in_id_literal_or_property8435 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_constant_in_id_literal_or_property8454 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_reference_in_id_literal_or_property8471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_variant_in_variant_type8502 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_variant_field_in_variant_type8506 = new BitSet(new long[]{0x0000000010000008L});
	public static final BitSet FOLLOW_COLON_in_variant_field8535 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_variant_field8539 = new BitSet(new long[]{0x8000400000000000L,0x8000402400000000L,0x0000010010000000L,0x00010004010001C0L,0x0000000000000008L});
	public static final BitSet FOLLOW_type_in_variant_field8543 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_ANNEX_in_assertion_annex_library8578 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASSERTION_ANNEX_in_assertion_annex_library8587 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_in_assertion_annex_library8591 = new BitSet(new long[]{0x000000000001A008L});
	public static final BitSet FOLLOW_ASSERTION_ANNEX_in_assertion_annex_library8612 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_assertion_annex_library8616 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_ENUMERATION_in_assertion8645 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LABEL_in_assertion8650 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion8654 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PARAMETERS_in_assertion8659 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion8663 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion8669 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_ENUMERATION_in_assertion8713 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_enumeration_in_assertion8717 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_in_assertion8755 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LABEL_in_assertion8760 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion8764 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PARAMETERS_in_assertion8769 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion8773 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_predicate_in_assertion8780 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_in_assertion8826 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LABEL_in_assertion8831 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion8835 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_predicate_in_assertion8842 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_FUNCTION_in_assertion8883 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LABEL_in_assertion8887 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion8891 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PARAMETERS_in_assertion8896 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_formal_assertion_parameter_list_in_assertion8900 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion8906 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_FUNCTION_in_assertion8952 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LABEL_in_assertion8956 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion8960 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion8966 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_FUNCTION_in_assertion9007 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_function_value_in_assertion9012 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_in_assertion9049 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_assertion9055 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ASSERTION_in_assertion9092 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_DUMMY_in_assertion9096 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_formal_assertion_parameter9139 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TILDE_in_formal_assertion_parameter9162 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_formal_assertion_parameter9166 = new BitSet(new long[]{0x8000400000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_type_name_in_formal_assertion_parameter9170 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list9206 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_formal_assertion_parameter_list9226 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_formal_assertion_parameter_in_formal_assertion_parameter_list9230 = new BitSet(new long[]{0x8000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_conditional_assertion_function_in_assertion_function_value9265 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_value9280 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CONDITIONAL_FUNCTION_in_conditional_assertion_function9301 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_condition_value_pair_in_conditional_assertion_function9307 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000001L});
	public static final BitSet FOLLOW_IMP_in_condition_value_pair9341 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_condition_value_pair9345 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_condition_value_pair9349 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration9386 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_invocation_in_assertion_enumeration9390 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PLUS_ARROW_in_assertion_enumeration9415 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_enumeration_pair_in_assertion_enumeration9419 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_ID_in_enumeration_pair9456 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_enumeration_pair9460 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_all_in_universal_quantification9500 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_logic_variables_in_universal_quantification9504 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_universal_quantification9508 = new BitSet(new long[]{0x9010000004040180L,0x0100000030000041L,0x0004080003400014L,0x10E0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_predicate_in_universal_quantification9512 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COMMA_in_lattice_variables9561 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_identifier_in_lattice_variables9565 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_ID_in_lattice_variables9591 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exists_in_existential_quantification9622 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_logic_variables_in_existential_quantification9626 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_existential_quantification9630 = new BitSet(new long[]{0x9010000004040180L,0x0100000030000041L,0x0004080003400014L,0x10E0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_predicate_in_existential_quantification9634 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COLON_in_logic_variables9682 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_type_in_logic_variables9686 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_identifier_in_logic_variables9690 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_LITERAL_in_in_logic_variable_domain9735 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_range_symbol_in_logic_variable_domain9741 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain9745 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_logic_variable_domain9749 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_in_in_logic_variable_domain9791 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_logic_variable_domain9795 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_universal_quantification_in_predicate9841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_existential_quantification_in_predicate9862 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_predicate9879 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subpredicate_in_predicate9883 = new BitSet(new long[]{0x9010000004040188L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_LITERAL_or_in_predicate9908 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subpredicate_in_predicate9912 = new BitSet(new long[]{0x9010000004040188L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_LITERAL_xor_in_predicate9937 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subpredicate_in_predicate9941 = new BitSet(new long[]{0x9010000004040188L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_LITERAL_implies_in_predicate9966 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subpredicate_in_predicate9970 = new BitSet(new long[]{0x9010000004040180L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_subpredicate_in_predicate9974 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_iff_in_predicate10005 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subpredicate_in_predicate10009 = new BitSet(new long[]{0x9010000004040180L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_subpredicate_in_predicate10013 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_IMP_in_predicate10044 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_subpredicate_in_predicate10048 = new BitSet(new long[]{0x9010000004040180L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_subpredicate_in_predicate10052 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_subpredicate_in_predicate10081 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_subpredicate10125 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_atom_stub_in_subpredicate10129 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_predicate_atom_stub_in_subpredicate10153 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_predicate_atom_stub10187 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_predicate_atom_stub10205 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_stop_in_predicate_atom_stub10223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_predicate_in_predicate_atom_stub10240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_relation_symbol_in_predicate_atom_stub10259 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_predicate_atom_stub10264 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_predicate_atom_stub10268 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_in_in_predicate_atom_stub10300 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_predicate_atom_stub10304 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_assertion_range_in_predicate_atom_stub10308 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PLUS_EQUALS_in_predicate_atom_stub10332 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_in_predicate_atom_stub10338 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_predicate_atom_stub10342 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_def_in_predicate_atom_stub10370 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_parameter_in_predicate_atom_stub10374 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_range_symbol_in_assertion_range10411 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range10415 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_range10419 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_assertion_parameter10458 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TILDE_in_assertion_parameter10475 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion_parameter10479 = new BitSet(new long[]{0x8000400000000000L,0x0000402000000000L,0x0000010010000000L,0x00000004000000C0L,0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_type_in_assertion_parameter10483 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_boolean_in_assertion_type10520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_natural_in_assertion_type10537 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_integer_in_assertion_type10552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_rational_in_assertion_type10567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_real_in_assertion_type10582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_complex_in_assertion_type10597 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_time_in_assertion_type10611 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_assertion_type10629 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_timed_predicate10653 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate10671 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate10686 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_timed_predicate10702 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate10706 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_TICK_in_timed_predicate10730 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_in_timed_predicate10734 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_predicate10756 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_in_timed_predicate10766 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate10780 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_stop_in_timed_predicate10794 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_true_in_timed_predicate10821 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate10834 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_predicate10848 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_CARET_in_timed_predicate10964 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_in_timed_predicate10974 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_parenthesized_predicate_in_timed_predicate10984 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_stop_in_timed_predicate10994 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_LITERAL_true_in_timed_predicate11009 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_predicate_invocation_in_timed_predicate11018 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_period_shift_in_timed_predicate11033 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_predicate11159 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_parenthesized_predicate11163 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_predicate11167 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVOKE_in_predicate_invocation11198 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_predicate_invocation11204 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_predicate_invocation11208 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_INVOKE_in_predicate_invocation11239 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_predicate_invocation11243 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVOKE_in_predicate_invocation11266 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_predicate_invocation11272 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_invocation11276 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_WP_in_predicate_invocation11307 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_actions_in_predicate_invocation11311 = new BitSet(new long[]{0x9010000004040180L,0x0100000030000041L,0x0004080003400014L,0x10E0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_predicate_in_predicate_invocation11315 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PARAMETER_in_actual_assertion_parameter11356 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter11360 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_actual_assertion_parameter11364 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PARAMETER_in_actual_assertion_parameter11391 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_COLON_TILDE_in_actual_assertion_parameter11393 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_actual_assertion_parameter11397 = new BitSet(new long[]{0x9010000004040180L,0x0100000030000041L,0x0004080003400014L,0x10E0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_predicate_in_actual_assertion_parameter11401 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_relation_symbol_in_predicate_relation11440 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_relation11444 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_relation11448 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_in_in_predicate_relation11490 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_predicate_relation11494 = new BitSet(new long[]{0x0000300180000000L});
	public static final BitSet FOLLOW_range_in_predicate_relation11498 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_range_symbol_in_range11532 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_in_range11536 = new BitSet(new long[]{0x8840441208000010L,0x001044002000000AL,0x0004591010000010L,0x4460012C000004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_expression_in_range11540 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_sum_in_assertion_expression11589 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression11593 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression11597 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression11601 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression11605 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_product_in_assertion_expression11641 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression11645 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000002000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression11649 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_LITERAL_of_in_assertion_expression11653 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_expression11657 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_numberof_in_assertion_expression11694 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_logic_variables_in_assertion_expression11698 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000002000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_logic_variable_domain_in_assertion_expression11702 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LITERAL_that_in_assertion_expression11705 = new BitSet(new long[]{0x9010000004040180L,0x0100000000000040L,0x0000080002000010L,0x10C0010000800000L,0x0000401000000048L});
	public static final BitSet FOLLOW_subpredicate_in_assertion_expression11709 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PLUS_in_assertion_expression11744 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11748 = new BitSet(new long[]{0x800040120C040018L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_TIMES_in_assertion_expression11776 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11780 = new BitSet(new long[]{0x800040120C040018L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_MINUS_in_assertion_expression11810 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11814 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11818 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DIVIDE_in_assertion_expression11856 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11860 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11864 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_EXP_in_assertion_expression11903 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11907 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11911 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_mod_in_assertion_expression11950 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11954 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11958 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_rem_in_assertion_expression11993 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression11997 = new BitSet(new long[]{0x800040120C040010L,0x010040000200008AL,0x0000510010000010L,0x4040012C000000C0L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression12001 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_subexpression_in_assertion_expression12034 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression12071 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_assertion_subexpression12088 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression12092 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_abs_in_assertion_subexpression12115 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_timed_expression_in_assertion_subexpression12119 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_def_in_assertion_subexpression12146 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_parameter_in_assertion_subexpression12150 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_assertion_type_conversion_in_assertion_subexpression12178 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_value_in_timed_expression12215 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_timed_expression12239 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_timed_expression12253 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_timed_expression12269 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_timed_expression12274 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_timed_expression12280 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_AT_SIGN_in_timed_expression12320 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_timed_expression12326 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_timed_expression12333 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_timed_expression12339 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_timed_expression12346 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_CARET_in_timed_expression12408 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_timed_expression12414 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_parenthesized_assertion_expression_in_timed_expression12421 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_timed_expression12427 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_period_shift_in_timed_expression12434 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12514 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_time_expression12533 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12537 = new BitSet(new long[]{0x8000400200000018L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_TIMES_in_time_expression12564 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12568 = new BitSet(new long[]{0x8000400200000018L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_MINUS_in_time_expression12595 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12599 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12603 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DIVIDE_in_time_expression12633 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12637 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12641 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_EXP_in_time_expression12671 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12675 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12679 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_mod_in_time_expression12709 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12713 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12717 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_rem_in_time_expression12747 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12751 = new BitSet(new long[]{0x8000400200000010L,0x000000000000008AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_time_subexpression_in_time_expression12755 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_time_subexpression12794 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_time_subexpression12798 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_time_subexpression12822 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_time_subexpression12826 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_time_subexpression12850 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LPAREN_in_time_subexpression12855 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_expression_in_time_subexpression12859 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_time_subexpression12863 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_value_in_time_subexpression12888 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_function_invocation_in_time_subexpression12904 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_time_subexpression12921 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_time_expression_in_time_subexpression12925 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_time_subexpression12929 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVOKE_FUNCTION_in_assertion_function_invocation12961 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation12965 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVOKE_FUNCTION_in_assertion_function_invocation12990 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation12995 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_assertion_function_invocation12999 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INVOKE_FUNCTION_in_assertion_function_invocation13030 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion_function_invocation13035 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_actual_assertion_parameter_in_assertion_function_invocation13040 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_assertion_expression13092 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_parenthesized_assertion_expression13096 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_assertion_expression13098 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_conditional_assertion_expression_in_parenthesized_assertion_expression13124 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assertion_record_term_in_parenthesized_assertion_expression13149 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_expression_in_parenthesized_assertion_expression13167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CONDITIONAL_in_conditional_assertion_expression13204 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_conditional_assertion_expression13208 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression13212 = new BitSet(new long[]{0x804044120C040010L,0x010040000200008AL,0x4000D11010000010L,0x4440012C080004C0L,0x0000105000450018L});
	public static final BitSet FOLLOW_assertion_expression_in_conditional_assertion_expression13216 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_assertion_record_term13265 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_record_value_in_assertion_record_term13269 = new BitSet(new long[]{0x0000000000001000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_assertion_record_term13272 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ARROW_in_assertion_record_value13308 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_assertion_record_value13312 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4000012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_value_in_assertion_record_value13316 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_value_in_period_shift13352 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_period_shift13373 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_name_in_period_shift13377 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_UNARY_MINUS_in_period_shift13399 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13403 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift13426 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13430 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift13432 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift13454 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_MINUS_in_period_shift13457 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13461 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13465 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift13468 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift13494 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_DIVIDE_in_period_shift13497 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13501 = new BitSet(new long[]{0x8000400200000010L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13505 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift13508 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift13534 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_PLUS_in_period_shift13537 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13541 = new BitSet(new long[]{0x8000400200000018L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift13545 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_period_shift13567 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_TIMES_in_period_shift13570 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_period_shift_in_period_shift13574 = new BitSet(new long[]{0x8000400200000018L,0x000000000000000AL,0x0000500000000010L,0x4040012800000000L,0x0000101000450008L});
	public static final BitSet FOLLOW_RPAREN_in_period_shift13578 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_availability_in_availability13627 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability13631 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_and_in_availability_expression13661 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression13665 = new BitSet(new long[]{0x8000000000000008L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_or_in_availability_expression13685 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression13689 = new BitSet(new long[]{0x8000000000000008L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_LITERAL_xor_in_availability_expression13709 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression13713 = new BitSet(new long[]{0x8000000000000008L,0x0000000000000000L,0x0000080000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_availability_subexpression_in_availability_expression13734 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_availability_subexpression13757 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LPAREN_in_availability_subexpression13760 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_availability_expression_in_availability_subexpression13764 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_not_in_availability_subexpression13785 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_availability_subexpression13789 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_availability_subexpression13809 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_availability_expression_in_availability_subexpression13813 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_ID_in_availability_subexpression13834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_dispatch_in_dispatch_condition13859 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_dispatch_expression_in_dispatch_condition13864 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_or_in_dispatch_expression13908 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression13912 = new BitSet(new long[]{0x8000000000000008L,0x0000000020000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_dispatch_conjunction_in_dispatch_expression13935 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction13961 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_dispatch_conjunction13973 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_dispatch_trigger_in_dispatch_conjunction13977 = new BitSet(new long[]{0x8000000000000008L,0x0000000000000000L,0x0000000000000000L,0x0000000800800000L});
	public static final BitSet FOLLOW_ID_in_dispatch_trigger14012 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger14037 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LPAREN_in_dispatch_trigger14039 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_dispatch_trigger14044 = new BitSet(new long[]{0x8000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_dispatch_trigger14048 = new BitSet(new long[]{0x0000000000400000L});
	public static final BitSet FOLLOW_behavior_time_in_dispatch_trigger14052 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger14087 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_timeout_in_dispatch_trigger14106 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_behavior_time_in_dispatch_trigger14110 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_stop_in_dispatch_trigger14133 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_integer_literal14158 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_true_in_value_constant14185 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_false_in_value_constant14202 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AADL_STRING_LITERAL_in_value_constant14218 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_numeric_constant_in_value_constant14234 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_value_in_value_constant14250 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TICK_in_enumeration_value14283 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_enumeration_value14287 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_enumeration_value14291 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_constant14359 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_property_constant14363 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_property_constant14367 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference14408 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_property_name_in_property_reference14412 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference14450 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_property_name_in_property_reference14454 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference14458 = new BitSet(new long[]{0x0000000000000008L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference14501 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_self_in_property_reference14505 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference14509 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference14552 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_self_in_property_reference14556 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference14560 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference14564 = new BitSet(new long[]{0x0000000000000008L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference14614 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_property_reference14618 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference14622 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_OCTOTHORPE_in_property_reference14658 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_unique_component_classifier_reference_in_property_reference14662 = new BitSet(new long[]{0x0000400000000000L});
	public static final BitSet FOLLOW_property_name_in_property_reference14666 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_property_field_in_property_reference14670 = new BitSet(new long[]{0x0000000000000008L,0x0000000000002000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_DOUBLE_COLON_in_property_name14710 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_property_name14714 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_property_name14718 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LBRACKET_in_property_field14755 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_property_field14759 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_property_field14761 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LBRACKET_in_property_field14785 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_property_field14789 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_RBRACKET_in_property_field14791 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_property_field14815 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_ID_in_property_field14819 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_property_field14843 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_upper_bound_in_property_field14845 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_PERIOD_in_property_field14866 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_lower_bound_in_property_field14868 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_numeric_constant14899 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_LIT_in_numeric_constant14922 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rational_literal_in_numeric_constant14947 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_complex_literal_in_numeric_constant14964 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_constant_in_numeric_constant14982 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_reference_in_numeric_constant14999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RATIONAL_in_rational_literal15022 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15026 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15030 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_RATIONAL_in_rational_literal15056 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal15059 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15063 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15068 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_RATIONAL_in_rational_literal15094 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15098 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal15101 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15105 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_RATIONAL_in_rational_literal15132 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal15135 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15139 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_MINUS_in_rational_literal15143 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_INTEGER_LIT_in_rational_literal15147 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COMPLEX_in_complex_literal15183 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15187 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15191 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COMPLEX_in_complex_literal15217 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal15220 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15224 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15229 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COMPLEX_in_complex_literal15255 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15259 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0400000000000000L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal15262 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15266 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_COMPLEX_in_complex_literal15293 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal15296 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15300 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_MINUS_in_complex_literal15304 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_REAL_LIT_in_complex_literal15308 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_in_in_in_modes15355 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_LITERAL_modes_in_in_modes15357 = new BitSet(new long[]{0x8000000000000000L});
	public static final BitSet FOLLOW_ID_in_in_modes15361 = new BitSet(new long[]{0x8000000000000008L});
	public static final BitSet FOLLOW_record_term_in_parenthesized_xxx15413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_xxx15427 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_parenthesized_xxx15431 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_xxx15433 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_xxx15460 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_parenthesized_xxx15464 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_xxx15466 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized_xxx15492 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_predicate_in_parenthesized_xxx15496 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized_xxx15500 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_relation_in_boolean_expression_or_relation15546 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolean_expression_in_boolean_expression_or_relation15560 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_and_in_boolean_expression15589 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression15593 = new BitSet(new long[]{0x8000401208000018L,0x000000000000000AL,0x0000580000000010L,0x4040012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_LITERAL_or_in_boolean_expression15619 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression15623 = new BitSet(new long[]{0x8000401208000018L,0x000000000000000AL,0x0000580000000010L,0x4040012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_LITERAL_xor_in_boolean_expression15649 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression15653 = new BitSet(new long[]{0x8000401208000018L,0x000000000000000AL,0x0000580000000010L,0x4040012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_LITERAL_cand_in_boolean_expression15679 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression15683 = new BitSet(new long[]{0x8000401208000018L,0x000000000000000AL,0x0000580000000010L,0x4040012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_LITERAL_cor_in_boolean_expression15709 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression15713 = new BitSet(new long[]{0x8000401208000018L,0x000000000000000AL,0x0000580000000010L,0x4040012800000000L,0x0000001000450008L});
	public static final BitSet FOLLOW_boolean_subexpression_in_boolean_expression15739 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_not_in_boolean_subexpression15766 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_value_in_boolean_subexpression15770 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LITERAL_not_in_boolean_subexpression15794 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_boolean_subexpression15798 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_value_in_boolean_subexpression15823 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_subexpression_in_boolean_subexpression15841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_all_in_synpred1_UnparseBLESS9834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LITERAL_exists_in_synpred2_UnparseBLESS9855 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_record_term_in_synpred3_UnparseBLESS15413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred4_UnparseBLESS15427 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_expression_or_relation_in_synpred4_UnparseBLESS15431 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_synpred4_UnparseBLESS15433 = new BitSet(new long[]{0x0000000000000008L});
	public static final BitSet FOLLOW_LPAREN_in_synpred5_UnparseBLESS15460 = new BitSet(new long[]{0x0000000000000004L});
	public static final BitSet FOLLOW_assertion_expression_in_synpred5_UnparseBLESS15464 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000001000000L});
	public static final BitSet FOLLOW_RPAREN_in_synpred5_UnparseBLESS15466 = new BitSet(new long[]{0x0000000000000008L});
}
