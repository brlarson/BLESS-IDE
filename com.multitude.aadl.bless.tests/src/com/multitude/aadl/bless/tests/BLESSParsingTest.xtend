/*
 * (C) Multitude Corporation 2020
 * generated by Xtext 2.20.0
 from BLESS.xtext, by BRL 
 */
package com.multitude.aadl.bless.tests

import com.google.inject.Inject
import com.multitude.aadl.bless.bLESS.BLESSGrammarRoots
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(BLESSInjectorProvider)
class BLESSParsingTest {
	@Inject
	ParseHelper<BLESSGrammarRoots> parseHelper
	
  @Test
  def void emptyBlessSubclause() {
    val result = parseHelper.parse('''
      blesssubclause
    ''')
    Assert.assertNotNull(result)
    val errors = result.eResource.errors
    Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
  }
  
  
  @Test
  def void justAssertClause() {
    val result = parseHelper.parse('''
      blesssubclause
assert       
  << notVRP: : --Ventricular Refractory Period
    (n or p)@last_beat --last beat before now,
    and ((now-last_beat)>=vrp)>>  --older than VRP
  << VS: : --ventricular sense detected, not in VRP
    s@now and notVRP() >>
  << VP: : --cause ventricular pace
    (n or p)@(now-lrl)  --last beat occurred LRL interval ago,
    and --not since then
      not (exists t~time  --there is no time  
        in (now-lrl),,now  --since then, ",," means open interval
        that (n or p)@t) >>  --with a beat
  << PACE:x~time: --pace occurred in the previous LRL interval
    p@last_beat and  --previous beat was a pace
    (exists t~time  --there is a time 
      in (x-lrl)..x  --in the previous LRL interval 
      that p@t) >>  --with a ventricular pace     
  << SENSE:x~time:  --sense occurred in the previous LRL interval
    n@last_beat and  --previous beat was a sense
    (exists t~time  --there is a time 
      in (x-lrl)..x  --in the previous LRL interval
      that n@t) >>  --with a non-refractory sense 
    ''')
    Assert.assertNotNull(result)
    val errors = result.eResource.errors
    Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
  }
  
  @Test
  def void justInvariantClause() {
    val result = parseHelper.parse('''
      blesssubclause
invariant  
  << LRL: : --Lower Rate Limit
    exists t~time  --there was a moment
      in (now-lrl)..now   --within the previous LRL interval
      that (n@t or p@t) >>  --with a pace or non-refractory sense 
    ''')
    Assert.assertNotNull(result)
    val errors = result.eResource.errors
    Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
  }
  
  @Test
  def void justVariablesSection() {
    val result = parseHelper.parse('''
      blesssubclause
variables
  last_beat ~ time := 0 s  --useless initialization needed so Slang won't complain
    --the last pace or non-refractory sense occurred at last_beat
  << LAST: :(n or p)@last_beat>>  
    ''')
    Assert.assertNotNull(result)
    val errors = result.eResource.errors
    Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
  }
  
  
  @Test
  def void justStatesSection() {
    val result = parseHelper.parse('''
      blesssubclause
states
  power_on : initial state  --powered-up, 
    <<now=0>> --start with "sense"
  pace : complete state 
      --a ventricular pace has occured in the 
      --previous LRL-interval milliseconds
    << PACE(now)>> 
  sense : complete state  
      --a ventricular sense has occured in the 
      --previous LRL-interval milliseconds
    << SENSE(now)>>   
  check_pace_vrp : state  
      --execute state to check if s is in vrp after pace
    <<s@now and PACE(now)>>
  check_sense_vrp : state  
      --execute state to check if s is in vrp after sense
    <<s@now and SENSE(now)>>
  off : final state  --upon "stop"
    ''')
    Assert.assertNotNull(result)
    val errors = result.eResource.errors
    Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
  }
  
  
  @Test
  def void justTransitions() {
    val result = parseHelper.parse('''
      blesssubclause
transitions  
  T1_POWER_ON:  --initialization
  power_on -[ ]-> sense 
    {
      <<now=0>>
    n! <<n@now>>   --first "sense" at initialization
    & 
    last_beat:=now 
    <<last_beat=now>>
    };    

  T2_STOP:    --turn off pacing
  pace,sense -[on dispatch stop]-> off{}

  T3_PACE_LRL_AFTER_VP: --pace when LRL times out
  pace -[on dispatch timeout (n or p) lrl]-> pace
    { << VP()>>
    p! <<p@now>>   --cause pace when LRL times out
    & last_beat:=now <<last_beat=now>>}  

  T4_VS_AFTER_VP: --sense after pace=>check if in VRP
  pace -[on dispatch s]-> check_pace_vrp{}  

  T5_VS_AFTER_VP_IN_VRP:  -- s in VRP,  go back to "pace" state
  check_pace_vrp -[(now-last_beat)<vrp]-> pace{}  

  T6_VS_AFTER_VP_IS_NR: --s after VRP, 
    --go to "sense" state, send n!, reset timeouts
  check_pace_vrp -[(now-last_beat)>=vrp]-> sense     
    {  << VS()>>
    n! <<n@now>>  --send n! to reset timeouts
    & last_beat:=now <<last_beat=now>>}  

  T7_PACE_LRL_AFTER_VS: --pace when LRL times out after VS
  sense -[on dispatch timeout (p or n) lrl]-> pace
    {<< VP()>>
    p! <<p@now>>
    & last_beat:=now <<last_beat=now>>} 

  T8_VS_AFTER_VS: --check if s in VRP
  sense -[on dispatch s]-> check_sense_vrp{}  

  T9_VS_AFTER_VS_IN_VRP:  -- s in VRP,  go back to "sense" state
  check_sense_vrp -[(now-last_beat)<vrp]-> sense{}  

  T10_VS_AFTER_VS_IS_NR:  --s after VRP is non-refractory
  check_sense_vrp -[(now-last_beat)>=vrp]-> sense 
    --reset timeouts with n! port send
    {  << VS()>>
    n! <<n@now>>  --non-refractory ventricular sense
    & last_beat:=now <<last_beat=now>>
    }  
    ''')
    Assert.assertNotNull(result)
    val errors = result.eResource.errors
    Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
  }
  
  
  @Test
  def void parseDispatchConditions() {
    val result = parseHelper.parse('''
        blesssubclause
  transitions  
  T1: s -[on dispatch p]-> d
  T2: s -[on dispatch p or q]-> d
  T3: s -[on dispatch timeout (p or q) 10 ms]-> d
  T4: s -[on dispatch timeout (p or q) 10 ms and r]-> d
  T5: s -[on dispatch p or q and r]-> d
  T6: s -[on dispatch p or q and r or timeout]-> d
  T7: s -[on dispatch stop]-> d
          ''')
      Assert.assertNotNull(result)
      val errors = result.eResource.errors
      Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
    }
  
  
  @Test
  def void parseMultipleSourceStates() {
    val result = parseHelper.parse('''
        blesssubclause
  transitions  
  T1: s,t,u,v -[ ]-> d

          ''')
      Assert.assertNotNull(result)
      val errors = result.eResource.errors
      Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
    }
  
   @Test
  def void parseExecuteConditions() {
    val result = parseHelper.parse('''
        blesssubclause
  transitions  
  T1: s -[true]-> d
  T2: s -[false]-> d
  T3: s -[x=5 or not b]-> d
  T4: s -[otherwise]-> d
  T5: s -[a or b implies c or else d]-> d
  T6: s -[a xor c and d xor e and then f]-> d
  T7: s -[x=y or a<>b and f<g]-> d
          ''')
      Assert.assertNotNull(result)
      val errors = result.eResource.errors
      Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
    }
  
  @Test
  def void parseBehaviorActions() {
    val result = parseHelper.parse('''
        blesssubclause
  transitions  
  T1: s -[true]-> d {skip} <<true>>;
  T2: s -[false]-> d {a:=5 ; c:=d} <<c=d>>
  T3: s -[x=5 or not b]-> d {skip & b:=5}
  T4: s -[otherwise]-> d {<<PRE()>> x:= x+1 <<POST()>>}
  T5: s -[a or b implies c or else d]-> d {<<X>> skip <<X>> ; <<X>> skip <<X>>}
          ''')
      Assert.assertNotNull(result)
      val errors = result.eResource.errors
      Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
    }
  
   
	
	
}
