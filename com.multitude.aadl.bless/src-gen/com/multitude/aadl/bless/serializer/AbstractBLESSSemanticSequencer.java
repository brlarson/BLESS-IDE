/*
 * (C) Multitude Corporation 2023
 * generated by Xtext 2.27.0
 from BLESS.xtext, by BRL 
 */
package com.multitude.aadl.bless.serializer;

import com.google.inject.Inject;
import com.multitude.aadl.bless.bLESS.ANumber;
import com.multitude.aadl.bless.bLESS.ActionSubclause;
import com.multitude.aadl.bless.bLESS.ActionTimeout;
import com.multitude.aadl.bless.bLESS.ActualParameter;
import com.multitude.aadl.bless.bLESS.AddSub;
import com.multitude.aadl.bless.bLESS.Alternative;
import com.multitude.aadl.bless.bLESS.ArrayRange;
import com.multitude.aadl.bless.bLESS.ArrayRangeList;
import com.multitude.aadl.bless.bLESS.ArrayType;
import com.multitude.aadl.bless.bLESS.AssertClause;
import com.multitude.aadl.bless.bLESS.AssertedAction;
import com.multitude.aadl.bless.bLESS.Assertion;
import com.multitude.aadl.bless.bLESS.AssertionEnumeration;
import com.multitude.aadl.bless.bLESS.AssertionFunctionValue;
import com.multitude.aadl.bless.bLESS.AssertionLibrary;
import com.multitude.aadl.bless.bLESS.Assignment;
import com.multitude.aadl.bless.bLESS.BAAlternative;
import com.multitude.aadl.bless.bLESS.BLESSAlternative;
import com.multitude.aadl.bless.bLESS.BLESSGrammarRoots;
import com.multitude.aadl.bless.bLESS.BLESSPackage;
import com.multitude.aadl.bless.bLESS.BLESSSubclause;
import com.multitude.aadl.bless.bLESS.BasicAction;
import com.multitude.aadl.bless.bLESS.BehaviorActions;
import com.multitude.aadl.bless.bLESS.BehaviorState;
import com.multitude.aadl.bless.bLESS.BehaviorTime;
import com.multitude.aadl.bless.bLESS.BehaviorTransition;
import com.multitude.aadl.bless.bLESS.BooleanType;
import com.multitude.aadl.bless.bLESS.CaseChoice;
import com.multitude.aadl.bless.bLESS.CaseExpression;
import com.multitude.aadl.bless.bLESS.CatchClause;
import com.multitude.aadl.bless.bLESS.CatchClauseTerm;
import com.multitude.aadl.bless.bLESS.CombinableOperation;
import com.multitude.aadl.bless.bLESS.CommunicationAction;
import com.multitude.aadl.bless.bLESS.Computation;
import com.multitude.aadl.bless.bLESS.ConditionValuePair;
import com.multitude.aadl.bless.bLESS.ConditionalAssertionFunction;
import com.multitude.aadl.bless.bLESS.ConditionalExpression;
import com.multitude.aadl.bless.bLESS.Conjunction;
import com.multitude.aadl.bless.bLESS.Constant;
import com.multitude.aadl.bless.bLESS.CountingQuantification;
import com.multitude.aadl.bless.bLESS.Disjunction;
import com.multitude.aadl.bless.bLESS.DispatchCondition;
import com.multitude.aadl.bless.bLESS.DispatchConjunction;
import com.multitude.aadl.bless.bLESS.DispatchExpression;
import com.multitude.aadl.bless.bLESS.DispatchTrigger;
import com.multitude.aadl.bless.bLESS.DoUntilLoop;
import com.multitude.aadl.bless.bLESS.ElseAlternative;
import com.multitude.aadl.bless.bLESS.ElseifAlternative;
import com.multitude.aadl.bless.bLESS.EnumerationPair;
import com.multitude.aadl.bless.bLESS.EnumerationType;
import com.multitude.aadl.bless.bLESS.EnumerationValue;
import com.multitude.aadl.bless.bLESS.EventTrigger;
import com.multitude.aadl.bless.bLESS.ExceptionLibrary;
import com.multitude.aadl.bless.bLESS.ExecuteCondition;
import com.multitude.aadl.bless.bLESS.ExecuteTimeout;
import com.multitude.aadl.bless.bLESS.ExistentialLatticeQuantification;
import com.multitude.aadl.bless.bLESS.ExistentialQuantification;
import com.multitude.aadl.bless.bLESS.Exp;
import com.multitude.aadl.bless.bLESS.Expression;
import com.multitude.aadl.bless.bLESS.ExpressionOrAny;
import com.multitude.aadl.bless.bLESS.ForLoop;
import com.multitude.aadl.bless.bLESS.ForallVariable;
import com.multitude.aadl.bless.bLESS.FormalActual;
import com.multitude.aadl.bless.bLESS.FormalActualList;
import com.multitude.aadl.bless.bLESS.FormalExpressionPair;
import com.multitude.aadl.bless.bLESS.FreezePort;
import com.multitude.aadl.bless.bLESS.FunctionParameters;
import com.multitude.aadl.bless.bLESS.GhostVariable;
import com.multitude.aadl.bless.bLESS.GhostVariables;
import com.multitude.aadl.bless.bLESS.GuardedAction;
import com.multitude.aadl.bless.bLESS.IndexExpression;
import com.multitude.aadl.bless.bLESS.IndexExpressionOrRange;
import com.multitude.aadl.bless.bLESS.InternalCondition;
import com.multitude.aadl.bless.bLESS.InvariantClause;
import com.multitude.aadl.bless.bLESS.Invocation;
import com.multitude.aadl.bless.bLESS.IssueException;
import com.multitude.aadl.bless.bLESS.LockingAction;
import com.multitude.aadl.bless.bLESS.LogicVariables;
import com.multitude.aadl.bless.bLESS.LogicalOperator;
import com.multitude.aadl.bless.bLESS.ModeCondition;
import com.multitude.aadl.bless.bLESS.MultDiv;
import com.multitude.aadl.bless.bLESS.NameTick;
import com.multitude.aadl.bless.bLESS.NamedAssertion;
import com.multitude.aadl.bless.bLESS.NamelessAssertion;
import com.multitude.aadl.bless.bLESS.NamelessEnumeration;
import com.multitude.aadl.bless.bLESS.NamelessFunction;
import com.multitude.aadl.bless.bLESS.NullType;
import com.multitude.aadl.bless.bLESS.Otherwise;
import com.multitude.aadl.bless.bLESS.ParenthesizedSubexpression;
import com.multitude.aadl.bless.bLESS.PartialName;
import com.multitude.aadl.bless.bLESS.Pause;
import com.multitude.aadl.bless.bLESS.PeriodShift;
import com.multitude.aadl.bless.bLESS.PortInput;
import com.multitude.aadl.bless.bLESS.PortName;
import com.multitude.aadl.bless.bLESS.PortOutput;
import com.multitude.aadl.bless.bLESS.Priority;
import com.multitude.aadl.bless.bLESS.ProductQuantification;
import com.multitude.aadl.bless.bLESS.PropertyField;
import com.multitude.aadl.bless.bLESS.PropertyReference;
import com.multitude.aadl.bless.bLESS.QuantifiedVariables;
import com.multitude.aadl.bless.bLESS.Quantity;
import com.multitude.aadl.bless.bLESS.QuantityType;
import com.multitude.aadl.bless.bLESS.Range;
import com.multitude.aadl.bless.bLESS.RecordField;
import com.multitude.aadl.bless.bLESS.RecordTerm;
import com.multitude.aadl.bless.bLESS.RecordType;
import com.multitude.aadl.bless.bLESS.RecordValue;
import com.multitude.aadl.bless.bLESS.Relation;
import com.multitude.aadl.bless.bLESS.RootDeclaration;
import com.multitude.aadl.bless.bLESS.SimultaneousAssignment;
import com.multitude.aadl.bless.bLESS.StatesSection;
import com.multitude.aadl.bless.bLESS.StringType;
import com.multitude.aadl.bless.bLESS.SubProgramParameter;
import com.multitude.aadl.bless.bLESS.Subexpression;
import com.multitude.aadl.bless.bLESS.SubprogramAccessDispatch;
import com.multitude.aadl.bless.bLESS.SubprogramCall;
import com.multitude.aadl.bless.bLESS.SumQuantification;
import com.multitude.aadl.bless.bLESS.ThrowsClause;
import com.multitude.aadl.bless.bLESS.TimedExpression;
import com.multitude.aadl.bless.bLESS.TimedSubject;
import com.multitude.aadl.bless.bLESS.Transitions;
import com.multitude.aadl.bless.bLESS.TriggerLogicalExpression;
import com.multitude.aadl.bless.bLESS.TypeDeclaration;
import com.multitude.aadl.bless.bLESS.TypeLibrary;
import com.multitude.aadl.bless.bLESS.TypeOrReference;
import com.multitude.aadl.bless.bLESS.UnaryOperator;
import com.multitude.aadl.bless.bLESS.UnitExtension;
import com.multitude.aadl.bless.bLESS.UnitFactor;
import com.multitude.aadl.bless.bLESS.UnitFormula;
import com.multitude.aadl.bless.bLESS.UnitLibrary;
import com.multitude.aadl.bless.bLESS.UnitName;
import com.multitude.aadl.bless.bLESS.UniversalLatticeQuantification;
import com.multitude.aadl.bless.bLESS.UniversalQuantification;
import com.multitude.aadl.bless.bLESS.Value;
import com.multitude.aadl.bless.bLESS.ValueName;
import com.multitude.aadl.bless.bLESS.Variable;
import com.multitude.aadl.bless.bLESS.VariableDeclaration;
import com.multitude.aadl.bless.bLESS.VariableList;
import com.multitude.aadl.bless.bLESS.VariablesSection;
import com.multitude.aadl.bless.bLESS.WhenThrow;
import com.multitude.aadl.bless.bLESS.WhileLoop;
import com.multitude.aadl.bless.services.BLESSGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.aadl2.Aadl2Package;

@SuppressWarnings("all")
public abstract class AbstractBLESSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BLESSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BLESSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BLESSPackage.ANUMBER:
				sequence_ANumber(context, (ANumber) semanticObject); 
				return; 
			case BLESSPackage.ACTION:
				sequence_Action(context, (com.multitude.aadl.bless.bLESS.Action) semanticObject); 
				return; 
			case BLESSPackage.ACTION_SUBCLAUSE:
				sequence_ActionSubclause(context, (ActionSubclause) semanticObject); 
				return; 
			case BLESSPackage.ACTION_TIMEOUT:
				sequence_ActionTimeout(context, (ActionTimeout) semanticObject); 
				return; 
			case BLESSPackage.ACTUAL_PARAMETER:
				sequence_ActualParameter(context, (ActualParameter) semanticObject); 
				return; 
			case BLESSPackage.ADD_SUB:
				sequence_AddSub(context, (AddSub) semanticObject); 
				return; 
			case BLESSPackage.ALTERNATIVE:
				sequence_Alternative(context, (Alternative) semanticObject); 
				return; 
			case BLESSPackage.ARRAY_RANGE:
				sequence_ArrayRange(context, (ArrayRange) semanticObject); 
				return; 
			case BLESSPackage.ARRAY_RANGE_LIST:
				sequence_ArrayRangeList(context, (ArrayRangeList) semanticObject); 
				return; 
			case BLESSPackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case BLESSPackage.ASSERT_CLAUSE:
				sequence_AssertClause(context, (AssertClause) semanticObject); 
				return; 
			case BLESSPackage.ASSERTED_ACTION:
				sequence_AssertedAction(context, (AssertedAction) semanticObject); 
				return; 
			case BLESSPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case BLESSPackage.ASSERTION_ENUMERATION:
				sequence_AssertionEnumeration(context, (AssertionEnumeration) semanticObject); 
				return; 
			case BLESSPackage.ASSERTION_FUNCTION_VALUE:
				sequence_AssertionFunctionValue(context, (AssertionFunctionValue) semanticObject); 
				return; 
			case BLESSPackage.ASSERTION_LIBRARY:
				sequence_AssertionLibrary(context, (AssertionLibrary) semanticObject); 
				return; 
			case BLESSPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case BLESSPackage.BA_ALTERNATIVE:
				sequence_BAAlternative(context, (BAAlternative) semanticObject); 
				return; 
			case BLESSPackage.BLESS_ALTERNATIVE:
				sequence_BLESSAlternative(context, (BLESSAlternative) semanticObject); 
				return; 
			case BLESSPackage.BLESS_GRAMMAR_ROOTS:
				sequence_BLESSGrammarRoots(context, (BLESSGrammarRoots) semanticObject); 
				return; 
			case BLESSPackage.BLESS_SUBCLAUSE:
				sequence_BLESSSubclause(context, (BLESSSubclause) semanticObject); 
				return; 
			case BLESSPackage.BASIC_ACTION:
				sequence_BasicAction(context, (BasicAction) semanticObject); 
				return; 
			case BLESSPackage.BEHAVIOR_ACTIONS:
				sequence_BehaviorActions(context, (BehaviorActions) semanticObject); 
				return; 
			case BLESSPackage.BEHAVIOR_STATE:
				sequence_BehaviorState(context, (BehaviorState) semanticObject); 
				return; 
			case BLESSPackage.BEHAVIOR_TIME:
				sequence_BehaviorTime(context, (BehaviorTime) semanticObject); 
				return; 
			case BLESSPackage.BEHAVIOR_TRANSITION:
				sequence_BehaviorTransition(context, (BehaviorTransition) semanticObject); 
				return; 
			case BLESSPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case BLESSPackage.CASE_CHOICE:
				sequence_CaseChoice(context, (CaseChoice) semanticObject); 
				return; 
			case BLESSPackage.CASE_EXPRESSION:
				sequence_CaseExpression(context, (CaseExpression) semanticObject); 
				return; 
			case BLESSPackage.CATCH_CLAUSE:
				sequence_CatchClause(context, (CatchClause) semanticObject); 
				return; 
			case BLESSPackage.CATCH_CLAUSE_TERM:
				sequence_CatchClauseTerm(context, (CatchClauseTerm) semanticObject); 
				return; 
			case BLESSPackage.COMBINABLE_OPERATION:
				sequence_CombinableOperation(context, (CombinableOperation) semanticObject); 
				return; 
			case BLESSPackage.COMMUNICATION_ACTION:
				sequence_CommunicationAction(context, (CommunicationAction) semanticObject); 
				return; 
			case BLESSPackage.COMPUTATION:
				sequence_Computation(context, (Computation) semanticObject); 
				return; 
			case BLESSPackage.CONDITION_VALUE_PAIR:
				sequence_ConditionValuePair(context, (ConditionValuePair) semanticObject); 
				return; 
			case BLESSPackage.CONDITIONAL_ASSERTION_FUNCTION:
				sequence_ConditionalAssertionFunction(context, (ConditionalAssertionFunction) semanticObject); 
				return; 
			case BLESSPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case BLESSPackage.CONJUNCTION:
				sequence_Conjunction(context, (Conjunction) semanticObject); 
				return; 
			case BLESSPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case BLESSPackage.COUNTING_QUANTIFICATION:
				sequence_CountingQuantification(context, (CountingQuantification) semanticObject); 
				return; 
			case BLESSPackage.DISJUNCTION:
				sequence_Disjunction(context, (Disjunction) semanticObject); 
				return; 
			case BLESSPackage.DISPATCH_CONDITION:
				sequence_DispatchCondition(context, (DispatchCondition) semanticObject); 
				return; 
			case BLESSPackage.DISPATCH_CONJUNCTION:
				sequence_DispatchConjunction(context, (DispatchConjunction) semanticObject); 
				return; 
			case BLESSPackage.DISPATCH_EXPRESSION:
				sequence_DispatchExpression(context, (DispatchExpression) semanticObject); 
				return; 
			case BLESSPackage.DISPATCH_TRIGGER:
				sequence_DispatchTrigger(context, (DispatchTrigger) semanticObject); 
				return; 
			case BLESSPackage.DO_UNTIL_LOOP:
				sequence_DoUntilLoop(context, (DoUntilLoop) semanticObject); 
				return; 
			case BLESSPackage.ELSE_ALTERNATIVE:
				sequence_ElseAlternative(context, (ElseAlternative) semanticObject); 
				return; 
			case BLESSPackage.ELSEIF_ALTERNATIVE:
				sequence_ElseifAlternative(context, (ElseifAlternative) semanticObject); 
				return; 
			case BLESSPackage.ENUMERATION_PAIR:
				sequence_EnumerationPair(context, (EnumerationPair) semanticObject); 
				return; 
			case BLESSPackage.ENUMERATION_TYPE:
				sequence_EnumerationType(context, (EnumerationType) semanticObject); 
				return; 
			case BLESSPackage.ENUMERATION_VALUE:
				sequence_EnumerationValue(context, (EnumerationValue) semanticObject); 
				return; 
			case BLESSPackage.EVENT_TRIGGER:
				sequence_EventTrigger(context, (EventTrigger) semanticObject); 
				return; 
			case BLESSPackage.EXCEPTION:
				sequence_Exception(context, (com.multitude.aadl.bless.bLESS.Exception) semanticObject); 
				return; 
			case BLESSPackage.EXCEPTION_LIBRARY:
				sequence_ExceptionLibrary(context, (ExceptionLibrary) semanticObject); 
				return; 
			case BLESSPackage.EXECUTE_CONDITION:
				sequence_ExecuteCondition(context, (ExecuteCondition) semanticObject); 
				return; 
			case BLESSPackage.EXECUTE_TIMEOUT:
				sequence_ExecuteTimeout(context, (ExecuteTimeout) semanticObject); 
				return; 
			case BLESSPackage.EXISTENTIAL_LATTICE_QUANTIFICATION:
				sequence_ExistentialLatticeQuantification(context, (ExistentialLatticeQuantification) semanticObject); 
				return; 
			case BLESSPackage.EXISTENTIAL_QUANTIFICATION:
				sequence_ExistentialQuantification(context, (ExistentialQuantification) semanticObject); 
				return; 
			case BLESSPackage.EXP:
				sequence_Exp(context, (Exp) semanticObject); 
				return; 
			case BLESSPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case BLESSPackage.EXPRESSION_OR_ANY:
				sequence_ExpressionOrAny(context, (ExpressionOrAny) semanticObject); 
				return; 
			case BLESSPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case BLESSPackage.FORALL_VARIABLE:
				sequence_ForallVariable(context, (ForallVariable) semanticObject); 
				return; 
			case BLESSPackage.FORMAL_ACTUAL:
				sequence_FormalActual(context, (FormalActual) semanticObject); 
				return; 
			case BLESSPackage.FORMAL_ACTUAL_LIST:
				sequence_FormalActualList(context, (FormalActualList) semanticObject); 
				return; 
			case BLESSPackage.FORMAL_EXPRESSION_PAIR:
				sequence_FormalExpressionPair(context, (FormalExpressionPair) semanticObject); 
				return; 
			case BLESSPackage.FREEZE_PORT:
				sequence_FreezePort(context, (FreezePort) semanticObject); 
				return; 
			case BLESSPackage.FUNCTION_PARAMETERS:
				sequence_FunctionParameters(context, (FunctionParameters) semanticObject); 
				return; 
			case BLESSPackage.GHOST_VARIABLE:
				sequence_GhostVariable(context, (GhostVariable) semanticObject); 
				return; 
			case BLESSPackage.GHOST_VARIABLES:
				sequence_GhostVariables(context, (GhostVariables) semanticObject); 
				return; 
			case BLESSPackage.GUARDED_ACTION:
				sequence_GuardedAction(context, (GuardedAction) semanticObject); 
				return; 
			case BLESSPackage.INDEX_EXPRESSION:
				sequence_IndexExpression(context, (IndexExpression) semanticObject); 
				return; 
			case BLESSPackage.INDEX_EXPRESSION_OR_RANGE:
				sequence_IndexExpressionOrRange(context, (IndexExpressionOrRange) semanticObject); 
				return; 
			case BLESSPackage.INTERNAL_CONDITION:
				sequence_InternalCondition(context, (InternalCondition) semanticObject); 
				return; 
			case BLESSPackage.INVARIANT_CLAUSE:
				sequence_InvariantClause(context, (InvariantClause) semanticObject); 
				return; 
			case BLESSPackage.INVOCATION:
				sequence_Invocation(context, (Invocation) semanticObject); 
				return; 
			case BLESSPackage.ISSUE_EXCEPTION:
				sequence_IssueException(context, (IssueException) semanticObject); 
				return; 
			case BLESSPackage.LOCKING_ACTION:
				sequence_LockingAction(context, (LockingAction) semanticObject); 
				return; 
			case BLESSPackage.LOGIC_VARIABLES:
				sequence_LogicVariables(context, (LogicVariables) semanticObject); 
				return; 
			case BLESSPackage.LOGICAL_OPERATOR:
				sequence_LogicalOperator(context, (LogicalOperator) semanticObject); 
				return; 
			case BLESSPackage.MODE_CONDITION:
				sequence_ModeCondition(context, (ModeCondition) semanticObject); 
				return; 
			case BLESSPackage.MULT_DIV:
				sequence_MultDiv(context, (MultDiv) semanticObject); 
				return; 
			case BLESSPackage.NAME_TICK:
				sequence_NameTick(context, (NameTick) semanticObject); 
				return; 
			case BLESSPackage.NAMED_ASSERTION:
				sequence_NamedAssertion(context, (NamedAssertion) semanticObject); 
				return; 
			case BLESSPackage.NAMELESS_ASSERTION:
				sequence_NamelessAssertion(context, (NamelessAssertion) semanticObject); 
				return; 
			case BLESSPackage.NAMELESS_ENUMERATION:
				sequence_NamelessEnumeration(context, (NamelessEnumeration) semanticObject); 
				return; 
			case BLESSPackage.NAMELESS_FUNCTION:
				sequence_NamelessFunction(context, (NamelessFunction) semanticObject); 
				return; 
			case BLESSPackage.NULL_TYPE:
				sequence_NullType(context, (NullType) semanticObject); 
				return; 
			case BLESSPackage.OTHERWISE:
				sequence_Otherwise(context, (Otherwise) semanticObject); 
				return; 
			case BLESSPackage.PARENTHESIZED_SUBEXPRESSION:
				sequence_ParenthesizedSubexpression(context, (ParenthesizedSubexpression) semanticObject); 
				return; 
			case BLESSPackage.PARTIAL_NAME:
				sequence_PartialName(context, (PartialName) semanticObject); 
				return; 
			case BLESSPackage.PAUSE:
				sequence_Pause(context, (Pause) semanticObject); 
				return; 
			case BLESSPackage.PERIOD_SHIFT:
				sequence_PeriodShift(context, (PeriodShift) semanticObject); 
				return; 
			case BLESSPackage.PORT_INPUT:
				sequence_PortInput(context, (PortInput) semanticObject); 
				return; 
			case BLESSPackage.PORT_NAME:
				sequence_PortName(context, (PortName) semanticObject); 
				return; 
			case BLESSPackage.PORT_OUTPUT:
				sequence_PortOutput(context, (PortOutput) semanticObject); 
				return; 
			case BLESSPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case BLESSPackage.PRODUCT_QUANTIFICATION:
				sequence_ProductQuantification(context, (ProductQuantification) semanticObject); 
				return; 
			case BLESSPackage.PROPERTY_FIELD:
				sequence_PropertyField(context, (PropertyField) semanticObject); 
				return; 
			case BLESSPackage.PROPERTY_REFERENCE:
				sequence_PropertyReference(context, (PropertyReference) semanticObject); 
				return; 
			case BLESSPackage.QUANTIFIED_VARIABLES:
				sequence_QuantifiedVariables(context, (QuantifiedVariables) semanticObject); 
				return; 
			case BLESSPackage.QUANTITY:
				sequence_Quantity(context, (Quantity) semanticObject); 
				return; 
			case BLESSPackage.QUANTITY_TYPE:
				sequence_QuantityType(context, (QuantityType) semanticObject); 
				return; 
			case BLESSPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case BLESSPackage.RECORD_FIELD:
				sequence_RecordField(context, (RecordField) semanticObject); 
				return; 
			case BLESSPackage.RECORD_TERM:
				sequence_RecordTerm(context, (RecordTerm) semanticObject); 
				return; 
			case BLESSPackage.RECORD_TYPE:
				sequence_RecordType(context, (RecordType) semanticObject); 
				return; 
			case BLESSPackage.RECORD_VALUE:
				sequence_RecordValue(context, (RecordValue) semanticObject); 
				return; 
			case BLESSPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case BLESSPackage.ROOT_DECLARATION:
				sequence_RootDeclaration(context, (RootDeclaration) semanticObject); 
				return; 
			case BLESSPackage.SIMULTANEOUS_ASSIGNMENT:
				sequence_SimultaneousAssignment(context, (SimultaneousAssignment) semanticObject); 
				return; 
			case BLESSPackage.STATES_SECTION:
				sequence_StatesSection(context, (StatesSection) semanticObject); 
				return; 
			case BLESSPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case BLESSPackage.SUB_PROGRAM_PARAMETER:
				sequence_SubProgramParameter(context, (SubProgramParameter) semanticObject); 
				return; 
			case BLESSPackage.SUBEXPRESSION:
				sequence_Subexpression(context, (Subexpression) semanticObject); 
				return; 
			case BLESSPackage.SUBPROGRAM_ACCESS_DISPATCH:
				sequence_SubprogramAccessDispatch(context, (SubprogramAccessDispatch) semanticObject); 
				return; 
			case BLESSPackage.SUBPROGRAM_CALL:
				sequence_SubprogramCall(context, (SubprogramCall) semanticObject); 
				return; 
			case BLESSPackage.SUM_QUANTIFICATION:
				sequence_SumQuantification(context, (SumQuantification) semanticObject); 
				return; 
			case BLESSPackage.THROWS_CLAUSE:
				sequence_ThrowsClause(context, (ThrowsClause) semanticObject); 
				return; 
			case BLESSPackage.TIMED_EXPRESSION:
				sequence_TimedExpression(context, (TimedExpression) semanticObject); 
				return; 
			case BLESSPackage.TIMED_SUBJECT:
				sequence_TimedSubject(context, (TimedSubject) semanticObject); 
				return; 
			case BLESSPackage.TRANSITIONS:
				sequence_Transitions(context, (Transitions) semanticObject); 
				return; 
			case BLESSPackage.TRIGGER_LOGICAL_EXPRESSION:
				sequence_TriggerLogicalExpression(context, (TriggerLogicalExpression) semanticObject); 
				return; 
			case BLESSPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case BLESSPackage.TYPE_LIBRARY:
				sequence_TypeLibrary(context, (TypeLibrary) semanticObject); 
				return; 
			case BLESSPackage.TYPE_OR_REFERENCE:
				sequence_TypeOrReference(context, (TypeOrReference) semanticObject); 
				return; 
			case BLESSPackage.UNARY_OPERATOR:
				sequence_UnaryOperator(context, (UnaryOperator) semanticObject); 
				return; 
			case BLESSPackage.UNIT_EXTENSION:
				sequence_UnitExtension(context, (UnitExtension) semanticObject); 
				return; 
			case BLESSPackage.UNIT_FACTOR:
				sequence_UnitFactor(context, (UnitFactor) semanticObject); 
				return; 
			case BLESSPackage.UNIT_FORMULA:
				sequence_UnitFormula(context, (UnitFormula) semanticObject); 
				return; 
			case BLESSPackage.UNIT_LIBRARY:
				sequence_UnitLibrary(context, (UnitLibrary) semanticObject); 
				return; 
			case BLESSPackage.UNIT_NAME:
				sequence_UnitName(context, (UnitName) semanticObject); 
				return; 
			case BLESSPackage.UNIVERSAL_LATTICE_QUANTIFICATION:
				sequence_UniversalLatticeQuantification(context, (UniversalLatticeQuantification) semanticObject); 
				return; 
			case BLESSPackage.UNIVERSAL_QUANTIFICATION:
				sequence_UniversalQuantification(context, (UniversalQuantification) semanticObject); 
				return; 
			case BLESSPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case BLESSPackage.VALUE_NAME:
				sequence_ValueName(context, (ValueName) semanticObject); 
				return; 
			case BLESSPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case BLESSPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case BLESSPackage.VARIABLE_LIST:
				sequence_VariableList(context, (VariableList) semanticObject); 
				return; 
			case BLESSPackage.VARIABLES_SECTION:
				sequence_VariablesSection(context, (VariablesSection) semanticObject); 
				return; 
			case BLESSPackage.WHEN_THROW:
				sequence_WhenThrow(context, (WhenThrow) semanticObject); 
				return; 
			case BLESSPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ANumber returns ANumber
	 *     Element returns ANumber
	 *
	 * Constraint:
	 *     (lit=NUMBER | property=PropertyReference | propertyConstant=[PropertyConstant|QCLREF])
	 * </pre>
	 */
	protected void sequence_ANumber(ISerializationContext context, ANumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexSubclause returns ActionSubclause
	 *     ActionSubclause returns ActionSubclause
	 *     Element returns ActionSubclause
	 *
	 * Constraint:
	 *     (
	 *         no_proof?='DO_NOT_PROVE'? 
	 *         throws_clause=ThrowsClause? 
	 *         assert_clause=AssertClause? 
	 *         precondition=Assertion? 
	 *         postcondition=Assertion? 
	 *         invariant=Assertion? 
	 *         elq=ExistentialLatticeQuantification
	 *     )
	 * </pre>
	 */
	protected void sequence_ActionSubclause(ISerializationContext context, ActionSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActionTimeout returns ActionTimeout
	 *     Element returns ActionTimeout
	 *
	 * Constraint:
	 *     duration=BehaviorTime
	 * </pre>
	 */
	protected void sequence_ActionTimeout(ISerializationContext context, ActionTimeout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getActionTimeout_Duration()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getActionTimeout_Duration()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionTimeoutAccess().getDurationBehaviorTimeParserRuleCall_1_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *     Element returns Action
	 *
	 * Constraint:
	 *     (
	 *         basic=BasicAction | 
	 *         if_fi=Alternative | 
	 *         wl=WhileLoop | 
	 *         fl=ForLoop | 
	 *         du=DoUntilLoop | 
	 *         elq=ExistentialLatticeQuantification | 
	 *         ulq=UniversalLatticeQuantification | 
	 *         la=LockingAction
	 *     )
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, com.multitude.aadl.bless.bLESS.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActualParameter returns ActualParameter
	 *     Element returns ActualParameter
	 *
	 * Constraint:
	 *     (formal=ID actual=Expression)
	 * </pre>
	 */
	protected void sequence_ActualParameter(ISerializationContext context, ActualParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getActualParameter_Formal()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getActualParameter_Formal()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getActualParameter_Actual()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getActualParameter_Actual()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActualParameterAccess().getFormalIDTerminalRuleCall_0_0(), semanticObject.getFormal());
		feeder.accept(grammarAccess.getActualParameterAccess().getActualExpressionParserRuleCall_2_0(), semanticObject.getActual());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AddSub returns AddSub
	 *     Element returns AddSub
	 *
	 * Constraint:
	 *     (l=MultDiv ((sym='+' r+=MultDiv r+=MultDiv*) | (sym='-' r+=MultDiv))?)
	 * </pre>
	 */
	protected void sequence_AddSub(ISerializationContext context, AddSub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Alternative returns Alternative
	 *     Element returns Alternative
	 *
	 * Constraint:
	 *     (guard=BooleanExpression (blessalt=BLESSAlternative | baalt=BAAlternative))
	 * </pre>
	 */
	protected void sequence_Alternative(ISerializationContext context, Alternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArrayRangeList returns ArrayRangeList
	 *     Element returns ArrayRangeList
	 *
	 * Constraint:
	 *     (range+=ArrayRange (comma?=',' range+=ArrayRange range+=ArrayRange*)?)
	 * </pre>
	 */
	protected void sequence_ArrayRangeList(ISerializationContext context, ArrayRangeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArrayRange returns ArrayRange
	 *     Element returns ArrayRange
	 *
	 * Constraint:
	 *     (lb=ANumber ub=ANumber?)
	 * </pre>
	 */
	protected void sequence_ArrayRange(ISerializationContext context, ArrayRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArrayType returns ArrayType
	 *     Element returns ArrayType
	 *     Type returns ArrayType
	 *
	 * Constraint:
	 *     (array_ranges=ArrayRangeList typ=TypeOrReference)
	 * </pre>
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getArrayType_Array_ranges()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getArrayType_Array_ranges()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getArrayType_Typ()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getArrayType_Typ()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeAccess().getArray_rangesArrayRangeListParserRuleCall_2_0(), semanticObject.getArray_ranges());
		feeder.accept(grammarAccess.getArrayTypeAccess().getTypTypeOrReferenceParserRuleCall_5_0(), semanticObject.getTyp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssertClause returns AssertClause
	 *     Element returns AssertClause
	 *
	 * Constraint:
	 *     assertions+=NamedAssertion+
	 * </pre>
	 */
	protected void sequence_AssertClause(ISerializationContext context, AssertClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssertedAction returns AssertedAction
	 *     Element returns AssertedAction
	 *
	 * Constraint:
	 *     (precondition=Assertion? action=Action postcondition=Assertion?)
	 * </pre>
	 */
	protected void sequence_AssertedAction(ISerializationContext context, AssertedAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssertionEnumeration returns AssertionEnumeration
	 *     Element returns AssertionEnumeration
	 *
	 * Constraint:
	 *     (pred=Invocation | (pair+=EnumerationPair pair+=EnumerationPair*))
	 * </pre>
	 */
	protected void sequence_AssertionEnumeration(ISerializationContext context, AssertionEnumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssertionFunctionValue returns AssertionFunctionValue
	 *     Element returns AssertionFunctionValue
	 *
	 * Constraint:
	 *     (cexp=ConditionalAssertionFunction | pexp=AssertionNumericExpression)
	 * </pre>
	 */
	protected void sequence_AssertionFunctionValue(ISerializationContext context, AssertionFunctionValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexLibrary returns AssertionLibrary
	 *     AssertionLibrary returns AssertionLibrary
	 *     Element returns AssertionLibrary
	 *
	 * Constraint:
	 *     (ghosts=GhostVariables? assertion_list+=NamedAssertion*)
	 * </pre>
	 */
	protected void sequence_AssertionLibrary(ISerializationContext context, AssertionLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Assertion returns Assertion
	 *     Element returns Assertion
	 *
	 * Constraint:
	 *     (namedassertion=NamedAssertion | namelessassertion=NamelessAssertion | namelessfunction=NamelessFunction | namelessenumeration=NamelessEnumeration)
	 * </pre>
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Assignment returns Assignment
	 *     Element returns Assignment
	 *
	 * Constraint:
	 *     (lhs=NameTick asgn=':=' rhs=ExpressionOrAny)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getAssignment_Lhs()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getAssignment_Lhs()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getAssignment_Asgn()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getAssignment_Asgn()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getAssignment_Rhs()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getAssignment_Rhs()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getLhsNameTickParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAssignmentAccess().getAsgnColonEqualsSignKeyword_1_0(), semanticObject.getAsgn());
		feeder.accept(grammarAccess.getAssignmentAccess().getRhsExpressionOrAnyParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BAAlternative returns BAAlternative
	 *     Element returns BAAlternative
	 *
	 * Constraint:
	 *     (actions=BehaviorActions elseifalt+=ElseifAlternative* elsealt=ElseAlternative?)
	 * </pre>
	 */
	protected void sequence_BAAlternative(ISerializationContext context, BAAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BLESSAlternative returns BLESSAlternative
	 *     Element returns BLESSAlternative
	 *
	 * Constraint:
	 *     (action=AssertedAction alternative+=GuardedAction+)
	 * </pre>
	 */
	protected void sequence_BLESSAlternative(ISerializationContext context, BLESSAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BLESSGrammarRoots returns BLESSGrammarRoots
	 *
	 * Constraint:
	 *     (
	 *         unit_library=UnitLibrary | 
	 *         type_library=TypeLibrary | 
	 *         assertion_library=AssertionLibrary | 
	 *         action_subclause=ActionSubclause | 
	 *         exception_library=ExceptionLibrary | 
	 *         bless_subclause=BLESSSubclause
	 *     )
	 * </pre>
	 */
	protected void sequence_BLESSGrammarRoots(ISerializationContext context, BLESSGrammarRoots semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexSubclause returns BLESSSubclause
	 *     BLESSSubclause returns BLESSSubclause
	 *     Element returns BLESSSubclause
	 *
	 * Constraint:
	 *     (
	 *         no_proof?='DO_NOT_PROVE'? 
	 *         assert_clause=AssertClause? 
	 *         invariant=InvariantClause? 
	 *         variables=VariablesSection? 
	 *         statesSection=StatesSection? 
	 *         transitions=Transitions?
	 *     )
	 * </pre>
	 */
	protected void sequence_BLESSSubclause(ISerializationContext context, BLESSSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BasicAction returns BasicAction
	 *     Element returns BasicAction
	 *
	 * Constraint:
	 *     (
	 *         skip='skip' | 
	 *         assign=Assignment | 
	 *         mode=[Mode|ID] | 
	 *         when=WhenThrow | 
	 *         comb=CombinableOperation | 
	 *         communication=CommunicationAction | 
	 *         computation=Computation | 
	 *         multi_assign=SimultaneousAssignment | 
	 *         exc=IssueException
	 *     )
	 * </pre>
	 */
	protected void sequence_BasicAction(ISerializationContext context, BasicAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorActions returns BehaviorActions
	 *     Element returns BehaviorActions
	 *
	 * Constraint:
	 *     (
	 *         action+=AssertedAction 
	 *         ((semi?=';' action+=AssertedAction action+=AssertedAction*) | (amp?='&' action+=AssertedAction action+=AssertedAction*))?
	 *     )
	 * </pre>
	 */
	protected void sequence_BehaviorActions(ISerializationContext context, BehaviorActions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorState returns BehaviorState
	 *     NamedElement returns BehaviorState
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         initial?='initial'? 
	 *         complete?='complete'? 
	 *         final?='final'? 
	 *         mode?='mode'? 
	 *         state_assertion=Assertion?
	 *     )
	 * </pre>
	 */
	protected void sequence_BehaviorState(ISerializationContext context, BehaviorState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorTime returns BehaviorTime
	 *     Element returns BehaviorTime
	 *
	 * Constraint:
	 *     (quantity=Quantity | value=ValueName | duration=ParenthesizedSubexpression)
	 * </pre>
	 */
	protected void sequence_BehaviorTime(ISerializationContext context, BehaviorTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorTransition returns BehaviorTransition
	 *     NamedElement returns BehaviorTransition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         priority=Priority? 
	 *         colon=':' 
	 *         sources+=[BehaviorState|ID] 
	 *         sources+=[BehaviorState|ID]* 
	 *         (dispatch=DispatchCondition | execute=ExecuteCondition | mode=ModeCondition | internal=InternalCondition)? 
	 *         destination=[BehaviorState|ID] 
	 *         actions=BehaviorActions? 
	 *         ass=Assertion?
	 *     )
	 * </pre>
	 */
	protected void sequence_BehaviorTransition(ISerializationContext context, BehaviorTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BooleanType returns BooleanType
	 *     Element returns BooleanType
	 *     Type returns BooleanType
	 *
	 * Constraint:
	 *     b='boolean'
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getBooleanType_B()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getBooleanType_B()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeAccess().getBBooleanKeyword_0(), semanticObject.getB());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CaseChoice returns CaseChoice
	 *     Element returns CaseChoice
	 *
	 * Constraint:
	 *     (be=BooleanExpression exp=Expression)
	 * </pre>
	 */
	protected void sequence_CaseChoice(ISerializationContext context, CaseChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getCaseChoice_Be()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getCaseChoice_Be()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getCaseChoice_Exp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getCaseChoice_Exp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseChoiceAccess().getBeBooleanExpressionParserRuleCall_1_0(), semanticObject.getBe());
		feeder.accept(grammarAccess.getCaseChoiceAccess().getExpExpressionParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CaseExpression returns CaseExpression
	 *     Element returns CaseExpression
	 *
	 * Constraint:
	 *     cc+=CaseChoice+
	 * </pre>
	 */
	protected void sequence_CaseExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CatchClauseTerm returns CatchClauseTerm
	 *     Element returns CatchClauseTerm
	 *
	 * Constraint:
	 *     ((exceptions+=[Exception|ID]+ | all?='all') action=BasicAction)
	 * </pre>
	 */
	protected void sequence_CatchClauseTerm(ISerializationContext context, CatchClauseTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CatchClause returns CatchClause
	 *     Element returns CatchClause
	 *
	 * Constraint:
	 *     catches+=CatchClauseTerm+
	 * </pre>
	 */
	protected void sequence_CatchClause(ISerializationContext context, CatchClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CombinableOperation returns CombinableOperation
	 *     Element returns CombinableOperation
	 *
	 * Constraint:
	 *     (
	 *         (f_add?='fetchadd' target=[Variable|ID] arithmetic=Expression result=[Variable|ID]) | 
	 *         ((f_or?='fetchor' | f_and?='fetchand' | f_xor?='fetchxor') target=[Variable|ID] bool=Expression result=[Variable|ID]?) | 
	 *         (sw?='swap' target=[Variable|ID] reference=[Variable|ID] result=[Variable|ID])
	 *     )
	 * </pre>
	 */
	protected void sequence_CombinableOperation(ISerializationContext context, CombinableOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CommunicationAction returns CommunicationAction
	 *     Element returns CommunicationAction
	 *
	 * Constraint:
	 *     (pc=SubprogramCall | po=PortOutput | pi=PortInput | fp=FreezePort | pause=Pause)
	 * </pre>
	 */
	protected void sequence_CommunicationAction(ISerializationContext context, CommunicationAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Computation returns Computation
	 *     Element returns Computation
	 *
	 * Constraint:
	 *     (lb=BehaviorTime ub=BehaviorTime? component+=[ComponentClassifier|QCREF]*)
	 * </pre>
	 */
	protected void sequence_Computation(ISerializationContext context, Computation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionValuePair returns ConditionValuePair
	 *     Element returns ConditionValuePair
	 *
	 * Constraint:
	 *     (condition=Predicate expression=AssertionNumericExpression)
	 * </pre>
	 */
	protected void sequence_ConditionValuePair(ISerializationContext context, ConditionValuePair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getConditionValuePair_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getConditionValuePair_Condition()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getConditionValuePair_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getConditionValuePair_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionValuePairAccess().getConditionPredicateParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionValuePairAccess().getExpressionAssertionNumericExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalAssertionFunction returns ConditionalAssertionFunction
	 *     Element returns ConditionalAssertionFunction
	 *
	 * Constraint:
	 *     (cvp+=ConditionValuePair cvp+=ConditionValuePair+)
	 * </pre>
	 */
	protected void sequence_ConditionalAssertionFunction(ISerializationContext context, ConditionalAssertionFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalExpression returns ConditionalExpression
	 *     Element returns ConditionalExpression
	 *
	 * Constraint:
	 *     (pred=Expression t=Expression f=Expression)
	 * </pre>
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getConditionalExpression_Pred()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getConditionalExpression_Pred()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getConditionalExpression_T()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getConditionalExpression_T()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getConditionalExpression_F()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getConditionalExpression_F()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getPredExpressionParserRuleCall_2_0(), semanticObject.getPred());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getTExpressionParserRuleCall_4_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getFExpressionParserRuleCall_6_0(), semanticObject.getF());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conjunction returns Conjunction
	 *     Element returns Conjunction
	 *
	 * Constraint:
	 *     (l=Relation ((sym='and' r+=Relation r+=Relation*) | (sym='then' r+=Relation r+=Relation*))?)
	 * </pre>
	 */
	protected void sequence_Conjunction(ISerializationContext context, Conjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constant returns Constant
	 *     Element returns Constant
	 *
	 * Constraint:
	 *     (numeric_constant=Quantity | string_literal=STRING | t='true' | f='false' | nul='null')
	 * </pre>
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CountingQuantification returns CountingQuantification
	 *     Element returns CountingQuantification
	 *
	 * Constraint:
	 *     (variables=LogicVariables ((in?='in' range=Range) | (which?='which' condition=Predicate)) counted=Predicate)
	 * </pre>
	 */
	protected void sequence_CountingQuantification(ISerializationContext context, CountingQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Disjunction returns Disjunction
	 *     Element returns Disjunction
	 *
	 * Constraint:
	 *     (
	 *         l=Conjunction 
	 *         ((sym='or' r+=Conjunction r+=Conjunction*) | (sym='else' r+=Conjunction r+=Conjunction*) | (sym='xor' r+=Conjunction r+=Conjunction*))?
	 *     )
	 * </pre>
	 */
	protected void sequence_Disjunction(ISerializationContext context, Disjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DispatchCondition returns DispatchCondition
	 *     Element returns DispatchCondition
	 *
	 * Constraint:
	 *     (dispatch='dispatch' de=DispatchExpression? frozen=FreezePort?)
	 * </pre>
	 */
	protected void sequence_DispatchCondition(ISerializationContext context, DispatchCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DispatchConjunction returns DispatchConjunction
	 *     Element returns DispatchConjunction
	 *
	 * Constraint:
	 *     (trigger+=DispatchTrigger (and?='and' trigger+=DispatchTrigger trigger+=DispatchTrigger*)?)
	 * </pre>
	 */
	protected void sequence_DispatchConjunction(ISerializationContext context, DispatchConjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DispatchExpression returns DispatchExpression
	 *     Element returns DispatchExpression
	 *
	 * Constraint:
	 *     ((dc+=DispatchConjunction (or?='or' dc+=DispatchConjunction dc+=DispatchConjunction*)?) | subprogramaccessdispatch=SubprogramAccessDispatch)
	 * </pre>
	 */
	protected void sequence_DispatchExpression(ISerializationContext context, DispatchExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DispatchTrigger returns DispatchTrigger
	 *     Element returns DispatchTrigger
	 *
	 * Constraint:
	 *     (port=PortName | (timeout='timeout' ((lp?='(' ports+=[NamedElement|ID] ports+=[NamedElement|ID]*)? time=BehaviorTime)?))
	 * </pre>
	 */
	protected void sequence_DispatchTrigger(ISerializationContext context, DispatchTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DoUntilLoop returns DoUntilLoop
	 *     Element returns DoUntilLoop
	 *
	 * Constraint:
	 *     ((invariant?='invariant' inv=NamelessAssertion)? (bound?='bound' bnd=Expression)? actions=BehaviorActions guard=BooleanExpression)
	 * </pre>
	 */
	protected void sequence_DoUntilLoop(ISerializationContext context, DoUntilLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseAlternative returns ElseAlternative
	 *     Element returns ElseAlternative
	 *
	 * Constraint:
	 *     actions=BehaviorActions
	 * </pre>
	 */
	protected void sequence_ElseAlternative(ISerializationContext context, ElseAlternative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getElseAlternative_Actions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getElseAlternative_Actions()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseAlternativeAccess().getActionsBehaviorActionsParserRuleCall_1_0(), semanticObject.getActions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseifAlternative returns ElseifAlternative
	 *     Element returns ElseifAlternative
	 *
	 * Constraint:
	 *     (test=BooleanExpression actions=BehaviorActions)
	 * </pre>
	 */
	protected void sequence_ElseifAlternative(ISerializationContext context, ElseifAlternative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getElseifAlternative_Test()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getElseifAlternative_Test()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getElseifAlternative_Actions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getElseifAlternative_Actions()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseifAlternativeAccess().getTestBooleanExpressionParserRuleCall_2_0(), semanticObject.getTest());
		feeder.accept(grammarAccess.getElseifAlternativeAccess().getActionsBehaviorActionsParserRuleCall_4_0(), semanticObject.getActions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumerationPair returns EnumerationPair
	 *     Element returns EnumerationPair
	 *
	 * Constraint:
	 *     (enumeration_literal=ID predicate=Predicate)
	 * </pre>
	 */
	protected void sequence_EnumerationPair(ISerializationContext context, EnumerationPair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getEnumerationPair_Enumeration_literal()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getEnumerationPair_Enumeration_literal()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getEnumerationPair_Predicate()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getEnumerationPair_Predicate()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationPairAccess().getEnumeration_literalIDTerminalRuleCall_0_0(), semanticObject.getEnumeration_literal());
		feeder.accept(grammarAccess.getEnumerationPairAccess().getPredicatePredicateParserRuleCall_2_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumerationType returns EnumerationType
	 *     Element returns EnumerationType
	 *     Type returns EnumerationType
	 *
	 * Constraint:
	 *     defining_enumeration_literal+=ID+
	 * </pre>
	 */
	protected void sequence_EnumerationType(ISerializationContext context, EnumerationType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumerationValue returns EnumerationValue
	 *     Element returns EnumerationValue
	 *
	 * Constraint:
	 *     (enumeration_type=[TypeDeclaration|ID] tick=''' enumeration_value=ID)
	 * </pre>
	 */
	protected void sequence_EnumerationValue(ISerializationContext context, EnumerationValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getEnumerationValue_Enumeration_type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getEnumerationValue_Enumeration_type()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getEnumerationValue_Tick()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getEnumerationValue_Tick()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getEnumerationValue_Enumeration_value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getEnumerationValue_Enumeration_value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationValueAccess().getEnumeration_typeTypeDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(BLESSPackage.eINSTANCE.getEnumerationValue_Enumeration_type(), false));
		feeder.accept(grammarAccess.getEnumerationValueAccess().getTickApostropheKeyword_1_0(), semanticObject.getTick());
		feeder.accept(grammarAccess.getEnumerationValueAccess().getEnumeration_valueIDTerminalRuleCall_2_0(), semanticObject.getEnumeration_value());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventTrigger returns EventTrigger
	 *     Element returns EventTrigger
	 *
	 * Constraint:
	 *     ((sub+=ID sub+=ID* port=[NamedElement|ID] index=NUMBER?) | tle=TriggerLogicalExpression)
	 * </pre>
	 */
	protected void sequence_EventTrigger(ISerializationContext context, EventTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexLibrary returns ExceptionLibrary
	 *     ExceptionLibrary returns ExceptionLibrary
	 *
	 * Constraint:
	 *     exceptiondefinitions+=Exception+
	 * </pre>
	 */
	protected void sequence_ExceptionLibrary(ISerializationContext context, ExceptionLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exception returns Exception
	 *     NamedElement returns Exception
	 *
	 * Constraint:
	 *     (name=ID description=STRING code=NUMBER?)
	 * </pre>
	 */
	protected void sequence_Exception(ISerializationContext context, com.multitude.aadl.bless.bLESS.Exception semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExecuteCondition returns ExecuteCondition
	 *     Element returns ExecuteCondition
	 *
	 * Constraint:
	 *     (eor=BooleanExpression | otherwise=Otherwise)
	 * </pre>
	 */
	protected void sequence_ExecuteCondition(ISerializationContext context, ExecuteCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExecuteTimeout returns ExecuteTimeout
	 *
	 * Constraint:
	 *     t='timeout'
	 * </pre>
	 */
	protected void sequence_ExecuteTimeout(ISerializationContext context, ExecuteTimeout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getExecuteTimeout_T()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getExecuteTimeout_T()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExecuteTimeoutAccess().getTTimeoutKeyword_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExistentialLatticeQuantification returns ExistentialLatticeQuantification
	 *     Element returns ExistentialLatticeQuantification
	 *
	 * Constraint:
	 *     (quantified_variables=QuantifiedVariables? actions=BehaviorActions timeout=ActionTimeout? catch_clause=CatchClause?)
	 * </pre>
	 */
	protected void sequence_ExistentialLatticeQuantification(ISerializationContext context, ExistentialLatticeQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExistentialQuantification returns ExistentialQuantification
	 *     Element returns ExistentialQuantification
	 *
	 * Constraint:
	 *     (variables=LogicVariables ((in?='in' range=Range) | (which?='which' condition=Predicate)) predicate=Predicate)
	 * </pre>
	 */
	protected void sequence_ExistentialQuantification(ISerializationContext context, ExistentialQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Exp
	 *     Element returns Exp
	 *
	 * Constraint:
	 *     (l=Subexpression (sym='**' r=Subexpression)?)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Exp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionOrAny returns ExpressionOrAny
	 *     Element returns ExpressionOrAny
	 *
	 * Constraint:
	 *     (exp=Expression | any=Any)
	 * </pre>
	 */
	protected void sequence_ExpressionOrAny(ISerializationContext context, ExpressionOrAny semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Predicate returns Expression
	 *     AssertionNumericExpression returns Expression
	 *     BooleanExpression returns Expression
	 *     NumericExpression returns Expression
	 *     Expression returns Expression
	 *     Element returns Expression
	 *
	 * Constraint:
	 *     (
	 *         all=UniversalQuantification | 
	 *         exists=ExistentialQuantification | 
	 *         sum=SumQuantification | 
	 *         product=ProductQuantification | 
	 *         numberof=CountingQuantification | 
	 *         (l=Disjunction ((sym='iff' | sym='implies') r=Disjunction)?)
	 *     )
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ForLoop returns ForLoop
	 *     Element returns ForLoop
	 *
	 * Constraint:
	 *     (count=ForallVariable lower_bound=Expression upper_bound=Expression (invariant?='invariant' inv=NamelessAssertion)? action=BehaviorActions)
	 * </pre>
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ForallVariable returns ForallVariable
	 *     NamedElement returns ForallVariable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ForallVariable(ISerializationContext context, ForallVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForallVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormalActualList returns FormalActualList
	 *     Element returns FormalActualList
	 *
	 * Constraint:
	 *     (variables+=FormalActual (comma?=',' variables+=FormalActual variables+=FormalActual*)?)
	 * </pre>
	 */
	protected void sequence_FormalActualList(ISerializationContext context, FormalActualList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormalActual returns FormalActual
	 *     Element returns FormalActual
	 *
	 * Constraint:
	 *     (formal=[Parameter|ID]? actual=SubProgramParameter)
	 * </pre>
	 */
	protected void sequence_FormalActual(ISerializationContext context, FormalActual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormalExpressionPair returns FormalExpressionPair
	 *     Element returns FormalExpressionPair
	 *
	 * Constraint:
	 *     (formal=ID actual=Expression)
	 * </pre>
	 */
	protected void sequence_FormalExpressionPair(ISerializationContext context, FormalExpressionPair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getFormalExpressionPair_Formal()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getFormalExpressionPair_Formal()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getFormalExpressionPair_Actual()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getFormalExpressionPair_Actual()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormalExpressionPairAccess().getFormalIDTerminalRuleCall_0_0(), semanticObject.getFormal());
		feeder.accept(grammarAccess.getFormalExpressionPairAccess().getActualExpressionParserRuleCall_2_0(), semanticObject.getActual());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FreezePort returns FreezePort
	 *
	 * Constraint:
	 *     (frozen+=[Port|ID] frozen+=[Port|ID]*)
	 * </pre>
	 */
	protected void sequence_FreezePort(ISerializationContext context, FreezePort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionParameters returns FunctionParameters
	 *     Element returns FunctionParameters
	 *
	 * Constraint:
	 *     (parameters+=FormalExpressionPair (comma?=',' parameters+=FormalExpressionPair parameters+=FormalExpressionPair*)?)
	 * </pre>
	 */
	protected void sequence_FunctionParameters(ISerializationContext context, FunctionParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GhostVariable returns GhostVariable
	 *     NamedElement returns GhostVariable
	 *
	 * Constraint:
	 *     (name=ID tod=TypeOrReference)
	 * </pre>
	 */
	protected void sequence_GhostVariable(ISerializationContext context, GhostVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getGhostVariable_Tod()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getGhostVariable_Tod()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGhostVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGhostVariableAccess().getTodTypeOrReferenceParserRuleCall_3_0(), semanticObject.getTod());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GhostVariables returns GhostVariables
	 *     Element returns GhostVariables
	 *
	 * Constraint:
	 *     gv+=GhostVariable+
	 * </pre>
	 */
	protected void sequence_GhostVariables(ISerializationContext context, GhostVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GuardedAction returns GuardedAction
	 *     Element returns GuardedAction
	 *
	 * Constraint:
	 *     (guard=BooleanExpression action=AssertedAction)
	 * </pre>
	 */
	protected void sequence_GuardedAction(ISerializationContext context, GuardedAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getGuardedAction_Guard()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getGuardedAction_Guard()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getGuardedAction_Action()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getGuardedAction_Action()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardedActionAccess().getGuardBooleanExpressionParserRuleCall_1_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getGuardedActionAccess().getActionAssertedActionParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IndexExpressionOrRange returns IndexExpressionOrRange
	 *     Element returns IndexExpressionOrRange
	 *
	 * Constraint:
	 *     (left_hand_side=IndexExpression (dd?=DOTDOT right_hand_side=IndexExpression)?)
	 * </pre>
	 */
	protected void sequence_IndexExpressionOrRange(ISerializationContext context, IndexExpressionOrRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IndexExpression returns IndexExpression
	 *     Element returns IndexExpression
	 *
	 * Constraint:
	 *     (
	 *         l=PeriodShift 
	 *         (
	 *             (sym='-' r+=PeriodShift) | 
	 *             (sym='div' r+=PeriodShift) | 
	 *             (sym='mod' r+=PeriodShift) | 
	 *             (sym='+' r+=PeriodShift r+=PeriodShift*) | 
	 *             (sym=TIMES r+=PeriodShift r+=PeriodShift*)
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_IndexExpression(ISerializationContext context, IndexExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InternalCondition returns InternalCondition
	 *     Element returns InternalCondition
	 *
	 * Constraint:
	 *     (first=[Port|ID] ports+=[Port|ID]*)
	 * </pre>
	 */
	protected void sequence_InternalCondition(ISerializationContext context, InternalCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InvariantClause returns InvariantClause
	 *     Element returns InvariantClause
	 *
	 * Constraint:
	 *     inv=Assertion
	 * </pre>
	 */
	protected void sequence_InvariantClause(ISerializationContext context, InvariantClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getInvariantClause_Inv()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getInvariantClause_Inv()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantClauseAccess().getInvAssertionParserRuleCall_1_0(), semanticObject.getInv());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Invocation returns Invocation
	 *     Element returns Invocation
	 *
	 * Constraint:
	 *     (label=[NamedAssertion|ID] ((params+=ActualParameter params+=ActualParameter*) | actual_parameter=NumericExpression)?)
	 * </pre>
	 */
	protected void sequence_Invocation(ISerializationContext context, Invocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IssueException returns IssueException
	 *     Element returns IssueException
	 *
	 * Constraint:
	 *     (exception=[Exception|ID] message=STRING?)
	 * </pre>
	 */
	protected void sequence_IssueException(ISerializationContext context, IssueException semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LockingAction returns LockingAction
	 *
	 * Constraint:
	 *     (entercritical='*!&lt;' | leavecritical='*!&gt;' | (required_data_access=[DataAccess|ID] lock='!&lt;') | (required_data_access=[DataAccess|ID] unlock='!&gt;'))
	 * </pre>
	 */
	protected void sequence_LockingAction(ISerializationContext context, LockingAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicVariables returns LogicVariables
	 *     Element returns LogicVariables
	 *
	 * Constraint:
	 *     (lv+=Variable lv+=Variable*)
	 * </pre>
	 */
	protected void sequence_LogicVariables(ISerializationContext context, LogicVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalOperator returns LogicalOperator
	 *     Element returns LogicalOperator
	 *
	 * Constraint:
	 *     (op='and' | op='or' | op='xor' | op='then' | op='else')
	 * </pre>
	 */
	protected void sequence_LogicalOperator(ISerializationContext context, LogicalOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModeCondition returns ModeCondition
	 *     Element returns ModeCondition
	 *
	 * Constraint:
	 *     tle=TriggerLogicalExpression
	 * </pre>
	 */
	protected void sequence_ModeCondition(ISerializationContext context, ModeCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getModeCondition_Tle()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getModeCondition_Tle()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModeConditionAccess().getTleTriggerLogicalExpressionParserRuleCall_1_0(), semanticObject.getTle());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultDiv returns MultDiv
	 *     Element returns MultDiv
	 *
	 * Constraint:
	 *     (l=Exp (((sym='/' | sym='div' | sym='mod' | sym='rem') r+=Exp) | (sym=TIMES r+=Exp r+=Exp*))?)
	 * </pre>
	 */
	protected void sequence_MultDiv(ISerializationContext context, MultDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NameTick returns NameTick
	 *     Element returns NameTick
	 *
	 * Constraint:
	 *     (value=ValueName tick?='''?)
	 * </pre>
	 */
	protected void sequence_NameTick(ISerializationContext context, NameTick semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedAssertion returns NamedAssertion
	 *     NamedElement returns NamedAssertion
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (formals=VariableList? ((pred?=':' predicate=Predicate) | (tod=TypeOrReference func?=':=' functionvalue=AssertionFunctionValue))) | 
	 *             (assertionvariable=ID enumerationType=[TypeDeclaration|ID] enumer?='+=&gt;' enumeration=AssertionEnumeration)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_NamedAssertion(ISerializationContext context, NamedAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamelessAssertion returns NamelessAssertion
	 *     Element returns NamelessAssertion
	 *
	 * Constraint:
	 *     predicate=Predicate
	 * </pre>
	 */
	protected void sequence_NamelessAssertion(ISerializationContext context, NamelessAssertion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getNamelessAssertion_Predicate()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getNamelessAssertion_Predicate()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamelessAssertionAccess().getPredicatePredicateParserRuleCall_1_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamelessEnumeration returns NamelessEnumeration
	 *     Element returns NamelessEnumeration
	 *
	 * Constraint:
	 *     enumeration=Invocation
	 * </pre>
	 */
	protected void sequence_NamelessEnumeration(ISerializationContext context, NamelessEnumeration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getNamelessEnumeration_Enumeration()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getNamelessEnumeration_Enumeration()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamelessEnumerationAccess().getEnumerationInvocationParserRuleCall_2_0(), semanticObject.getEnumeration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamelessFunction returns NamelessFunction
	 *     Element returns NamelessFunction
	 *
	 * Constraint:
	 *     (tod=TypeOrReference func?=':=' functionvalue=AssertionFunctionValue)
	 * </pre>
	 */
	protected void sequence_NamelessFunction(ISerializationContext context, NamelessFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getNamelessFunction_Tod()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getNamelessFunction_Tod()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getNamelessFunction_Func()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getNamelessFunction_Func()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getNamelessFunction_Functionvalue()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getNamelessFunction_Functionvalue()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamelessFunctionAccess().getTodTypeOrReferenceParserRuleCall_2_0(), semanticObject.getTod());
		feeder.accept(grammarAccess.getNamelessFunctionAccess().getFuncColonEqualsSignKeyword_3_0(), semanticObject.isFunc());
		feeder.accept(grammarAccess.getNamelessFunctionAccess().getFunctionvalueAssertionFunctionValueParserRuleCall_4_0(), semanticObject.getFunctionvalue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NullType returns NullType
	 *     Element returns NullType
	 *     Type returns NullType
	 *
	 * Constraint:
	 *     n='null'
	 * </pre>
	 */
	protected void sequence_NullType(ISerializationContext context, NullType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getNullType_N()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getNullType_N()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullTypeAccess().getNNullKeyword_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Otherwise returns Otherwise
	 *     Element returns Otherwise
	 *
	 * Constraint:
	 *     o='otherwise'
	 * </pre>
	 */
	protected void sequence_Otherwise(ISerializationContext context, Otherwise semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getOtherwise_O()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getOtherwise_O()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherwiseAccess().getOOtherwiseKeyword_0(), semanticObject.getO());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParenthesizedSubexpression returns ParenthesizedSubexpression
	 *     Element returns ParenthesizedSubexpression
	 *
	 * Constraint:
	 *     ((expression=Expression (t=Expression f=Expression)?) | caseexpression=CaseExpression)
	 * </pre>
	 */
	protected void sequence_ParenthesizedSubexpression(ISerializationContext context, ParenthesizedSubexpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PartialName returns PartialName
	 *     Element returns PartialName
	 *
	 * Constraint:
	 *     (record_id=ID (lb?='[' array_index+=IndexExpressionOrRange array_index+=IndexExpressionOrRange*)?)
	 * </pre>
	 */
	protected void sequence_PartialName(ISerializationContext context, PartialName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pause returns Pause
	 *
	 * Constraint:
	 *     pause='pause'
	 * </pre>
	 */
	protected void sequence_Pause(ISerializationContext context, Pause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getPause_Pause()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getPause_Pause()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPauseAccess().getPausePauseKeyword_0(), semanticObject.getPause());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PeriodShift returns PeriodShift
	 *     Element returns PeriodShift
	 *
	 * Constraint:
	 *     (unary_minus?='-'? (v=Value | index_expression=IndexExpression))
	 * </pre>
	 */
	protected void sequence_PeriodShift(ISerializationContext context, PeriodShift semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PortInput returns PortInput
	 *     Element returns PortInput
	 *
	 * Constraint:
	 *     (port=[Port|ID] target=ValueName)
	 * </pre>
	 */
	protected void sequence_PortInput(ISerializationContext context, PortInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getPortInput_Port()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getPortInput_Port()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getPortInput_Target()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getPortInput_Target()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortInputAccess().getPortPortIDTerminalRuleCall_0_0_1(), semanticObject.eGet(BLESSPackage.eINSTANCE.getPortInput_Port(), false));
		feeder.accept(grammarAccess.getPortInputAccess().getTargetValueNameParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PortName returns PortName
	 *
	 * Constraint:
	 *     (port=[NamedElement|ID] index=NUMBER?)
	 * </pre>
	 */
	protected void sequence_PortName(ISerializationContext context, PortName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PortOutput returns PortOutput
	 *     Element returns PortOutput
	 *
	 * Constraint:
	 *     (port=[Port|ID] eor=Expression?)
	 * </pre>
	 */
	protected void sequence_PortOutput(ISerializationContext context, PortOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Priority returns Priority
	 *     Element returns Priority
	 *
	 * Constraint:
	 *     priority=NUMBER
	 * </pre>
	 */
	protected void sequence_Priority(ISerializationContext context, Priority semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getPriority_Priority()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getPriority_Priority()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriorityAccess().getPriorityNUMBERTerminalRuleCall_1_0(), semanticObject.getPriority());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProductQuantification returns ProductQuantification
	 *     Element returns ProductQuantification
	 *
	 * Constraint:
	 *     (variables=LogicVariables ((in?='in' range=Range) | (which?='which' condition=Predicate)) numeric_expression=NumericExpression)
	 * </pre>
	 */
	protected void sequence_ProductQuantification(ISerializationContext context, ProductQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyField returns PropertyField
	 *     Element returns PropertyField
	 *
	 * Constraint:
	 *     (index=NUMBER | variable=[Variable|ID] | pf=ID | upper='upper_bound' | lower='lower_bound')
	 * </pre>
	 */
	protected void sequence_PropertyField(ISerializationContext context, PropertyField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyReference returns PropertyReference
	 *     Element returns PropertyReference
	 *
	 * Constraint:
	 *     (
	 *         (pname=[Property|QCLREF] field+=PropertyField*) | 
	 *         (self?='self' spname=[Property|QCLREF] field+=PropertyField*) | 
	 *         (component=[ComponentClassifier|QCREF] cpname=[Property|QCLREF] field+=PropertyField*)
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyReference(ISerializationContext context, PropertyReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuantifiedVariables returns QuantifiedVariables
	 *     Element returns QuantifiedVariables
	 *
	 * Constraint:
	 *     variables+=VariableDeclaration+
	 * </pre>
	 */
	protected void sequence_QuantifiedVariables(ISerializationContext context, QuantifiedVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QuantityType returns QuantityType
	 *     Element returns QuantityType
	 *     Type returns QuantityType
	 *
	 * Constraint:
	 *     ((unit=[UnitName|ID] | scalar?='scalar' | whole?='whole') (lb=ANumber ub=ANumber)? step=ANumber? representation=[PropertyConstant|QCLREF]?)
	 * </pre>
	 */
	protected void sequence_QuantityType(ISerializationContext context, QuantityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Quantity returns Quantity
	 *     Element returns Quantity
	 *
	 * Constraint:
	 *     (number=ANumber (unit=[UnitName|ID] | scalar?='scalar' | whole?='whole')?)
	 * </pre>
	 */
	protected void sequence_Quantity(ISerializationContext context, Quantity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Range returns Range
	 *     Element returns Range
	 *
	 * Constraint:
	 *     (lower_bound=Subexpression sym=RangeSymbol upper_bound=Subexpression)
	 * </pre>
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRange_Lower_bound()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRange_Lower_bound()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRange_Sym()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRange_Sym()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRange_Upper_bound()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRange_Upper_bound()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getLower_boundSubexpressionParserRuleCall_0_0(), semanticObject.getLower_bound());
		feeder.accept(grammarAccess.getRangeAccess().getSymRangeSymbolParserRuleCall_1_0(), semanticObject.getSym());
		feeder.accept(grammarAccess.getRangeAccess().getUpper_boundSubexpressionParserRuleCall_2_0(), semanticObject.getUpper_bound());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RecordField returns RecordField
	 *     Element returns RecordField
	 *
	 * Constraint:
	 *     (label=ID typ=TypeOrReference)
	 * </pre>
	 */
	protected void sequence_RecordField(ISerializationContext context, RecordField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRecordField_Label()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRecordField_Label()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRecordField_Typ()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRecordField_Typ()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordFieldAccess().getLabelIDTerminalRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getRecordFieldAccess().getTypTypeOrReferenceParserRuleCall_2_0(), semanticObject.getTyp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RecordTerm returns RecordTerm
	 *     Element returns RecordTerm
	 *
	 * Constraint:
	 *     (record_type=[TypeDeclaration|ID] record_value+=RecordValue+)
	 * </pre>
	 */
	protected void sequence_RecordTerm(ISerializationContext context, RecordTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RecordType returns RecordType
	 *     Element returns RecordType
	 *     Type returns RecordType
	 *
	 * Constraint:
	 *     ((record?='record' | variant?='variant' | variant?='union') fields+=RecordField+)
	 * </pre>
	 */
	protected void sequence_RecordType(ISerializationContext context, RecordType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RecordValue returns RecordValue
	 *     Element returns RecordValue
	 *
	 * Constraint:
	 *     (label=ID aval=Value)
	 * </pre>
	 */
	protected void sequence_RecordValue(ISerializationContext context, RecordValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRecordValue_Label()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRecordValue_Label()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getRecordValue_Aval()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getRecordValue_Aval()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordValueAccess().getLabelIDTerminalRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getRecordValueAccess().getAvalValueParserRuleCall_2_0(), semanticObject.getAval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Relation returns Relation
	 *     Element returns Relation
	 *
	 * Constraint:
	 *     (
	 *         l=AddSub 
	 *         (
	 *             (
	 *                 (
	 *                     sym='=' | 
	 *                     sym='&lt;&gt;' | 
	 *                     sym='&lt;' | 
	 *                     sym='&lt;=' | 
	 *                     sym='&gt;=' | 
	 *                     sym='&gt;' | 
	 *                     sym='!=' | 
	 *                     sym='+='
	 *                 ) 
	 *                 r=AddSub
	 *             ) | 
	 *             (in='in' range=Range)
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnitDeclaration returns RootDeclaration
	 *     RootDeclaration returns RootDeclaration
	 *     Element returns RootDeclaration
	 *
	 * Constraint:
	 *     ((base?='base' | formula=UnitFormula) kindWords+=ID+ unitName=UnitName factors+=UnitFactor*)
	 * </pre>
	 */
	protected void sequence_RootDeclaration(ISerializationContext context, RootDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimultaneousAssignment returns SimultaneousAssignment
	 *     Element returns SimultaneousAssignment
	 *
	 * Constraint:
	 *     (lhs+=NameTick lhs+=NameTick+ asgn=':=' rhs+=ExpressionOrAny rhs+=ExpressionOrAny+)
	 * </pre>
	 */
	protected void sequence_SimultaneousAssignment(ISerializationContext context, SimultaneousAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatesSection returns StatesSection
	 *     Element returns StatesSection
	 *
	 * Constraint:
	 *     (st='states' states+=BehaviorState+)
	 * </pre>
	 */
	protected void sequence_StatesSection(ISerializationContext context, StatesSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringType returns StringType
	 *     Element returns StringType
	 *     Type returns StringType
	 *
	 * Constraint:
	 *     s='string'
	 * </pre>
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getStringType_S()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getStringType_S()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getSStringKeyword_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubProgramParameter returns SubProgramParameter
	 *     Element returns SubProgramParameter
	 *
	 * Constraint:
	 *     (value=ValueName | constant=Constant | expression=ParenthesizedSubexpression)
	 * </pre>
	 */
	protected void sequence_SubProgramParameter(ISerializationContext context, SubProgramParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Subexpression returns Subexpression
	 *     Element returns Subexpression
	 *
	 * Constraint:
	 *     (unary=UnaryOperator? timed_expression=TimedExpression)
	 * </pre>
	 */
	protected void sequence_Subexpression(ISerializationContext context, Subexpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubprogramAccessDispatch returns SubprogramAccessDispatch
	 *     Element returns SubprogramAccessDispatch
	 *
	 * Constraint:
	 *     access=[SubprogramAccess|ID]
	 * </pre>
	 */
	protected void sequence_SubprogramAccessDispatch(ISerializationContext context, SubprogramAccessDispatch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getSubprogramAccessDispatch_Access()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getSubprogramAccessDispatch_Access()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubprogramAccessDispatchAccess().getAccessSubprogramAccessIDTerminalRuleCall_1_0_1(), semanticObject.eGet(BLESSPackage.eINSTANCE.getSubprogramAccessDispatch_Access(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubprogramCall returns SubprogramCall
	 *     Element returns SubprogramCall
	 *
	 * Constraint:
	 *     (procedure=[CalledSubprogram|ID] parameters=FormalActualList?)
	 * </pre>
	 */
	protected void sequence_SubprogramCall(ISerializationContext context, SubprogramCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SumQuantification returns SumQuantification
	 *     Element returns SumQuantification
	 *
	 * Constraint:
	 *     (variables=LogicVariables ((in?='in' range=Range) | (which?='which' condition=Predicate)) numeric_expression=NumericExpression)
	 * </pre>
	 */
	protected void sequence_SumQuantification(ISerializationContext context, SumQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ThrowsClause returns ThrowsClause
	 *
	 * Constraint:
	 *     exceptions+=[Exception|ID]
	 * </pre>
	 */
	protected void sequence_ThrowsClause(ISerializationContext context, ThrowsClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimedExpression returns TimedExpression
	 *     Element returns TimedExpression
	 *
	 * Constraint:
	 *     (subject=TimedSubject (tick=''' | (at?='@' time=Subexpression) | (caret?='^' shift=PeriodShift))?)
	 * </pre>
	 */
	protected void sequence_TimedExpression(ISerializationContext context, TimedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimedSubject returns TimedSubject
	 *     Element returns TimedSubject
	 *
	 * Constraint:
	 *     (ps=ParenthesizedSubexpression | value=Value | conditional=ConditionalExpression | record=RecordTerm | invocation=Invocation)
	 * </pre>
	 */
	protected void sequence_TimedSubject(ISerializationContext context, TimedSubject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transitions returns Transitions
	 *     Element returns Transitions
	 *
	 * Constraint:
	 *     bt+=BehaviorTransition+
	 * </pre>
	 */
	protected void sequence_Transitions(ISerializationContext context, Transitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TriggerLogicalExpression returns TriggerLogicalExpression
	 *     Element returns TriggerLogicalExpression
	 *
	 * Constraint:
	 *     (first=EventTrigger (op=LogicalOperator trigger+=EventTrigger (ops+=LogicalOperator trigger+=EventTrigger)*)?)
	 * </pre>
	 */
	protected void sequence_TriggerLogicalExpression(ISerializationContext context, TriggerLogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeDeclaration returns TypeDeclaration
	 *     NamedElement returns TypeDeclaration
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getTypeDeclaration_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getTypeDeclaration_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexLibrary returns TypeLibrary
	 *     TypeLibrary returns TypeLibrary
	 *
	 * Constraint:
	 *     decs+=TypeDeclaration+
	 * </pre>
	 */
	protected void sequence_TypeLibrary(ISerializationContext context, TypeLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeOrReference returns TypeOrReference
	 *     Element returns TypeOrReference
	 *
	 * Constraint:
	 *     (ty=Type | ref=[TypeDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_TypeOrReference(ISerializationContext context, TypeOrReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnaryOperator returns UnaryOperator
	 *     Element returns UnaryOperator
	 *
	 * Constraint:
	 *     (not='not' | unary_minus='-' | absolute_value='abs' | truncate='truncate' | round='round')
	 * </pre>
	 */
	protected void sequence_UnaryOperator(ISerializationContext context, UnaryOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnitDeclaration returns UnitExtension
	 *     UnitExtension returns UnitExtension
	 *     Element returns UnitExtension
	 *
	 * Constraint:
	 *     (root=[UnitName|ID] factors+=UnitFactor+)
	 * </pre>
	 */
	protected void sequence_UnitExtension(ISerializationContext context, UnitExtension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnitFactor returns UnitFactor
	 *     Element returns UnitFactor
	 *
	 * Constraint:
	 *     (unit=UnitName op=MulDiv factor=PositiveNumber)
	 * </pre>
	 */
	protected void sequence_UnitFactor(ISerializationContext context, UnitFactor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getUnitFactor_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getUnitFactor_Unit()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getUnitFactor_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getUnitFactor_Op()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getUnitFactor_Factor()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getUnitFactor_Factor()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnitFactorAccess().getUnitUnitNameParserRuleCall_1_0(), semanticObject.getUnit());
		feeder.accept(grammarAccess.getUnitFactorAccess().getOpMulDivParserRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnitFactorAccess().getFactorPositiveNumberParserRuleCall_3_0(), semanticObject.getFactor());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnitFormula returns UnitFormula
	 *     Element returns UnitFormula
	 *
	 * Constraint:
	 *     ((top+=[UnitName|ID]+ (slash?='/' bottom+=[UnitName|ID]+)?) | (slash?='/' bottom+=[UnitName|ID]+))
	 * </pre>
	 */
	protected void sequence_UnitFormula(ISerializationContext context, UnitFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexLibrary returns UnitLibrary
	 *     UnitLibrary returns UnitLibrary
	 *
	 * Constraint:
	 *     unitDeclarations+=UnitDeclaration+
	 * </pre>
	 */
	protected void sequence_UnitLibrary(ISerializationContext context, UnitLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnitName returns UnitName
	 *     NamedElement returns UnitName
	 *
	 * Constraint:
	 *     (longname+=ID* name=ID)
	 * </pre>
	 */
	protected void sequence_UnitName(ISerializationContext context, UnitName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UniversalLatticeQuantification returns UniversalLatticeQuantification
	 *     Element returns UniversalLatticeQuantification
	 *
	 * Constraint:
	 *     (variables+=ForallVariable+ lower_bound=Expression upper_bound=Expression elq=ExistentialLatticeQuantification)
	 * </pre>
	 */
	protected void sequence_UniversalLatticeQuantification(ISerializationContext context, UniversalLatticeQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UniversalQuantification returns UniversalQuantification
	 *     Element returns UniversalQuantification
	 *
	 * Constraint:
	 *     (variables=LogicVariables ((in?='in' range=Range) | (which?='which' condition=Predicate)) predicate=Predicate)
	 * </pre>
	 */
	protected void sequence_UniversalQuantification(ISerializationContext context, UniversalQuantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueName returns ValueName
	 *     Element returns ValueName
	 *
	 * Constraint:
	 *     (
	 *         id=[NamedElement|ID] 
	 *         (lp?='(' pr=FunctionParameters?)? 
	 *         (lb?='[' array_index+=IndexExpressionOrRange array_index+=IndexExpressionOrRange*)? 
	 *         (dot?='.' pn+=PartialName pn+=PartialName*)? 
	 *         (q?='?' | fresh?='fresh' | count?='count' | updated?='updated')?
	 *     )
	 * </pre>
	 */
	protected void sequence_ValueName(ISerializationContext context, ValueName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Value
	 *     Element returns Value
	 *
	 * Constraint:
	 *     (
	 *         value_name=ValueName | 
	 *         constant=Constant | 
	 *         timeout='timeout' | 
	 *         now='now' | 
	 *         tops='tops' | 
	 *         enum_val=EnumerationValue
	 *     )
	 * </pre>
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *     Element returns VariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         variable=Variable 
	 *         (nonvolatile?='nonvolatile' | shared?='shared' | constant?='constant' | spread?='spread' | final?='final')? 
	 *         (assign?=':=' expression=Expression)? 
	 *         assertion=Assertion?
	 *     )
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableList returns VariableList
	 *     Element returns VariableList
	 *
	 * Constraint:
	 *     (first=Variable (comma?=',' parameter+=Variable parameter+=Variable*)?)
	 * </pre>
	 */
	protected void sequence_VariableList(ISerializationContext context, VariableList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns Variable
	 *     NamedElement returns Variable
	 *
	 * Constraint:
	 *     (name=ID tod=TypeOrReference)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, BLESSPackage.eINSTANCE.getVariable_Tod()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BLESSPackage.eINSTANCE.getVariable_Tod()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getTodTypeOrReferenceParserRuleCall_2_0(), semanticObject.getTod());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariablesSection returns VariablesSection
	 *     Element returns VariablesSection
	 *
	 * Constraint:
	 *     behavior_variables+=VariableDeclaration+
	 * </pre>
	 */
	protected void sequence_VariablesSection(ISerializationContext context, VariablesSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WhenThrow returns WhenThrow
	 *     Element returns WhenThrow
	 *
	 * Constraint:
	 *     (exp=Expression exception=[Exception|ID] message=STRING?)
	 * </pre>
	 */
	protected void sequence_WhenThrow(ISerializationContext context, WhenThrow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WhileLoop returns WhileLoop
	 *     Element returns WhileLoop
	 *
	 * Constraint:
	 *     (
	 *         test=BooleanExpression 
	 *         (invariant?='invariant' inv=NamelessAssertion)? 
	 *         (bound?='bound' bound_function=Expression)? 
	 *         elq=ExistentialLatticeQuantification
	 *     )
	 * </pre>
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
