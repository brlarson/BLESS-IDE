/*
 * (C) Multitude Corporation 2020
 * generated by Xtext 2.20.0
 from BLESS.xtext, by BRL 
 */
package com.multitude.aadl.bless.ui.outline

import com.google.inject.Inject
import com.multitude.aadl.bless.bLESS.ActionSubclause
import com.multitude.aadl.bless.bLESS.ArrayType
import com.multitude.aadl.bless.bLESS.AssertClause
import com.multitude.aadl.bless.bLESS.Assertion
import com.multitude.aadl.bless.bLESS.AssertionLibrary
import com.multitude.aadl.bless.bLESS.BLESSSubclause
import com.multitude.aadl.bless.bLESS.BehaviorActions
import com.multitude.aadl.bless.bLESS.BehaviorState
import com.multitude.aadl.bless.bLESS.BehaviorTransition
import com.multitude.aadl.bless.bLESS.BooleanType
import com.multitude.aadl.bless.bLESS.ConditionValuePair
import com.multitude.aadl.bless.bLESS.ConditionalAssertionFunction
import com.multitude.aadl.bless.bLESS.DispatchCondition
import com.multitude.aadl.bless.bLESS.EnumerationType
import com.multitude.aadl.bless.bLESS.ExecuteCondition
import com.multitude.aadl.bless.bLESS.GhostVariable
import com.multitude.aadl.bless.bLESS.GhostVariables
import com.multitude.aadl.bless.bLESS.InternalCondition
import com.multitude.aadl.bless.bLESS.InvariantClause
import com.multitude.aadl.bless.bLESS.ModeCondition
import com.multitude.aadl.bless.bLESS.NamedAssertion
import com.multitude.aadl.bless.bLESS.NamelessAssertion
import com.multitude.aadl.bless.bLESS.NamelessEnumeration
import com.multitude.aadl.bless.bLESS.NamelessFunction
import com.multitude.aadl.bless.bLESS.QuantityType
import com.multitude.aadl.bless.bLESS.RecordField
import com.multitude.aadl.bless.bLESS.RecordType
import com.multitude.aadl.bless.bLESS.RootDeclaration
import com.multitude.aadl.bless.bLESS.StatesSection
import com.multitude.aadl.bless.bLESS.StringType
import com.multitude.aadl.bless.bLESS.Transitions
import com.multitude.aadl.bless.bLESS.TypeDeclaration
import com.multitude.aadl.bless.bLESS.TypeLibrary
import com.multitude.aadl.bless.bLESS.TypeOrReference
import com.multitude.aadl.bless.bLESS.UnitExtension
import com.multitude.aadl.bless.bLESS.UnitFactor
import com.multitude.aadl.bless.bLESS.UnitFormula
import com.multitude.aadl.bless.bLESS.UnitLibrary
import com.multitude.aadl.bless.bLESS.VariableDeclaration
import com.multitude.aadl.bless.bLESS.VariableList
import com.multitude.aadl.bless.bLESS.VariablesSection
import com.multitude.aadl.bless.util.TypeUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.outline.IOutlineNode
import org.eclipse.xtext.ui.editor.outline.impl.BackgroundOutlineTreeProvider
import org.osate.aadl2.DefaultAnnexLibrary
import org.osate.aadl2.DefaultAnnexSubclause

class BLESSOutlineTreeProvider extends // DefaultOutlineTreeProvider 
    BackgroundOutlineTreeProvider
{

@Inject extension TypeUtil 


  override void
internalCreateChildren(IOutlineNode parentNode, EObject modelElement)
  {
  val p = parentNode  
  if (modelElement instanceof DefaultAnnexLibrary) 
    { 
    val o = (modelElement as DefaultAnnexLibrary).parsedAnnexLibrary  
    if (o instanceof TypeLibrary)
      (o as TypeLibrary).decs.forEach[udec | createNode(p,udec)]
    else if (o instanceof UnitLibrary) 
      (o as UnitLibrary).unitDeclarations.forEach[udec | createNode(p,udec)]
    else if (o instanceof AssertionLibrary)
      {
      if ((o as AssertionLibrary).ghosts !== null)
        createNode(parentNode,(o as AssertionLibrary).ghosts)
      (o as AssertionLibrary).assertion_list.forEach[a | createNode(parentNode,a)]
      }    
    }
  else if (modelElement instanceof DefaultAnnexSubclause) 
    { 
    val o = (modelElement as DefaultAnnexSubclause).parsedAnnexSubclause  
    if (o instanceof ActionSubclause)
    {
    val a = o as ActionSubclause  
      if (a.throws_clause !== null)  
        createNode(parentNode,a.throws_clause)
      if (a.assert_clause !== null)  
        createNode(parentNode,a.assert_clause)
      if (a.invariant !== null)  
        createNode(parentNode,a.invariant)
      if (a.precondition !== null)  
        createNode(parentNode,a.precondition)
      if (a.postcondition !== null)  
        createNode(parentNode,a.postcondition)
      if (a.invariant !== null)  
        createNode(parentNode,a.invariant)
//      if (a.types !== null)  
//        createNode(parentNode,a.types)      
      createNode(parentNode,a.elq)
    }
  else if (o instanceof BLESSSubclause)
    {
    val b = o as BLESSSubclause 
    if (b.assert_clause !== null)
      createNode(parentNode,b.assert_clause)
    if (b.invariant !== null)
      createNode(parentNode,b.invariant)
    if (b.variables !== null)
      createNode(parentNode,b.variables)
    if (b.statesSection !== null)
      createNode(parentNode,b.statesSection)
    if (b.transitions !== null)
      createNode(parentNode,b.transitions)
    }
  }  //done with annex librarties and subclauses
  else if (modelElement instanceof TypeDeclaration)
    createNode(p,(modelElement as TypeDeclaration).type)
  else if (modelElement instanceof ArrayType)
    {
    val at = modelElement as ArrayType
    if (at.typ !== null)
      if (at.typ.ty!==null)
        createNode(p,at.typ.ty)
      else if (at.typ.ref!==null)
        createNode(p,at.typ.ref)
    }
  else if (modelElement instanceof RecordType)
    (modelElement as RecordType).fields.forEach[rf | createNode(p,rf)]
  else if (modelElement instanceof RecordField)
    createNode(p,(modelElement as RecordField).typ)
  else if (modelElement instanceof GhostVariables)
    (modelElement as GhostVariables).gv.forEach[g | createNode(p,g)]
  else if (modelElement instanceof AssertClause)
    {
    val c = (modelElement as AssertClause)  
    for (assn : c.assertions)
      createNode(p,assn)
    }
  else if (modelElement instanceof InvariantClause)
    createNode(p,(modelElement as InvariantClause).inv)
  else if (modelElement instanceof VariablesSection)
    for (v : (modelElement as VariablesSection).behavior_variables)
       createNode(p,v)   
  else if (modelElement instanceof StatesSection)
    for (s : (modelElement as StatesSection).states)
       createNode(p,s)        
  else if (modelElement instanceof Transitions)
    for (t : (modelElement as Transitions).bt)
      createNode(p,t)           
  else if (modelElement instanceof BehaviorTransition)
    {
    val c = modelElement as BehaviorTransition  
    if (c.actions !== null)  
      createNode(p,c.actions)  
     
//    if (c.actions !== null) 
//      createNode(outlineNode,c.actions)
//    if (c.ass !== null) 
//      createNode(outlineNode,c.ass)
    }
  }
  
  override Object 
getText(Object modelElement)
  {
  if (modelElement instanceof RootDeclaration)
    {
    val rd = (modelElement as RootDeclaration) 
    if (rd.unitName === null)
      'null root unit name for '+rd.toString
    else
      (rd.base?'base':rd.formula.getText) + ' [' + rd.kindWords.join(' ') + '] ' +
      (rd.unitName.longname !== null && rd.unitName.longname.size>0 ? '<'+rd.unitName.longname.join(' ',[it])+'> ' : '')+
      rd.unitName.name.getSuffix 
    }
  else if (modelElement instanceof UnitFormula)
    {
    val form = modelElement as UnitFormula
    val top = form.top.join(' ',[u | u.name.getSuffix])
    val bottom = form.bottom.join(' ',[u | u.name.getSuffix+' '])
    if (form.slash)
      top + ' / ' + bottom
    else
      top + bottom    
    }
  else if (modelElement instanceof UnitFactor)
    {
    val uf = modelElement as UnitFactor 
    (uf?.unit?.longname.size>0 ? '<'+uf?.unit?.longname?.join(' ',[it])+'> ' : '')+
      uf?.unit?.name.getSuffix +' '+ uf?.op +
      ' '+uf?.factor
    }
  else if (modelElement instanceof UnitExtension)
    'extension '+ (modelElement as UnitExtension).root.name.getSuffix
  else if (modelElement instanceof TypeDeclaration)
    'type '+(modelElement as TypeDeclaration).name.getSuffix 
  else if (modelElement instanceof BooleanType)
    'boolean'
  else if (modelElement instanceof StringType)
    'string'
  else if (modelElement instanceof RecordType)
    {
    val ty = modelElement as RecordType
      (ty.record?'record':'')+(ty.variant?'variant':'')
    }
  else if (modelElement instanceof RecordField)
    {
    val rf = modelElement as RecordField
    rf.label+':'+rf.typ.typeString 
    }
  else if (modelElement instanceof EnumerationType)
    'enumeration' 
  else if (modelElement instanceof QuantityType)
    (modelElement as QuantityType).typeString
  else if (modelElement instanceof ArrayType)
    (modelElement as ArrayType).typeString
  else if (modelElement instanceof Assertion)
   {
   val a = (modelElement as Assertion)
    if (a.namedassertion !== null)
     '<<'+ a.namedassertion.name +'>>'
    else  if (a.namelessassertion !== null)
      '<< >>'
    else  if (a.namelessfunction !== null)
      '<< := >>'
    else  if (a.namelessenumeration !== null)
      '<< +=> >> '
   }
  else if (modelElement instanceof GhostVariables)
    'ghost variables'
  else if (modelElement instanceof GhostVariable)
    {
     val gv = modelElement as GhostVariable
      'def '+gv.name+' '+gv.tod.typeString
    }
  else if (modelElement instanceof TypeOrReference)
    {
    val tod = modelElement as TypeOrReference  
    if (tod.ref !== null)
      tod.ref.name
    if (tod.ty !== null)
      tod.ty.toString
    }
  else if (modelElement instanceof NamedAssertion)
    (modelElement as NamedAssertion).name + ' :' 
  else if (modelElement instanceof NamelessAssertion)
    ':'
  else if (modelElement instanceof NamelessFunction)
    ':='
  else if (modelElement instanceof NamelessEnumeration)
    '+=>' 
  else if (modelElement instanceof ConditionalAssertionFunction)
    '[  ]' 
  else if (modelElement instanceof ConditionValuePair)
    '->' 
  else if (modelElement instanceof VariableList)
    ',' 
  else if (modelElement instanceof AssertClause)
    'assert' 
  else if (modelElement instanceof InvariantClause)
    'invariant' 
  else if (modelElement instanceof VariablesSection)
    'variables' 
  else if (modelElement instanceof StatesSection)
    'states' 
  else if (modelElement instanceof Transitions)
    'transitions' 
  else if (modelElement instanceof BehaviorTransition)
    { 
    val c = modelElement as BehaviorTransition  
    c?.name+': ' +c.sources.map[s | s.name].join(', ') + ' -[ ]-> ' +
      c?.destination?.name
    } 
//  else if (modelElement instanceof DispatchCondition)
//    '-[ on dispatch ]->' 
//  else if (modelElement instanceof ExecuteCondition)
//    '-[  ]->' 
//  else if (modelElement instanceof ModeCondition)
//    '-[ on mode ]->' 
//  else if (modelElement instanceof InternalCondition)
//    '-[ on internal ]->' 
  else if (modelElement instanceof BehaviorActions)
    'actions' 
  else if (modelElement instanceof VariableDeclaration)
    {
    val c = modelElement as VariableDeclaration  
    c.variable.name + '~' + 
    (c.variable?.tod?.ty === null ? c.variable?.tod?.ref?.name : c.variable?.tod?.ty?.typeString)+' ' + 
    (c.nonvolatile ? 'nonvolatile ' : '') +
    (c.shared ? 'shared ' : '') +
    (c.constant ? 'constant ' : '') +
    (c.spread ? 'spread ' : '') +
    (c.final ? 'final' : '') +
    (c.assign ? ':=' : '')
    }    
  else if (modelElement instanceof BehaviorState)
    {
    val bs = (modelElement as BehaviorState)
    bs.name + ' : ' + (bs.initial ? 'initial ' : '') + (bs.complete ? 'complete ' : '') + (bs.final ? 'final ' : '') +
      'state'
    }
    
  else modelElement.toString  
  }
  
  override boolean
isLeaf(EObject modelElement)
  {
  val o = modelElement  
  if (o instanceof UnitFactor || o instanceof RecordField || o instanceof TypeDeclaration || o instanceof Assertion || 
    o instanceof NamedAssertion || o instanceof GhostVariable || o instanceof DispatchCondition || 
    o instanceof ExecuteCondition || o instanceof ModeCondition || o instanceof InternalCondition || o instanceof BehaviorState || 
    o instanceof BehaviorActions || o instanceof VariableDeclaration ) 
    true
  else
    false
  }

  
//@Inject extension TypeUtil
//
//val pluginImageHelper = new PluginImageHelper
//  
//  def void _createChildren(DocumentRootNode outlineNode, BLESSGrammarRoots ugr)
//    {
//    if (ugr.unit_library !== null)
//      createNode(outlineNode,ugr.unit_library)
////      ugr.unit_library.unitDeclarations.forEach[udec | createNode(outlineNode,udec)]
//    else if (ugr.type_library !== null)  
//      createNode(outlineNode,ugr.type_library)  //.decs.forEach[udec | createNode(outlineNode,udec)]
//    else if (ugr.assertion_library !== null) 
//      createNode(outlineNode,ugr.assertion_library)	
//    else if (ugr.bless_subclause !== null) 
//      createNode(outlineNode,ugr.bless_subclause) 
//    else if (ugr.action_subclause !== null) 
//      createNode(outlineNode,ugr.action_subclause) 
//    }
 
//   def void _createChildren(DocumentRootNode outlineNode, UnitLibrary library) 
//    {
//    _createChildren(outlineNode, library)
//  	}
//  	
//   def void _createChildren(DocumentRootNode outlineNode, TypeLibrary library) 
//  	{
//  		_createChildren(outlineNode, library)
//  	}
//  	
//   def void _createChildren(DocumentRootNode outlineNode, AssertionLibrary library) 
//  	{
//  		_createChildren(outlineNode, library)
//  	}
//  
// 
//  def void _createChildren(DocumentRootNode outlineNode, BLESSSubclause subclause) 
//    {
//  		_createChildren(outlineNode, subclause)
//  	}
//  	
//  def void _createChildren(DocumentRootNode outlineNode, ActionSubclause subclause) 
//  	{
//  		_createChildren(outlineNode, subclause)
//  	}
// 
// 
 
 /////////////////////////////  UNIT ANNEX OUTLINE   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
//  def _isLeaf(UnitFactor ul) 
//    {true}
//    
//  def void _createChildren(DocumentRootNode outlineNode, UnitLibrary lib)
//    {
//    lib.unitDeclarations.forEach[udec | createNode(outlineNode,udec)]
//    }
//  
//    
//  def void _createChildren(IOutlineNode outlineNode, RootDeclaration root)
//    {
//    }
//  
//  def _text(UnitLibrary dal)
//    { 'Unit'}
//  
//  def _text(RootDeclaration ud)  
//    { 
//    if (ud.unitName === null)
//      'null root unit name for '+ud.toString
//    else
////    (ud.base ? 'base ' : '')+
//    (ud.unitName.longname !== null && ud.unitName.longname.size>0 ? '<'+ud.unitName.longname.join(' ',[it])+'> ' : '')+
//    ud.unitName.name.getSuffix + ' [' + ud.kindWords.join(' ') + '] ' +
//      (ud.base?'base':_text(ud.formula))
//    }
//    
//  def _text(UnitFormula form)
//    {
//    var top = form.top.join(' ',[u | u.name.getSuffix])
//    var bottom = form.bottom.join(' ',[u | u.name.getSuffix+' '])
//    if (form.slash)
//      top + ' / ' + bottom
//    else
//      top + bottom
//    } 
//    
//  def _text(UnitFactor uf) 
//    { (uf?.unit?.longname.size>0 ? '<'+uf?.unit?.longname?.join(' ',[it])+'> ' : '')+
//    	uf?.unit?.name.getSuffix +' '+ uf?.op +
//      ' '+uf?.factor}
//   
//  def _text(UnitExtension ue)
//    {
//    	'extension '+ ue.root.name.getSuffix
//    }

  def getSuffix(String s)
    {if (s===null)
    	return "";
    if (s.lastIndexOf('.')>0)
    	s.substring(s.lastIndexOf('.'))
    else s	
    }

/////////////////////////////////  TYPE OUTLINE   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//
//  def _isLeaf(RecordField rf) {true}
//
// def void _createChildren(DocumentRootNode outlineNode, TypeLibrary lib)
//    {
//    lib.decs.forEach[udec | createNode(outlineNode,udec)]
//    }
//
//  def _isLeaf(TypeDeclaration td) {true}
//
////  def void _createChildren(IOutlineNode outlineNode, TypeDeclaration dec)
////    {
////    	createNode(outlineNode,dec.type)
////    }
////
////  def void _createChildren(IOutlineNode outlineNode, ArrayType at)
////    { 
////    	if (at.typ !== null)
////    	  if (at.typ.ty!==null)
////    	    createNode(outlineNode,at.typ.ty)
////    	  else if (at.typ.ref!==null)
////    	    createNode(outlineNode,at.typ.ref)
////    }
////  
////  def void _createChildren(IOutlineNode outlineNode, RecordType rt)
////    {
////    rt.fields.forEach[rf | createNode(outlineNode,rf)]
////    }
////  
////  def void _createChildren(IOutlineNode outlineNode, RecordField rf)
////    {
////    createNode(outlineNode,rf.typ)	
////    }
////    
//  def _text(TypeDeclaration dec)
//    { 'type '+dec.name.getSuffix }
//
//  def _text(BooleanType ty)
//    { 'boolean' }
//
//  def _text(StringType ty)
//    { 'string' }
//
//  def _text(RecordType ty)
//    { (ty.record?'record':'')+(ty.variant?'variant':'') }
//
//  def _text(RecordField rf)
//    { rf.label+':'+rf.typ.typeString }
//
//  def _text(EnumerationType ty)
//    { 'enumeration' }
//
//  def _text(QuantityType ty)
//    { ty.typeString
//    //'quantity '+(ty.scalar ? 'scalar' : (ty.whole?'whole':ty.unit.name) )  //ty.unit) 	
//    }
//
//  def _text(ArrayType ty)
//    { ty.typeString
//    }
//
//
////////////////////////////////   ASSERTION OUTLINE   \\\\\\\\\\\\\\\\\\\\\\\\\\\
//
//  def void _createChildren(DocumentRootNode outlineNode, AssertionLibrary lib)
//    {
//      if (lib.ghosts !== null)	
//      	createNode(outlineNode,lib.ghosts)
//      lib.assertion_list.forEach[assertion | createNode(outlineNode,assertion)]   
//    }
//  
//   def _isLeaf(Assertion na) 
//    {true}
//
//   def _isLeaf(NamedAssertion na) 
//    {true}
//  
//   def _isLeaf(GhostVariable gv) 
//    {true}
//
//  def void _createChildren(IOutlineNode outlineNode, GhostVariables gho)
//    {
//    gho.gv.forEach[g | createNode(outlineNode,g)]
//    }
//
//  def _text(Assertion a)
//   {
//   	if (a.namedassertion !== null)
//     	a.namedassertion.name
//    else 	if (a.namelessassertion !== null)
//      'nameless assertion'
//    else 	if (a.namelessfunction !== null)
//      'nameless function'
//    else 	if (a.namelessenumeration !== null)
//      'nameless enumeration'
//   }
//
//  def _text(GhostVariables gho)
//    {'ghost variables'}
//  
//  def _image(GhostVariables gho) 
//    { pluginImageHelper.getImage('platform:/plugin/com.multitude.aadl.bless.ui/fantomCompartment.gif') }
//
//  def _text(GhostVariable gv)
//    {
//    	'def '+gv.ghost.name+' '+gv.ghost.tod.typeString
//    }
//
//  def _text(TypeOrReference tod)
//    {
//    if (tod.ref !== null)
//      tod.ref.name
//    if (tod.ty !== null)
//      tod.ty.toString
//    }
//  def _text(NamedAssertion na)
//    { na.name + ' :' }
//
//  def _text(NamelessAssertion na)
//    { ':' }
//
//  def _text(NamelessFunction na)
//    { ':=' }
//
//  def _text(NamelessEnumeration na)
//    { '+=>' }
//    
//   def _text(ConditionalAssertionFunction na)
//    { '[  ]' }
//    
//   def _text(ConditionValuePair na)
//    { '->' }
//    
//   def _text(VariableList na)
//    { ',' }
// 
//
////////////////////////////////   BLESS OUTLINE   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//
//  def void _createChildren(DocumentRootNode outlineNode, BLESSSubclause subclause)
//    {
//      if (subclause.assert_clause !== null)	 
//        createNode(outlineNode,subclause.assert_clause)
//      if (subclause.invariant !== null)	 
//        createNode(outlineNode,subclause.invariant)
//      if (subclause.variables !== null)	 
//        createNode(outlineNode,subclause.variables)
//      createNode(outlineNode,subclause.statesSection)
//      if (subclause.transitions !== null)	 
//        createNode(outlineNode,subclause.transitions)      
//    }
//
//  def void _createChildren(IOutlineNode outlineNode, AssertClause c)
//    {
//    for (assn : c.assertions)
//      createNode(outlineNode,assn)
//    }
//  def _text(AssertClause c) { 'assert' }
//  
//  def void _createChildren(IOutlineNode outlineNode, InvariantClause c)
//    {
//    	createNode(outlineNode,c.inv)
//    }
//  def _text(InvariantClause c) { 'invariant' }
//  
//  def void _createChildren(IOutlineNode outlineNode, VariablesSection c)
//    {
//    for (v : c.behavior_variables)
//       createNode(outlineNode,v)   
//    }
//  def _text(VariablesSection c) { 'variables' }
//  
//  def void _createChildren(IOutlineNode outlineNode, StatesSection c)
//    {
//    for (s : c.states)
//       createNode(outlineNode,s)       	
//    }
//  def _text(StatesSection c) { 'states' }
//  
//  def void _createChildren(IOutlineNode outlineNode, Transitions c)
//    {
//    for (t : c.bt)
//      createNode(outlineNode,t)       		
//    }
//  def _text(Transitions c) { 'transitions' }
//  
//  def void _createChildren(IOutlineNode outlineNode, BehaviorTransition c)
//    {
//    for (source : c.sources)
//      createNode(outlineNode,source)
//    if (c.dispatch !== null) 
//      createNode(outlineNode,c.dispatch)
//    if (c.execute !== null) 
//      createNode(outlineNode,c.execute) 		
//    if (c.mode !== null) 
//      createNode(outlineNode,c.mode) 		
//    if (c.internal !== null) 
//      createNode(outlineNode,c.internal) 	
//    createNode(outlineNode,c.destination) 	
////    if (c.actions !== null) 
////      createNode(outlineNode,c.actions)
////    if (c.ass !== null) 
////      createNode(outlineNode,c.ass)
//    }
//  def _text(BehaviorTransition c) { c.transition_label.id+': ' } //+c.sources.map[s | s.name].join(', ') }
//  
//  def _isLeaf(DispatchCondition c) {true}
//  def _isLeaf(ExecuteCondition c) {true}
//  def _isLeaf(ModeCondition c) {true}
//  def _isLeaf(InternalCondition c) {true}
//  def _isLeaf(BehaviorState c) {true}
//  def _isLeaf(BehaviorActions c) {true}
//  
//  def _text(DispatchCondition c) { '-[ on dispatch ]->' }
//  def _text(ExecuteCondition c) { '-[  ]->' }
//  def _text(ModeCondition c) { '-[ on mode ]->' }
//  def _text(InternalCondition c) { '-[ on internal ]->' }
//  def _text(BehaviorActions d) { 'actions' }
//  
////  def void _createChildren(IOutlineNode outlineNode, BehaviorActions c)
////    {
////    for (act : c.action)	
////      createNode(outlineNode,act)
////    }
////  def _isText(BehaviorActions c)
////    { '{ '+ (c.semi ? '; ' : '') + (c.amp ? '& ' : '') + '}' }
//    
////  def _isLeaf(BehaviorVariable c) { true } 
////  def _text(BehaviorVariable c) 
////    {
////    (c.nonvolatile ? 'nonvolatile ' : '') +
////    (c.shared ? 'shared ' : '') +
////    (c.constant ? 'constant ' : '') +
////    (c.spread ? 'spread ' : '') +
////    (c.final ? 'final' : '') +
////    c.declaration.variable.name + '~' + 
////    (c.declaration.variable.tod.ty === null ? '' : c.declaration.variable.tod.ty.typeString) + 
////    (c.declaration.variable.tod.dec === null ? '' : c.declaration.variable.tod.dec.name) + 
////    (c.declaration.assign ? ':=' : '')
////    }
//// 
//
/////////////////////////////    ACTION OUTLINE   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//
//  def void _createChildren(DocumentRootNode outlineNode, ActionSubclause subclause)
//    {
//      if (subclause.throws_clause !== null)  
//        createNode(outlineNode,subclause.throws_clause)
//      if (subclause.assert_clause !== null)  
//        createNode(outlineNode,subclause.assert_clause)
//      if (subclause.invariant !== null)  
//        createNode(outlineNode,subclause.invariant)
//      if (subclause.precondition !== null)  
//        createNode(outlineNode,subclause.precondition)
//      if (subclause.postcondition !== null)  
//        createNode(outlineNode,subclause.postcondition)
//      if (subclause.invariant !== null)  
//        createNode(outlineNode,subclause.invariant)
//      if (subclause.types !== null)  
//        createNode(outlineNode,subclause.types)      
//      createNode(outlineNode,subclause.elq)
//    }

 
}
